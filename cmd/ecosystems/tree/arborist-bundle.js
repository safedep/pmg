var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/treeverse/lib/breadth.js
var require_breadth = __commonJS({
  "node_modules/treeverse/lib/breadth.js"(exports2, module2) {
    var breadth = ({
      visit,
      filter = () => true,
      getChildren,
      tree
    }) => {
      const queue = [];
      const seen = /* @__PURE__ */ new Map();
      const next = () => {
        while (queue.length) {
          const node = queue.shift();
          const res = visitNode(node);
          if (isPromise(res)) {
            return res.then(() => next());
          }
        }
        return seen.get(tree);
      };
      const visitNode = (visitTree) => {
        if (seen.has(visitTree)) {
          return seen.get(visitTree);
        }
        seen.set(visitTree, null);
        const res = visit ? visit(visitTree) : visitTree;
        if (isPromise(res)) {
          const fullResult = res.then((resThen) => {
            seen.set(visitTree, resThen);
            return kidNodes(visitTree);
          });
          seen.set(visitTree, fullResult);
          return fullResult;
        } else {
          seen.set(visitTree, res);
          return kidNodes(visitTree);
        }
      };
      const kidNodes = (kidTree) => {
        const kids = getChildren(kidTree, seen.get(kidTree));
        return isPromise(kids) ? kids.then(processKids) : processKids(kids);
      };
      const processKids = (kids) => {
        kids = (kids || []).filter(filter);
        queue.push(...kids);
      };
      queue.push(tree);
      return next();
    };
    var isPromise = (p) => p && typeof p.then === "function";
    module2.exports = breadth;
  }
});

// node_modules/treeverse/lib/depth-descent.js
var require_depth_descent = __commonJS({
  "node_modules/treeverse/lib/depth-descent.js"(exports2, module2) {
    var depth = ({
      visit,
      filter,
      getChildren,
      tree
    }) => {
      const stack = [];
      const seen = /* @__PURE__ */ new Map();
      const next = () => {
        while (stack.length) {
          const node = stack.pop();
          const res = visitNode(node);
          if (isPromise(res)) {
            return res.then(() => next());
          }
        }
        return seen.get(tree);
      };
      const visitNode = (visitTree) => {
        if (seen.has(visitTree)) {
          return seen.get(visitTree);
        }
        seen.set(visitTree, null);
        const res = visit ? visit(visitTree) : visitTree;
        if (isPromise(res)) {
          const fullResult = res.then((resThen) => {
            seen.set(visitTree, resThen);
            return kidNodes(visitTree);
          });
          seen.set(visitTree, fullResult);
          return fullResult;
        } else {
          seen.set(visitTree, res);
          return kidNodes(visitTree);
        }
      };
      const kidNodes = (kidTree) => {
        const kids = getChildren(kidTree, seen.get(kidTree));
        return isPromise(kids) ? kids.then(processKids) : processKids(kids);
      };
      const processKids = (kids) => {
        kids = (kids || []).filter(filter);
        stack.push(...kids);
      };
      stack.push(tree);
      return next();
    };
    var isPromise = (p) => p && typeof p.then === "function";
    module2.exports = depth;
  }
});

// node_modules/treeverse/lib/depth.js
var require_depth = __commonJS({
  "node_modules/treeverse/lib/depth.js"(exports2, module2) {
    var depthDescent = require_depth_descent();
    var depth = ({
      visit,
      leave,
      filter = () => true,
      seen = /* @__PURE__ */ new Map(),
      getChildren,
      tree
    }) => {
      if (!leave) {
        return depthDescent({ visit, filter, getChildren, tree });
      }
      if (seen.has(tree)) {
        return seen.get(tree);
      }
      seen.set(tree, null);
      const visitNode = () => {
        const res = visit ? visit(tree) : tree;
        if (isPromise(res)) {
          const fullResult = res.then((resThen) => {
            seen.set(tree, resThen);
            return kidNodes();
          });
          seen.set(tree, fullResult);
          return fullResult;
        } else {
          seen.set(tree, res);
          return kidNodes();
        }
      };
      const kidNodes = () => {
        const kids = getChildren(tree, seen.get(tree));
        return isPromise(kids) ? kids.then(processKids) : processKids(kids);
      };
      const processKids = (nodes) => {
        const kids = (nodes || []).filter(filter).map((kid) => depth({ visit, leave, filter, seen, getChildren, tree: kid }));
        return kids.some(isPromise) ? Promise.all(kids).then(leaveNode) : leaveNode(kids);
      };
      const leaveNode = (kids) => {
        const res = leave(seen.get(tree), kids);
        seen.set(tree, res);
        return res;
      };
      return visitNode();
    };
    var isPromise = (p) => p && typeof p.then === "function";
    module2.exports = depth;
  }
});

// node_modules/treeverse/lib/index.js
var require_lib = __commonJS({
  "node_modules/treeverse/lib/index.js"(exports2, module2) {
    module2.exports = {
      breadth: require_breadth(),
      depth: require_depth()
    };
  }
});

// node_modules/@npmcli/name-from-folder/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@npmcli/name-from-folder/lib/index.js"(exports2, module2) {
    var { basename, dirname } = require("path");
    var getName = (parent, base) => parent.charAt(0) === "@" ? `${parent}/${base}` : base;
    module2.exports = (dir) => dir ? getName(basename(dirname(dir)), basename(dir)) : false;
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m) return [str];
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/dist/commonjs/assert-valid-pattern.js
var require_assert_valid_pattern = __commonJS({
  "node_modules/minimatch/dist/commonjs/assert-valid-pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertValidPattern = void 0;
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    exports2.assertValidPattern = assertValidPattern;
  }
});

// node_modules/minimatch/dist/commonjs/brace-expressions.js
var require_brace_expressions = __commonJS({
  "node_modules/minimatch/dist/commonjs/brace-expressions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseClass = void 0;
    var posixClasses = {
      "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
      "[:alpha:]": ["\\p{L}\\p{Nl}", true],
      "[:ascii:]": ["\\x00-\\x7f", false],
      "[:blank:]": ["\\p{Zs}\\t", true],
      "[:cntrl:]": ["\\p{Cc}", true],
      "[:digit:]": ["\\p{Nd}", true],
      "[:graph:]": ["\\p{Z}\\p{C}", true, true],
      "[:lower:]": ["\\p{Ll}", true],
      "[:print:]": ["\\p{C}", true],
      "[:punct:]": ["\\p{P}", true],
      "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
      "[:upper:]": ["\\p{Lu}", true],
      "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
      "[:xdigit:]": ["A-Fa-f0-9", false]
    };
    var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
    var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var rangesToString = (ranges) => ranges.join("");
    var parseClass = (glob, position) => {
      const pos = position;
      if (glob.charAt(pos) !== "[") {
        throw new Error("not in a brace expression");
      }
      const ranges = [];
      const negs = [];
      let i = pos + 1;
      let sawStart = false;
      let uflag = false;
      let escaping = false;
      let negate = false;
      let endPos = pos;
      let rangeStart = "";
      WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
          negate = true;
          i++;
          continue;
        }
        if (c === "]" && sawStart && !escaping) {
          endPos = i + 1;
          break;
        }
        sawStart = true;
        if (c === "\\") {
          if (!escaping) {
            escaping = true;
            i++;
            continue;
          }
        }
        if (c === "[" && !escaping) {
          for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
            if (glob.startsWith(cls, i)) {
              if (rangeStart) {
                return ["$.", false, glob.length - pos, true];
              }
              i += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
          } else if (c === rangeStart) {
            ranges.push(braceEscape(c));
          }
          rangeStart = "";
          i++;
          continue;
        }
        if (glob.startsWith("-]", i + 1)) {
          ranges.push(braceEscape(c + "-"));
          i += 2;
          continue;
        }
        if (glob.startsWith("-", i + 1)) {
          rangeStart = c;
          i += 2;
          continue;
        }
        ranges.push(braceEscape(c));
        i++;
      }
      if (endPos < i) {
        return ["", false, 0, false];
      }
      if (!ranges.length && !negs.length) {
        return ["$.", false, glob.length - pos, true];
      }
      if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
      }
      const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
      const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
      const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
      return [comb, uflag, endPos - pos, true];
    };
    exports2.parseClass = parseClass;
  }
});

// node_modules/minimatch/dist/commonjs/unescape.js
var require_unescape = __commonJS({
  "node_modules/minimatch/dist/commonjs/unescape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unescape = void 0;
    var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
    };
    exports2.unescape = unescape;
  }
});

// node_modules/minimatch/dist/commonjs/ast.js
var require_ast = __commonJS({
  "node_modules/minimatch/dist/commonjs/ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AST = void 0;
    var brace_expressions_js_1 = require_brace_expressions();
    var unescape_js_1 = require_unescape();
    var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
    var isExtglobType = (c) => types.has(c);
    var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
    var startNoDot = "(?!\\.)";
    var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
    var justDots = /* @__PURE__ */ new Set(["..", "."]);
    var reSpecials = new Set("().*{}+?[]^$\\!");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var qmark = "[^/]";
    var star = qmark + "*?";
    var starNoEmpty = qmark + "+?";
    var AST = class _AST {
      type;
      #root;
      #hasMagic;
      #uflag = false;
      #parts = [];
      #parent;
      #parentIndex;
      #negs;
      #filledNegs = false;
      #options;
      #toString;
      // set to true if it's an extglob with no children
      // (which really means one child of '')
      #emptyExt = false;
      constructor(type, parent, options = {}) {
        this.type = type;
        if (type)
          this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === "!" && !this.#root.#filledNegs)
          this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
      }
      get hasMagic() {
        if (this.#hasMagic !== void 0)
          return this.#hasMagic;
        for (const p of this.#parts) {
          if (typeof p === "string")
            continue;
          if (p.type || p.hasMagic)
            return this.#hasMagic = true;
        }
        return this.#hasMagic;
      }
      // reconstructs the pattern
      toString() {
        if (this.#toString !== void 0)
          return this.#toString;
        if (!this.type) {
          return this.#toString = this.#parts.map((p) => String(p)).join("");
        } else {
          return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
        }
      }
      #fillNegs() {
        if (this !== this.#root)
          throw new Error("should only call on root");
        if (this.#filledNegs)
          return this;
        this.toString();
        this.#filledNegs = true;
        let n;
        while (n = this.#negs.pop()) {
          if (n.type !== "!")
            continue;
          let p = n;
          let pp = p.#parent;
          while (pp) {
            for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
              for (const part of n.#parts) {
                if (typeof part === "string") {
                  throw new Error("string part in extglob AST??");
                }
                part.copyIn(pp.#parts[i]);
              }
            }
            p = pp;
            pp = p.#parent;
          }
        }
        return this;
      }
      push(...parts) {
        for (const p of parts) {
          if (p === "")
            continue;
          if (typeof p !== "string" && !(p instanceof _AST && p.#parent === this)) {
            throw new Error("invalid part: " + p);
          }
          this.#parts.push(p);
        }
      }
      toJSON() {
        const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
        if (this.isStart() && !this.type)
          ret.unshift([]);
        if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
          ret.push({});
        }
        return ret;
      }
      isStart() {
        if (this.#root === this)
          return true;
        if (!this.#parent?.isStart())
          return false;
        if (this.#parentIndex === 0)
          return true;
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
          const pp = p.#parts[i];
          if (!(pp instanceof _AST && pp.type === "!")) {
            return false;
          }
        }
        return true;
      }
      isEnd() {
        if (this.#root === this)
          return true;
        if (this.#parent?.type === "!")
          return true;
        if (!this.#parent?.isEnd())
          return false;
        if (!this.type)
          return this.#parent?.isEnd();
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        return this.#parentIndex === pl - 1;
      }
      copyIn(part) {
        if (typeof part === "string")
          this.push(part);
        else
          this.push(part.clone(this));
      }
      clone(parent) {
        const c = new _AST(this.type, parent);
        for (const p of this.#parts) {
          c.copyIn(p);
        }
        return c;
      }
      static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
          let i2 = pos;
          let acc2 = "";
          while (i2 < str.length) {
            const c = str.charAt(i2++);
            if (escaping || c === "\\") {
              escaping = !escaping;
              acc2 += c;
              continue;
            }
            if (inBrace) {
              if (i2 === braceStart + 1) {
                if (c === "^" || c === "!") {
                  braceNeg = true;
                }
              } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
                inBrace = false;
              }
              acc2 += c;
              continue;
            } else if (c === "[") {
              inBrace = true;
              braceStart = i2;
              braceNeg = false;
              acc2 += c;
              continue;
            }
            if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
              ast.push(acc2);
              acc2 = "";
              const ext = new _AST(c, ast);
              i2 = _AST.#parseAST(str, ext, i2, opt);
              ast.push(ext);
              continue;
            }
            acc2 += c;
          }
          ast.push(acc2);
          return i2;
        }
        let i = pos + 1;
        let part = new _AST(null, ast);
        const parts = [];
        let acc = "";
        while (i < str.length) {
          const c = str.charAt(i++);
          if (escaping || c === "\\") {
            escaping = !escaping;
            acc += c;
            continue;
          }
          if (inBrace) {
            if (i === braceStart + 1) {
              if (c === "^" || c === "!") {
                braceNeg = true;
              }
            } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
              inBrace = false;
            }
            acc += c;
            continue;
          } else if (c === "[") {
            inBrace = true;
            braceStart = i;
            braceNeg = false;
            acc += c;
            continue;
          }
          if (isExtglobType(c) && str.charAt(i) === "(") {
            part.push(acc);
            acc = "";
            const ext = new _AST(c, part);
            part.push(ext);
            i = _AST.#parseAST(str, ext, i, opt);
            continue;
          }
          if (c === "|") {
            part.push(acc);
            acc = "";
            parts.push(part);
            part = new _AST(null, ast);
            continue;
          }
          if (c === ")") {
            if (acc === "" && ast.#parts.length === 0) {
              ast.#emptyExt = true;
            }
            part.push(acc);
            acc = "";
            ast.push(...parts, part);
            return i;
          }
          acc += c;
        }
        ast.type = null;
        ast.#hasMagic = void 0;
        ast.#parts = [str.substring(pos - 1)];
        return i;
      }
      static fromGlob(pattern, options = {}) {
        const ast = new _AST(null, void 0, options);
        _AST.#parseAST(pattern, ast, 0, options);
        return ast;
      }
      // returns the regular expression if there's magic, or the unescaped
      // string if not.
      toMMPattern() {
        if (this !== this.#root)
          return this.#root.toMMPattern();
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
        if (!anyMagic) {
          return body;
        }
        const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
        return Object.assign(new RegExp(`^${re}$`, flags), {
          _src: re,
          _glob: glob
        });
      }
      get options() {
        return this.#options;
      }
      // returns the string match, the regexp source, whether there's magic
      // in the regexp (so a regular expression is required) and whether or
      // not the uflag is needed for the regular expression (for posix classes)
      // TODO: instead of injecting the start/end at this point, just return
      // the BODY of the regexp, along with the start/end portions suitable
      // for binding the start/end in either a joined full-path makeRe context
      // (where we bind to (^|/), or a standalone matchPart context (where
      // we bind to ^, and not /).  Otherwise slashes get duped!
      //
      // In part-matching mode, the start is:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: ^(?!\.\.?$)
      // - if dots allowed or not possible: ^
      // - if dots possible and not allowed: ^(?!\.)
      // end is:
      // - if not isEnd(): nothing
      // - else: $
      //
      // In full-path matching mode, we put the slash at the START of the
      // pattern, so start is:
      // - if first pattern: same as part-matching mode
      // - if not isStart(): nothing
      // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
      // - if dots allowed or not possible: /
      // - if dots possible and not allowed: /(?!\.)
      // end is:
      // - if last pattern, same as part-matching mode
      // - else nothing
      //
      // Always put the (?:$|/) on negated tails, though, because that has to be
      // there to bind the end of the negated pattern portion, and it's easier to
      // just stick it in now rather than try to inject it later in the middle of
      // the pattern.
      //
      // We can just always return the same end, and leave it up to the caller
      // to know whether it's going to be used joined or in parts.
      // And, if the start is adjusted slightly, can do the same there:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
      // - if dots allowed or not possible: (?:/|^)
      // - if dots possible and not allowed: (?:/|^)(?!\.)
      //
      // But it's better to have a simpler binding without a conditional, for
      // performance, so probably better to return both start options.
      //
      // Then the caller just ignores the end if it's not the first pattern,
      // and the start always gets applied.
      //
      // But that's always going to be $ if it's the ending pattern, or nothing,
      // so the caller can just attach $ at the end of the pattern when building.
      //
      // So the todo is:
      // - better detect what kind of start is needed
      // - return both flavors of starting pattern
      // - attach $ at the end of the pattern when creating the actual RegExp
      //
      // Ah, but wait, no, that all only applies to the root when the first pattern
      // is not an extglob. If the first pattern IS an extglob, then we need all
      // that dot prevention biz to live in the extglob portions, because eg
      // +(*|.x*) can match .xy but not .yx.
      //
      // So, return the two flavors if it's #root and the first child is not an
      // AST, otherwise leave it to the child AST to handle it, and there,
      // use the (?:^|/) style of start binding.
      //
      // Even simplified further:
      // - Since the start for a join is eg /(?!\.) and the start for a part
      // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
      // or start or whatever) and prepend ^ or / at the Regexp construction.
      toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
          this.#fillNegs();
        if (!this.type) {
          const noEmpty = this.isStart() && this.isEnd();
          const src = this.#parts.map((p) => {
            const [re, _, hasMagic, uflag] = typeof p === "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
            this.#hasMagic = this.#hasMagic || hasMagic;
            this.#uflag = this.#uflag || uflag;
            return re;
          }).join("");
          let start2 = "";
          if (this.isStart()) {
            if (typeof this.#parts[0] === "string") {
              const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
              if (!dotTravAllowed) {
                const aps = addPatternStart;
                const needNoTrav = (
                  // dots are allowed, and the pattern starts with [ or .
                  dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
                  src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
                  src.startsWith("\\.\\.") && aps.has(src.charAt(4))
                );
                const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
              }
            }
          }
          let end = "";
          if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
            end = "(?:$|\\/)";
          }
          const final2 = start2 + src + end;
          return [
            final2,
            (0, unescape_js_1.unescape)(src),
            this.#hasMagic = !!this.#hasMagic,
            this.#uflag
          ];
        }
        const repeated = this.type === "*" || this.type === "+";
        const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
          const s = this.toString();
          this.#parts = [s];
          this.type = null;
          this.#hasMagic = void 0;
          return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
        }
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
          bodyDotAllowed = "";
        }
        if (bodyDotAllowed) {
          body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        let final = "";
        if (this.type === "!" && this.#emptyExt) {
          final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
        } else {
          const close = this.type === "!" ? (
            // !() must match something,but !(x) can match ''
            "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
          ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
          final = start + body + close;
        }
        return [
          final,
          (0, unescape_js_1.unescape)(body),
          this.#hasMagic = !!this.#hasMagic,
          this.#uflag
        ];
      }
      #partsToRegExp(dot) {
        return this.#parts.map((p) => {
          if (typeof p === "string") {
            throw new Error("string type in extglob ast??");
          }
          const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
          this.#uflag = this.#uflag || uflag;
          return re;
        }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
      }
      static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = "";
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
          const c = glob.charAt(i);
          if (escaping) {
            escaping = false;
            re += (reSpecials.has(c) ? "\\" : "") + c;
            continue;
          }
          if (c === "\\") {
            if (i === glob.length - 1) {
              re += "\\\\";
            } else {
              escaping = true;
            }
            continue;
          }
          if (c === "[") {
            const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
            if (consumed) {
              re += src;
              uflag = uflag || needUflag;
              i += consumed - 1;
              hasMagic = hasMagic || magic;
              continue;
            }
          }
          if (c === "*") {
            if (noEmpty && glob === "*")
              re += starNoEmpty;
            else
              re += star;
            hasMagic = true;
            continue;
          }
          if (c === "?") {
            re += qmark;
            hasMagic = true;
            continue;
          }
          re += regExpEscape(c);
        }
        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
      }
    };
    exports2.AST = AST;
  }
});

// node_modules/minimatch/dist/commonjs/escape.js
var require_escape = __commonJS({
  "node_modules/minimatch/dist/commonjs/escape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escape = void 0;
    var escape = (s, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
    };
    exports2.escape = escape;
  }
});

// node_modules/minimatch/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/minimatch/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unescape = exports2.escape = exports2.AST = exports2.Minimatch = exports2.match = exports2.makeRe = exports2.braceExpand = exports2.defaults = exports2.filter = exports2.GLOBSTAR = exports2.sep = exports2.minimatch = void 0;
    var brace_expansion_1 = __importDefault(require_brace_expansion());
    var assert_valid_pattern_js_1 = require_assert_valid_pattern();
    var ast_js_1 = require_ast();
    var escape_js_1 = require_escape();
    var unescape_js_1 = require_unescape();
    var minimatch = (p, pattern, options = {}) => {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    exports2.minimatch = minimatch;
    var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
    var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
    var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
    var starDotExtTestNocase = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
    };
    var starDotExtTestNocaseDot = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => f.toLowerCase().endsWith(ext2);
    };
    var starDotStarRE = /^\*+\.\*+$/;
    var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
    var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
    var dotStarRE = /^\.\*+$/;
    var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
    var starRE = /^\*+$/;
    var starTest = (f) => f.length !== 0 && !f.startsWith(".");
    var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
    var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
    var qmarksTestNocase = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    var qmarksTestDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    var qmarksTest = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    var qmarksTestNoExt = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && !f.startsWith(".");
    };
    var qmarksTestNoExtDot = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && f !== "." && f !== "..";
    };
    var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
    var path = {
      win32: { sep: "\\" },
      posix: { sep: "/" }
    };
    exports2.sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
    exports2.minimatch.sep = exports2.sep;
    exports2.GLOBSTAR = Symbol("globstar **");
    exports2.minimatch.GLOBSTAR = exports2.GLOBSTAR;
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var filter = (pattern, options = {}) => (p) => (0, exports2.minimatch)(p, pattern, options);
    exports2.filter = filter;
    exports2.minimatch.filter = exports2.filter;
    var ext = (a, b = {}) => Object.assign({}, a, b);
    var defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return exports2.minimatch;
      }
      const orig = exports2.minimatch;
      const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
      return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
          constructor(pattern, options = {}) {
            super(pattern, ext(def, options));
          }
          static defaults(options) {
            return orig.defaults(ext(def, options)).Minimatch;
          }
        },
        AST: class AST extends orig.AST {
          /* c8 ignore start */
          constructor(type, parent, options = {}) {
            super(type, parent, ext(def, options));
          }
          /* c8 ignore stop */
          static fromGlob(pattern, options = {}) {
            return orig.AST.fromGlob(pattern, ext(def, options));
          }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: exports2.GLOBSTAR
      });
    };
    exports2.defaults = defaults;
    exports2.minimatch.defaults = exports2.defaults;
    var braceExpand = (pattern, options = {}) => {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return (0, brace_expansion_1.default)(pattern);
    };
    exports2.braceExpand = braceExpand;
    exports2.minimatch.braceExpand = exports2.braceExpand;
    var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
    exports2.makeRe = makeRe;
    exports2.minimatch.makeRe = exports2.makeRe;
    var match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    exports2.match = match;
    exports2.minimatch.match = exports2.match;
    var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var Minimatch = class {
      options;
      set;
      pattern;
      windowsPathsNoEscape;
      nonegate;
      negate;
      comment;
      empty;
      preserveMultipleSlashes;
      partial;
      globSet;
      globParts;
      nocase;
      isWindows;
      platform;
      windowsNoMagicRoot;
      regexp;
      constructor(pattern, options = {}) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === "win32";
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        this.make();
      }
      hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
          return true;
        }
        for (const pattern of this.set) {
          for (const part of pattern) {
            if (typeof part !== "string")
              return true;
          }
        }
        return false;
      }
      debug(..._) {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
          this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        let set = this.globParts.map((s, _, __) => {
          if (this.isWindows && this.windowsNoMagicRoot) {
            const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
            const isDrive = /^[a-z]:/i.test(s[0]);
            if (isUNC) {
              return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
            } else if (isDrive) {
              return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
            }
          }
          return s.map((ss) => this.parse(ss));
        });
        this.debug(this.pattern, set);
        this.set = set.filter((s) => s.indexOf(false) === -1);
        if (this.isWindows) {
          for (let i = 0; i < this.set.length; i++) {
            const p = this.set[i];
            if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
              p[2] = "?";
            }
          }
        }
        this.debug(this.pattern, this.set);
      }
      // various transforms to equivalent pattern sets that are
      // faster to process in a filesystem walk.  The goal is to
      // eliminate what we can, and push all ** patterns as far
      // to the right as possible, even if it increases the number
      // of patterns that we have to process.
      preprocess(globParts) {
        if (this.options.noglobstar) {
          for (let i = 0; i < globParts.length; i++) {
            for (let j = 0; j < globParts[i].length; j++) {
              if (globParts[i][j] === "**") {
                globParts[i][j] = "*";
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          globParts = this.firstPhasePreProcess(globParts);
          globParts = this.secondPhasePreProcess(globParts);
        } else if (optimizationLevel >= 1) {
          globParts = this.levelOneOptimize(globParts);
        } else {
          globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
      }
      // just get rid of adjascent ** portions
      adjascentGlobstarOptimize(globParts) {
        return globParts.map((parts) => {
          let gs = -1;
          while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
            let i = gs;
            while (parts[i + 1] === "**") {
              i++;
            }
            if (i !== gs) {
              parts.splice(gs, i - gs);
            }
          }
          return parts;
        });
      }
      // get rid of adjascent ** and resolve .. portions
      levelOneOptimize(globParts) {
        return globParts.map((parts) => {
          parts = parts.reduce((set, part) => {
            const prev = set[set.length - 1];
            if (part === "**" && prev === "**") {
              return set;
            }
            if (part === "..") {
              if (prev && prev !== ".." && prev !== "." && prev !== "**") {
                set.pop();
                return set;
              }
            }
            set.push(part);
            return set;
          }, []);
          return parts.length === 0 ? [""] : parts;
        });
      }
      levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
          parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
          didSomething = false;
          if (!this.preserveMultipleSlashes) {
            for (let i = 1; i < parts.length - 1; i++) {
              const p = parts[i];
              if (i === 1 && p === "" && parts[0] === "")
                continue;
              if (p === "." || p === "") {
                didSomething = true;
                parts.splice(i, 1);
                i--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd = 0;
          while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
            const p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = true;
              parts.splice(dd - 1, 2);
              dd -= 2;
            }
          }
        } while (didSomething);
        return parts.length === 0 ? [""] : parts;
      }
      // First phase: single-pattern processing
      // <pre> is 1 or more portions
      // <rest> is 1 or more portions
      // <p> is any portion other than ., .., '', or **
      // <e> is . or ''
      //
      // **/.. is *brutal* for filesystem walking performance, because
      // it effectively resets the recursive walk each time it occurs,
      // and ** cannot be reduced out by a .. pattern part like a regexp
      // or most strings (other than .., ., and '') can be.
      //
      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
      // <pre>/<e>/<rest> -> <pre>/<rest>
      // <pre>/<p>/../<rest> -> <pre>/<rest>
      // **/**/<rest> -> **/<rest>
      //
      // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
      // this WOULD be allowed if ** did follow symlinks, or * didn't
      firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
          didSomething = false;
          for (let parts of globParts) {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
              let gss = gs;
              while (parts[gss + 1] === "**") {
                gss++;
              }
              if (gss > gs) {
                parts.splice(gs + 1, gss - gs);
              }
              let next = parts[gs + 1];
              const p = parts[gs + 2];
              const p2 = parts[gs + 3];
              if (next !== "..")
                continue;
              if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
                continue;
              }
              didSomething = true;
              parts.splice(gs, 1);
              const other = parts.slice(0);
              other[gs] = "**";
              globParts.push(other);
              gs--;
            }
            if (!this.preserveMultipleSlashes) {
              for (let i = 1; i < parts.length - 1; i++) {
                const p = parts[i];
                if (i === 1 && p === "" && parts[0] === "")
                  continue;
                if (p === "." || p === "") {
                  didSomething = true;
                  parts.splice(i, 1);
                  i--;
                }
              }
              if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
                didSomething = true;
                parts.pop();
              }
            }
            let dd = 0;
            while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
              const p = parts[dd - 1];
              if (p && p !== "." && p !== ".." && p !== "**") {
                didSomething = true;
                const needDot = dd === 1 && parts[dd + 1] === "**";
                const splin = needDot ? ["."] : [];
                parts.splice(dd - 1, 2, ...splin);
                if (parts.length === 0)
                  parts.push("");
                dd -= 2;
              }
            }
          }
        } while (didSomething);
        return globParts;
      }
      // second phase: multi-pattern dedupes
      // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
      // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
      // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
      //
      // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
      // ^-- not valid because ** doens't follow symlinks
      secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
          for (let j = i + 1; j < globParts.length; j++) {
            const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
            if (matched) {
              globParts[i] = [];
              globParts[j] = matched;
              break;
            }
          }
        }
        return globParts.filter((gs) => gs.length);
      }
      partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = "";
        while (ai < a.length && bi < b.length) {
          if (a[ai] === b[bi]) {
            result.push(which === "b" ? b[bi] : a[ai]);
            ai++;
            bi++;
          } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
            result.push(a[ai]);
            ai++;
          } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
            result.push(b[bi]);
            bi++;
          } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
            if (which === "b")
              return false;
            which = "a";
            result.push(a[ai]);
            ai++;
            bi++;
          } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
            if (which === "a")
              return false;
            which = "b";
            result.push(b[bi]);
            ai++;
            bi++;
          } else {
            return false;
          }
        }
        return a.length === b.length && result;
      }
      parseNegate() {
        if (this.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial = false) {
        const options = this.options;
        if (this.isWindows) {
          const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
          const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
          const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
          const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
          const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
          const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
          if (typeof fdi === "number" && typeof pdi === "number") {
            const [fd, pd] = [file[fdi], pattern[pdi]];
            if (fd.toLowerCase() === pd.toLowerCase()) {
              pattern[pdi] = fd;
              if (pdi > fdi) {
                pattern = pattern.slice(pdi);
              } else if (fdi > pdi) {
                file = file.slice(fdi);
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          file = this.levelTwoFileOptimize(file);
        }
        this.debug("matchOne", this, { file, pattern });
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false) {
            return false;
          }
          if (p === exports2.GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl) {
                return true;
              }
            }
            return false;
          }
          let hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = p.test(f);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        } else {
          throw new Error("wtf?");
        }
      }
      braceExpand() {
        return (0, exports2.braceExpand)(this.pattern, this.options);
      }
      parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options = this.options;
        if (pattern === "**")
          return exports2.GLOBSTAR;
        if (pattern === "")
          return "";
        let m;
        let fastTest = null;
        if (m = pattern.match(starRE)) {
          fastTest = options.dot ? starTestDot : starTest;
        } else if (m = pattern.match(starDotExtRE)) {
          fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
        } else if (m = pattern.match(qmarksRE)) {
          fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
        } else if (m = pattern.match(starDotStarRE)) {
          fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        } else if (m = pattern.match(dotStarRE)) {
          fastTest = dotStarTest;
        }
        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === "object") {
          Reflect.defineProperty(re, "test", { value: fastTest });
        }
        return re;
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = new Set(options.nocase ? ["i"] : []);
        let re = set.map((pattern) => {
          const pp = pattern.map((p) => {
            if (p instanceof RegExp) {
              for (const f of p.flags.split(""))
                flags.add(f);
            }
            return typeof p === "string" ? regExpEscape(p) : p === exports2.GLOBSTAR ? exports2.GLOBSTAR : p._src;
          });
          pp.forEach((p, i) => {
            const next = pp[i + 1];
            const prev = pp[i - 1];
            if (p !== exports2.GLOBSTAR || prev === exports2.GLOBSTAR) {
              return;
            }
            if (prev === void 0) {
              if (next !== void 0 && next !== exports2.GLOBSTAR) {
                pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
              } else {
                pp[i] = twoStar;
              }
            } else if (next === void 0) {
              pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
            } else if (next !== exports2.GLOBSTAR) {
              pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
              pp[i + 1] = exports2.GLOBSTAR;
            }
          });
          return pp.filter((p) => p !== exports2.GLOBSTAR).join("/");
        }).join("|");
        const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
        re = "^" + open + re + close + "$";
        if (this.negate)
          re = "^(?!" + re + ").+$";
        try {
          this.regexp = new RegExp(re, [...flags].join(""));
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      slashSplit(p) {
        if (this.preserveMultipleSlashes) {
          return p.split("/");
        } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
          return ["", ...p.split(/\/+/)];
        } else {
          return p.split(/\/+/);
        }
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment) {
          return false;
        }
        if (this.empty) {
          return f === "";
        }
        if (f === "/" && partial) {
          return true;
        }
        const options = this.options;
        if (this.isWindows) {
          f = f.split("\\").join("/");
        }
        const ff = this.slashSplit(f);
        this.debug(this.pattern, "split", ff);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename = ff[ff.length - 1];
        if (!filename) {
          for (let i = ff.length - 2; !filename && i >= 0; i--) {
            filename = ff[i];
          }
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = ff;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate) {
              return true;
            }
            return !this.negate;
          }
        }
        if (options.flipNegate) {
          return false;
        }
        return this.negate;
      }
      static defaults(def) {
        return exports2.minimatch.defaults(def).Minimatch;
      }
    };
    exports2.Minimatch = Minimatch;
    var ast_js_2 = require_ast();
    Object.defineProperty(exports2, "AST", { enumerable: true, get: function() {
      return ast_js_2.AST;
    } });
    var escape_js_2 = require_escape();
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    var unescape_js_2 = require_unescape();
    Object.defineProperty(exports2, "unescape", { enumerable: true, get: function() {
      return unescape_js_2.unescape;
    } });
    exports2.minimatch.AST = ast_js_1.AST;
    exports2.minimatch.Minimatch = Minimatch;
    exports2.minimatch.escape = escape_js_1.escape;
    exports2.minimatch.unescape = unescape_js_1.unescape;
  }
});

// node_modules/json-parse-even-better-errors/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/json-parse-even-better-errors/lib/index.js"(exports2, module2) {
    "use strict";
    var INDENT = Symbol.for("indent");
    var NEWLINE = Symbol.for("newline");
    var DEFAULT_NEWLINE = "\n";
    var DEFAULT_INDENT = "  ";
    var BOM = /^\uFEFF/;
    var FORMAT = /^\s*[{[]((?:\r?\n)+)([\s\t]*)/;
    var EMPTY = /^(?:\{\}|\[\])((?:\r?\n)+)?$/;
    var UNEXPECTED_TOKEN = /^Unexpected token '?(.)'?(,)? /i;
    var hexify = (char) => {
      const h = char.charCodeAt(0).toString(16).toUpperCase();
      return `0x${h.length % 2 ? "0" : ""}${h}`;
    };
    var stripBOM = (txt) => String(txt).replace(BOM, "");
    var makeParsedError = (msg, parsing, position = 0) => ({
      message: `${msg} while parsing ${parsing}`,
      position
    });
    var parseError = (e, txt, context = 20) => {
      let msg = e.message;
      if (!txt) {
        return makeParsedError(msg, "empty string");
      }
      const badTokenMatch = msg.match(UNEXPECTED_TOKEN);
      const badIndexMatch = msg.match(/ position\s+(\d+)/i);
      if (badTokenMatch) {
        msg = msg.replace(
          UNEXPECTED_TOKEN,
          `Unexpected token ${JSON.stringify(badTokenMatch[1])} (${hexify(badTokenMatch[1])})$2 `
        );
      }
      let errIdx;
      if (badIndexMatch) {
        errIdx = +badIndexMatch[1];
      } else if (msg.match(/^Unexpected end of JSON.*/i)) {
        errIdx = txt.length - 1;
      }
      if (errIdx == null) {
        return makeParsedError(msg, `'${txt.slice(0, context * 2)}'`);
      }
      const start = errIdx <= context ? 0 : errIdx - context;
      const end = errIdx + context >= txt.length ? txt.length : errIdx + context;
      const slice = `${start ? "..." : ""}${txt.slice(start, end)}${end === txt.length ? "" : "..."}`;
      return makeParsedError(
        msg,
        `${txt === slice ? "" : "near "}${JSON.stringify(slice)}`,
        errIdx
      );
    };
    var JSONParseError = class extends SyntaxError {
      constructor(er, txt, context, caller) {
        const metadata = parseError(er, txt, context);
        super(metadata.message);
        Object.assign(this, metadata);
        this.code = "EJSONPARSE";
        this.systemError = er;
        Error.captureStackTrace(this, caller || this.constructor);
      }
      get name() {
        return this.constructor.name;
      }
      set name(n) {
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    var parseJson = (txt, reviver) => {
      const result = JSON.parse(txt, reviver);
      if (result && typeof result === "object") {
        const match = txt.match(EMPTY) || txt.match(FORMAT) || [null, "", ""];
        result[NEWLINE] = match[1] ?? DEFAULT_NEWLINE;
        result[INDENT] = match[2] ?? DEFAULT_INDENT;
      }
      return result;
    };
    var parseJsonError = (raw, reviver, context) => {
      const txt = stripBOM(raw);
      try {
        return parseJson(txt, reviver);
      } catch (e) {
        if (typeof raw !== "string" && !Buffer.isBuffer(raw)) {
          const msg = Array.isArray(raw) && raw.length === 0 ? "an empty array" : String(raw);
          throw Object.assign(
            new TypeError(`Cannot parse ${msg}`),
            { code: "EJSONPARSE", systemError: e }
          );
        }
        throw new JSONParseError(e, txt, context, parseJsonError);
      }
    };
    module2.exports = parseJsonError;
    parseJsonError.JSONParseError = JSONParseError;
    parseJsonError.noExceptions = (raw, reviver) => {
      try {
        return parseJson(stripBOM(raw), reviver);
      } catch {
      }
    };
  }
});

// node_modules/@npmcli/package-json/lib/update-dependencies.js
var require_update_dependencies = __commonJS({
  "node_modules/@npmcli/package-json/lib/update-dependencies.js"(exports2, module2) {
    var depTypes = /* @__PURE__ */ new Set([
      "dependencies",
      "optionalDependencies",
      "devDependencies",
      "peerDependencies"
    ]);
    var orderDeps = (content) => {
      for (const type of depTypes) {
        if (content && content[type]) {
          content[type] = Object.keys(content[type]).sort((a, b) => a.localeCompare(b, "en")).reduce((res, key) => {
            res[key] = content[type][key];
            return res;
          }, {});
        }
      }
      return content;
    };
    var updateDependencies = ({ content, originalContent }) => {
      const pkg = orderDeps({
        ...content
      });
      if (pkg.dependencies) {
        if (pkg.optionalDependencies) {
          for (const name of Object.keys(pkg.optionalDependencies)) {
            delete pkg.dependencies[name];
          }
        }
      }
      const result = { ...originalContent };
      for (const type of depTypes) {
        if (pkg[type]) {
          result[type] = pkg[type];
        }
        const emptyDepType = pkg[type] && typeof pkg === "object" && Object.keys(pkg[type]).length === 0;
        if (emptyDepType) {
          delete result[type];
        }
      }
      const { dependencies: origProd, peerDependencies: origPeer } = originalContent || {};
      const { peerDependencies: newPeer } = result;
      if (origProd && origPeer && newPeer) {
        for (const name of Object.keys(origPeer)) {
          if (origProd[name] !== void 0 && newPeer[name] !== void 0) {
            result.dependencies = result.dependencies || {};
            result.dependencies[name] = newPeer[name];
          }
        }
      }
      return result;
    };
    updateDependencies.knownKeys = depTypes;
    module2.exports = updateDependencies;
  }
});

// node_modules/@npmcli/package-json/lib/update-scripts.js
var require_update_scripts = __commonJS({
  "node_modules/@npmcli/package-json/lib/update-scripts.js"(exports2, module2) {
    var updateScripts = ({ content, originalContent = {} }) => {
      const newScripts = content.scripts;
      if (!newScripts) {
        return originalContent;
      }
      const hasInvalidScripts = () => Object.entries(newScripts).some(([key, value]) => typeof key !== "string" || typeof value !== "string");
      if (hasInvalidScripts()) {
        throw Object.assign(
          new TypeError(
            "package.json scripts should be a key-value pair of strings."
          ),
          { code: "ESCRIPTSINVALID" }
        );
      }
      return {
        ...originalContent,
        scripts: {
          ...newScripts
        }
      };
    };
    module2.exports = updateScripts;
  }
});

// node_modules/@npmcli/package-json/lib/update-workspaces.js
var require_update_workspaces = __commonJS({
  "node_modules/@npmcli/package-json/lib/update-workspaces.js"(exports2, module2) {
    var updateWorkspaces = ({ content, originalContent = {} }) => {
      const newWorkspaces = content.workspaces;
      if (!newWorkspaces) {
        return originalContent;
      }
      const hasInvalidWorkspaces = () => newWorkspaces.some((w) => !(typeof w === "string"));
      if (!newWorkspaces.length || hasInvalidWorkspaces()) {
        throw Object.assign(
          new TypeError("workspaces should be an array of strings."),
          { code: "EWORKSPACESINVALID" }
        );
      }
      return {
        ...originalContent,
        workspaces: [
          ...newWorkspaces
        ]
      };
    };
    module2.exports = updateWorkspaces;
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, safeSrc: src, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`);
            const match = `-${identifier}`.match(r);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse = require_parse();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse = require_parse();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/proc-log/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/proc-log/lib/index.js"(exports2, module2) {
    var META = Symbol("proc-log.meta");
    module2.exports = {
      META,
      output: {
        LEVELS: [
          "standard",
          "error",
          "buffer",
          "flush"
        ],
        KEYS: {
          standard: "standard",
          error: "error",
          buffer: "buffer",
          flush: "flush"
        },
        standard: function(...args) {
          return process.emit("output", "standard", ...args);
        },
        error: function(...args) {
          return process.emit("output", "error", ...args);
        },
        buffer: function(...args) {
          return process.emit("output", "buffer", ...args);
        },
        flush: function(...args) {
          return process.emit("output", "flush", ...args);
        }
      },
      log: {
        LEVELS: [
          "notice",
          "error",
          "warn",
          "info",
          "verbose",
          "http",
          "silly",
          "timing",
          "pause",
          "resume"
        ],
        KEYS: {
          notice: "notice",
          error: "error",
          warn: "warn",
          info: "info",
          verbose: "verbose",
          http: "http",
          silly: "silly",
          timing: "timing",
          pause: "pause",
          resume: "resume"
        },
        error: function(...args) {
          return process.emit("log", "error", ...args);
        },
        notice: function(...args) {
          return process.emit("log", "notice", ...args);
        },
        warn: function(...args) {
          return process.emit("log", "warn", ...args);
        },
        info: function(...args) {
          return process.emit("log", "info", ...args);
        },
        verbose: function(...args) {
          return process.emit("log", "verbose", ...args);
        },
        http: function(...args) {
          return process.emit("log", "http", ...args);
        },
        silly: function(...args) {
          return process.emit("log", "silly", ...args);
        },
        timing: function(...args) {
          return process.emit("log", "timing", ...args);
        },
        pause: function() {
          return process.emit("log", "pause");
        },
        resume: function() {
          return process.emit("log", "resume");
        }
      },
      time: {
        LEVELS: [
          "start",
          "end"
        ],
        KEYS: {
          start: "start",
          end: "end"
        },
        start: function(name, fn) {
          process.emit("time", "start", name);
          function end() {
            return process.emit("time", "end", name);
          }
          if (typeof fn === "function") {
            const res = fn();
            if (res && res.finally) {
              return res.finally(end);
            }
            end();
            return res;
          }
          return end;
        },
        end: function(name) {
          return process.emit("time", "end", name);
        }
      },
      input: {
        LEVELS: [
          "start",
          "end",
          "read"
        ],
        KEYS: {
          start: "start",
          end: "end",
          read: "read"
        },
        start: function(fn) {
          process.emit("input", "start");
          function end() {
            return process.emit("input", "end");
          }
          if (typeof fn === "function") {
            const res = fn();
            if (res && res.finally) {
              return res.finally(end);
            }
            end();
            return res;
          }
          return end;
        },
        end: function() {
          return process.emit("input", "end");
        },
        read: function(...args) {
          let resolve, reject;
          const promise = new Promise((_resolve, _reject) => {
            resolve = _resolve;
            reject = _reject;
          });
          process.emit("input", "read", resolve, reject, ...args);
          return promise;
        }
      }
    };
  }
});

// node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs2 = __commonJS({
  "node_modules/lru-cache/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class _Stack {
      heap;
      length;
      // private constructor
      static #constructing = false;
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        _Stack.#constructing = true;
        const s = new _Stack(max, HeapCls);
        _Stack.#constructing = false;
        return s;
      }
      constructor(max, HeapCls) {
        if (!_Stack.#constructing) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      // options that cannot be changed without disaster
      #max;
      #maxSize;
      #dispose;
      #disposeAfter;
      #fetchMethod;
      #memoMethod;
      /**
       * {@link LRUCache.OptionsBase.ttl}
       */
      ttl;
      /**
       * {@link LRUCache.OptionsBase.ttlResolution}
       */
      ttlResolution;
      /**
       * {@link LRUCache.OptionsBase.ttlAutopurge}
       */
      ttlAutopurge;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnGet}
       */
      updateAgeOnGet;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnHas}
       */
      updateAgeOnHas;
      /**
       * {@link LRUCache.OptionsBase.allowStale}
       */
      allowStale;
      /**
       * {@link LRUCache.OptionsBase.noDisposeOnSet}
       */
      noDisposeOnSet;
      /**
       * {@link LRUCache.OptionsBase.noUpdateTTL}
       */
      noUpdateTTL;
      /**
       * {@link LRUCache.OptionsBase.maxEntrySize}
       */
      maxEntrySize;
      /**
       * {@link LRUCache.OptionsBase.sizeCalculation}
       */
      sizeCalculation;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
       */
      noDeleteOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
       */
      noDeleteOnStaleGet;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
       */
      allowStaleOnFetchAbort;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
       */
      allowStaleOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.ignoreFetchAbort}
       */
      ignoreFetchAbort;
      // computed properties
      #size;
      #calculatedSize;
      #keyMap;
      #keyList;
      #valList;
      #next;
      #prev;
      #head;
      #tail;
      #free;
      #disposed;
      #sizes;
      #starts;
      #ttls;
      #hasDispose;
      #hasFetchMethod;
      #hasDisposeAfter;
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c) {
        return {
          // properties
          starts: c.#starts,
          ttls: c.#ttls,
          sizes: c.#sizes,
          keyMap: c.#keyMap,
          keyList: c.#keyList,
          valList: c.#valList,
          next: c.#next,
          prev: c.#prev,
          get head() {
            return c.#head;
          },
          get tail() {
            return c.#tail;
          },
          free: c.#free,
          // methods
          isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
          backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
          moveToTail: (index) => c.#moveToTail(index),
          indexes: (options) => c.#indexes(options),
          rindexes: (options) => c.#rindexes(options),
          isStale: (index) => c.#isStale(index)
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return this.#max;
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return this.#maxSize;
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return this.#calculatedSize;
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return this.#size;
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return this.#fetchMethod;
      }
      get memoMethod() {
        return this.#memoMethod;
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return this.#dispose;
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return this.#disposeAfter;
      }
      constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!this.#maxSize && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (memoMethod !== void 0 && typeof memoMethod !== "function") {
          throw new TypeError("memoMethod must be a function if defined");
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = /* @__PURE__ */ new Map();
        this.#keyList = new Array(max).fill(void 0);
        this.#valList = new Array(max).fill(void 0);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === "function") {
          this.#dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.#disposeAfter = disposeAfter;
          this.#disposed = [];
        } else {
          this.#disposeAfter = void 0;
          this.#disposed = void 0;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.#maxSize !== 0) {
            if (!isPosInt(this.#maxSize)) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.#initializeTTLTracking();
        }
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Return the number of ms left in the item's TTL. If item is not in cache,
       * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
       */
      getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
      }
      #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
          starts[index] = ttl !== 0 ? start : 0;
          ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.#isStale(index)) {
                this.#delete(this.#keyList[index], "expire");
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.#updateItemAge = (index) => {
          starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
          if (ttls[index]) {
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start)
              return;
            status.ttl = ttl;
            status.start = start;
            status.now = cachedNow || getNow();
            const age = status.now - start;
            status.remainingTTL = ttl - age;
          }
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.#keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start) {
            return Infinity;
          }
          const age = (cachedNow || getNow()) - start;
          return ttl - age;
        };
        this.#isStale = (index) => {
          const s = starts[index];
          const t = ttls[index];
          return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
      }
      // conditionally set private methods related to TTL
      #updateItemAge = () => {
      };
      #statusTTL = () => {
      };
      #setItemTTL = () => {
      };
      /* c8 ignore stop */
      #isStale = () => false;
      #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index) => {
          this.#calculatedSize -= sizes[index];
          sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
          if (this.#isBackgroundFetch(v)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
            } else {
              throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
            }
          }
          return size;
        };
        this.#addItemSize = (index, size, status) => {
          sizes[index] = size;
          if (this.#maxSize) {
            const maxSize = this.#maxSize - sizes[index];
            while (this.#calculatedSize > maxSize) {
              this.#evict(true);
            }
          }
          this.#calculatedSize += sizes[index];
          if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = this.#calculatedSize;
          }
        };
      }
      #removeItemSize = (_i) => {
      };
      #addItemSize = (_i, _s, _st) => {
      };
      #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
        return 0;
      };
      *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#tail; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#head) {
              break;
            } else {
              i = this.#prev[i];
            }
          }
        }
      }
      *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#head; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#tail) {
              break;
            } else {
              i = this.#next[i];
            }
          }
        }
      }
      #isValidIndex(index) {
        return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i of this.#indexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i of this.#rindexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i of this.#indexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i of this.#rindexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * A String value that is used in the creation of the default string
       * description of an object. Called by the built-in method
       * `Object.prototype.toString`.
       */
      [Symbol.toStringTag] = "LRUCache";
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
       */
      find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, this.#keyList[i], this)) {
            return this.get(this.#keyList[i], getOptions);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from most
       * recently used to least recently used.
       *
       * `fn` is called as `fn(value, key, cache)`.
       *
       * If `thisp` is provided, function will be called in the `this`-context of
       * the provided object, or the cache if no `thisp` object is provided.
       *
       * Does not update age or recenty of use, or iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
          if (this.#isStale(i)) {
            this.#delete(this.#keyList[i], "expire");
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Returns `undefined` if the key is not present.
       *
       * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
       * serialization, the `start` value is always the current timestamp, and the
       * `ttl` is a calculated remaining time to live (negative if expired).
       *
       * Always returns stale values, if their info is found in the cache, so be
       * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
       * if relevant.
       */
      info(key) {
        const i = this.#keyMap.get(key);
        if (i === void 0)
          return void 0;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          return void 0;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          const ttl = this.#ttls[i];
          const start = this.#starts[i];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        return entry;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to {@link LRLUCache#load}.
       *
       * The `start` fields are calculated relative to a portable `Date.now()`
       * timestamp, even if `performance.now()` is available.
       *
       * Stale entries are always included in the `dump`, even if
       * {@link LRUCache.OptionsBase.allowStale} is false.
       *
       * Note: this returns an actual array, not a generator, so it can be more
       * easily passed around.
       */
      dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
          const key = this.#keyList[i];
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key === void 0)
            continue;
          const entry = { value };
          if (this.#ttls && this.#starts) {
            entry.ttl = this.#ttls[i];
            const age = perf.now() - this.#starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.#sizes) {
            entry.size = this.#sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       *
       * The shape of the resulting cache may be different if the same options are
       * not used in both caches.
       *
       * The `start` fields are assumed to be calculated relative to a portable
       * `Date.now()` timestamp, even if `performance.now()` is available.
       */
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       *
       * Fields on the {@link LRUCache.SetOptions} options param will override
       * their corresponding values in the constructor options for the scope
       * of this single `set()` operation.
       *
       * If `start` is provided, then that will set the effective start
       * time for the TTL calculation. Note that this must be a previous
       * value of `performance.now()` if supported, or a previous value of
       * `Date.now()` if not.
       *
       * Options object may also include `size`, which will prevent
       * calling the `sizeCalculation` function and just use the specified
       * number if it is a positive integer, and `noDisposeOnSet` which
       * will prevent calling a `dispose` function in the case of
       * overwrites.
       *
       * If the `size` (or return value of `sizeCalculation`) for a given
       * entry is greater than `maxEntrySize`, then the item will not be
       * added to the cache.
       *
       * Will update the recency of the entry.
       *
       * If the value is `undefined`, then this is an alias for
       * `cache.delete(key)`. `undefined` is never stored in the cache.
       */
      set(k, v, setOptions = {}) {
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.#delete(k, "set");
          return this;
        }
        let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
        if (index === void 0) {
          index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
          this.#keyList[index] = k;
          this.#valList[index] = v;
          this.#keyMap.set(k, index);
          this.#next[this.#tail] = index;
          this.#prev[index] = this.#tail;
          this.#tail = index;
          this.#size++;
          this.#addItemSize(index, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
        } else {
          this.#moveToTail(index);
          const oldVal = this.#valList[index];
          if (v !== oldVal) {
            if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if (this.#hasDispose) {
                  this.#dispose?.(s, k, "set");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(oldVal, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([oldVal, k, "set"]);
              }
            }
            this.#removeItemSize(index);
            this.#addItemSize(index, size, status);
            this.#valList[index] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && !this.#ttls) {
          this.#initializeTTLTracking();
        }
        if (this.#ttls) {
          if (!noUpdateTTL) {
            this.#setItemTTL(index, ttl, start);
          }
          if (status)
            this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        try {
          while (this.#size) {
            const val = this.#valList[this.#head];
            this.#evict(true);
            if (this.#isBackgroundFetch(val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while (task = dt?.shift()) {
              this.#disposeAfter?.(...task);
            }
          }
        }
      }
      #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("evicted"));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
          if (this.#hasDispose) {
            this.#dispose?.(v, k, "evict");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, "evict"]);
          }
        }
        this.#removeItemSize(head);
        if (free) {
          this.#keyList[head] = void 0;
          this.#valList[head] = void 0;
          this.#free.push(head);
        }
        if (this.#size === 1) {
          this.#head = this.#tail = 0;
          this.#free.length = 0;
        } else {
          this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Check if a key is in the cache, without updating the recency of
       * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
       * to `true` in either the options or the constructor.
       *
       * Will return `false` if the item is stale, even though it is technically in
       * the cache. The difference can be determined (if it matters) by using a
       * `status` argument, and inspecting the `has` field.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!this.#isStale(index)) {
            if (updateAgeOnHas) {
              this.#updateItemAge(index);
            }
            if (status) {
              status.has = "hit";
              this.#statusTTL(status, index);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            this.#statusTTL(status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === void 0 || !allowStale && this.#isStale(index)) {
          return;
        }
        const v = this.#valList[index];
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
      #backgroundFetch(k, index, options, context) {
        const v = index === void 0 ? void 0 : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const { signal } = options;
        signal?.addEventListener("abort", () => ac.abort(signal.reason), {
          signal: ac.signal
        });
        const fetchOpts = {
          signal: ac.signal,
          options,
          context
        };
        const cb = (v2, updateCache = false) => {
          const { aborted } = ac.signal;
          const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
          if (options.status) {
            if (aborted && !updateCache) {
              options.status.fetchAborted = true;
              options.status.fetchError = ac.signal.reason;
              if (ignoreAbort)
                options.status.fetchAbortIgnored = true;
            } else {
              options.status.fetchResolved = true;
            }
          }
          if (aborted && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          const bf2 = p;
          if (this.#valList[index] === p) {
            if (v2 === void 0) {
              if (bf2.__staleWhileFetching) {
                this.#valList[index] = bf2.__staleWhileFetching;
              } else {
                this.#delete(k, "fetch");
              }
            } else {
              if (options.status)
                options.status.fetchUpdated = true;
              this.set(k, v2, fetchOpts.options);
            }
          }
          return v2;
        };
        const eb = (er) => {
          if (options.status) {
            options.status.fetchRejected = true;
            options.status.fetchError = er;
          }
          return fetchFail(er);
        };
        const fetchFail = (er) => {
          const { aborted } = ac.signal;
          const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
          const noDelete = allowStale || options.noDeleteOnFetchRejection;
          const bf2 = p;
          if (this.#valList[index] === p) {
            const del = !noDelete || bf2.__staleWhileFetching === void 0;
            if (del) {
              this.#delete(k, "fetch");
            } else if (!allowStaleAborted) {
              this.#valList[index] = bf2.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options.status && bf2.__staleWhileFetching !== void 0) {
              options.status.returnedStale = true;
            }
            return bf2.__staleWhileFetching;
          } else if (bf2.__returned === bf2) {
            throw er;
          }
        };
        const pcall = (res, rej) => {
          const fmp = this.#fetchMethod?.(k, v, fetchOpts);
          if (fmp && fmp instanceof Promise) {
            fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
          }
          ac.signal.addEventListener("abort", () => {
            if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
              res(void 0);
              if (options.allowStaleOnFetchAbort) {
                res = (v2) => cb(v2, true);
              }
            }
          });
        };
        if (options.status)
          options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
          __abortController: ac,
          __staleWhileFetching: v,
          __returned: void 0
        });
        if (index === void 0) {
          this.set(k, bf, { ...fetchOpts.options, status: void 0 });
          index = this.#keyMap.get(k);
        } else {
          this.#valList[index] = bf;
        }
        return bf;
      }
      #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
          return false;
        const b = p;
        return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!this.#hasFetchMethod) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = this.#keyMap.get(k);
        if (index === void 0) {
          if (status)
            status.fetch = "miss";
          const p = this.#backgroundFetch(k, index, options, context);
          return p.__returned = p;
        } else {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = this.#isStale(index);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            if (status)
              this.#statusTTL(status, index);
            return v;
          }
          const p = this.#backgroundFetch(k, index, options, context);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === void 0)
          throw new Error("fetch() returned undefined");
        return v;
      }
      memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
          throw new Error("no memoMethod provided to constructor");
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== void 0)
          return v;
        const vv = memoMethod(k, v, {
          options,
          context
        });
        this.set(k, vv, options);
        return vv;
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const value = this.#valList[index];
          const fetching = this.#isBackgroundFetch(value);
          if (status)
            this.#statusTTL(status, index);
          if (this.#isStale(index)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.#delete(k, "expire");
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
      }
      #moveToTail(index) {
        if (index !== this.#tail) {
          if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            this.#connect(this.#prev[index], this.#next[index]);
          }
          this.#connect(this.#tail, index);
          this.#tail = index;
        }
      }
      /**
       * Deletes a key out of the cache.
       *
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k) {
        return this.#delete(k, "delete");
      }
      #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
          const index = this.#keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.#size === 1) {
              this.#clear(reason);
            } else {
              this.#removeItemSize(index);
              const v = this.#valList[index];
              if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
              } else if (this.#hasDispose || this.#hasDisposeAfter) {
                if (this.#hasDispose) {
                  this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([v, k, reason]);
                }
              }
              this.#keyMap.delete(k);
              this.#keyList[index] = void 0;
              this.#valList[index] = void 0;
              if (index === this.#tail) {
                this.#tail = this.#prev[index];
              } else if (index === this.#head) {
                this.#head = this.#next[index];
              } else {
                const pi = this.#prev[index];
                this.#next[pi] = this.#next[index];
                const ni = this.#next[index];
                this.#prev[ni] = this.#prev[index];
              }
              this.#size--;
              this.#free.push(index);
            }
          }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return deleted;
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        return this.#clear("delete");
      }
      #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.#keyList[index];
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
        }
        this.#keyMap.clear();
        this.#valList.fill(void 0);
        this.#keyList.fill(void 0);
        if (this.#ttls && this.#starts) {
          this.#ttls.fill(0);
          this.#starts.fill(0);
        }
        if (this.#sizes) {
          this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/hosted-git-info/lib/hosts.js
var require_hosts = __commonJS({
  "node_modules/hosted-git-info/lib/hosts.js"(exports2, module2) {
    "use strict";
    var maybeJoin = (...args) => args.every((arg) => arg) ? args.join("") : "";
    var maybeEncode = (arg) => arg ? encodeURIComponent(arg) : "";
    var formatHashFragment = (f) => f.toLowerCase().replace(/^\W+/g, "").replace(/(?<!\W)\W+$/, "").replace(/\//g, "").replace(/\W+/g, "-");
    var defaults = {
      sshtemplate: ({ domain, user, project, committish }) => `git@${domain}:${user}/${project}.git${maybeJoin("#", committish)}`,
      sshurltemplate: ({ domain, user, project, committish }) => `git+ssh://git@${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
      edittemplate: ({ domain, user, project, committish, editpath, path }) => `https://${domain}/${user}/${project}${maybeJoin("/", editpath, "/", maybeEncode(committish || "HEAD"), "/", path)}`,
      browsetemplate: ({ domain, user, project, committish, treepath }) => `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish))}`,
      browsetreetemplate: ({ domain, user, project, committish, treepath, path, fragment, hashformat }) => `https://${domain}/${user}/${project}/${treepath}/${maybeEncode(committish || "HEAD")}/${path}${maybeJoin("#", hashformat(fragment || ""))}`,
      browseblobtemplate: ({ domain, user, project, committish, blobpath, path, fragment, hashformat }) => `https://${domain}/${user}/${project}/${blobpath}/${maybeEncode(committish || "HEAD")}/${path}${maybeJoin("#", hashformat(fragment || ""))}`,
      docstemplate: ({ domain, user, project, treepath, committish }) => `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish))}#readme`,
      httpstemplate: ({ auth, domain, user, project, committish }) => `git+https://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
      filetemplate: ({ domain, user, project, committish, path }) => `https://${domain}/${user}/${project}/raw/${maybeEncode(committish || "HEAD")}/${path}`,
      shortcuttemplate: ({ type, user, project, committish }) => `${type}:${user}/${project}${maybeJoin("#", committish)}`,
      pathtemplate: ({ user, project, committish }) => `${user}/${project}${maybeJoin("#", committish)}`,
      bugstemplate: ({ domain, user, project }) => `https://${domain}/${user}/${project}/issues`,
      hashformat: formatHashFragment
    };
    var hosts = {};
    hosts.github = {
      // First two are insecure and generally shouldn't be used any more, but
      // they are still supported.
      protocols: ["git:", "http:", "git+ssh:", "git+https:", "ssh:", "https:"],
      domain: "github.com",
      treepath: "tree",
      blobpath: "blob",
      editpath: "edit",
      filetemplate: ({ auth, user, project, committish, path }) => `https://${maybeJoin(auth, "@")}raw.githubusercontent.com/${user}/${project}/${maybeEncode(committish || "HEAD")}/${path}`,
      gittemplate: ({ auth, domain, user, project, committish }) => `git://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
      tarballtemplate: ({ domain, user, project, committish }) => `https://codeload.${domain}/${user}/${project}/tar.gz/${maybeEncode(committish || "HEAD")}`,
      extract: (url) => {
        let [, user, project, type, committish] = url.pathname.split("/", 5);
        if (type && type !== "tree") {
          return;
        }
        if (!type) {
          committish = url.hash.slice(1);
        }
        if (project && project.endsWith(".git")) {
          project = project.slice(0, -4);
        }
        if (!user || !project) {
          return;
        }
        return { user, project, committish };
      }
    };
    hosts.bitbucket = {
      protocols: ["git+ssh:", "git+https:", "ssh:", "https:"],
      domain: "bitbucket.org",
      treepath: "src",
      blobpath: "src",
      editpath: "?mode=edit",
      edittemplate: ({ domain, user, project, committish, treepath, path, editpath }) => `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish || "HEAD"), "/", path, editpath)}`,
      tarballtemplate: ({ domain, user, project, committish }) => `https://${domain}/${user}/${project}/get/${maybeEncode(committish || "HEAD")}.tar.gz`,
      extract: (url) => {
        let [, user, project, aux] = url.pathname.split("/", 4);
        if (["get"].includes(aux)) {
          return;
        }
        if (project && project.endsWith(".git")) {
          project = project.slice(0, -4);
        }
        if (!user || !project) {
          return;
        }
        return { user, project, committish: url.hash.slice(1) };
      }
    };
    hosts.gitlab = {
      protocols: ["git+ssh:", "git+https:", "ssh:", "https:"],
      domain: "gitlab.com",
      treepath: "tree",
      blobpath: "tree",
      editpath: "-/edit",
      httpstemplate: ({ auth, domain, user, project, committish }) => `git+https://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
      tarballtemplate: ({ domain, user, project, committish }) => `https://${domain}/${user}/${project}/repository/archive.tar.gz?ref=${maybeEncode(committish || "HEAD")}`,
      extract: (url) => {
        const path = url.pathname.slice(1);
        if (path.includes("/-/") || path.includes("/archive.tar.gz")) {
          return;
        }
        const segments = path.split("/");
        let project = segments.pop();
        if (project.endsWith(".git")) {
          project = project.slice(0, -4);
        }
        const user = segments.join("/");
        if (!user || !project) {
          return;
        }
        return { user, project, committish: url.hash.slice(1) };
      }
    };
    hosts.gist = {
      protocols: ["git:", "git+ssh:", "git+https:", "ssh:", "https:"],
      domain: "gist.github.com",
      editpath: "edit",
      sshtemplate: ({ domain, project, committish }) => `git@${domain}:${project}.git${maybeJoin("#", committish)}`,
      sshurltemplate: ({ domain, project, committish }) => `git+ssh://git@${domain}/${project}.git${maybeJoin("#", committish)}`,
      edittemplate: ({ domain, user, project, committish, editpath }) => `https://${domain}/${user}/${project}${maybeJoin("/", maybeEncode(committish))}/${editpath}`,
      browsetemplate: ({ domain, project, committish }) => `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}`,
      browsetreetemplate: ({ domain, project, committish, path, hashformat }) => `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}${maybeJoin("#", hashformat(path))}`,
      browseblobtemplate: ({ domain, project, committish, path, hashformat }) => `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}${maybeJoin("#", hashformat(path))}`,
      docstemplate: ({ domain, project, committish }) => `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}`,
      httpstemplate: ({ domain, project, committish }) => `git+https://${domain}/${project}.git${maybeJoin("#", committish)}`,
      filetemplate: ({ user, project, committish, path }) => `https://gist.githubusercontent.com/${user}/${project}/raw${maybeJoin("/", maybeEncode(committish))}/${path}`,
      shortcuttemplate: ({ type, project, committish }) => `${type}:${project}${maybeJoin("#", committish)}`,
      pathtemplate: ({ project, committish }) => `${project}${maybeJoin("#", committish)}`,
      bugstemplate: ({ domain, project }) => `https://${domain}/${project}`,
      gittemplate: ({ domain, project, committish }) => `git://${domain}/${project}.git${maybeJoin("#", committish)}`,
      tarballtemplate: ({ project, committish }) => `https://codeload.github.com/gist/${project}/tar.gz/${maybeEncode(committish || "HEAD")}`,
      extract: (url) => {
        let [, user, project, aux] = url.pathname.split("/", 4);
        if (aux === "raw") {
          return;
        }
        if (!project) {
          if (!user) {
            return;
          }
          project = user;
          user = null;
        }
        if (project.endsWith(".git")) {
          project = project.slice(0, -4);
        }
        return { user, project, committish: url.hash.slice(1) };
      },
      hashformat: function(fragment) {
        return fragment && "file-" + formatHashFragment(fragment);
      }
    };
    hosts.sourcehut = {
      protocols: ["git+ssh:", "https:"],
      domain: "git.sr.ht",
      treepath: "tree",
      blobpath: "tree",
      filetemplate: ({ domain, user, project, committish, path }) => `https://${domain}/${user}/${project}/blob/${maybeEncode(committish) || "HEAD"}/${path}`,
      httpstemplate: ({ domain, user, project, committish }) => `https://${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
      tarballtemplate: ({ domain, user, project, committish }) => `https://${domain}/${user}/${project}/archive/${maybeEncode(committish) || "HEAD"}.tar.gz`,
      bugstemplate: () => null,
      extract: (url) => {
        let [, user, project, aux] = url.pathname.split("/", 4);
        if (["archive"].includes(aux)) {
          return;
        }
        if (project && project.endsWith(".git")) {
          project = project.slice(0, -4);
        }
        if (!user || !project) {
          return;
        }
        return { user, project, committish: url.hash.slice(1) };
      }
    };
    for (const [name, host] of Object.entries(hosts)) {
      hosts[name] = Object.assign({}, defaults, host);
    }
    module2.exports = hosts;
  }
});

// node_modules/hosted-git-info/lib/parse-url.js
var require_parse_url = __commonJS({
  "node_modules/hosted-git-info/lib/parse-url.js"(exports2, module2) {
    var url = require("url");
    var lastIndexOfBefore = (str, char, beforeChar) => {
      const startPosition = str.indexOf(beforeChar);
      return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity);
    };
    var safeUrl = (u) => {
      try {
        return new url.URL(u);
      } catch {
      }
    };
    var correctProtocol = (arg, protocols) => {
      const firstColon = arg.indexOf(":");
      const proto = arg.slice(0, firstColon + 1);
      if (Object.prototype.hasOwnProperty.call(protocols, proto)) {
        return arg;
      }
      const firstAt = arg.indexOf("@");
      if (firstAt > -1) {
        if (firstAt > firstColon) {
          return `git+ssh://${arg}`;
        } else {
          return arg;
        }
      }
      const doubleSlash = arg.indexOf("//");
      if (doubleSlash === firstColon + 1) {
        return arg;
      }
      return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`;
    };
    var correctUrl = (giturl) => {
      const firstAt = lastIndexOfBefore(giturl, "@", "#");
      const lastColonBeforeHash = lastIndexOfBefore(giturl, ":", "#");
      if (lastColonBeforeHash > firstAt) {
        giturl = giturl.slice(0, lastColonBeforeHash) + "/" + giturl.slice(lastColonBeforeHash + 1);
      }
      if (lastIndexOfBefore(giturl, ":", "#") === -1 && giturl.indexOf("//") === -1) {
        giturl = `git+ssh://${giturl}`;
      }
      return giturl;
    };
    module2.exports = (giturl, protocols) => {
      const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl;
      return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol));
    };
  }
});

// node_modules/hosted-git-info/lib/from-url.js
var require_from_url = __commonJS({
  "node_modules/hosted-git-info/lib/from-url.js"(exports2, module2) {
    "use strict";
    var parseUrl = require_parse_url();
    var isGitHubShorthand = (arg) => {
      const firstHash = arg.indexOf("#");
      const firstSlash = arg.indexOf("/");
      const secondSlash = arg.indexOf("/", firstSlash + 1);
      const firstColon = arg.indexOf(":");
      const firstSpace = /\s/.exec(arg);
      const firstAt = arg.indexOf("@");
      const spaceOnlyAfterHash = !firstSpace || firstHash > -1 && firstSpace.index > firstHash;
      const atOnlyAfterHash = firstAt === -1 || firstHash > -1 && firstAt > firstHash;
      const colonOnlyAfterHash = firstColon === -1 || firstHash > -1 && firstColon > firstHash;
      const secondSlashOnlyAfterHash = secondSlash === -1 || firstHash > -1 && secondSlash > firstHash;
      const hasSlash = firstSlash > 0;
      const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== "/" : !arg.endsWith("/");
      const doesNotStartWithDot = !arg.startsWith(".");
      return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash;
    };
    module2.exports = (giturl, opts, { gitHosts, protocols }) => {
      if (!giturl) {
        return;
      }
      const correctedUrl = isGitHubShorthand(giturl) ? `github:${giturl}` : giturl;
      const parsed = parseUrl(correctedUrl, protocols);
      if (!parsed) {
        return;
      }
      const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];
      const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith("www.") ? parsed.hostname.slice(4) : parsed.hostname];
      const gitHostName = gitHostShortcut || gitHostDomain;
      if (!gitHostName) {
        return;
      }
      const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];
      let auth = null;
      if (protocols[parsed.protocol]?.auth && (parsed.username || parsed.password)) {
        auth = `${parsed.username}${parsed.password ? ":" + parsed.password : ""}`;
      }
      let committish = null;
      let user = null;
      let project = null;
      let defaultRepresentation = null;
      try {
        if (gitHostShortcut) {
          let pathname = parsed.pathname.startsWith("/") ? parsed.pathname.slice(1) : parsed.pathname;
          const firstAt = pathname.indexOf("@");
          if (firstAt > -1) {
            pathname = pathname.slice(firstAt + 1);
          }
          const lastSlash = pathname.lastIndexOf("/");
          if (lastSlash > -1) {
            user = decodeURIComponent(pathname.slice(0, lastSlash));
            if (!user) {
              user = null;
            }
            project = decodeURIComponent(pathname.slice(lastSlash + 1));
          } else {
            project = decodeURIComponent(pathname);
          }
          if (project.endsWith(".git")) {
            project = project.slice(0, -4);
          }
          if (parsed.hash) {
            committish = decodeURIComponent(parsed.hash.slice(1));
          }
          defaultRepresentation = "shortcut";
        } else {
          if (!gitHostInfo.protocols.includes(parsed.protocol)) {
            return;
          }
          const segments = gitHostInfo.extract(parsed);
          if (!segments) {
            return;
          }
          user = segments.user && decodeURIComponent(segments.user);
          project = decodeURIComponent(segments.project);
          committish = decodeURIComponent(segments.committish);
          defaultRepresentation = protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1);
        }
      } catch (err) {
        if (err instanceof URIError) {
          return;
        } else {
          throw err;
        }
      }
      return [gitHostName, user, auth, project, committish, defaultRepresentation, opts];
    };
  }
});

// node_modules/hosted-git-info/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/hosted-git-info/lib/index.js"(exports2, module2) {
    "use strict";
    var { LRUCache } = require_commonjs2();
    var hosts = require_hosts();
    var fromUrl = require_from_url();
    var parseUrl = require_parse_url();
    var cache = new LRUCache({ max: 1e3 });
    var GitHost = class _GitHost {
      constructor(type, user, auth, project, committish, defaultRepresentation, opts = {}) {
        Object.assign(this, _GitHost.#gitHosts[type], {
          type,
          user,
          auth,
          project,
          committish,
          default: defaultRepresentation,
          opts
        });
      }
      static #gitHosts = { byShortcut: {}, byDomain: {} };
      static #protocols = {
        "git+ssh:": { name: "sshurl" },
        "ssh:": { name: "sshurl" },
        "git+https:": { name: "https", auth: true },
        "git:": { auth: true },
        "http:": { auth: true },
        "https:": { auth: true },
        "git+http:": { auth: true }
      };
      static addHost(name, host) {
        _GitHost.#gitHosts[name] = host;
        _GitHost.#gitHosts.byDomain[host.domain] = name;
        _GitHost.#gitHosts.byShortcut[`${name}:`] = name;
        _GitHost.#protocols[`${name}:`] = { name };
      }
      static fromUrl(giturl, opts) {
        if (typeof giturl !== "string") {
          return;
        }
        const key = giturl + JSON.stringify(opts || {});
        if (!cache.has(key)) {
          const hostArgs = fromUrl(giturl, opts, {
            gitHosts: _GitHost.#gitHosts,
            protocols: _GitHost.#protocols
          });
          cache.set(key, hostArgs ? new _GitHost(...hostArgs) : void 0);
        }
        return cache.get(key);
      }
      static parseUrl(url) {
        return parseUrl(url);
      }
      #fill(template, opts) {
        if (typeof template !== "function") {
          return null;
        }
        const options = { ...this, ...this.opts, ...opts };
        if (!options.path) {
          options.path = "";
        }
        if (options.path.startsWith("/")) {
          options.path = options.path.slice(1);
        }
        if (options.noCommittish) {
          options.committish = null;
        }
        const result = template(options);
        return options.noGitPlus && result.startsWith("git+") ? result.slice(4) : result;
      }
      hash() {
        return this.committish ? `#${this.committish}` : "";
      }
      ssh(opts) {
        return this.#fill(this.sshtemplate, opts);
      }
      sshurl(opts) {
        return this.#fill(this.sshurltemplate, opts);
      }
      browse(path, ...args) {
        if (typeof path !== "string") {
          return this.#fill(this.browsetemplate, path);
        }
        if (typeof args[0] !== "string") {
          return this.#fill(this.browsetreetemplate, { ...args[0], path });
        }
        return this.#fill(this.browsetreetemplate, { ...args[1], fragment: args[0], path });
      }
      // If the path is known to be a file, then browseFile should be used. For some hosts
      // the url is the same as browse, but for others like GitHub a file can use both `/tree/`
      // and `/blob/` in the path. When using a default committish of `HEAD` then the `/tree/`
      // path will redirect to a specific commit. Using the `/blob/` path avoids this and
      // does not redirect to a different commit.
      browseFile(path, ...args) {
        if (typeof args[0] !== "string") {
          return this.#fill(this.browseblobtemplate, { ...args[0], path });
        }
        return this.#fill(this.browseblobtemplate, { ...args[1], fragment: args[0], path });
      }
      docs(opts) {
        return this.#fill(this.docstemplate, opts);
      }
      bugs(opts) {
        return this.#fill(this.bugstemplate, opts);
      }
      https(opts) {
        return this.#fill(this.httpstemplate, opts);
      }
      git(opts) {
        return this.#fill(this.gittemplate, opts);
      }
      shortcut(opts) {
        return this.#fill(this.shortcuttemplate, opts);
      }
      path(opts) {
        return this.#fill(this.pathtemplate, opts);
      }
      tarball(opts) {
        return this.#fill(this.tarballtemplate, { ...opts, noCommittish: false });
      }
      file(path, opts) {
        return this.#fill(this.filetemplate, { ...opts, path });
      }
      edit(path, opts) {
        return this.#fill(this.edittemplate, { ...opts, path });
      }
      getDefaultRepresentation() {
        return this.default;
      }
      toString(opts) {
        if (this.default && typeof this[this.default] === "function") {
          return this[this.default](opts);
        }
        return this.sshurl(opts);
      }
    };
    for (const [name, host] of Object.entries(hosts)) {
      GitHost.addHost(name, host);
    }
    module2.exports = GitHost;
  }
});

// node_modules/minipass/dist/commonjs/index.js
var require_commonjs3 = __commonJS({
  "node_modules/minipass/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Minipass = exports2.isWritable = exports2.isReadable = exports2.isStream = void 0;
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var node_events_1 = require("node:events");
    var node_stream_1 = __importDefault(require("node:stream"));
    var node_string_decoder_1 = require("node:string_decoder");
    var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof node_stream_1.default || (0, exports2.isReadable)(s) || (0, exports2.isWritable)(s));
    exports2.isStream = isStream;
    var isReadable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
    s.pipe !== node_stream_1.default.Writable.prototype.pipe;
    exports2.isReadable = isReadable;
    var isWritable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
    exports2.isWritable = isWritable;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFER = Symbol("buffer");
    var PIPES = Symbol("pipes");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var ERROR = Symbol("error");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var ABORT = Symbol("abort");
    var ABORTED = Symbol("aborted");
    var SIGNAL = Symbol("signal");
    var DATALISTENERS = Symbol("dataListeners");
    var DISCARDED = Symbol("discarded");
    var defer = (fn) => Promise.resolve().then(fn);
    var nodefer = (fn) => fn();
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      src;
      dest;
      opts;
      ondrain;
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        this.dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // only here for the prototype
      /* c8 ignore start */
      proxyErrors(_er) {
      }
      /* c8 ignore stop */
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    var isObjectModeOptions = (o) => !!o.objectMode;
    var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
    var Minipass = class extends node_events_1.EventEmitter {
      [FLOWING] = false;
      [PAUSED] = false;
      [PIPES] = [];
      [BUFFER] = [];
      [OBJECTMODE];
      [ENCODING];
      [ASYNC];
      [DECODER];
      [EOF] = false;
      [EMITTED_END] = false;
      [EMITTING_END] = false;
      [CLOSED] = false;
      [EMITTED_ERROR] = null;
      [BUFFERLENGTH] = 0;
      [DESTROYED] = false;
      [SIGNAL];
      [ABORTED] = false;
      [DATALISTENERS] = 0;
      [DISCARDED] = false;
      /**
       * true if the stream can be written
       */
      writable = true;
      /**
       * true if the stream can be read
       */
      readable = true;
      /**
       * If `RType` is Buffer, then options do not need to be provided.
       * Otherwise, an options object must be provided to specify either
       * {@link Minipass.SharedOptions.objectMode} or
       * {@link Minipass.SharedOptions.encoding}, as appropriate.
       */
      constructor(...args) {
        const options = args[0] || {};
        super();
        if (options.objectMode && typeof options.encoding === "string") {
          throw new TypeError("Encoding and objectMode may not be used together");
        }
        if (isObjectModeOptions(options)) {
          this[OBJECTMODE] = true;
          this[ENCODING] = null;
        } else if (isEncodingOptions(options)) {
          this[ENCODING] = options.encoding;
          this[OBJECTMODE] = false;
        } else {
          this[OBJECTMODE] = false;
          this[ENCODING] = null;
        }
        this[ASYNC] = !!options.async;
        this[DECODER] = this[ENCODING] ? new node_string_decoder_1.StringDecoder(this[ENCODING]) : null;
        if (options && options.debugExposeBuffer === true) {
          Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
        }
        if (options && options.debugExposePipes === true) {
          Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
        }
        const { signal } = options;
        if (signal) {
          this[SIGNAL] = signal;
          if (signal.aborted) {
            this[ABORT]();
          } else {
            signal.addEventListener("abort", () => this[ABORT]());
          }
        }
      }
      /**
       * The amount of data stored in the buffer waiting to be read.
       *
       * For Buffer strings, this will be the total byte length.
       * For string encoding streams, this will be the string character length,
       * according to JavaScript's `string.length` logic.
       * For objectMode streams, this is a count of the items waiting to be
       * emitted.
       */
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      /**
       * The `BufferEncoding` currently in use, or `null`
       */
      get encoding() {
        return this[ENCODING];
      }
      /**
       * @deprecated - This is a read only property
       */
      set encoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * @deprecated - Encoding may only be set at instantiation time
       */
      setEncoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * True if this is an objectMode stream
       */
      get objectMode() {
        return this[OBJECTMODE];
      }
      /**
       * @deprecated - This is a read-only property
       */
      set objectMode(_om) {
        throw new Error("objectMode must be set at instantiation time");
      }
      /**
       * true if this is an async stream
       */
      get ["async"]() {
        return this[ASYNC];
      }
      /**
       * Set to true to make this stream async.
       *
       * Once set, it cannot be unset, as this would potentially cause incorrect
       * behavior.  Ie, a sync stream can be made async, but an async stream
       * cannot be safely made sync.
       */
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      // drop everything and get out of the flow completely
      [ABORT]() {
        this[ABORTED] = true;
        this.emit("abort", this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
      }
      /**
       * True if the stream has been aborted.
       */
      get aborted() {
        return this[ABORTED];
      }
      /**
       * No-op setter. Stream aborted status is set via the AbortSignal provided
       * in the constructor options.
       */
      set aborted(_) {
      }
      write(chunk, encoding, cb) {
        if (this[ABORTED])
          return false;
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
          return true;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = "utf8";
        }
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer : nodefer;
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk)) {
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          } else if (isArrayBufferLike(chunk)) {
            chunk = Buffer.from(chunk);
          } else if (typeof chunk !== "string") {
            throw new Error("Non-contiguous data written to non-objectMode stream");
          }
        }
        if (this[OBJECTMODE]) {
          if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this[FLOWING])
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
          chunk = this[DECODER].write(chunk);
        }
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      /**
       * Low-level explicit read method.
       *
       * In objectMode, the argument is ignored, and one item is returned if
       * available.
       *
       * `n` is the number of bytes (or in the case of encoding streams,
       * characters) to consume. If `n` is not provided, then the entire buffer
       * is returned, or `null` is returned if no data is available.
       *
       * If `n` is greater that the amount of data in the internal buffer,
       * then `null` is returned.
       */
      read(n) {
        if (this[DESTROYED])
          return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
          this[BUFFER] = [
            this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
          ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (this[OBJECTMODE])
          this[BUFFERSHIFT]();
        else {
          const c = chunk;
          if (n === c.length || n === null)
            this[BUFFERSHIFT]();
          else if (typeof c === "string") {
            this[BUFFER][0] = c.slice(n);
            chunk = c.slice(0, n);
            this[BUFFERLENGTH] -= n;
          } else {
            this[BUFFER][0] = c.subarray(n);
            chunk = c.subarray(0, n);
            this[BUFFERLENGTH] -= n;
          }
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = void 0;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = "utf8";
        }
        if (chunk !== void 0)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this[FLOWING] || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
          this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      /**
       * Resume the stream if it is currently in a paused state
       *
       * If called when there are no pipe destinations or `data` event listeners,
       * this will place the stream in a "discarded" state, where all data will
       * be thrown away. The discarded state is removed if a pipe destination or
       * data handler is added, if pause() is called, or if any synchronous or
       * asynchronous iteration is started.
       */
      resume() {
        return this[RESUME]();
      }
      /**
       * Pause the stream
       */
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
      }
      /**
       * true if the stream has been forcibly destroyed
       */
      get destroyed() {
        return this[DESTROYED];
      }
      /**
       * true if the stream is currently in a flowing state, meaning that
       * any writes will be immediately emitted.
       */
      get flowing() {
        return this[FLOWING];
      }
      /**
       * true if the stream is currently in a paused state
       */
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
      }
      [FLUSH](noDrain = false) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        this.emit("data", chunk);
        return this[FLOWING];
      }
      /**
       * Pipe all data emitted by this stream into the destination provided.
       *
       * Triggers the flow of data.
       */
      pipe(dest, opts) {
        if (this[DESTROYED])
          return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      /**
       * Fully unhook a piped destination stream.
       *
       * If the destination stream was the only consumer of this stream (ie,
       * there are no other piped destinations or `'data'` event listeners)
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      unpipe(dest) {
        const p = this[PIPES].find((p2) => p2.dest === dest);
        if (p) {
          if (this[PIPES].length === 1) {
            if (this[FLOWING] && this[DATALISTENERS] === 0) {
              this[FLOWING] = false;
            }
            this[PIPES] = [];
          } else
            this[PIPES].splice(this[PIPES].indexOf(p), 1);
          p.unpipe();
        }
      }
      /**
       * Alias for {@link Minipass#on}
       */
      addListener(ev, handler) {
        return this.on(ev, handler);
      }
      /**
       * Mostly identical to `EventEmitter.on`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * - Adding a 'data' event handler will trigger the flow of data
       *
       * - Adding a 'readable' event handler when there is data waiting to be read
       *   will cause 'readable' to be emitted immediately.
       *
       * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
       *   already passed will cause the event to be emitted immediately and all
       *   handlers removed.
       *
       * - Adding an 'error' event handler after an error has been emitted will
       *   cause the event to be re-emitted immediately with the error previously
       *   raised.
       */
      on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === "data") {
          this[DISCARDED] = false;
          this[DATALISTENERS]++;
          if (!this[PIPES].length && !this[FLOWING]) {
            this[RESUME]();
          }
        } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
          super.emit("readable");
        } else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          const h = handler;
          if (this[ASYNC])
            defer(() => h.call(this, this[EMITTED_ERROR]));
          else
            h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      /**
       * Alias for {@link Minipass#off}
       */
      removeListener(ev, handler) {
        return this.off(ev, handler);
      }
      /**
       * Mostly identical to `EventEmitter.off`
       *
       * If a 'data' event handler is removed, and it was the last consumer
       * (ie, there are no pipe destinations or other 'data' event listeners),
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      off(ev, handler) {
        const ret = super.off(ev, handler);
        if (ev === "data") {
          this[DATALISTENERS] = this.listeners("data").length;
          if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * Mostly identical to `EventEmitter.removeAllListeners`
       *
       * If all 'data' event handlers are removed, and they were the last consumer
       * (ie, there are no pipe destinations), then the flow of data will stop
       * until there is another consumer or {@link Minipass#resume} is explicitly
       * called.
       */
      removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === "data" || ev === void 0) {
          this[DATALISTENERS] = 0;
          if (!this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * true if the 'end' event has been emitted
       */
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      /**
       * Mostly identical to `EventEmitter.emit`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * If the stream has been destroyed, and the event is something other
       * than 'close' or 'error', then `false` is returned and no handlers
       * are called.
       *
       * If the event is 'end', and has already been emitted, then the event
       * is ignored. If the stream is in a paused or non-flowing state, then
       * the event will be deferred until data flow resumes. If the stream is
       * async, then handlers will be called on the next tick rather than
       * immediately.
       *
       * If the event is 'close', and 'end' has not yet been emitted, then
       * the event will be deferred until after 'end' is emitted.
       *
       * If the event is 'error', and an AbortSignal was provided for the stream,
       * and there are no listeners, then the event is ignored, matching the
       * behavior of node core streams in the presense of an AbortSignal.
       *
       * If the event is 'finish' or 'prefinish', then all listeners will be
       * removed after emitting the event, to prevent double-firing.
       */
      emit(ev, ...args) {
        const data = args[0];
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
          return false;
        } else if (ev === "data") {
          return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return false;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          super.emit(ERROR, data);
          const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this[PIPES]) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this[PIPES]) {
              p.dest.write(data);
            }
            if (!this[DISCARDED])
              super.emit("data", data);
          }
        }
        for (const p of this[PIPES]) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      /**
       * Return a Promise that resolves to an array of all emitted data once
       * the stream ends.
       */
      async collect() {
        const buf = Object.assign([], {
          dataLength: 0
        });
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        await p;
        return buf;
      }
      /**
       * Return a Promise that resolves to the concatenation of all emitted data
       * once the stream ends.
       *
       * Not allowed on objectMode streams.
       */
      async concat() {
        if (this[OBJECTMODE]) {
          throw new Error("cannot concat in objectMode");
        }
        const buf = await this.collect();
        return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
      }
      /**
       * Return a void Promise that resolves once the stream ends.
       */
      async promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      /**
       * Asynchronous `for await of` iteration.
       *
       * This will continue emitting all chunks until the stream terminates.
       */
      [Symbol.asyncIterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
          this.pause();
          stopped = true;
          return { value: void 0, done: true };
        };
        const next = () => {
          if (stopped)
            return stop();
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return stop();
          let resolve;
          let reject;
          const onerr = (er) => {
            this.off("data", ondata);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            stop();
            reject(er);
          };
          const ondata = (value) => {
            this.off("error", onerr);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.off("error", onerr);
            this.off("data", ondata);
            this.off(DESTROYED, ondestroy);
            stop();
            resolve({ done: true, value: void 0 });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
      /**
       * Synchronous `for of` iteration.
       *
       * The iteration will terminate when the internal buffer runs out, even
       * if the stream has not yet terminated.
       */
      [Symbol.iterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
          this.pause();
          this.off(ERROR, stop);
          this.off(DESTROYED, stop);
          this.off("end", stop);
          stopped = true;
          return { done: true, value: void 0 };
        };
        const next = () => {
          if (stopped)
            return stop();
          const value = this.read();
          return value === null ? stop() : { done: false, value };
        };
        this.once("end", stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.iterator]() {
            return this;
          }
        };
      }
      /**
       * Destroy a stream, preventing it from being used for any further purpose.
       *
       * If the stream has a `close()` method, then it will be called on
       * destruction.
       *
       * After destruction, any attempt to write data, read data, or emit most
       * events will be ignored.
       *
       * If an error argument is provided, then it will be emitted in an
       * 'error' event.
       */
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === "function" && !this[CLOSED])
          wc.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      /**
       * Alias for {@link isStream}
       *
       * Former export location, maintained for backwards compatibility.
       *
       * @deprecated
       */
      static get isStream() {
        return exports2.isStream;
      }
    };
    exports2.Minipass = Minipass;
  }
});

// node_modules/path-scurry/dist/commonjs/index.js
var require_commonjs4 = __commonJS({
  "node_modules/path-scurry/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathScurry = exports2.Path = exports2.PathScurryDarwin = exports2.PathScurryPosix = exports2.PathScurryWin32 = exports2.PathScurryBase = exports2.PathPosix = exports2.PathWin32 = exports2.PathBase = exports2.ChildrenCache = exports2.ResolveCache = void 0;
    var lru_cache_1 = require_commonjs2();
    var node_path_1 = require("node:path");
    var node_url_1 = require("node:url");
    var fs_1 = require("fs");
    var actualFS = __importStar(require("node:fs"));
    var realpathSync = fs_1.realpathSync.native;
    var promises_1 = require("node:fs/promises");
    var minipass_1 = require_commonjs3();
    var defaultFS = {
      lstatSync: fs_1.lstatSync,
      readdir: fs_1.readdir,
      readdirSync: fs_1.readdirSync,
      readlinkSync: fs_1.readlinkSync,
      realpathSync,
      promises: {
        lstat: promises_1.lstat,
        readdir: promises_1.readdir,
        readlink: promises_1.readlink,
        realpath: promises_1.realpath
      }
    };
    var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
      ...defaultFS,
      ...fsOption,
      promises: {
        ...defaultFS.promises,
        ...fsOption.promises || {}
      }
    };
    var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
    var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    var eitherSep = /[\\\/]/;
    var UNKNOWN = 0;
    var IFIFO = 1;
    var IFCHR = 2;
    var IFDIR = 4;
    var IFBLK = 6;
    var IFREG = 8;
    var IFLNK = 10;
    var IFSOCK = 12;
    var IFMT = 15;
    var IFMT_UNKNOWN = ~IFMT;
    var READDIR_CALLED = 16;
    var LSTAT_CALLED = 32;
    var ENOTDIR = 64;
    var ENOENT = 128;
    var ENOREADLINK = 256;
    var ENOREALPATH = 512;
    var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
    var TYPEMASK = 1023;
    var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
    var normalizeCache = /* @__PURE__ */ new Map();
    var normalize = (s) => {
      const c = normalizeCache.get(s);
      if (c)
        return c;
      const n = s.normalize("NFKD");
      normalizeCache.set(s, n);
      return n;
    };
    var normalizeNocaseCache = /* @__PURE__ */ new Map();
    var normalizeNocase = (s) => {
      const c = normalizeNocaseCache.get(s);
      if (c)
        return c;
      const n = normalize(s.toLowerCase());
      normalizeNocaseCache.set(s, n);
      return n;
    };
    var ResolveCache = class extends lru_cache_1.LRUCache {
      constructor() {
        super({ max: 256 });
      }
    };
    exports2.ResolveCache = ResolveCache;
    var ChildrenCache = class extends lru_cache_1.LRUCache {
      constructor(maxSize = 16 * 1024) {
        super({
          maxSize,
          // parent + children
          sizeCalculation: (a) => a.length + 1
        });
      }
    };
    exports2.ChildrenCache = ChildrenCache;
    var setAsCwd = Symbol("PathScurry setAsCwd");
    var PathBase = class {
      /**
       * the basename of this path
       *
       * **Important**: *always* test the path name against any test string
       * usingthe {@link isNamed} method, and not by directly comparing this
       * string. Otherwise, unicode path strings that the system sees as identical
       * will not be properly treated as the same path, leading to incorrect
       * behavior and possible security issues.
       */
      name;
      /**
       * the Path entry corresponding to the path root.
       *
       * @internal
       */
      root;
      /**
       * All roots found within the current PathScurry family
       *
       * @internal
       */
      roots;
      /**
       * a reference to the parent path, or undefined in the case of root entries
       *
       * @internal
       */
      parent;
      /**
       * boolean indicating whether paths are compared case-insensitively
       * @internal
       */
      nocase;
      /**
       * boolean indicating that this path is the current working directory
       * of the PathScurry collection that contains it.
       */
      isCWD = false;
      // potential default fs override
      #fs;
      // Stats fields
      #dev;
      get dev() {
        return this.#dev;
      }
      #mode;
      get mode() {
        return this.#mode;
      }
      #nlink;
      get nlink() {
        return this.#nlink;
      }
      #uid;
      get uid() {
        return this.#uid;
      }
      #gid;
      get gid() {
        return this.#gid;
      }
      #rdev;
      get rdev() {
        return this.#rdev;
      }
      #blksize;
      get blksize() {
        return this.#blksize;
      }
      #ino;
      get ino() {
        return this.#ino;
      }
      #size;
      get size() {
        return this.#size;
      }
      #blocks;
      get blocks() {
        return this.#blocks;
      }
      #atimeMs;
      get atimeMs() {
        return this.#atimeMs;
      }
      #mtimeMs;
      get mtimeMs() {
        return this.#mtimeMs;
      }
      #ctimeMs;
      get ctimeMs() {
        return this.#ctimeMs;
      }
      #birthtimeMs;
      get birthtimeMs() {
        return this.#birthtimeMs;
      }
      #atime;
      get atime() {
        return this.#atime;
      }
      #mtime;
      get mtime() {
        return this.#mtime;
      }
      #ctime;
      get ctime() {
        return this.#ctime;
      }
      #birthtime;
      get birthtime() {
        return this.#birthtime;
      }
      #matchName;
      #depth;
      #fullpath;
      #fullpathPosix;
      #relative;
      #relativePosix;
      #type;
      #children;
      #linkTarget;
      #realpath;
      /**
       * This property is for compatibility with the Dirent class as of
       * Node v20, where Dirent['parentPath'] refers to the path of the
       * directory that was passed to readdir. For root entries, it's the path
       * to the entry itself.
       */
      get parentPath() {
        return (this.parent || this).fullpath();
      }
      /**
       * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
       * this property refers to the *parent* path, not the path object itself.
       */
      get path() {
        return this.parentPath;
      }
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        this.name = name;
        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
          this.#fs = this.parent.#fs;
        } else {
          this.#fs = fsFromOption(opts.fs);
        }
      }
      /**
       * Returns the depth of the Path object from its root.
       *
       * For example, a path at `/foo/bar` would have a depth of 2.
       */
      depth() {
        if (this.#depth !== void 0)
          return this.#depth;
        if (!this.parent)
          return this.#depth = 0;
        return this.#depth = this.parent.depth() + 1;
      }
      /**
       * @internal
       */
      childrenCache() {
        return this.#children;
      }
      /**
       * Get the Path object referenced by the string path, resolved from this Path
       */
      resolve(path) {
        if (!path) {
          return this;
        }
        const rootPath = this.getRootString(path);
        const dir = path.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
        return result;
      }
      #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts) {
          p = p.child(part);
        }
        return p;
      }
      /**
       * Returns the cached children Path objects, if still available.  If they
       * have fallen out of the cache, then returns an empty array, and resets the
       * READDIR_CALLED bit, so that future calls to readdir() will require an fs
       * lookup.
       *
       * @internal
       */
      children() {
        const cached = this.#children.get(this);
        if (cached) {
          return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        this.#children.set(this, children);
        this.#type &= ~READDIR_CALLED;
        return children;
      }
      /**
       * Resolves a path portion and returns or creates the child Path.
       *
       * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
       * `'..'`.
       *
       * This should not be called directly.  If `pathPart` contains any path
       * separators, it will lead to unsafe undefined behavior.
       *
       * Use `Path.resolve()` instead.
       *
       * @internal
       */
      child(pathPart, opts) {
        if (pathPart === "" || pathPart === ".") {
          return this;
        }
        if (pathPart === "..") {
          return this.parent || this;
        }
        const children = this.children();
        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
        for (const p of children) {
          if (p.#matchName === name) {
            return p;
          }
        }
        const s = this.parent ? this.sep : "";
        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
        const pchild = this.newChild(pathPart, UNKNOWN, {
          ...opts,
          parent: this,
          fullpath
        });
        if (!this.canReaddir()) {
          pchild.#type |= ENOENT;
        }
        children.push(pchild);
        return pchild;
      }
      /**
       * The relative path from the cwd. If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpath()
       */
      relative() {
        if (this.isCWD)
          return "";
        if (this.#relative !== void 0) {
          return this.#relative;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return this.#relative = this.name;
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? "" : this.sep) + name;
      }
      /**
       * The relative path from the cwd, using / as the path separator.
       * If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpathPosix()
       * On posix systems, this is identical to relative().
       */
      relativePosix() {
        if (this.sep === "/")
          return this.relative();
        if (this.isCWD)
          return "";
        if (this.#relativePosix !== void 0)
          return this.#relativePosix;
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return this.#relativePosix = this.fullpathPosix();
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? "" : "/") + name;
      }
      /**
       * The fully resolved path string for this Path entry
       */
      fullpath() {
        if (this.#fullpath !== void 0) {
          return this.#fullpath;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return this.#fullpath = this.name;
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? "" : this.sep) + name;
        return this.#fullpath = fp;
      }
      /**
       * On platforms other than windows, this is identical to fullpath.
       *
       * On windows, this is overridden to return the forward-slash form of the
       * full UNC path.
       */
      fullpathPosix() {
        if (this.#fullpathPosix !== void 0)
          return this.#fullpathPosix;
        if (this.sep === "/")
          return this.#fullpathPosix = this.fullpath();
        if (!this.parent) {
          const p2 = this.fullpath().replace(/\\/g, "/");
          if (/^[a-z]:\//i.test(p2)) {
            return this.#fullpathPosix = `//?/${p2}`;
          } else {
            return this.#fullpathPosix = p2;
          }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
        return this.#fullpathPosix = fpp;
      }
      /**
       * Is the Path of an unknown type?
       *
       * Note that we might know *something* about it if there has been a previous
       * filesystem operation, for example that it does not exist, or is not a
       * link, or whether it has child entries.
       */
      isUnknown() {
        return (this.#type & IFMT) === UNKNOWN;
      }
      isType(type) {
        return this[`is${type}`]();
      }
      getType() {
        return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
          /* c8 ignore start */
          this.isSocket() ? "Socket" : "Unknown"
        );
      }
      /**
       * Is the Path a regular file?
       */
      isFile() {
        return (this.#type & IFMT) === IFREG;
      }
      /**
       * Is the Path a directory?
       */
      isDirectory() {
        return (this.#type & IFMT) === IFDIR;
      }
      /**
       * Is the path a character device?
       */
      isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
      }
      /**
       * Is the path a block device?
       */
      isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
      }
      /**
       * Is the path a FIFO pipe?
       */
      isFIFO() {
        return (this.#type & IFMT) === IFIFO;
      }
      /**
       * Is the path a socket?
       */
      isSocket() {
        return (this.#type & IFMT) === IFSOCK;
      }
      /**
       * Is the path a symbolic link?
       */
      isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
      }
      /**
       * Return the entry if it has been subject of a successful lstat, or
       * undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* simply
       * mean that we haven't called lstat on it.
       */
      lstatCached() {
        return this.#type & LSTAT_CALLED ? this : void 0;
      }
      /**
       * Return the cached link target if the entry has been the subject of a
       * successful readlink, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readlink() has been called at some point.
       */
      readlinkCached() {
        return this.#linkTarget;
      }
      /**
       * Returns the cached realpath target if the entry has been the subject
       * of a successful realpath, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * realpath() has been called at some point.
       */
      realpathCached() {
        return this.#realpath;
      }
      /**
       * Returns the cached child Path entries array if the entry has been the
       * subject of a successful readdir(), or [] otherwise.
       *
       * Does not read the filesystem, so an empty array *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readdir() has been called recently enough to still be valid.
       */
      readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
      }
      /**
       * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
       * any indication that readlink will definitely fail.
       *
       * Returns false if the path is known to not be a symlink, if a previous
       * readlink failed, or if the entry does not exist.
       */
      canReadlink() {
        if (this.#linkTarget)
          return true;
        if (!this.parent)
          return false;
        const ifmt = this.#type & IFMT;
        return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
      }
      /**
       * Return true if readdir has previously been successfully called on this
       * path, indicating that cachedReaddir() is likely valid.
       */
      calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
      }
      /**
       * Returns true if the path is known to not exist. That is, a previous lstat
       * or readdir failed to verify its existence when that would have been
       * expected, or a parent entry was marked either enoent or enotdir.
       */
      isENOENT() {
        return !!(this.#type & ENOENT);
      }
      /**
       * Return true if the path is a match for the given path name.  This handles
       * case sensitivity and unicode normalization.
       *
       * Note: even on case-sensitive systems, it is **not** safe to test the
       * equality of the `.name` property to determine whether a given pathname
       * matches, due to unicode normalization mismatches.
       *
       * Always use this method instead of testing the `path.name` property
       * directly.
       */
      isNamed(n) {
        return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
      }
      /**
       * Return the Path object corresponding to the target of a symbolic link.
       *
       * If the Path is not a symbolic link, or if the readlink call fails for any
       * reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       */
      async readlink() {
        const target = this.#linkTarget;
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read = await this.#fs.promises.readlink(this.fullpath());
          const linkTarget = (await this.parent.realpath())?.resolve(read);
          if (linkTarget) {
            return this.#linkTarget = linkTarget;
          }
        } catch (er) {
          this.#readlinkFail(er.code);
          return void 0;
        }
      }
      /**
       * Synchronous {@link PathBase.readlink}
       */
      readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read = this.#fs.readlinkSync(this.fullpath());
          const linkTarget = this.parent.realpathSync()?.resolve(read);
          if (linkTarget) {
            return this.#linkTarget = linkTarget;
          }
        } catch (er) {
          this.#readlinkFail(er.code);
          return void 0;
        }
      }
      #readdirSuccess(children) {
        this.#type |= READDIR_CALLED;
        for (let p = children.provisional; p < children.length; p++) {
          const c = children[p];
          if (c)
            c.#markENOENT();
        }
      }
      #markENOENT() {
        if (this.#type & ENOENT)
          return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
      }
      #markChildrenENOENT() {
        const children = this.children();
        children.provisional = 0;
        for (const p of children) {
          p.#markENOENT();
        }
      }
      #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
      }
      // save the information when we know the entry is not a dir
      #markENOTDIR() {
        if (this.#type & ENOTDIR)
          return;
        let t = this.#type;
        if ((t & IFMT) === IFDIR)
          t &= IFMT_UNKNOWN;
        this.#type = t | ENOTDIR;
        this.#markChildrenENOENT();
      }
      #readdirFail(code = "") {
        if (code === "ENOTDIR" || code === "EPERM") {
          this.#markENOTDIR();
        } else if (code === "ENOENT") {
          this.#markENOENT();
        } else {
          this.children().provisional = 0;
        }
      }
      #lstatFail(code = "") {
        if (code === "ENOTDIR") {
          const p = this.parent;
          p.#markENOTDIR();
        } else if (code === "ENOENT") {
          this.#markENOENT();
        }
      }
      #readlinkFail(code = "") {
        let ter = this.#type;
        ter |= ENOREADLINK;
        if (code === "ENOENT")
          ter |= ENOENT;
        if (code === "EINVAL" || code === "UNKNOWN") {
          ter &= IFMT_UNKNOWN;
        }
        this.#type = ter;
        if (code === "ENOTDIR" && this.parent) {
          this.parent.#markENOTDIR();
        }
      }
      #readdirAddChild(e, c) {
        return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
      }
      #readdirAddNewChild(e, c) {
        const type = entToType(e);
        const child = this.newChild(e.name, type, { parent: this });
        const ifmt = child.#type & IFMT;
        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
          child.#type |= ENOTDIR;
        }
        c.unshift(child);
        c.provisional++;
        return child;
      }
      #readdirMaybePromoteChild(e, c) {
        for (let p = c.provisional; p < c.length; p++) {
          const pchild = c[p];
          const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
          if (name !== pchild.#matchName) {
            continue;
          }
          return this.#readdirPromoteChild(e, pchild, p, c);
        }
      }
      #readdirPromoteChild(e, p, index, c) {
        const v = p.name;
        p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
        if (v !== e.name)
          p.name = e.name;
        if (index !== c.provisional) {
          if (index === c.length - 1)
            c.pop();
          else
            c.splice(index, 1);
          c.unshift(p);
        }
        c.provisional++;
        return p;
      }
      /**
       * Call lstat() on this Path, and update all known information that can be
       * determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat() {
        if ((this.#type & ENOENT) === 0) {
          try {
            this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
            return this;
          } catch (er) {
            this.#lstatFail(er.code);
          }
        }
      }
      /**
       * synchronous {@link PathBase.lstat}
       */
      lstatSync() {
        if ((this.#type & ENOENT) === 0) {
          try {
            this.#applyStat(this.#fs.lstatSync(this.fullpath()));
            return this;
          } catch (er) {
            this.#lstatFail(er.code);
          }
        }
      }
      #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
          this.#type |= ENOTDIR;
        }
      }
      #onReaddirCB = [];
      #readdirCBInFlight = false;
      #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach((cb) => cb(null, children));
      }
      /**
       * Standard node-style callback interface to get list of directory entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       *
       * @param cb The callback called with (er, entries).  Note that the `er`
       * param is somewhat extraneous, as all readdir() errors are handled and
       * simply result in an empty set of entries being returned.
       * @param allowZalgo Boolean indicating that immediately known results should
       * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
       * zalgo at your peril, the dark pony lord is devious and unforgiving.
       */
      readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
          if (allowZalgo)
            cb(null, []);
          else
            queueMicrotask(() => cb(null, []));
          return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
          const c = children.slice(0, children.provisional);
          if (allowZalgo)
            cb(null, c);
          else
            queueMicrotask(() => cb(null, c));
          return;
        }
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
          return;
        }
        this.#readdirCBInFlight = true;
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
          if (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
          } else {
            for (const e of entries) {
              this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
          }
          this.#callOnReaddirCB(children.slice(0, children.provisional));
          return;
        });
      }
      #asyncReaddirInFlight;
      /**
       * Return an array of known child entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async readdir() {
        if (!this.canReaddir()) {
          return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
          return children.slice(0, children.provisional);
        }
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
          await this.#asyncReaddirInFlight;
        } else {
          let resolve = () => {
          };
          this.#asyncReaddirInFlight = new Promise((res) => resolve = res);
          try {
            for (const e of await this.#fs.promises.readdir(fullpath, {
              withFileTypes: true
            })) {
              this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
          } catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
          }
          this.#asyncReaddirInFlight = void 0;
          resolve();
        }
        return children.slice(0, children.provisional);
      }
      /**
       * synchronous {@link PathBase.readdir}
       */
      readdirSync() {
        if (!this.canReaddir()) {
          return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
          return children.slice(0, children.provisional);
        }
        const fullpath = this.fullpath();
        try {
          for (const e of this.#fs.readdirSync(fullpath, {
            withFileTypes: true
          })) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        } catch (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        }
        return children.slice(0, children.provisional);
      }
      canReaddir() {
        if (this.#type & ENOCHILD)
          return false;
        const ifmt = IFMT & this.#type;
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
          return false;
        }
        return true;
      }
      shouldWalk(dirs, walkFilter) {
        return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
      }
      /**
       * Return the Path object corresponding to path as resolved
       * by realpath(3).
       *
       * If the realpath call fails for any reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       * On success, returns a Path object.
       */
      async realpath() {
        if (this.#realpath)
          return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
          return void 0;
        try {
          const rp = await this.#fs.promises.realpath(this.fullpath());
          return this.#realpath = this.resolve(rp);
        } catch (_) {
          this.#markENOREALPATH();
        }
      }
      /**
       * Synchronous {@link realpath}
       */
      realpathSync() {
        if (this.#realpath)
          return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
          return void 0;
        try {
          const rp = this.#fs.realpathSync(this.fullpath());
          return this.#realpath = this.resolve(rp);
        } catch (_) {
          this.#markENOREALPATH();
        }
      }
      /**
       * Internal method to mark this Path object as the scurry cwd,
       * called by {@link PathScurry#chdir}
       *
       * @internal
       */
      [setAsCwd](oldCwd) {
        if (oldCwd === this)
          return;
        oldCwd.isCWD = false;
        this.isCWD = true;
        const changed = /* @__PURE__ */ new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
          changed.add(p);
          p.#relative = rp.join(this.sep);
          p.#relativePosix = rp.join("/");
          p = p.parent;
          rp.push("..");
        }
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
          p.#relative = void 0;
          p.#relativePosix = void 0;
          p = p.parent;
        }
      }
    };
    exports2.PathBase = PathBase;
    var PathWin32 = class _PathWin32 extends PathBase {
      /**
       * Separator for generating path strings.
       */
      sep = "\\";
      /**
       * Separator for parsing path strings.
       */
      splitSep = eitherSep;
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
      }
      /**
       * @internal
       */
      newChild(name, type = UNKNOWN, opts = {}) {
        return new _PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
      /**
       * @internal
       */
      getRootString(path) {
        return node_path_1.win32.parse(path).root;
      }
      /**
       * @internal
       */
      getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
          return this.root;
        }
        for (const [compare, root] of Object.entries(this.roots)) {
          if (this.sameRoot(rootPath, compare)) {
            return this.roots[rootPath] = root;
          }
        }
        return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
      }
      /**
       * @internal
       */
      sameRoot(rootPath, compare = this.root.name) {
        rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
        return rootPath === compare;
      }
    };
    exports2.PathWin32 = PathWin32;
    var PathPosix = class _PathPosix extends PathBase {
      /**
       * separator for parsing path strings
       */
      splitSep = "/";
      /**
       * separator for generating path strings
       */
      sep = "/";
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
      }
      /**
       * @internal
       */
      getRootString(path) {
        return path.startsWith("/") ? "/" : "";
      }
      /**
       * @internal
       */
      getRoot(_rootPath) {
        return this.root;
      }
      /**
       * @internal
       */
      newChild(name, type = UNKNOWN, opts = {}) {
        return new _PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
    };
    exports2.PathPosix = PathPosix;
    var PathScurryBase = class {
      /**
       * The root Path entry for the current working directory of this Scurry
       */
      root;
      /**
       * The string path for the root of this Scurry's current working directory
       */
      rootPath;
      /**
       * A collection of all roots encountered, referenced by rootPath
       */
      roots;
      /**
       * The Path entry corresponding to this PathScurry's current working directory.
       */
      cwd;
      #resolveCache;
      #resolvePosixCache;
      #children;
      /**
       * Perform path comparisons case-insensitively.
       *
       * Defaults true on Darwin and Windows systems, false elsewhere.
       */
      nocase;
      #fs;
      /**
       * This class should not be instantiated directly.
       *
       * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
       *
       * @internal
       */
      constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs: fs2 = defaultFS } = {}) {
        this.#fs = fsFromOption(fs2);
        if (cwd instanceof URL || cwd.startsWith("file://")) {
          cwd = (0, node_url_1.fileURLToPath)(cwd);
        }
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = /* @__PURE__ */ Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        if (split.length === 1 && !split[0]) {
          split.pop();
        }
        if (nocase === void 0) {
          throw new TypeError("must provide nocase setting to PathScurryBase ctor");
        }
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
          const l = len--;
          prev = prev.child(part, {
            relative: new Array(l).fill("..").join(joinSep),
            relativePosix: new Array(l).fill("..").join("/"),
            fullpath: abs += (sawFirst ? "" : joinSep) + part
          });
          sawFirst = true;
        }
        this.cwd = prev;
      }
      /**
       * Get the depth of a provided path, string, or the cwd
       */
      depth(path = this.cwd) {
        if (typeof path === "string") {
          path = this.cwd.resolve(path);
        }
        return path.depth();
      }
      /**
       * Return the cache of child entries.  Exposed so subclasses can create
       * child Path objects in a platform-specific way.
       *
       * @internal
       */
      childrenCache() {
        return this.#children;
      }
      /**
       * Resolve one or more path strings to a resolved string
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolve(...paths) {
        let r = "";
        for (let i = paths.length - 1; i >= 0; i--) {
          const p = paths[i];
          if (!p || p === ".")
            continue;
          r = r ? `${p}/${r}` : p;
          if (this.isAbsolute(p)) {
            break;
          }
        }
        const cached = this.#resolveCache.get(r);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        this.#resolveCache.set(r, result);
        return result;
      }
      /**
       * Resolve one or more path strings to a resolved string, returning
       * the posix path.  Identical to .resolve() on posix systems, but on
       * windows will return a forward-slash separated UNC path.
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolvePosix(...paths) {
        let r = "";
        for (let i = paths.length - 1; i >= 0; i--) {
          const p = paths[i];
          if (!p || p === ".")
            continue;
          r = r ? `${p}/${r}` : p;
          if (this.isAbsolute(p)) {
            break;
          }
        }
        const cached = this.#resolvePosixCache.get(r);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r).fullpathPosix();
        this.#resolvePosixCache.set(r, result);
        return result;
      }
      /**
       * find the relative path from the cwd to the supplied path string or entry
       */
      relative(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.relative();
      }
      /**
       * find the relative path from the cwd to the supplied path string or
       * entry, using / as the path delimiter, even on Windows.
       */
      relativePosix(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.relativePosix();
      }
      /**
       * Return the basename for the provided string or Path object
       */
      basename(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.name;
      }
      /**
       * Return the dirname for the provided string or Path object
       */
      dirname(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return (entry.parent || entry).fullpath();
      }
      async readdir(entry = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes } = opts;
        if (!entry.canReaddir()) {
          return [];
        } else {
          const p = await entry.readdir();
          return withFileTypes ? p : p.map((e) => e.name);
        }
      }
      readdirSync(entry = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true } = opts;
        if (!entry.canReaddir()) {
          return [];
        } else if (withFileTypes) {
          return entry.readdirSync();
        } else {
          return entry.readdirSync().map((e) => e.name);
        }
      }
      /**
       * Call lstat() on the string or Path object, and update all known
       * information that can be determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.lstat();
      }
      /**
       * synchronous {@link PathScurryBase.lstat}
       */
      lstatSync(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.lstatSync();
      }
      async readlink(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = await entry.readlink();
        return withFileTypes ? e : e?.fullpath();
      }
      readlinkSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = entry.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
      }
      async realpath(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = await entry.realpath();
        return withFileTypes ? e : e?.fullpath();
      }
      realpathSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = entry.realpathSync();
        return withFileTypes ? e : e?.fullpath();
      }
      async walk(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = [];
        if (!filter || filter(entry)) {
          results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const walk = (dir, cb) => {
          dirs.add(dir);
          dir.readdirCB((er, entries) => {
            if (er) {
              return cb(er);
            }
            let len = entries.length;
            if (!len)
              return cb();
            const next = () => {
              if (--len === 0) {
                cb();
              }
            };
            for (const e of entries) {
              if (!filter || filter(e)) {
                results.push(withFileTypes ? e : e.fullpath());
              }
              if (follow && e.isSymbolicLink()) {
                e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
              } else {
                if (e.shouldWalk(dirs, walkFilter)) {
                  walk(e, next);
                } else {
                  next();
                }
              }
            }
          }, true);
        };
        const start = entry;
        return new Promise((res, rej) => {
          walk(start, (er) => {
            if (er)
              return rej(er);
            res(results);
          });
        });
      }
      walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = [];
        if (!filter || filter(entry)) {
          results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set([entry]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter || filter(e)) {
              results.push(withFileTypes ? e : e.fullpath());
            }
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              dirs.add(r);
            }
          }
        }
        return results;
      }
      /**
       * Support for `for await`
       *
       * Alias for {@link PathScurryBase.iterate}
       *
       * Note: As of Node 19, this is very slow, compared to other methods of
       * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
       * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
       */
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
      iterate(entry = this.cwd, options = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          options = entry;
          entry = this.cwd;
        }
        return this.stream(entry, options)[Symbol.asyncIterator]();
      }
      /**
       * Iterating over a PathScurry performs a synchronous walk.
       *
       * Alias for {@link PathScurryBase.iterateSync}
       */
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        if (!filter || filter(entry)) {
          yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = /* @__PURE__ */ new Set([entry]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter || filter(e)) {
              yield withFileTypes ? e : e.fullpath();
            }
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              dirs.add(r);
            }
          }
        }
      }
      stream(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = new minipass_1.Minipass({ objectMode: true });
        if (!filter || filter(entry)) {
          results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const queue = [entry];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const onReaddir = (er, entries, didRealpaths = false) => {
              if (er)
                return results.emit("error", er);
              if (follow && !didRealpaths) {
                const promises = [];
                for (const e of entries) {
                  if (e.isSymbolicLink()) {
                    promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
                  }
                }
                if (promises.length) {
                  Promise.all(promises).then(() => onReaddir(null, entries, true));
                  return;
                }
              }
              for (const e of entries) {
                if (e && (!filter || filter(e))) {
                  if (!results.write(withFileTypes ? e : e.fullpath())) {
                    paused = true;
                  }
                }
              }
              processing--;
              for (const e of entries) {
                const r = e.realpathCached() || e;
                if (r.shouldWalk(dirs, walkFilter)) {
                  queue.push(r);
                }
              }
              if (paused && !results.flowing) {
                results.once("drain", process2);
              } else if (!sync) {
                process2();
              }
            };
            let sync = true;
            dir.readdirCB(onReaddir, true);
            sync = false;
          }
        };
        process2();
        return results;
      }
      streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = new minipass_1.Minipass({ objectMode: true });
        const dirs = /* @__PURE__ */ new Set();
        if (!filter || filter(entry)) {
          results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [entry];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const entries = dir.readdirSync();
            for (const e of entries) {
              if (!filter || filter(e)) {
                if (!results.write(withFileTypes ? e : e.fullpath())) {
                  paused = true;
                }
              }
            }
            processing--;
            for (const e of entries) {
              let r = e;
              if (e.isSymbolicLink()) {
                if (!(follow && (r = e.realpathSync())))
                  continue;
                if (r.isUnknown())
                  r.lstatSync();
              }
              if (r.shouldWalk(dirs, walkFilter)) {
                queue.push(r);
              }
            }
          }
          if (paused && !results.flowing)
            results.once("drain", process2);
        };
        process2();
        return results;
      }
      chdir(path = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path === "string" ? this.cwd.resolve(path) : path;
        this.cwd[setAsCwd](oldCwd);
      }
    };
    exports2.PathScurryBase = PathScurryBase;
    var PathScurryWin32 = class extends PathScurryBase {
      /**
       * separator for generating path strings
       */
      sep = "\\";
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, node_path_1.win32, "\\", { ...opts, nocase });
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
          p.nocase = this.nocase;
        }
      }
      /**
       * @internal
       */
      parseRootPath(dir) {
        return node_path_1.win32.parse(dir).root.toUpperCase();
      }
      /**
       * @internal
       */
      newRoot(fs2) {
        return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs2 });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p) {
        return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
      }
    };
    exports2.PathScurryWin32 = PathScurryWin32;
    var PathScurryPosix = class extends PathScurryBase {
      /**
       * separator for generating path strings
       */
      sep = "/";
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, node_path_1.posix, "/", { ...opts, nocase });
        this.nocase = nocase;
      }
      /**
       * @internal
       */
      parseRootPath(_dir) {
        return "/";
      }
      /**
       * @internal
       */
      newRoot(fs2) {
        return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs2 });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p) {
        return p.startsWith("/");
      }
    };
    exports2.PathScurryPosix = PathScurryPosix;
    var PathScurryDarwin = class extends PathScurryPosix {
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
      }
    };
    exports2.PathScurryDarwin = PathScurryDarwin;
    exports2.Path = process.platform === "win32" ? PathWin32 : PathPosix;
    exports2.PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;
  }
});

// node_modules/glob/dist/commonjs/pattern.js
var require_pattern = __commonJS({
  "node_modules/glob/dist/commonjs/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Pattern = void 0;
    var minimatch_1 = require_commonjs();
    var isPatternList = (pl) => pl.length >= 1;
    var isGlobList = (gl) => gl.length >= 1;
    var Pattern = class _Pattern {
      #patternList;
      #globList;
      #index;
      length;
      #platform;
      #rest;
      #globString;
      #isDrive;
      #isUNC;
      #isAbsolute;
      #followGlobstar = true;
      constructor(patternList, globList, index, platform) {
        if (!isPatternList(patternList)) {
          throw new TypeError("empty pattern list");
        }
        if (!isGlobList(globList)) {
          throw new TypeError("empty glob list");
        }
        if (globList.length !== patternList.length) {
          throw new TypeError("mismatched pattern list and glob list lengths");
        }
        this.length = patternList.length;
        if (index < 0 || index >= this.length) {
          throw new TypeError("index out of range");
        }
        this.#patternList = patternList;
        this.#globList = globList;
        this.#index = index;
        this.#platform = platform;
        if (this.#index === 0) {
          if (this.isUNC()) {
            const [p0, p1, p2, p3, ...prest] = this.#patternList;
            const [g0, g1, g2, g3, ...grest] = this.#globList;
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p = [p0, p1, p2, p3, ""].join("/");
            const g = [g0, g1, g2, g3, ""].join("/");
            this.#patternList = [p, ...prest];
            this.#globList = [g, ...grest];
            this.length = this.#patternList.length;
          } else if (this.isDrive() || this.isAbsolute()) {
            const [p1, ...prest] = this.#patternList;
            const [g1, ...grest] = this.#globList;
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p = p1 + "/";
            const g = g1 + "/";
            this.#patternList = [p, ...prest];
            this.#globList = [g, ...grest];
            this.length = this.#patternList.length;
          }
        }
      }
      /**
       * The first entry in the parsed list of patterns
       */
      pattern() {
        return this.#patternList[this.#index];
      }
      /**
       * true of if pattern() returns a string
       */
      isString() {
        return typeof this.#patternList[this.#index] === "string";
      }
      /**
       * true of if pattern() returns GLOBSTAR
       */
      isGlobstar() {
        return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;
      }
      /**
       * true if pattern() returns a regexp
       */
      isRegExp() {
        return this.#patternList[this.#index] instanceof RegExp;
      }
      /**
       * The /-joined set of glob parts that make up this pattern
       */
      globString() {
        return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
      }
      /**
       * true if there are more pattern parts after this one
       */
      hasMore() {
        return this.length > this.#index + 1;
      }
      /**
       * The rest of the pattern after this part, or null if this is the end
       */
      rest() {
        if (this.#rest !== void 0)
          return this.#rest;
        if (!this.hasMore())
          return this.#rest = null;
        this.#rest = new _Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
        this.#rest.#isAbsolute = this.#isAbsolute;
        this.#rest.#isUNC = this.#isUNC;
        this.#rest.#isDrive = this.#isDrive;
        return this.#rest;
      }
      /**
       * true if the pattern represents a //unc/path/ on windows
       */
      isUNC() {
        const pl = this.#patternList;
        return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
      }
      // pattern like C:/...
      // split = ['C:', ...]
      // XXX: would be nice to handle patterns like `c:*` to test the cwd
      // in c: for *, but I don't know of a way to even figure out what that
      // cwd is without actually chdir'ing into it?
      /**
       * True if the pattern starts with a drive letter on Windows
       */
      isDrive() {
        const pl = this.#patternList;
        return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
      }
      // pattern = '/' or '/...' or '/x/...'
      // split = ['', ''] or ['', ...] or ['', 'x', ...]
      // Drive and UNC both considered absolute on windows
      /**
       * True if the pattern is rooted on an absolute path
       */
      isAbsolute() {
        const pl = this.#patternList;
        return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
      }
      /**
       * consume the root of the pattern, and return it
       */
      root() {
        const p = this.#patternList[0];
        return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
      }
      /**
       * Check to see if the current globstar pattern is allowed to follow
       * a symbolic link.
       */
      checkFollowGlobstar() {
        return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
      }
      /**
       * Mark that the current globstar pattern is following a symbolic link
       */
      markFollowGlobstar() {
        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
          return false;
        this.#followGlobstar = false;
        return true;
      }
    };
    exports2.Pattern = Pattern;
  }
});

// node_modules/glob/dist/commonjs/ignore.js
var require_ignore = __commonJS({
  "node_modules/glob/dist/commonjs/ignore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Ignore = void 0;
    var minimatch_1 = require_commonjs();
    var pattern_js_1 = require_pattern();
    var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    var Ignore = class {
      relative;
      relativeChildren;
      absolute;
      absoluteChildren;
      platform;
      mmopts;
      constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform }) {
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        this.platform = platform;
        this.mmopts = {
          dot: true,
          nobrace,
          nocase,
          noext,
          noglobstar,
          optimizationLevel: 2,
          platform,
          nocomment: true,
          nonegate: true
        };
        for (const ign of ignored)
          this.add(ign);
      }
      add(ign) {
        const mm = new minimatch_1.Minimatch(ign, this.mmopts);
        for (let i = 0; i < mm.set.length; i++) {
          const parsed = mm.set[i];
          const globParts = mm.globParts[i];
          if (!parsed || !globParts) {
            throw new Error("invalid pattern object");
          }
          while (parsed[0] === "." && globParts[0] === ".") {
            parsed.shift();
            globParts.shift();
          }
          const p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform);
          const m = new minimatch_1.Minimatch(p.globString(), this.mmopts);
          const children = globParts[globParts.length - 1] === "**";
          const absolute = p.isAbsolute();
          if (absolute)
            this.absolute.push(m);
          else
            this.relative.push(m);
          if (children) {
            if (absolute)
              this.absoluteChildren.push(m);
            else
              this.relativeChildren.push(m);
          }
        }
      }
      ignored(p) {
        const fullpath = p.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative = p.relative() || ".";
        const relatives = `${relative}/`;
        for (const m of this.relative) {
          if (m.match(relative) || m.match(relatives))
            return true;
        }
        for (const m of this.absolute) {
          if (m.match(fullpath) || m.match(fullpaths))
            return true;
        }
        return false;
      }
      childrenIgnored(p) {
        const fullpath = p.fullpath() + "/";
        const relative = (p.relative() || ".") + "/";
        for (const m of this.relativeChildren) {
          if (m.match(relative))
            return true;
        }
        for (const m of this.absoluteChildren) {
          if (m.match(fullpath))
            return true;
        }
        return false;
      }
    };
    exports2.Ignore = Ignore;
  }
});

// node_modules/glob/dist/commonjs/processor.js
var require_processor = __commonJS({
  "node_modules/glob/dist/commonjs/processor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Processor = exports2.SubWalks = exports2.MatchRecord = exports2.HasWalkedCache = void 0;
    var minimatch_1 = require_commonjs();
    var HasWalkedCache = class _HasWalkedCache {
      store;
      constructor(store = /* @__PURE__ */ new Map()) {
        this.store = store;
      }
      copy() {
        return new _HasWalkedCache(new Map(this.store));
      }
      hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
      }
      storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
          cached.add(pattern.globString());
        else
          this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
      }
    };
    exports2.HasWalkedCache = HasWalkedCache;
    var MatchRecord = class {
      store = /* @__PURE__ */ new Map();
      add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === void 0 ? n : n & current);
      }
      // match, absolute, ifdir
      entries() {
        return [...this.store.entries()].map(([path, n]) => [
          path,
          !!(n & 2),
          !!(n & 1)
        ]);
      }
    };
    exports2.MatchRecord = MatchRecord;
    var SubWalks = class {
      store = /* @__PURE__ */ new Map();
      add(target, pattern) {
        if (!target.canReaddir()) {
          return;
        }
        const subs = this.store.get(target);
        if (subs) {
          if (!subs.find((p) => p.globString() === pattern.globString())) {
            subs.push(pattern);
          }
        } else
          this.store.set(target, [pattern]);
      }
      get(target) {
        const subs = this.store.get(target);
        if (!subs) {
          throw new Error("attempting to walk unknown path");
        }
        return subs;
      }
      entries() {
        return this.keys().map((k) => [k, this.store.get(k)]);
      }
      keys() {
        return [...this.store.keys()].filter((t) => t.canReaddir());
      }
    };
    exports2.SubWalks = SubWalks;
    var Processor = class _Processor {
      hasWalkedCache;
      matches = new MatchRecord();
      subwalks = new SubWalks();
      patterns;
      follow;
      dot;
      opts;
      constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
      }
      processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map((p) => [target, p]);
        for (let [t, pattern] of processingSet) {
          this.hasWalkedCache.storeWalked(t, pattern);
          const root = pattern.root();
          const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
          if (root) {
            t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
            const rest2 = pattern.rest();
            if (!rest2) {
              this.matches.add(t, true, false);
              continue;
            } else {
              pattern = rest2;
            }
          }
          if (t.isENOENT())
            continue;
          let p;
          let rest;
          let changed = false;
          while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
            const c = t.resolve(p);
            t = c;
            pattern = rest;
            changed = true;
          }
          p = pattern.pattern();
          rest = pattern.rest();
          if (changed) {
            if (this.hasWalkedCache.hasWalked(t, pattern))
              continue;
            this.hasWalkedCache.storeWalked(t, pattern);
          }
          if (typeof p === "string") {
            const ifDir = p === ".." || p === "" || p === ".";
            this.matches.add(t.resolve(p), absolute, ifDir);
            continue;
          } else if (p === minimatch_1.GLOBSTAR) {
            if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
              this.subwalks.add(t, pattern);
            }
            const rp = rest?.pattern();
            const rrest = rest?.rest();
            if (!rest || (rp === "" || rp === ".") && !rrest) {
              this.matches.add(t, absolute, rp === "" || rp === ".");
            } else {
              if (rp === "..") {
                const tp = t.parent || t;
                if (!rrest)
                  this.matches.add(tp, absolute, true);
                else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                  this.subwalks.add(tp, rrest);
                }
              }
            }
          } else if (p instanceof RegExp) {
            this.subwalks.add(t, pattern);
          }
        }
        return this;
      }
      subwalkTargets() {
        return this.subwalks.keys();
      }
      child() {
        return new _Processor(this.opts, this.hasWalkedCache);
      }
      // return a new Processor containing the subwalks for each
      // child entry, and a set of matches, and
      // a hasWalkedCache that's a copy of this one
      // then we're going to call
      filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        const results = this.child();
        for (const e of entries) {
          for (const pattern of patterns) {
            const absolute = pattern.isAbsolute();
            const p = pattern.pattern();
            const rest = pattern.rest();
            if (p === minimatch_1.GLOBSTAR) {
              results.testGlobstar(e, pattern, rest, absolute);
            } else if (p instanceof RegExp) {
              results.testRegExp(e, p, rest, absolute);
            } else {
              results.testString(e, p, rest, absolute);
            }
          }
        }
        return results;
      }
      testGlobstar(e, pattern, rest, absolute) {
        if (this.dot || !e.name.startsWith(".")) {
          if (!pattern.hasMore()) {
            this.matches.add(e, absolute, false);
          }
          if (e.canReaddir()) {
            if (this.follow || !e.isSymbolicLink()) {
              this.subwalks.add(e, pattern);
            } else if (e.isSymbolicLink()) {
              if (rest && pattern.checkFollowGlobstar()) {
                this.subwalks.add(e, rest);
              } else if (pattern.markFollowGlobstar()) {
                this.subwalks.add(e, pattern);
              }
            }
          }
        }
        if (rest) {
          const rp = rest.pattern();
          if (typeof rp === "string" && // dots and empty were handled already
          rp !== ".." && rp !== "" && rp !== ".") {
            this.testString(e, rp, rest.rest(), absolute);
          } else if (rp === "..") {
            const ep = e.parent || e;
            this.subwalks.add(ep, rest);
          } else if (rp instanceof RegExp) {
            this.testRegExp(e, rp, rest.rest(), absolute);
          }
        }
      }
      testRegExp(e, p, rest, absolute) {
        if (!p.test(e.name))
          return;
        if (!rest) {
          this.matches.add(e, absolute, false);
        } else {
          this.subwalks.add(e, rest);
        }
      }
      testString(e, p, rest, absolute) {
        if (!e.isNamed(p))
          return;
        if (!rest) {
          this.matches.add(e, absolute, false);
        } else {
          this.subwalks.add(e, rest);
        }
      }
    };
    exports2.Processor = Processor;
  }
});

// node_modules/glob/dist/commonjs/walker.js
var require_walker = __commonJS({
  "node_modules/glob/dist/commonjs/walker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GlobStream = exports2.GlobWalker = exports2.GlobUtil = void 0;
    var minipass_1 = require_commonjs3();
    var ignore_js_1 = require_ignore();
    var processor_js_1 = require_processor();
    var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new ignore_js_1.Ignore([ignore], opts) : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts) : ignore;
    var GlobUtil = class {
      path;
      patterns;
      opts;
      seen = /* @__PURE__ */ new Set();
      paused = false;
      aborted = false;
      #onResume = [];
      #ignore;
      #sep;
      signal;
      maxDepth;
      includeChildMatches;
      constructor(patterns, path, opts) {
        this.patterns = patterns;
        this.path = path;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
        this.includeChildMatches = opts.includeChildMatches !== false;
        if (opts.ignore || !this.includeChildMatches) {
          this.#ignore = makeIgnore(opts.ignore ?? [], opts);
          if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
            const m = "cannot ignore child matches, ignore lacks add() method.";
            throw new Error(m);
          }
        }
        this.maxDepth = opts.maxDepth || Infinity;
        if (opts.signal) {
          this.signal = opts.signal;
          this.signal.addEventListener("abort", () => {
            this.#onResume.length = 0;
          });
        }
      }
      #ignored(path) {
        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
      }
      #childrenIgnored(path) {
        return !!this.#ignore?.childrenIgnored?.(path);
      }
      // backpressure mechanism
      pause() {
        this.paused = true;
      }
      resume() {
        if (this.signal?.aborted)
          return;
        this.paused = false;
        let fn = void 0;
        while (!this.paused && (fn = this.#onResume.shift())) {
          fn();
        }
      }
      onResume(fn) {
        if (this.signal?.aborted)
          return;
        if (!this.paused) {
          fn();
        } else {
          this.#onResume.push(fn);
        }
      }
      // do the requisite realpath/stat checking, and return the path
      // to add or undefined to filter it out.
      async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e.realpathCached() || await e.realpath();
          if (!rpc)
            return void 0;
          e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
          const target = await s.realpath();
          if (target && (target.isUnknown() || this.opts.stat)) {
            await target.lstat();
          }
        }
        return this.matchCheckTest(s, ifDir);
      }
      matchCheckTest(e, ifDir) {
        return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
      }
      matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e.realpathCached() || e.realpathSync();
          if (!rpc)
            return void 0;
          e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
          const target = s.realpathSync();
          if (target && (target?.isUnknown() || this.opts.stat)) {
            target.lstatSync();
          }
        }
        return this.matchCheckTest(s, ifDir);
      }
      matchFinish(e, absolute) {
        if (this.#ignored(e))
          return;
        if (!this.includeChildMatches && this.#ignore?.add) {
          const ign = `${e.relativePosix()}/**`;
          this.#ignore.add(ign);
        }
        const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
        if (this.opts.withFileTypes) {
          this.matchEmit(e);
        } else if (abs) {
          const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
          this.matchEmit(abs2 + mark);
        } else {
          const rel = this.opts.posix ? e.relativePosix() : e.relative();
          const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
          this.matchEmit(!rel ? "." + mark : pre + rel + mark);
        }
      }
      async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
          this.matchFinish(p, absolute);
      }
      matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
          this.matchFinish(p, absolute);
      }
      walkCB(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);
      }
      walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2(target, patterns, processor, cb));
          return;
        }
        processor.processPatterns(target, patterns);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          tasks++;
          this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks++;
          const childrenCached = t.readdirCached();
          if (t.calledReaddir())
            this.walkCB3(t, childrenCached, processor, next);
          else {
            t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
          }
        }
        next();
      }
      walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          tasks++;
          this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target2, patterns] of processor.subwalks.entries()) {
          tasks++;
          this.walkCB2(target2, patterns, processor.child(), next);
        }
        next();
      }
      walkCBSync(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);
      }
      walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
          return;
        }
        processor.processPatterns(target, patterns);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          this.matchSync(m, absolute, ifDir);
        }
        for (const t of processor.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks++;
          const children = t.readdirSync();
          this.walkCB3Sync(t, children, processor, next);
        }
        next();
      }
      walkCB3Sync(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          this.matchSync(m, absolute, ifDir);
        }
        for (const [target2, patterns] of processor.subwalks.entries()) {
          tasks++;
          this.walkCB2Sync(target2, patterns, processor.child(), next);
        }
        next();
      }
    };
    exports2.GlobUtil = GlobUtil;
    var GlobWalker = class extends GlobUtil {
      matches = /* @__PURE__ */ new Set();
      constructor(patterns, path, opts) {
        super(patterns, path, opts);
      }
      matchEmit(e) {
        this.matches.add(e);
      }
      async walk() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          await this.path.lstat();
        }
        await new Promise((res, rej) => {
          this.walkCB(this.path, this.patterns, () => {
            if (this.signal?.aborted) {
              rej(this.signal.reason);
            } else {
              res(this.matches);
            }
          });
        });
        return this.matches;
      }
      walkSync() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => {
          if (this.signal?.aborted)
            throw this.signal.reason;
        });
        return this.matches;
      }
    };
    exports2.GlobWalker = GlobWalker;
    var GlobStream = class extends GlobUtil {
      results;
      constructor(patterns, path, opts) {
        super(patterns, path, opts);
        this.results = new minipass_1.Minipass({
          signal: this.signal,
          objectMode: true
        });
        this.results.on("drain", () => this.resume());
        this.results.on("resume", () => this.resume());
      }
      matchEmit(e) {
        this.results.write(e);
        if (!this.results.flowing)
          this.pause();
      }
      stream() {
        const target = this.path;
        if (target.isUnknown()) {
          target.lstat().then(() => {
            this.walkCB(target, this.patterns, () => this.results.end());
          });
        } else {
          this.walkCB(target, this.patterns, () => this.results.end());
        }
        return this.results;
      }
      streamSync() {
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => this.results.end());
        return this.results;
      }
    };
    exports2.GlobStream = GlobStream;
  }
});

// node_modules/glob/dist/commonjs/glob.js
var require_glob = __commonJS({
  "node_modules/glob/dist/commonjs/glob.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Glob = void 0;
    var minimatch_1 = require_commonjs();
    var node_url_1 = require("node:url");
    var path_scurry_1 = require_commonjs4();
    var pattern_js_1 = require_pattern();
    var walker_js_1 = require_walker();
    var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    var Glob = class {
      absolute;
      cwd;
      root;
      dot;
      dotRelative;
      follow;
      ignore;
      magicalBraces;
      mark;
      matchBase;
      maxDepth;
      nobrace;
      nocase;
      nodir;
      noext;
      noglobstar;
      pattern;
      platform;
      realpath;
      scurry;
      stat;
      signal;
      windowsPathsNoEscape;
      withFileTypes;
      includeChildMatches;
      /**
       * The options provided to the constructor.
       */
      opts;
      /**
       * An array of parsed immutable {@link Pattern} objects.
       */
      patterns;
      /**
       * All options are stored as properties on the `Glob` object.
       *
       * See {@link GlobOptions} for full options descriptions.
       *
       * Note that a previous `Glob` object can be passed as the
       * `GlobOptions` to another `Glob` instantiation to re-use settings
       * and caches with a new pattern.
       *
       * Traversal functions can be called multiple times to run the walk
       * again.
       */
      constructor(pattern, opts) {
        if (!opts)
          throw new TypeError("glob options required");
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
          this.cwd = "";
        } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
          opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);
        }
        this.cwd = opts.cwd || "";
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.includeChildMatches = opts.includeChildMatches !== false;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== void 0) {
          throw new Error("cannot set absolute and withFileTypes:true");
        }
        if (typeof pattern === "string") {
          pattern = [pattern];
        }
        this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          pattern = pattern.map((p) => p.replace(/\\/g, "/"));
        }
        if (this.matchBase) {
          if (opts.noglobstar) {
            throw new TypeError("base matching requires globstar");
          }
          pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
        }
        this.pattern = pattern;
        this.platform = opts.platform || defaultPlatform;
        this.opts = { ...opts, platform: this.platform };
        if (opts.scurry) {
          this.scurry = opts.scurry;
          if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
            throw new Error("nocase option contradicts provided scurry option");
          }
        } else {
          const Scurry = opts.platform === "win32" ? path_scurry_1.PathScurryWin32 : opts.platform === "darwin" ? path_scurry_1.PathScurryDarwin : opts.platform ? path_scurry_1.PathScurryPosix : path_scurry_1.PathScurry;
          this.scurry = new Scurry(this.cwd, {
            nocase: opts.nocase,
            fs: opts.fs
          });
        }
        this.nocase = this.scurry.nocase;
        const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
        const mmo = {
          // default nocase based on platform
          ...opts,
          dot: this.dot,
          matchBase: this.matchBase,
          nobrace: this.nobrace,
          nocase: this.nocase,
          nocaseMagicOnly,
          nocomment: true,
          noext: this.noext,
          nonegate: true,
          optimizationLevel: 2,
          platform: this.platform,
          windowsPathsNoEscape: this.windowsPathsNoEscape,
          debug: !!this.opts.debug
        };
        const mms = this.pattern.map((p) => new minimatch_1.Minimatch(p, mmo));
        const [matchSet, globParts] = mms.reduce((set, m) => {
          set[0].push(...m.set);
          set[1].push(...m.globParts);
          return set;
        }, [[], []]);
        this.patterns = matchSet.map((set, i) => {
          const g = globParts[i];
          if (!g)
            throw new Error("invalid pattern object");
          return new pattern_js_1.Pattern(set, g, 0, this.platform);
        });
      }
      async walk() {
        return [
          ...await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches
          }).walk()
        ];
      }
      walkSync() {
        return [
          ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches
          }).walkSync()
        ];
      }
      stream() {
        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).stream();
      }
      streamSync() {
        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).streamSync();
      }
      /**
       * Default sync iteration function. Returns a Generator that
       * iterates over the results.
       */
      iterateSync() {
        return this.streamSync()[Symbol.iterator]();
      }
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      /**
       * Default async iteration function. Returns an AsyncGenerator that
       * iterates over the results.
       */
      iterate() {
        return this.stream()[Symbol.asyncIterator]();
      }
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
    };
    exports2.Glob = Glob;
  }
});

// node_modules/glob/dist/commonjs/has-magic.js
var require_has_magic = __commonJS({
  "node_modules/glob/dist/commonjs/has-magic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasMagic = void 0;
    var minimatch_1 = require_commonjs();
    var hasMagic = (pattern, options = {}) => {
      if (!Array.isArray(pattern)) {
        pattern = [pattern];
      }
      for (const p of pattern) {
        if (new minimatch_1.Minimatch(p, options).hasMagic())
          return true;
      }
      return false;
    };
    exports2.hasMagic = hasMagic;
  }
});

// node_modules/glob/dist/commonjs/index.js
var require_commonjs5 = __commonJS({
  "node_modules/glob/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.glob = exports2.sync = exports2.iterate = exports2.iterateSync = exports2.stream = exports2.streamSync = exports2.Ignore = exports2.hasMagic = exports2.Glob = exports2.unescape = exports2.escape = void 0;
    exports2.globStreamSync = globStreamSync;
    exports2.globStream = globStream;
    exports2.globSync = globSync;
    exports2.globIterateSync = globIterateSync;
    exports2.globIterate = globIterate;
    var minimatch_1 = require_commonjs();
    var glob_js_1 = require_glob();
    var has_magic_js_1 = require_has_magic();
    var minimatch_2 = require_commonjs();
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return minimatch_2.escape;
    } });
    Object.defineProperty(exports2, "unescape", { enumerable: true, get: function() {
      return minimatch_2.unescape;
    } });
    var glob_js_2 = require_glob();
    Object.defineProperty(exports2, "Glob", { enumerable: true, get: function() {
      return glob_js_2.Glob;
    } });
    var has_magic_js_2 = require_has_magic();
    Object.defineProperty(exports2, "hasMagic", { enumerable: true, get: function() {
      return has_magic_js_2.hasMagic;
    } });
    var ignore_js_1 = require_ignore();
    Object.defineProperty(exports2, "Ignore", { enumerable: true, get: function() {
      return ignore_js_1.Ignore;
    } });
    function globStreamSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).streamSync();
    }
    function globStream(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).stream();
    }
    function globSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).walkSync();
    }
    async function glob_(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).walk();
    }
    function globIterateSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).iterateSync();
    }
    function globIterate(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).iterate();
    }
    exports2.streamSync = globStreamSync;
    exports2.stream = Object.assign(globStream, { sync: globStreamSync });
    exports2.iterateSync = globIterateSync;
    exports2.iterate = Object.assign(globIterate, {
      sync: globIterateSync
    });
    exports2.sync = Object.assign(globSync, {
      stream: globStreamSync,
      iterate: globIterateSync
    });
    exports2.glob = Object.assign(glob_, {
      glob: glob_,
      globSync,
      sync: exports2.sync,
      globStream,
      stream: exports2.stream,
      globStreamSync,
      streamSync: exports2.streamSync,
      globIterate,
      iterate: exports2.iterate,
      globIterateSync,
      iterateSync: exports2.iterateSync,
      Glob: glob_js_1.Glob,
      hasMagic: has_magic_js_1.hasMagic,
      escape: minimatch_1.escape,
      unescape: minimatch_1.unescape
    });
    exports2.glob.glob = exports2.glob;
  }
});

// node_modules/isexe/dist/cjs/posix.js
var require_posix = __commonJS({
  "node_modules/isexe/dist/cjs/posix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sync = exports2.isexe = void 0;
    var fs_1 = require("fs");
    var promises_1 = require("fs/promises");
    var isexe = async (path, options = {}) => {
      const { ignoreErrors = false } = options;
      try {
        return checkStat(await (0, promises_1.stat)(path), options);
      } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES")
          return false;
        throw er;
      }
    };
    exports2.isexe = isexe;
    var sync = (path, options = {}) => {
      const { ignoreErrors = false } = options;
      try {
        return checkStat((0, fs_1.statSync)(path), options);
      } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES")
          return false;
        throw er;
      }
    };
    exports2.sync = sync;
    var checkStat = (stat, options) => stat.isFile() && checkMode(stat, options);
    var checkMode = (stat, options) => {
      const myUid = options.uid ?? process.getuid?.();
      const myGroups = options.groups ?? process.getgroups?.() ?? [];
      const myGid = options.gid ?? process.getgid?.() ?? myGroups[0];
      if (myUid === void 0 || myGid === void 0) {
        throw new Error("cannot get uid or gid");
      }
      const groups = /* @__PURE__ */ new Set([myGid, ...myGroups]);
      const mod = stat.mode;
      const uid = stat.uid;
      const gid = stat.gid;
      const u = parseInt("100", 8);
      const g = parseInt("010", 8);
      const o = parseInt("001", 8);
      const ug = u | g;
      return !!(mod & o || mod & g && groups.has(gid) || mod & u && uid === myUid || mod & ug && myUid === 0);
    };
  }
});

// node_modules/isexe/dist/cjs/win32.js
var require_win32 = __commonJS({
  "node_modules/isexe/dist/cjs/win32.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sync = exports2.isexe = void 0;
    var fs_1 = require("fs");
    var promises_1 = require("fs/promises");
    var isexe = async (path, options = {}) => {
      const { ignoreErrors = false } = options;
      try {
        return checkStat(await (0, promises_1.stat)(path), path, options);
      } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES")
          return false;
        throw er;
      }
    };
    exports2.isexe = isexe;
    var sync = (path, options = {}) => {
      const { ignoreErrors = false } = options;
      try {
        return checkStat((0, fs_1.statSync)(path), path, options);
      } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES")
          return false;
        throw er;
      }
    };
    exports2.sync = sync;
    var checkPathExt = (path, options) => {
      const { pathExt = process.env.PATHEXT || "" } = options;
      const peSplit = pathExt.split(";");
      if (peSplit.indexOf("") !== -1) {
        return true;
      }
      for (let i = 0; i < peSplit.length; i++) {
        const p = peSplit[i].toLowerCase();
        const ext = path.substring(path.length - p.length).toLowerCase();
        if (p && ext === p) {
          return true;
        }
      }
      return false;
    };
    var checkStat = (stat, path, options) => stat.isFile() && checkPathExt(path, options);
  }
});

// node_modules/isexe/dist/cjs/options.js
var require_options = __commonJS({
  "node_modules/isexe/dist/cjs/options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/isexe/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/isexe/dist/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sync = exports2.isexe = exports2.posix = exports2.win32 = void 0;
    var posix = __importStar(require_posix());
    exports2.posix = posix;
    var win32 = __importStar(require_win32());
    exports2.win32 = win32;
    __exportStar(require_options(), exports2);
    var platform = process.env._ISEXE_TEST_PLATFORM_ || process.platform;
    var impl = platform === "win32" ? win32 : posix;
    exports2.isexe = impl.isexe;
    exports2.sync = impl.sync;
  }
});

// node_modules/which/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/which/lib/index.js"(exports2, module2) {
    var { isexe, sync: isexeSync } = require_cjs();
    var { join, delimiter, sep, posix } = require("path");
    var isWindows = process.platform === "win32";
    var rSlash = new RegExp(`[${posix.sep}${sep === posix.sep ? "" : sep}]`.replace(/(\\)/g, "\\$1"));
    var rRel = new RegExp(`^\\.${rSlash.source}`);
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, {
      path: optPath = process.env.PATH,
      pathExt: optPathExt = process.env.PATHEXT,
      delimiter: optDelimiter = delimiter
    }) => {
      const pathEnv = cmd.match(rSlash) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(optPath || /* istanbul ignore next: very unusual */
        "").split(optDelimiter)
      ];
      if (isWindows) {
        const pathExtExe = optPathExt || [".EXE", ".CMD", ".BAT", ".COM"].join(optDelimiter);
        const pathExt = pathExtExe.split(optDelimiter).flatMap((item) => [item, item.toLowerCase()]);
        if (cmd.includes(".") && pathExt[0] !== "") {
          pathExt.unshift("");
        }
        return { pathEnv, pathExt, pathExtExe };
      }
      return { pathEnv, pathExt: [""] };
    };
    var getPathPart = (raw, cmd) => {
      const pathPart = /^".*"$/.test(raw) ? raw.slice(1, -1) : raw;
      const prefix = !pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : "";
      return prefix + join(pathPart, cmd);
    };
    var which = async (cmd, opt = {}) => {
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (const envPart of pathEnv) {
        const p = getPathPart(envPart, cmd);
        for (const ext of pathExt) {
          const withExt = p + ext;
          const is = await isexe(withExt, { pathExt: pathExtExe, ignoreErrors: true });
          if (is) {
            if (!opt.all) {
              return withExt;
            }
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length) {
        return found;
      }
      if (opt.nothrow) {
        return null;
      }
      throw getNotFoundError(cmd);
    };
    var whichSync = (cmd, opt = {}) => {
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (const pathEnvPart of pathEnv) {
        const p = getPathPart(pathEnvPart, cmd);
        for (const ext of pathExt) {
          const withExt = p + ext;
          const is = isexeSync(withExt, { pathExt: pathExtExe, ignoreErrors: true });
          if (is) {
            if (!opt.all) {
              return withExt;
            }
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length) {
        return found;
      }
      if (opt.nothrow) {
        return null;
      }
      throw getNotFoundError(cmd);
    };
    module2.exports = which;
    which.sync = whichSync;
  }
});

// node_modules/@npmcli/promise-spawn/lib/escape.js
var require_escape2 = __commonJS({
  "node_modules/@npmcli/promise-spawn/lib/escape.js"(exports2, module2) {
    "use strict";
    var cmd = (input, doubleEscape) => {
      if (!input.length) {
        return '""';
      }
      let result;
      if (!/[ \t\n\v"]/.test(input)) {
        result = input;
      } else {
        result = '"';
        for (let i = 0; i <= input.length; ++i) {
          let slashCount = 0;
          while (input[i] === "\\") {
            ++i;
            ++slashCount;
          }
          if (i === input.length) {
            result += "\\".repeat(slashCount * 2);
            break;
          }
          if (input[i] === '"') {
            result += "\\".repeat(slashCount * 2 + 1);
            result += input[i];
          } else {
            result += "\\".repeat(slashCount);
            result += input[i];
          }
        }
        result += '"';
      }
      result = result.replace(/[ !%^&()<>|"]/g, "^$&");
      if (doubleEscape) {
        result = result.replace(/[ !%^&()<>|"]/g, "^$&");
      }
      return result;
    };
    var sh = (input) => {
      if (!input.length) {
        return `''`;
      }
      if (!/[\t\n\r "#$&'()*;<>?\\`|~]/.test(input)) {
        return input;
      }
      const result = `'${input.replace(/'/g, `'\\''`)}'`.replace(/^(?:'')+(?!$)/, "").replace(/\\'''/g, `\\'`);
      return result;
    };
    module2.exports = {
      cmd,
      sh
    };
  }
});

// node_modules/@npmcli/promise-spawn/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/@npmcli/promise-spawn/lib/index.js"(exports2, module2) {
    "use strict";
    var { spawn } = require("child_process");
    var os = require("os");
    var which = require_lib6();
    var escape = require_escape2();
    var promiseSpawn = (cmd, args, opts = {}, extra = {}) => {
      if (opts.shell) {
        return spawnWithShell(cmd, args, opts, extra);
      }
      let resolve, reject;
      const promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
      });
      const closeError = new Error("command failed");
      const stdout = [];
      const stderr = [];
      const getResult = (result) => ({
        cmd,
        args,
        ...result,
        ...stdioResult(stdout, stderr, opts),
        ...extra
      });
      const rejectWithOpts = (er, erOpts) => {
        const resultError = getResult(erOpts);
        reject(Object.assign(er, resultError));
      };
      const proc = spawn(cmd, args, opts);
      promise.stdin = proc.stdin;
      promise.process = proc;
      proc.on("error", rejectWithOpts);
      if (proc.stdout) {
        proc.stdout.on("data", (c) => stdout.push(c));
        proc.stdout.on("error", rejectWithOpts);
      }
      if (proc.stderr) {
        proc.stderr.on("data", (c) => stderr.push(c));
        proc.stderr.on("error", rejectWithOpts);
      }
      proc.on("close", (code, signal) => {
        if (code || signal) {
          rejectWithOpts(closeError, { code, signal });
        } else {
          resolve(getResult({ code, signal }));
        }
      });
      return promise;
    };
    var spawnWithShell = (cmd, args, opts, extra) => {
      let command = opts.shell;
      if (command === true) {
        command = process.platform === "win32" ? process.env.ComSpec : "sh";
      }
      const options = { ...opts, shell: false };
      const realArgs = [];
      let script = cmd;
      const isCmd = /(?:^|\\)cmd(?:\.exe)?$/i.test(command);
      if (isCmd) {
        let doubleEscape = false;
        let initialCmd = "";
        let insideQuotes = false;
        for (let i = 0; i < cmd.length; ++i) {
          const char = cmd.charAt(i);
          if (char === " " && !insideQuotes) {
            break;
          }
          initialCmd += char;
          if (char === '"' || char === "'") {
            insideQuotes = !insideQuotes;
          }
        }
        let pathToInitial;
        try {
          pathToInitial = which.sync(initialCmd, {
            path: options.env && findInObject(options.env, "PATH") || process.env.PATH,
            pathext: options.env && findInObject(options.env, "PATHEXT") || process.env.PATHEXT
          }).toLowerCase();
        } catch (err) {
          pathToInitial = initialCmd.toLowerCase();
        }
        doubleEscape = pathToInitial.endsWith(".cmd") || pathToInitial.endsWith(".bat");
        for (const arg of args) {
          script += ` ${escape.cmd(arg, doubleEscape)}`;
        }
        realArgs.push("/d", "/s", "/c", script);
        options.windowsVerbatimArguments = true;
      } else {
        for (const arg of args) {
          script += ` ${escape.sh(arg)}`;
        }
        realArgs.push("-c", script);
      }
      return promiseSpawn(command, realArgs, options, extra);
    };
    var open = (_args, opts = {}, extra = {}) => {
      const options = { ...opts, shell: true };
      const args = [].concat(_args);
      let platform = process.platform;
      if (platform === "linux" && os.release().toLowerCase().includes("microsoft")) {
        platform = "wsl";
        if (!process.env.BROWSER) {
          return Promise.reject(
            new Error("Set the BROWSER environment variable to your desired browser.")
          );
        }
      }
      let command = options.command;
      if (!command) {
        if (platform === "win32") {
          options.shell = process.env.ComSpec;
          command = 'start ""';
        } else if (platform === "wsl") {
          command = "sensible-browser";
        } else if (platform === "darwin") {
          command = "open";
        } else {
          command = "xdg-open";
        }
      }
      return spawnWithShell(command, args, options, extra);
    };
    promiseSpawn.open = open;
    var isPipe = (stdio = "pipe", fd) => {
      if (stdio === "pipe" || stdio === null) {
        return true;
      }
      if (Array.isArray(stdio)) {
        return isPipe(stdio[fd], fd);
      }
      return false;
    };
    var stdioResult = (stdout, stderr, { stdioString = true, stdio }) => {
      const result = {
        stdout: null,
        stderr: null
      };
      if (isPipe(stdio, 1)) {
        result.stdout = Buffer.concat(stdout);
        if (stdioString) {
          result.stdout = result.stdout.toString().trim();
        }
      }
      if (isPipe(stdio, 2)) {
        result.stderr = Buffer.concat(stderr);
        if (stdioString) {
          result.stderr = result.stderr.toString().trim();
        }
      }
      return result;
    };
    var findInObject = (obj, key) => {
      key = key.toLowerCase();
      for (const objKey of Object.keys(obj).sort()) {
        if (objKey.toLowerCase() === key) {
          return obj[objKey];
        }
      }
    };
    module2.exports = promiseSpawn;
  }
});

// node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code === "object") {
        props = code;
        code = void 0;
      }
      if (code != null) {
        props.code = code;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        return assign(new ErrClass(), props);
      }
    }
    module2.exports = createError;
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts;
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(this._errors.length - 1, this._errors.length);
          this._timeouts = this._cachedTimeouts.slice(0);
          timeout = this._timeouts.shift();
        } else {
          return false;
        }
      }
      var self = this;
      var timer = setTimeout(function() {
        self._attempts++;
        if (self._operationTimeoutCb) {
          self._timeout = setTimeout(function() {
            self._operationTimeoutCb(self._attempts);
          }, self._operationTimeout);
          if (self._options.unref) {
            self._timeout.unref();
          }
        }
        self._fn(self._attempts);
      }, timeout);
      if (this._options.unref) {
        timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self._operationTimeoutCb();
        }, self._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry();
  }
});

// node_modules/promise-retry/index.js
var require_promise_retry = __commonJS({
  "node_modules/promise-retry/index.js"(exports2, module2) {
    "use strict";
    var errcode = require_err_code();
    var retry = require_retry2();
    var hasOwn = Object.prototype.hasOwnProperty;
    function isRetryError(err) {
      return err && err.code === "EPROMISERETRY" && hasOwn.call(err, "retried");
    }
    function promiseRetry(fn, options) {
      var temp;
      var operation;
      if (typeof fn === "object" && typeof options === "function") {
        temp = options;
        options = fn;
        fn = temp;
      }
      operation = retry.operation(options);
      return new Promise(function(resolve, reject) {
        operation.attempt(function(number) {
          Promise.resolve().then(function() {
            return fn(function(err) {
              if (isRetryError(err)) {
                err = err.retried;
              }
              throw errcode(new Error("Retrying"), "EPROMISERETRY", { retried: err });
            }, number);
          }).then(resolve, function(err) {
            if (isRetryError(err)) {
              err = err.retried;
              if (operation.retry(err || new Error())) {
                return;
              }
            }
            reject(err);
          });
        });
      });
    }
    module2.exports = promiseRetry;
  }
});

// node_modules/@npmcli/git/lib/errors.js
var require_errors = __commonJS({
  "node_modules/@npmcli/git/lib/errors.js"(exports2, module2) {
    var maxRetry = 3;
    var GitError = class extends Error {
      shouldRetry() {
        return false;
      }
    };
    var GitConnectionError = class extends GitError {
      constructor() {
        super("A git connection error occurred");
      }
      shouldRetry(number) {
        return number < maxRetry;
      }
    };
    var GitPathspecError = class extends GitError {
      constructor() {
        super("The git reference could not be found");
      }
    };
    var GitUnknownError = class extends GitError {
      constructor() {
        super("An unknown git error occurred");
      }
    };
    module2.exports = {
      GitConnectionError,
      GitPathspecError,
      GitUnknownError
    };
  }
});

// node_modules/@npmcli/git/lib/make-error.js
var require_make_error = __commonJS({
  "node_modules/@npmcli/git/lib/make-error.js"(exports2, module2) {
    var {
      GitConnectionError,
      GitPathspecError,
      GitUnknownError
    } = require_errors();
    var connectionErrorRe = new RegExp([
      "remote error: Internal Server Error",
      "The remote end hung up unexpectedly",
      "Connection timed out",
      "Operation timed out",
      "Failed to connect to .* Timed out",
      "Connection reset by peer",
      "SSL_ERROR_SYSCALL",
      "The requested URL returned error: 503"
    ].join("|"));
    var missingPathspecRe = /pathspec .* did not match any file\(s\) known to git/;
    function makeError(er) {
      const message = er.stderr;
      let gitEr;
      if (connectionErrorRe.test(message)) {
        gitEr = new GitConnectionError(message);
      } else if (missingPathspecRe.test(message)) {
        gitEr = new GitPathspecError(message);
      } else {
        gitEr = new GitUnknownError(message);
      }
      return Object.assign(gitEr, er);
    }
    module2.exports = makeError;
  }
});

// node_modules/ini/lib/ini.js
var require_ini = __commonJS({
  "node_modules/ini/lib/ini.js"(exports2, module2) {
    var { hasOwnProperty } = Object.prototype;
    var encode = (obj, opt = {}) => {
      if (typeof opt === "string") {
        opt = { section: opt };
      }
      opt.align = opt.align === true;
      opt.newline = opt.newline === true;
      opt.sort = opt.sort === true;
      opt.whitespace = opt.whitespace === true || opt.align === true;
      opt.platform = opt.platform || typeof process !== "undefined" && process.platform;
      opt.bracketedArray = opt.bracketedArray !== false;
      const eol = opt.platform === "win32" ? "\r\n" : "\n";
      const separator = opt.whitespace ? " = " : "=";
      const children = [];
      const keys = opt.sort ? Object.keys(obj).sort() : Object.keys(obj);
      let padToChars = 0;
      if (opt.align) {
        padToChars = safe(
          keys.filter((k) => obj[k] === null || Array.isArray(obj[k]) || typeof obj[k] !== "object").map((k) => Array.isArray(obj[k]) ? `${k}[]` : k).concat([""]).reduce((a, b) => safe(a).length >= safe(b).length ? a : b)
        ).length;
      }
      let out = "";
      const arraySuffix = opt.bracketedArray ? "[]" : "";
      for (const k of keys) {
        const val = obj[k];
        if (val && Array.isArray(val)) {
          for (const item of val) {
            out += safe(`${k}${arraySuffix}`).padEnd(padToChars, " ") + separator + safe(item) + eol;
          }
        } else if (val && typeof val === "object") {
          children.push(k);
        } else {
          out += safe(k).padEnd(padToChars, " ") + separator + safe(val) + eol;
        }
      }
      if (opt.section && out.length) {
        out = "[" + safe(opt.section) + "]" + (opt.newline ? eol + eol : eol) + out;
      }
      for (const k of children) {
        const nk = splitSections(k, ".").join("\\.");
        const section = (opt.section ? opt.section + "." : "") + nk;
        const child = encode(obj[k], {
          ...opt,
          section
        });
        if (out.length && child.length) {
          out += eol;
        }
        out += child;
      }
      return out;
    };
    function splitSections(str, separator) {
      var lastMatchIndex = 0;
      var lastSeparatorIndex = 0;
      var nextIndex = 0;
      var sections = [];
      do {
        nextIndex = str.indexOf(separator, lastMatchIndex);
        if (nextIndex !== -1) {
          lastMatchIndex = nextIndex + separator.length;
          if (nextIndex > 0 && str[nextIndex - 1] === "\\") {
            continue;
          }
          sections.push(str.slice(lastSeparatorIndex, nextIndex));
          lastSeparatorIndex = nextIndex + separator.length;
        }
      } while (nextIndex !== -1);
      sections.push(str.slice(lastSeparatorIndex));
      return sections;
    }
    var decode = (str, opt = {}) => {
      opt.bracketedArray = opt.bracketedArray !== false;
      const out = /* @__PURE__ */ Object.create(null);
      let p = out;
      let section = null;
      const re = /^\[([^\]]*)\]\s*$|^([^=]+)(=(.*))?$/i;
      const lines = str.split(/[\r\n]+/g);
      const duplicates = {};
      for (const line of lines) {
        if (!line || line.match(/^\s*[;#]/) || line.match(/^\s*$/)) {
          continue;
        }
        const match = line.match(re);
        if (!match) {
          continue;
        }
        if (match[1] !== void 0) {
          section = unsafe(match[1]);
          if (section === "__proto__") {
            p = /* @__PURE__ */ Object.create(null);
            continue;
          }
          p = out[section] = out[section] || /* @__PURE__ */ Object.create(null);
          continue;
        }
        const keyRaw = unsafe(match[2]);
        let isArray;
        if (opt.bracketedArray) {
          isArray = keyRaw.length > 2 && keyRaw.slice(-2) === "[]";
        } else {
          duplicates[keyRaw] = (duplicates?.[keyRaw] || 0) + 1;
          isArray = duplicates[keyRaw] > 1;
        }
        const key = isArray && keyRaw.endsWith("[]") ? keyRaw.slice(0, -2) : keyRaw;
        if (key === "__proto__") {
          continue;
        }
        const valueRaw = match[3] ? unsafe(match[4]) : true;
        const value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
        if (isArray) {
          if (!hasOwnProperty.call(p, key)) {
            p[key] = [];
          } else if (!Array.isArray(p[key])) {
            p[key] = [p[key]];
          }
        }
        if (Array.isArray(p[key])) {
          p[key].push(value);
        } else {
          p[key] = value;
        }
      }
      const remove = [];
      for (const k of Object.keys(out)) {
        if (!hasOwnProperty.call(out, k) || typeof out[k] !== "object" || Array.isArray(out[k])) {
          continue;
        }
        const parts = splitSections(k, ".");
        p = out;
        const l = parts.pop();
        const nl = l.replace(/\\\./g, ".");
        for (const part of parts) {
          if (part === "__proto__") {
            continue;
          }
          if (!hasOwnProperty.call(p, part) || typeof p[part] !== "object") {
            p[part] = /* @__PURE__ */ Object.create(null);
          }
          p = p[part];
        }
        if (p === out && nl === l) {
          continue;
        }
        p[nl] = out[k];
        remove.push(k);
      }
      for (const del of remove) {
        delete out[del];
      }
      return out;
    };
    var isQuoted = (val) => {
      return val.startsWith('"') && val.endsWith('"') || val.startsWith("'") && val.endsWith("'");
    };
    var safe = (val) => {
      if (typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim()) {
        return JSON.stringify(val);
      }
      return val.split(";").join("\\;").split("#").join("\\#");
    };
    var unsafe = (val) => {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'") {
          val = val.slice(1, -1);
        }
        try {
          val = JSON.parse(val);
        } catch {
        }
      } else {
        let esc = false;
        let unesc = "";
        for (let i = 0, l = val.length; i < l; i++) {
          const c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1) {
              unesc += c;
            } else {
              unesc += "\\" + c;
            }
            esc = false;
          } else if (";#".indexOf(c) !== -1) {
            break;
          } else if (c === "\\") {
            esc = true;
          } else {
            unesc += c;
          }
        }
        if (esc) {
          unesc += "\\";
        }
        return unesc.trim();
      }
      return val;
    };
    module2.exports = {
      parse: decode,
      decode,
      stringify: encode,
      encode,
      safe,
      unsafe
    };
  }
});

// node_modules/@npmcli/git/lib/opts.js
var require_opts = __commonJS({
  "node_modules/@npmcli/git/lib/opts.js"(exports2, module2) {
    var fs2 = require("node:fs");
    var os = require("node:os");
    var path = require("node:path");
    var ini = require_ini();
    var gitConfigPath = path.join(os.homedir(), ".gitconfig");
    var cachedConfig = null;
    var loadGitConfig = () => {
      if (cachedConfig === null) {
        try {
          cachedConfig = {};
          if (fs2.existsSync(gitConfigPath)) {
            const configContent = fs2.readFileSync(gitConfigPath, "utf-8");
            cachedConfig = ini.parse(configContent);
          }
        } catch (error) {
          cachedConfig = {};
        }
      }
      return cachedConfig;
    };
    var checkGitConfigs = () => {
      const config = loadGitConfig();
      return {
        sshCommandSetInConfig: config?.core?.sshCommand !== void 0,
        askPassSetInConfig: config?.core?.askpass !== void 0
      };
    };
    var sshCommandSetInEnv = process.env.GIT_SSH_COMMAND !== void 0;
    var askPassSetInEnv = process.env.GIT_ASKPASS !== void 0;
    var { sshCommandSetInConfig, askPassSetInConfig } = checkGitConfigs();
    var finalGitEnv = {
      ...askPassSetInEnv || askPassSetInConfig ? {} : {
        GIT_ASKPASS: "echo"
      },
      ...sshCommandSetInEnv || sshCommandSetInConfig ? {} : {
        GIT_SSH_COMMAND: "ssh -oStrictHostKeyChecking=accept-new"
      }
    };
    module2.exports = (opts = {}) => ({
      stdioString: true,
      ...opts,
      shell: false,
      env: opts.env || { ...finalGitEnv, ...process.env }
    });
    module2.exports.loadGitConfig = loadGitConfig;
  }
});

// node_modules/@npmcli/git/lib/which.js
var require_which = __commonJS({
  "node_modules/@npmcli/git/lib/which.js"(exports2, module2) {
    var which = require_lib6();
    var gitPath;
    try {
      gitPath = which.sync("git");
    } catch {
    }
    module2.exports = (opts = {}) => {
      if (opts.git) {
        return opts.git;
      }
      if (!gitPath || opts.git === false) {
        return Object.assign(new Error("No git binary found in $PATH"), { code: "ENOGIT" });
      }
      return gitPath;
    };
  }
});

// node_modules/@npmcli/git/lib/spawn.js
var require_spawn = __commonJS({
  "node_modules/@npmcli/git/lib/spawn.js"(exports2, module2) {
    var spawn = require_lib7();
    var promiseRetry = require_promise_retry();
    var { log } = require_lib4();
    var makeError = require_make_error();
    var makeOpts = require_opts();
    module2.exports = (gitArgs, opts = {}) => {
      const whichGit = require_which();
      const gitPath = whichGit(opts);
      if (gitPath instanceof Error) {
        return Promise.reject(gitPath);
      }
      const args = opts.allowReplace || gitArgs[0] === "--no-replace-objects" ? gitArgs : ["--no-replace-objects", ...gitArgs];
      let retryOpts = opts.retry;
      if (retryOpts === null || retryOpts === void 0) {
        retryOpts = {
          retries: opts.fetchRetries || 2,
          factor: opts.fetchRetryFactor || 10,
          maxTimeout: opts.fetchRetryMaxtimeout || 6e4,
          minTimeout: opts.fetchRetryMintimeout || 1e3
        };
      }
      return promiseRetry((retryFn, number) => {
        if (number !== 1) {
          log.silly("git", `Retrying git command: ${args.join(" ")} attempt # ${number}`);
        }
        return spawn(gitPath, args, makeOpts(opts)).catch((er) => {
          const gitError = makeError(er);
          if (!gitError.shouldRetry(number)) {
            throw gitError;
          }
          retryFn(gitError);
        });
      }, retryOpts);
    };
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports2, module2) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/@npmcli/git/lib/lines-to-revs.js
var require_lines_to_revs = __commonJS({
  "node_modules/@npmcli/git/lib/lines-to-revs.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = (lines) => finish(lines.reduce(linesToRevsReducer, {
      versions: {},
      "dist-tags": {},
      refs: {},
      shas: {}
    }));
    var finish = (revs) => distTags(shaList(peelTags(revs)));
    var shaList = (revs) => {
      Object.keys(revs.refs).forEach((ref) => {
        const doc = revs.refs[ref];
        if (!revs.shas[doc.sha]) {
          revs.shas[doc.sha] = [ref];
        } else {
          revs.shas[doc.sha].push(ref);
        }
      });
      return revs;
    };
    var peelTags = (revs) => {
      Object.keys(revs.refs).filter((ref) => ref.endsWith("^{}")).forEach((ref) => {
        const peeled = revs.refs[ref];
        const unpeeled = revs.refs[ref.replace(/\^\{\}$/, "")];
        if (unpeeled) {
          unpeeled.sha = peeled.sha;
          delete revs.refs[ref];
        }
      });
      return revs;
    };
    var distTags = (revs) => {
      const HEAD = revs.refs.HEAD || /* istanbul ignore next */
      {};
      const versions = Object.keys(revs.versions);
      versions.forEach((v) => {
        const ver = revs.versions[v];
        if (revs.refs.latest && ver.sha === revs.refs.latest.sha) {
          revs["dist-tags"].latest = v;
        } else if (ver.sha === HEAD.sha) {
          revs["dist-tags"].HEAD = v;
          if (!revs.refs.latest) {
            revs["dist-tags"].latest = v;
          }
        }
      });
      return revs;
    };
    var refType = (ref) => {
      if (ref.startsWith("refs/tags/")) {
        return "tag";
      }
      if (ref.startsWith("refs/heads/")) {
        return "branch";
      }
      if (ref.startsWith("refs/pull/")) {
        return "pull";
      }
      if (ref === "HEAD") {
        return "head";
      }
      return "other";
    };
    var lineToRevDoc = (line) => {
      const split = line.trim().split(/\s+/, 2);
      if (split.length < 2) {
        return null;
      }
      const sha = split[0].trim();
      const rawRef = split[1].trim();
      const type = refType(rawRef);
      if (type === "tag") {
        const ref = rawRef.slice("refs/tags/".length);
        return { sha, ref, rawRef, type };
      }
      if (type === "branch") {
        const ref = rawRef.slice("refs/heads/".length);
        return { sha, ref, rawRef, type };
      }
      if (type === "pull") {
        const ref = rawRef.slice("refs/".length).replace(/\/head$/, "");
        return { sha, ref, rawRef, type };
      }
      if (type === "head") {
        const ref = "HEAD";
        return { sha, ref, rawRef, type };
      }
      return { sha, ref: rawRef, rawRef, type };
    };
    var linesToRevsReducer = (revs, line) => {
      const doc = lineToRevDoc(line);
      if (!doc) {
        return revs;
      }
      revs.refs[doc.ref] = doc;
      revs.refs[doc.rawRef] = doc;
      if (doc.type === "tag") {
        const match = !doc.ref.endsWith("^{}") && doc.ref.match(/v?(\d+\.\d+\.\d+(?:[-+].+)?)$/);
        if (match && semver.valid(match[1], true)) {
          revs.versions[semver.clean(match[1], true)] = doc;
        }
      }
      return revs;
    };
  }
});

// node_modules/@npmcli/git/lib/revs.js
var require_revs = __commonJS({
  "node_modules/@npmcli/git/lib/revs.js"(exports2, module2) {
    var spawn = require_spawn();
    var { LRUCache } = require_commonjs2();
    var linesToRevs = require_lines_to_revs();
    var revsCache = new LRUCache({
      max: 100,
      ttl: 5 * 60 * 1e3
    });
    module2.exports = async (repo, opts = {}) => {
      if (!opts.noGitRevCache) {
        const cached = revsCache.get(repo);
        if (cached) {
          return cached;
        }
      }
      const { stdout } = await spawn(["ls-remote", repo], opts);
      const revs = linesToRevs(stdout.trim().split("\n"));
      revsCache.set(repo, revs);
      return revs;
    };
  }
});

// node_modules/@npmcli/git/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@npmcli/git/lib/utils.js"(exports2) {
    var isWindows = (opts) => (opts.fakePlatform || process.platform) === "win32";
    exports2.isWindows = isWindows;
  }
});

// node_modules/validate-npm-package-name/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/validate-npm-package-name/lib/index.js"(exports2, module2) {
    "use strict";
    var { builtinModules: builtins } = require("module");
    var scopedPackagePattern = new RegExp("^(?:@([^/]+?)[/])?([^/]+?)$");
    var blacklist = [
      "node_modules",
      "favicon.ico"
    ];
    function validate(name) {
      var warnings = [];
      var errors = [];
      if (name === null) {
        errors.push("name cannot be null");
        return done(warnings, errors);
      }
      if (name === void 0) {
        errors.push("name cannot be undefined");
        return done(warnings, errors);
      }
      if (typeof name !== "string") {
        errors.push("name must be a string");
        return done(warnings, errors);
      }
      if (!name.length) {
        errors.push("name length must be greater than zero");
      }
      if (name.match(/^\./)) {
        errors.push("name cannot start with a period");
      }
      if (name.match(/^_/)) {
        errors.push("name cannot start with an underscore");
      }
      if (name.trim() !== name) {
        errors.push("name cannot contain leading or trailing spaces");
      }
      blacklist.forEach(function(blacklistedName) {
        if (name.toLowerCase() === blacklistedName) {
          errors.push(blacklistedName + " is a blacklisted name");
        }
      });
      if (builtins.includes(name.toLowerCase())) {
        warnings.push(name + " is a core module name");
      }
      if (name.length > 214) {
        warnings.push("name can no longer contain more than 214 characters");
      }
      if (name.toLowerCase() !== name) {
        warnings.push("name can no longer contain capital letters");
      }
      if (/[~'!()*]/.test(name.split("/").slice(-1)[0])) {
        warnings.push(`name can no longer contain special characters ("~'!()*")`);
      }
      if (encodeURIComponent(name) !== name) {
        var nameMatch = name.match(scopedPackagePattern);
        if (nameMatch) {
          var user = nameMatch[1];
          var pkg = nameMatch[2];
          if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg) {
            return done(warnings, errors);
          }
        }
        errors.push("name can only contain URL-friendly characters");
      }
      return done(warnings, errors);
    }
    var done = function(warnings, errors) {
      var result = {
        validForNewPackages: errors.length === 0 && warnings.length === 0,
        validForOldPackages: errors.length === 0,
        warnings,
        errors
      };
      if (!result.warnings.length) {
        delete result.warnings;
      }
      if (!result.errors.length) {
        delete result.errors;
      }
      return result;
    };
    module2.exports = validate;
  }
});

// node_modules/npm-package-arg/lib/npa.js
var require_npa = __commonJS({
  "node_modules/npm-package-arg/lib/npa.js"(exports2, module2) {
    "use strict";
    var isWindows = process.platform === "win32";
    var { URL: URL2 } = require("node:url");
    var path = isWindows ? require("node:path/win32") : require("node:path");
    var { homedir } = require("node:os");
    var HostedGit = require_lib5();
    var semver = require_semver2();
    var validatePackageName = require_lib8();
    var { log } = require_lib4();
    var hasSlashes = isWindows ? /\\|[/]/ : /[/]/;
    var isURL = /^(?:git[+])?[a-z]+:/i;
    var isGit = /^[^@]+@[^:.]+\.[^:]+:.+$/i;
    var isFileType = /[.](?:tgz|tar.gz|tar)$/i;
    var isPortNumber = /:[0-9]+(\/|$)/i;
    var isWindowsFile = /^(?:[.]|~[/]|[/\\]|[a-zA-Z]:)/;
    var isPosixFile = /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;
    var defaultRegistry = "https://registry.npmjs.org";
    function npa(arg, where) {
      let name;
      let spec;
      if (typeof arg === "object") {
        if (arg instanceof Result && (!where || where === arg.where)) {
          return arg;
        } else if (arg.name && arg.rawSpec) {
          return npa.resolve(arg.name, arg.rawSpec, where || arg.where);
        } else {
          return npa(arg.raw, where || arg.where);
        }
      }
      const nameEndsAt = arg.indexOf("@", 1);
      const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg;
      if (isURL.test(arg)) {
        spec = arg;
      } else if (isGit.test(arg)) {
        spec = `git+ssh://${arg}`;
      } else if (!namePart.startsWith("@") && (hasSlashes.test(namePart) || isFileType.test(namePart))) {
        spec = arg;
      } else if (nameEndsAt > 0) {
        name = namePart;
        spec = arg.slice(nameEndsAt + 1) || "*";
      } else {
        const valid = validatePackageName(arg);
        if (valid.validForOldPackages) {
          name = arg;
          spec = "*";
        } else {
          spec = arg;
        }
      }
      return resolve(name, spec, where, arg);
    }
    function isFileSpec(spec) {
      if (!spec) {
        return false;
      }
      if (spec.toLowerCase().startsWith("file:")) {
        return true;
      }
      if (isWindows) {
        return isWindowsFile.test(spec);
      }
      return isPosixFile.test(spec);
    }
    function isAliasSpec(spec) {
      if (!spec) {
        return false;
      }
      return spec.toLowerCase().startsWith("npm:");
    }
    function resolve(name, spec, where, arg) {
      const res = new Result({
        raw: arg,
        name,
        rawSpec: spec,
        fromArgument: arg != null
      });
      if (name) {
        res.name = name;
      }
      if (!where) {
        where = process.cwd();
      }
      if (isFileSpec(spec)) {
        return fromFile(res, where);
      } else if (isAliasSpec(spec)) {
        return fromAlias(res, where);
      }
      const hosted = HostedGit.fromUrl(spec, {
        noGitPlus: true,
        noCommittish: true
      });
      if (hosted) {
        return fromHostedGit(res, hosted);
      } else if (spec && isURL.test(spec)) {
        return fromURL(res);
      } else if (spec && (hasSlashes.test(spec) || isFileType.test(spec))) {
        return fromFile(res, where);
      } else {
        return fromRegistry(res);
      }
    }
    function toPurl(arg, reg = defaultRegistry) {
      const res = npa(arg);
      if (res.type !== "version") {
        throw invalidPurlType(res.type, res.raw);
      }
      let purl = "pkg:npm/" + res.name.replace(/^@/, "%40") + "@" + res.rawSpec;
      if (reg !== defaultRegistry) {
        purl += "?repository_url=" + reg;
      }
      return purl;
    }
    function invalidPackageName(name, valid, raw) {
      const err = new Error(`Invalid package name "${name}" of package "${raw}": ${valid.errors.join("; ")}.`);
      err.code = "EINVALIDPACKAGENAME";
      return err;
    }
    function invalidTagName(name, raw) {
      const err = new Error(`Invalid tag name "${name}" of package "${raw}": Tags may not have any characters that encodeURIComponent encodes.`);
      err.code = "EINVALIDTAGNAME";
      return err;
    }
    function invalidPurlType(type, raw) {
      const err = new Error(`Invalid type "${type}" of package "${raw}": Purl can only be generated for "version" types.`);
      err.code = "EINVALIDPURLTYPE";
      return err;
    }
    var Result = class {
      constructor(opts) {
        this.type = opts.type;
        this.registry = opts.registry;
        this.where = opts.where;
        if (opts.raw == null) {
          this.raw = opts.name ? `${opts.name}@${opts.rawSpec}` : opts.rawSpec;
        } else {
          this.raw = opts.raw;
        }
        this.name = void 0;
        this.escapedName = void 0;
        this.scope = void 0;
        this.rawSpec = opts.rawSpec || "";
        this.saveSpec = opts.saveSpec;
        this.fetchSpec = opts.fetchSpec;
        if (opts.name) {
          this.setName(opts.name);
        }
        this.gitRange = opts.gitRange;
        this.gitCommittish = opts.gitCommittish;
        this.gitSubdir = opts.gitSubdir;
        this.hosted = opts.hosted;
      }
      // TODO move this to a getter/setter in a semver major
      setName(name) {
        const valid = validatePackageName(name);
        if (!valid.validForOldPackages) {
          throw invalidPackageName(name, valid, this.raw);
        }
        this.name = name;
        this.scope = name[0] === "@" ? name.slice(0, name.indexOf("/")) : void 0;
        this.escapedName = name.replace("/", "%2f");
        return this;
      }
      toString() {
        const full = [];
        if (this.name != null && this.name !== "") {
          full.push(this.name);
        }
        const spec = this.saveSpec || this.fetchSpec || this.rawSpec;
        if (spec != null && spec !== "") {
          full.push(spec);
        }
        return full.length ? full.join("@") : this.raw;
      }
      toJSON() {
        const result = Object.assign({}, this);
        delete result.hosted;
        return result;
      }
    };
    function setGitAttrs(res, committish) {
      if (!committish) {
        res.gitCommittish = null;
        return;
      }
      for (const part of committish.split("::")) {
        if (!part.includes(":")) {
          if (res.gitRange) {
            throw new Error("cannot override existing semver range with a committish");
          }
          if (res.gitCommittish) {
            throw new Error("cannot override existing committish with a second committish");
          }
          res.gitCommittish = part;
          continue;
        }
        const [name, value] = part.split(":");
        if (name === "semver") {
          if (res.gitCommittish) {
            throw new Error("cannot override existing committish with a semver range");
          }
          if (res.gitRange) {
            throw new Error("cannot override existing semver range with a second semver range");
          }
          res.gitRange = decodeURIComponent(value);
          continue;
        }
        if (name === "path") {
          if (res.gitSubdir) {
            throw new Error("cannot override existing path with a second path");
          }
          res.gitSubdir = `/${value}`;
          continue;
        }
        log.warn("npm-package-arg", `ignoring unknown key "${name}"`);
      }
    }
    var encodedPathChars = /* @__PURE__ */ new Map([
      ["\0", "%00"],
      ["	", "%09"],
      ["\n", "%0A"],
      ["\r", "%0D"],
      [" ", "%20"],
      ['"', "%22"],
      ["#", "%23"],
      ["%", "%25"],
      ["?", "%3F"],
      ["[", "%5B"],
      ["\\", isWindows ? "/" : "%5C"],
      ["]", "%5D"],
      ["^", "%5E"],
      ["|", "%7C"],
      ["~", "%7E"]
    ]);
    function pathToFileURL(str) {
      let result = "";
      for (let i = 0; i < str.length; i++) {
        result = `${result}${encodedPathChars.get(str[i]) ?? str[i]}`;
      }
      if (result.startsWith("file:")) {
        return result;
      }
      return `file:${result}`;
    }
    function fromFile(res, where) {
      res.type = isFileType.test(res.rawSpec) ? "file" : "directory";
      res.where = where;
      let rawSpec = pathToFileURL(res.rawSpec);
      if (rawSpec.startsWith("file:/")) {
        if (/^file:\/\/[^/]/.test(rawSpec)) {
          rawSpec = `file:/${rawSpec.slice(5)}`;
        }
        if (/^\/{1,3}\.\.?(\/|$)/.test(rawSpec.slice(5))) {
          rawSpec = rawSpec.replace(/^file:\/{1,3}/, "file:");
        }
      }
      let resolvedUrl;
      let specUrl;
      try {
        resolvedUrl = new URL2(rawSpec, `${pathToFileURL(path.resolve(where))}/`);
        specUrl = new URL2(rawSpec);
      } catch (originalError) {
        const er = new Error("Invalid file: URL, must comply with RFC 8089");
        throw Object.assign(er, {
          raw: res.rawSpec,
          spec: res,
          where,
          originalError
        });
      }
      let specPath = decodeURIComponent(specUrl.pathname);
      let resolvedPath = decodeURIComponent(resolvedUrl.pathname);
      if (isWindows) {
        specPath = specPath.replace(/^\/+([a-z]:\/)/i, "$1");
        resolvedPath = resolvedPath.replace(/^\/+([a-z]:\/)/i, "$1");
      }
      if (/^\/~(\/|$)/.test(specPath)) {
        res.saveSpec = `file:${specPath.substr(1)}`;
        resolvedPath = path.resolve(homedir(), specPath.substr(3));
      } else if (!path.isAbsolute(rawSpec.slice(5))) {
        res.saveSpec = `file:${path.relative(where, resolvedPath)}`;
      } else {
        res.saveSpec = `file:${path.resolve(resolvedPath)}`;
      }
      res.fetchSpec = path.resolve(where, resolvedPath);
      res.saveSpec = res.saveSpec.split("\\").join("/");
      if (res.saveSpec.startsWith("file://")) {
        res.saveSpec = `file:/${res.saveSpec.slice(7)}`;
      }
      return res;
    }
    function fromHostedGit(res, hosted) {
      res.type = "git";
      res.hosted = hosted;
      res.saveSpec = hosted.toString({ noGitPlus: false, noCommittish: false });
      res.fetchSpec = hosted.getDefaultRepresentation() === "shortcut" ? null : hosted.toString();
      setGitAttrs(res, hosted.committish);
      return res;
    }
    function unsupportedURLType(protocol, spec) {
      const err = new Error(`Unsupported URL Type "${protocol}": ${spec}`);
      err.code = "EUNSUPPORTEDPROTOCOL";
      return err;
    }
    function fromURL(res) {
      let rawSpec = res.rawSpec;
      res.saveSpec = rawSpec;
      if (rawSpec.startsWith("git+ssh:")) {
        const matched = rawSpec.match(/^git\+ssh:\/\/([^:#]+:[^#]+(?:\.git)?)(?:#(.*))?$/i);
        if (matched && !matched[1].match(isPortNumber)) {
          res.type = "git";
          setGitAttrs(res, matched[2]);
          res.fetchSpec = matched[1];
          return res;
        }
      } else if (rawSpec.startsWith("git+file://")) {
        rawSpec = rawSpec.replace(/\\/g, "/");
      }
      const parsedUrl = new URL2(rawSpec);
      switch (parsedUrl.protocol) {
        case "git:":
        case "git+http:":
        case "git+https:":
        case "git+rsync:":
        case "git+ftp:":
        case "git+file:":
        case "git+ssh:":
          res.type = "git";
          setGitAttrs(res, parsedUrl.hash.slice(1));
          if (parsedUrl.protocol === "git+file:" && /^git\+file:\/\/[a-z]:/i.test(rawSpec)) {
            res.fetchSpec = `git+file://${parsedUrl.host.toLowerCase()}:${parsedUrl.pathname}`;
          } else {
            parsedUrl.hash = "";
            res.fetchSpec = parsedUrl.toString();
          }
          if (res.fetchSpec.startsWith("git+")) {
            res.fetchSpec = res.fetchSpec.slice(4);
          }
          break;
        case "http:":
        case "https:":
          res.type = "remote";
          res.fetchSpec = res.saveSpec;
          break;
        default:
          throw unsupportedURLType(parsedUrl.protocol, rawSpec);
      }
      return res;
    }
    function fromAlias(res, where) {
      const subSpec = npa(res.rawSpec.substr(4), where);
      if (subSpec.type === "alias") {
        throw new Error("nested aliases not supported");
      }
      if (!subSpec.registry) {
        throw new Error("aliases only work for registry deps");
      }
      if (!subSpec.name) {
        throw new Error("aliases must have a name");
      }
      res.subSpec = subSpec;
      res.registry = true;
      res.type = "alias";
      res.saveSpec = null;
      res.fetchSpec = null;
      return res;
    }
    function fromRegistry(res) {
      res.registry = true;
      const spec = res.rawSpec.trim();
      res.saveSpec = null;
      res.fetchSpec = spec;
      const version = semver.valid(spec, true);
      const range = semver.validRange(spec, true);
      if (version) {
        res.type = "version";
      } else if (range) {
        res.type = "range";
      } else {
        if (encodeURIComponent(spec) !== spec) {
          throw invalidTagName(spec, res.raw);
        }
        res.type = "tag";
      }
      return res;
    }
    module2.exports = npa;
    module2.exports.resolve = resolve;
    module2.exports.toPurl = toPurl;
    module2.exports.Result = Result;
  }
});

// node_modules/npm-install-checks/lib/current-env.js
var require_current_env = __commonJS({
  "node_modules/npm-install-checks/lib/current-env.js"(exports2, module2) {
    var process2 = require("node:process");
    var nodeOs = require("node:os");
    var fs2 = require("node:fs");
    function isMusl(file) {
      return file.includes("libc.musl-") || file.includes("ld-musl-");
    }
    function os() {
      return process2.platform;
    }
    function cpu() {
      return process2.arch;
    }
    var LDD_PATH = "/usr/bin/ldd";
    function getFamilyFromFilesystem() {
      try {
        const content = fs2.readFileSync(LDD_PATH, "utf-8");
        if (content.includes("musl")) {
          return "musl";
        }
        if (content.includes("GNU C Library")) {
          return "glibc";
        }
        return null;
      } catch {
        return void 0;
      }
    }
    function getFamilyFromReport() {
      const originalExclude = process2.report.excludeNetwork;
      process2.report.excludeNetwork = true;
      const report = process2.report.getReport();
      process2.report.excludeNetwork = originalExclude;
      if (report.header?.glibcVersionRuntime) {
        family = "glibc";
      } else if (Array.isArray(report.sharedObjects) && report.sharedObjects.some(isMusl)) {
        family = "musl";
      } else {
        family = null;
      }
      return family;
    }
    var family;
    function libc(osName) {
      if (osName !== "linux") {
        return void 0;
      }
      if (family === void 0) {
        family = getFamilyFromFilesystem();
        if (family === void 0) {
          family = getFamilyFromReport();
        }
      }
      return family;
    }
    function devEngines(env = {}) {
      const osName = env.os || os();
      return {
        cpu: {
          name: env.cpu || cpu()
        },
        libc: {
          name: env.libc || libc(osName)
        },
        os: {
          name: osName,
          version: env.osVersion || nodeOs.release()
        },
        packageManager: {
          name: "npm",
          version: env.npmVersion
        },
        runtime: {
          name: "node",
          version: env.nodeVersion || process2.version
        }
      };
    }
    module2.exports = {
      cpu,
      libc,
      os,
      devEngines
    };
  }
});

// node_modules/npm-install-checks/lib/dev-engines.js
var require_dev_engines = __commonJS({
  "node_modules/npm-install-checks/lib/dev-engines.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var validRange = require_valid2();
    var recognizedOnFail = [
      "ignore",
      "warn",
      "error",
      "download"
    ];
    var recognizedProperties = [
      "name",
      "version",
      "onFail"
    ];
    var recognizedEngines = [
      "packageManager",
      "runtime",
      "cpu",
      "libc",
      "os"
    ];
    function checkDependency(wanted, current, opts) {
      const { engine } = opts;
      if (typeof wanted !== "object" || wanted === null || Array.isArray(wanted)) {
        throw new Error(`Invalid non-object value for "${engine}"`);
      }
      const properties = Object.keys(wanted);
      for (const prop of properties) {
        if (!recognizedProperties.includes(prop)) {
          throw new Error(`Invalid property "${prop}" for "${engine}"`);
        }
      }
      if (!properties.includes("name")) {
        throw new Error(`Missing "name" property for "${engine}"`);
      }
      if (typeof wanted.name !== "string") {
        throw new Error(`Invalid non-string value for "name" within "${engine}"`);
      }
      if (typeof current.name !== "string" || current.name === "") {
        throw new Error(`Unable to determine "name" for "${engine}"`);
      }
      if (properties.includes("onFail")) {
        if (typeof wanted.onFail !== "string") {
          throw new Error(`Invalid non-string value for "onFail" within "${engine}"`);
        }
        if (!recognizedOnFail.includes(wanted.onFail)) {
          throw new Error(`Invalid onFail value "${wanted.onFail}" for "${engine}"`);
        }
      }
      if (wanted.name !== current.name) {
        return new Error(
          `Invalid name "${wanted.name}" does not match "${current.name}" for "${engine}"`
        );
      }
      if (properties.includes("version")) {
        if (typeof wanted.version !== "string") {
          throw new Error(`Invalid non-string value for "version" within "${engine}"`);
        }
        if (typeof current.version !== "string" || current.version === "") {
          throw new Error(`Unable to determine "version" for "${engine}" "${wanted.name}"`);
        }
        if (validRange(wanted.version)) {
          if (!satisfies(current.version, wanted.version, opts.semver)) {
            return new Error(
              // eslint-disable-next-line max-len
              `Invalid semver version "${wanted.version}" does not match "${current.version}" for "${engine}"`
            );
          }
        } else if (wanted.version !== current.version) {
          return new Error(
            `Invalid version "${wanted.version}" does not match "${current.version}" for "${engine}"`
          );
        }
      }
    }
    function checkDevEngines(wanted, current = {}, opts = {}) {
      if (typeof wanted !== "object" || wanted === null || Array.isArray(wanted)) {
        throw new Error(`Invalid non-object value for devEngines`);
      }
      const errors = [];
      for (const engine of Object.keys(wanted)) {
        if (!recognizedEngines.includes(engine)) {
          throw new Error(`Invalid property "${engine}"`);
        }
        const dependencyAsAuthored = wanted[engine];
        const dependencies = [dependencyAsAuthored].flat();
        const currentEngine = current[engine] || {};
        if (dependencies.length === 0) {
          continue;
        }
        const depErrors = [];
        for (const dep of dependencies) {
          const result = checkDependency(dep, currentEngine, { ...opts, engine });
          if (result) {
            depErrors.push(result);
          }
        }
        const invalid = depErrors.length === dependencies.length;
        if (invalid) {
          const lastDependency = dependencies[dependencies.length - 1];
          let onFail = lastDependency.onFail || "error";
          if (onFail === "download") {
            onFail = "error";
          }
          const err = Object.assign(new Error(`Invalid engine "${engine}"`), {
            errors: depErrors,
            engine,
            isWarn: onFail === "warn",
            isError: onFail === "error",
            current: currentEngine,
            required: dependencyAsAuthored
          });
          errors.push(err);
        }
      }
      return errors;
    }
    module2.exports = {
      checkDevEngines
    };
  }
});

// node_modules/npm-install-checks/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/npm-install-checks/lib/index.js"(exports2, module2) {
    var semver = require_semver2();
    var currentEnv = require_current_env();
    var { checkDevEngines } = require_dev_engines();
    var checkEngine = (target, npmVer, nodeVer, force = false) => {
      const nodev = force ? null : nodeVer;
      const eng = target.engines;
      const opt = { includePrerelease: true };
      if (!eng) {
        return;
      }
      const nodeFail = nodev && eng.node && !semver.satisfies(nodev, eng.node, opt);
      const npmFail = npmVer && eng.npm && !semver.satisfies(npmVer, eng.npm, opt);
      if (nodeFail || npmFail) {
        throw Object.assign(new Error("Unsupported engine"), {
          pkgid: target._id,
          current: { node: nodeVer, npm: npmVer },
          required: eng,
          code: "EBADENGINE"
        });
      }
    };
    var checkPlatform = (target, force = false, environment = {}) => {
      if (force) {
        return;
      }
      const os = environment.os || currentEnv.os();
      const cpu = environment.cpu || currentEnv.cpu();
      const libc = environment.libc || currentEnv.libc(os);
      const osOk = target.os ? checkList(os, target.os) : true;
      const cpuOk = target.cpu ? checkList(cpu, target.cpu) : true;
      let libcOk = target.libc ? checkList(libc, target.libc) : true;
      if (target.libc && !libc) {
        libcOk = false;
      }
      if (!osOk || !cpuOk || !libcOk) {
        throw Object.assign(new Error("Unsupported platform"), {
          pkgid: target._id,
          current: {
            os,
            cpu,
            libc
          },
          required: {
            os: target.os,
            cpu: target.cpu,
            libc: target.libc
          },
          code: "EBADPLATFORM"
        });
      }
    };
    var checkList = (value, list) => {
      if (typeof list === "string") {
        list = [list];
      }
      if (list.length === 1 && list[0] === "any") {
        return true;
      }
      let negated = 0;
      let match = false;
      for (const entry of list) {
        const negate = entry.charAt(0) === "!";
        const test = negate ? entry.slice(1) : entry;
        if (negate) {
          negated++;
          if (value === test) {
            return false;
          }
        } else {
          match = match || value === test;
        }
      }
      return match || negated === list.length;
    };
    module2.exports = {
      checkEngine,
      checkPlatform,
      checkDevEngines,
      currentEnv
    };
  }
});

// node_modules/npm-normalize-package-bin/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/npm-normalize-package-bin/lib/index.js"(exports2, module2) {
    var { join, basename } = require("path");
    var normalize = (pkg) => !pkg.bin ? removeBin(pkg) : typeof pkg.bin === "string" ? normalizeString(pkg) : Array.isArray(pkg.bin) ? normalizeArray(pkg) : typeof pkg.bin === "object" ? normalizeObject(pkg) : removeBin(pkg);
    var normalizeString = (pkg) => {
      if (!pkg.name) {
        return removeBin(pkg);
      }
      pkg.bin = { [pkg.name]: pkg.bin };
      return normalizeObject(pkg);
    };
    var normalizeArray = (pkg) => {
      pkg.bin = pkg.bin.reduce((acc, k) => {
        acc[basename(k)] = k;
        return acc;
      }, {});
      return normalizeObject(pkg);
    };
    var removeBin = (pkg) => {
      delete pkg.bin;
      return pkg;
    };
    var normalizeObject = (pkg) => {
      const orig = pkg.bin;
      const clean = {};
      let hasBins = false;
      Object.keys(orig).forEach((binKey) => {
        const base = join("/", basename(binKey.replace(/\\|:/g, "/"))).slice(1);
        if (typeof orig[binKey] !== "string" || !base) {
          return;
        }
        const binTarget = join("/", orig[binKey].replace(/\\/g, "/")).replace(/\\/g, "/").slice(1);
        if (!binTarget) {
          return;
        }
        clean[base] = binTarget;
        hasBins = true;
      });
      if (hasBins) {
        pkg.bin = clean;
      } else {
        delete pkg.bin;
      }
      return pkg;
    };
    module2.exports = normalize;
  }
});

// node_modules/npm-pick-manifest/lib/index.js
var require_lib11 = __commonJS({
  "node_modules/npm-pick-manifest/lib/index.js"(exports2, module2) {
    "use strict";
    var npa = require_npa();
    var semver = require_semver2();
    var { checkEngine } = require_lib9();
    var normalizeBin = require_lib10();
    var engineOk = (manifest, npmVersion, nodeVersion) => {
      try {
        checkEngine(manifest, npmVersion, nodeVersion);
        return true;
      } catch (_) {
        return false;
      }
    };
    var isBefore = (verTimes, ver, time) => !verTimes || !verTimes[ver] || Date.parse(verTimes[ver]) <= time;
    var avoidSemverOpt = { includePrerelease: true, loose: true };
    var shouldAvoid = (ver, avoid) => avoid && semver.satisfies(ver, avoid, avoidSemverOpt);
    var decorateAvoid = (result, avoid) => result && shouldAvoid(result.version, avoid) ? { ...result, _shouldAvoid: true } : result;
    var pickManifest = (packument, wanted, opts) => {
      const {
        defaultTag = "latest",
        before = null,
        nodeVersion = process.version,
        npmVersion = null,
        includeStaged = false,
        avoid = null,
        avoidStrict = false
      } = opts;
      const { name, time: verTimes } = packument;
      const versions = packument.versions || {};
      if (avoidStrict) {
        const looseOpts = {
          ...opts,
          avoidStrict: false
        };
        const result = pickManifest(packument, wanted, looseOpts);
        if (!result || !result._shouldAvoid) {
          return result;
        }
        const caret = pickManifest(packument, `^${result.version}`, looseOpts);
        if (!caret || !caret._shouldAvoid) {
          return {
            ...caret,
            _outsideDependencyRange: true,
            _isSemVerMajor: false
          };
        }
        const star = pickManifest(packument, "*", looseOpts);
        if (!star || !star._shouldAvoid) {
          return {
            ...star,
            _outsideDependencyRange: true,
            _isSemVerMajor: true
          };
        }
        throw Object.assign(new Error(`No avoidable versions for ${name}`), {
          code: "ETARGET",
          name,
          wanted,
          avoid,
          before,
          versions: Object.keys(versions)
        });
      }
      const staged = includeStaged && packument.stagedVersions && packument.stagedVersions.versions || {};
      const restricted = packument.policyRestrictions && packument.policyRestrictions.versions || {};
      const time = before && verTimes ? +new Date(before) : Infinity;
      const spec = npa.resolve(name, wanted || defaultTag);
      const type = spec.type;
      const distTags = packument["dist-tags"] || {};
      if (type !== "tag" && type !== "version" && type !== "range") {
        throw new Error("Only tag, version, and range are supported");
      }
      if (wanted && type === "tag") {
        const ver = distTags[wanted];
        if (isBefore(verTimes, ver, time)) {
          return decorateAvoid(versions[ver] || staged[ver] || restricted[ver], avoid);
        } else {
          return pickManifest(packument, `<=${ver}`, opts);
        }
      }
      if (wanted && type === "version") {
        const ver = semver.clean(wanted, { loose: true });
        const mani = versions[ver] || staged[ver] || restricted[ver];
        return isBefore(verTimes, ver, time) ? decorateAvoid(mani, avoid) : null;
      }
      const range = type === "range" ? wanted : "*";
      const defaultVer = distTags[defaultTag];
      if (defaultVer && (range === "*" || semver.satisfies(defaultVer, range, { loose: true })) && !restricted[defaultVer] && !shouldAvoid(defaultVer, avoid)) {
        const mani = versions[defaultVer];
        const ok = mani && isBefore(verTimes, defaultVer, time) && engineOk(mani, npmVersion, nodeVersion) && !mani.deprecated && !staged[defaultVer];
        if (ok) {
          return mani;
        }
      }
      const allEntries = Object.entries(versions).concat(Object.entries(staged)).concat(Object.entries(restricted)).filter(([ver]) => isBefore(verTimes, ver, time));
      if (!allEntries.length) {
        throw Object.assign(new Error(`No versions available for ${name}`), {
          code: "ENOVERSIONS",
          name,
          type,
          wanted,
          before,
          versions: Object.keys(versions)
        });
      }
      const sortSemverOpt = { loose: true };
      const entries = allEntries.filter(([ver]) => semver.satisfies(ver, range, { loose: true })).sort((a, b) => {
        const [vera, mania] = a;
        const [verb, manib] = b;
        const notavoida = !shouldAvoid(vera, avoid);
        const notavoidb = !shouldAvoid(verb, avoid);
        const notrestra = !restricted[vera];
        const notrestrb = !restricted[verb];
        const notstagea = !staged[vera];
        const notstageb = !staged[verb];
        const notdepra = !mania.deprecated;
        const notdeprb = !manib.deprecated;
        const enginea = engineOk(mania, npmVersion, nodeVersion);
        const engineb = engineOk(manib, npmVersion, nodeVersion);
        return notavoidb - notavoida || notrestrb - notrestra || notstageb - notstagea || (notdeprb && engineb) - (notdepra && enginea) || engineb - enginea || notdeprb - notdepra || semver.rcompare(vera, verb, sortSemverOpt);
      });
      return decorateAvoid(entries[0] && entries[0][1], avoid);
    };
    module2.exports = (packument, wanted, opts = {}) => {
      const mani = pickManifest(packument, wanted, opts);
      const picked = mani && normalizeBin(mani);
      const policyRestrictions = packument.policyRestrictions;
      const restricted = policyRestrictions && policyRestrictions.versions || {};
      if (picked && !restricted[picked.version]) {
        return picked;
      }
      const { before = null, defaultTag = "latest" } = opts;
      const bstr = before ? new Date(before).toLocaleString() : "";
      const { name } = packument;
      const pckg = `${name}@${wanted}` + (before ? ` with a date before ${bstr}` : "");
      const isForbidden = picked && !!restricted[picked.version];
      const polMsg = isForbidden ? policyRestrictions.message : "";
      const msg = !isForbidden ? `No matching version found for ${pckg}.` : `Could not download ${pckg} due to policy violations:
${polMsg}`;
      const code = isForbidden ? "E403" : "ETARGET";
      throw Object.assign(new Error(msg), {
        code,
        type: npa.resolve(packument.name, wanted).type,
        wanted,
        versions: Object.keys(packument.versions ?? {}),
        name,
        distTags: packument["dist-tags"],
        defaultTag
      });
    };
  }
});

// node_modules/@npmcli/git/lib/clone.js
var require_clone = __commonJS({
  "node_modules/@npmcli/git/lib/clone.js"(exports2, module2) {
    var shallowHosts = /* @__PURE__ */ new Set([
      "github.com",
      "gist.github.com",
      "gitlab.com",
      "bitbucket.com",
      "bitbucket.org"
    ]);
    var { parse } = require("url");
    var path = require("path");
    var getRevs = require_revs();
    var spawn = require_spawn();
    var { isWindows } = require_utils();
    var pickManifest = require_lib11();
    var fs2 = require("fs/promises");
    module2.exports = (repo, ref = "HEAD", target = null, opts = {}) => getRevs(repo, opts).then((revs) => clone(
      repo,
      revs,
      ref,
      resolveRef(revs, ref, opts),
      target || defaultTarget(repo, opts.cwd),
      opts
    ));
    var maybeShallow = (repo, opts) => {
      if (opts.gitShallow === false || opts.gitShallow) {
        return opts.gitShallow;
      }
      return shallowHosts.has(parse(repo).host);
    };
    var defaultTarget = (repo, cwd = process.cwd()) => path.resolve(cwd, path.basename(repo.replace(/[/\\]?\.git$/, "")));
    var clone = (repo, revs, ref, revDoc, target, opts) => {
      if (!revDoc) {
        return unresolved(repo, ref, target, opts);
      }
      if (revDoc.sha === revs.refs.HEAD.sha) {
        return plain(repo, revDoc, target, opts);
      }
      if (revDoc.type === "tag" || revDoc.type === "branch") {
        return branch(repo, revDoc, target, opts);
      }
      return other(repo, revDoc, target, opts);
    };
    var resolveRef = (revs, ref, opts) => {
      const { spec = {} } = opts;
      ref = spec.gitCommittish || ref;
      if (!revs) {
        return null;
      }
      if (spec.gitRange) {
        return pickManifest(revs, spec.gitRange, opts);
      }
      if (!ref) {
        return revs.refs.HEAD;
      }
      if (revs.refs[ref]) {
        return revs.refs[ref];
      }
      if (revs.shas[ref]) {
        return revs.refs[revs.shas[ref][0]];
      }
      return null;
    };
    var other = (repo, revDoc, target, opts) => {
      const shallow = maybeShallow(repo, opts);
      const fetchOrigin = ["fetch", "origin", revDoc.rawRef].concat(shallow ? ["--depth=1"] : []);
      const git = (args) => spawn(args, { ...opts, cwd: target });
      return fs2.mkdir(target, { recursive: true }).then(() => git(["init"])).then(() => isWindows(opts) ? git(["config", "--local", "--add", "core.longpaths", "true"]) : null).then(() => git(["remote", "add", "origin", repo])).then(() => git(fetchOrigin)).then(() => git(["checkout", revDoc.sha])).then(() => updateSubmodules(target, opts)).then(() => revDoc.sha);
    };
    var branch = (repo, revDoc, target, opts) => {
      const args = [
        "clone",
        "-b",
        revDoc.ref,
        repo,
        target,
        "--recurse-submodules"
      ];
      if (maybeShallow(repo, opts)) {
        args.push("--depth=1");
      }
      if (isWindows(opts)) {
        args.push("--config", "core.longpaths=true");
      }
      return spawn(args, opts).then(() => revDoc.sha);
    };
    var plain = (repo, revDoc, target, opts) => {
      const args = [
        "clone",
        repo,
        target,
        "--recurse-submodules"
      ];
      if (maybeShallow(repo, opts)) {
        args.push("--depth=1");
      }
      if (isWindows(opts)) {
        args.push("--config", "core.longpaths=true");
      }
      return spawn(args, opts).then(() => revDoc.sha);
    };
    var updateSubmodules = async (target, opts) => {
      const hasSubmodules = await fs2.stat(`${target}/.gitmodules`).then(() => true).catch(() => false);
      if (!hasSubmodules) {
        return null;
      }
      return spawn([
        "submodule",
        "update",
        "-q",
        "--init",
        "--recursive"
      ], { ...opts, cwd: target });
    };
    var unresolved = (repo, ref, target, opts) => {
      const lp = isWindows(opts) ? ["--config", "core.longpaths=true"] : [];
      const cloneArgs = ["clone", "--mirror", "-q", repo, target + "/.git"];
      const git = (args) => spawn(args, { ...opts, cwd: target });
      return fs2.mkdir(target, { recursive: true }).then(() => git(cloneArgs.concat(lp))).then(() => git(["init"])).then(() => git(["checkout", ref])).then(() => updateSubmodules(target, opts)).then(() => git(["rev-parse", "--revs-only", "HEAD"])).then(({ stdout }) => stdout.trim());
    };
  }
});

// node_modules/@npmcli/git/lib/is.js
var require_is = __commonJS({
  "node_modules/@npmcli/git/lib/is.js"(exports2, module2) {
    var { stat } = require("fs/promises");
    module2.exports = ({ cwd = process.cwd() } = {}) => stat(cwd + "/.git").then(() => true, () => false);
  }
});

// node_modules/@npmcli/git/lib/find.js
var require_find = __commonJS({
  "node_modules/@npmcli/git/lib/find.js"(exports2, module2) {
    var is = require_is();
    var { dirname } = require("path");
    module2.exports = async ({ cwd = process.cwd(), root } = {}) => {
      while (true) {
        if (await is({ cwd })) {
          return cwd;
        }
        const next = dirname(cwd);
        if (cwd === root || cwd === next) {
          return null;
        }
        cwd = next;
      }
    };
  }
});

// node_modules/@npmcli/git/lib/is-clean.js
var require_is_clean = __commonJS({
  "node_modules/@npmcli/git/lib/is-clean.js"(exports2, module2) {
    var spawn = require_spawn();
    module2.exports = (opts = {}) => spawn(["status", "--porcelain=v1", "-uno"], opts).then((res) => !res.stdout.trim().split(/\r?\n+/).map((l) => l.trim()).filter((l) => l).length);
  }
});

// node_modules/@npmcli/git/lib/index.js
var require_lib12 = __commonJS({
  "node_modules/@npmcli/git/lib/index.js"(exports2, module2) {
    module2.exports = {
      clone: require_clone(),
      revs: require_revs(),
      spawn: require_spawn(),
      is: require_is(),
      find: require_find(),
      isClean: require_is_clean(),
      errors: require_errors()
    };
  }
});

// node_modules/spdx-license-ids/index.json
var require_spdx_license_ids = __commonJS({
  "node_modules/spdx-license-ids/index.json"(exports2, module2) {
    module2.exports = [
      "0BSD",
      "3D-Slicer-1.0",
      "AAL",
      "ADSL",
      "AFL-1.1",
      "AFL-1.2",
      "AFL-2.0",
      "AFL-2.1",
      "AFL-3.0",
      "AGPL-1.0-only",
      "AGPL-1.0-or-later",
      "AGPL-3.0-only",
      "AGPL-3.0-or-later",
      "AMD-newlib",
      "AMDPLPA",
      "AML",
      "AML-glslang",
      "AMPAS",
      "ANTLR-PD",
      "ANTLR-PD-fallback",
      "APAFML",
      "APL-1.0",
      "APSL-1.0",
      "APSL-1.1",
      "APSL-1.2",
      "APSL-2.0",
      "ASWF-Digital-Assets-1.0",
      "ASWF-Digital-Assets-1.1",
      "Abstyles",
      "AdaCore-doc",
      "Adobe-2006",
      "Adobe-Display-PostScript",
      "Adobe-Glyph",
      "Adobe-Utopia",
      "Afmparse",
      "Aladdin",
      "Apache-1.0",
      "Apache-1.1",
      "Apache-2.0",
      "App-s2p",
      "Arphic-1999",
      "Artistic-1.0",
      "Artistic-1.0-Perl",
      "Artistic-1.0-cl8",
      "Artistic-2.0",
      "BSD-1-Clause",
      "BSD-2-Clause",
      "BSD-2-Clause-Darwin",
      "BSD-2-Clause-Patent",
      "BSD-2-Clause-Views",
      "BSD-2-Clause-first-lines",
      "BSD-3-Clause",
      "BSD-3-Clause-Attribution",
      "BSD-3-Clause-Clear",
      "BSD-3-Clause-HP",
      "BSD-3-Clause-LBNL",
      "BSD-3-Clause-Modification",
      "BSD-3-Clause-No-Military-License",
      "BSD-3-Clause-No-Nuclear-License",
      "BSD-3-Clause-No-Nuclear-License-2014",
      "BSD-3-Clause-No-Nuclear-Warranty",
      "BSD-3-Clause-Open-MPI",
      "BSD-3-Clause-Sun",
      "BSD-3-Clause-acpica",
      "BSD-3-Clause-flex",
      "BSD-4-Clause",
      "BSD-4-Clause-Shortened",
      "BSD-4-Clause-UC",
      "BSD-4.3RENO",
      "BSD-4.3TAHOE",
      "BSD-Advertising-Acknowledgement",
      "BSD-Attribution-HPND-disclaimer",
      "BSD-Inferno-Nettverk",
      "BSD-Protection",
      "BSD-Source-Code",
      "BSD-Source-beginning-file",
      "BSD-Systemics",
      "BSD-Systemics-W3Works",
      "BSL-1.0",
      "BUSL-1.1",
      "Baekmuk",
      "Bahyph",
      "Barr",
      "Beerware",
      "BitTorrent-1.0",
      "BitTorrent-1.1",
      "Bitstream-Charter",
      "Bitstream-Vera",
      "BlueOak-1.0.0",
      "Boehm-GC",
      "Boehm-GC-without-fee",
      "Borceux",
      "Brian-Gladman-2-Clause",
      "Brian-Gladman-3-Clause",
      "C-UDA-1.0",
      "CAL-1.0",
      "CAL-1.0-Combined-Work-Exception",
      "CATOSL-1.1",
      "CC-BY-1.0",
      "CC-BY-2.0",
      "CC-BY-2.5",
      "CC-BY-2.5-AU",
      "CC-BY-3.0",
      "CC-BY-3.0-AT",
      "CC-BY-3.0-AU",
      "CC-BY-3.0-DE",
      "CC-BY-3.0-IGO",
      "CC-BY-3.0-NL",
      "CC-BY-3.0-US",
      "CC-BY-4.0",
      "CC-BY-NC-1.0",
      "CC-BY-NC-2.0",
      "CC-BY-NC-2.5",
      "CC-BY-NC-3.0",
      "CC-BY-NC-3.0-DE",
      "CC-BY-NC-4.0",
      "CC-BY-NC-ND-1.0",
      "CC-BY-NC-ND-2.0",
      "CC-BY-NC-ND-2.5",
      "CC-BY-NC-ND-3.0",
      "CC-BY-NC-ND-3.0-DE",
      "CC-BY-NC-ND-3.0-IGO",
      "CC-BY-NC-ND-4.0",
      "CC-BY-NC-SA-1.0",
      "CC-BY-NC-SA-2.0",
      "CC-BY-NC-SA-2.0-DE",
      "CC-BY-NC-SA-2.0-FR",
      "CC-BY-NC-SA-2.0-UK",
      "CC-BY-NC-SA-2.5",
      "CC-BY-NC-SA-3.0",
      "CC-BY-NC-SA-3.0-DE",
      "CC-BY-NC-SA-3.0-IGO",
      "CC-BY-NC-SA-4.0",
      "CC-BY-ND-1.0",
      "CC-BY-ND-2.0",
      "CC-BY-ND-2.5",
      "CC-BY-ND-3.0",
      "CC-BY-ND-3.0-DE",
      "CC-BY-ND-4.0",
      "CC-BY-SA-1.0",
      "CC-BY-SA-2.0",
      "CC-BY-SA-2.0-UK",
      "CC-BY-SA-2.1-JP",
      "CC-BY-SA-2.5",
      "CC-BY-SA-3.0",
      "CC-BY-SA-3.0-AT",
      "CC-BY-SA-3.0-DE",
      "CC-BY-SA-3.0-IGO",
      "CC-BY-SA-4.0",
      "CC-PDDC",
      "CC-PDM-1.0",
      "CC-SA-1.0",
      "CC0-1.0",
      "CDDL-1.0",
      "CDDL-1.1",
      "CDL-1.0",
      "CDLA-Permissive-1.0",
      "CDLA-Permissive-2.0",
      "CDLA-Sharing-1.0",
      "CECILL-1.0",
      "CECILL-1.1",
      "CECILL-2.0",
      "CECILL-2.1",
      "CECILL-B",
      "CECILL-C",
      "CERN-OHL-1.1",
      "CERN-OHL-1.2",
      "CERN-OHL-P-2.0",
      "CERN-OHL-S-2.0",
      "CERN-OHL-W-2.0",
      "CFITSIO",
      "CMU-Mach",
      "CMU-Mach-nodoc",
      "CNRI-Jython",
      "CNRI-Python",
      "CNRI-Python-GPL-Compatible",
      "COIL-1.0",
      "CPAL-1.0",
      "CPL-1.0",
      "CPOL-1.02",
      "CUA-OPL-1.0",
      "Caldera",
      "Caldera-no-preamble",
      "Catharon",
      "ClArtistic",
      "Clips",
      "Community-Spec-1.0",
      "Condor-1.1",
      "Cornell-Lossless-JPEG",
      "Cronyx",
      "Crossword",
      "CrystalStacker",
      "Cube",
      "D-FSL-1.0",
      "DEC-3-Clause",
      "DL-DE-BY-2.0",
      "DL-DE-ZERO-2.0",
      "DOC",
      "DRL-1.0",
      "DRL-1.1",
      "DSDP",
      "DocBook-Schema",
      "DocBook-Stylesheet",
      "DocBook-XML",
      "Dotseqn",
      "ECL-1.0",
      "ECL-2.0",
      "EFL-1.0",
      "EFL-2.0",
      "EPICS",
      "EPL-1.0",
      "EPL-2.0",
      "EUDatagrid",
      "EUPL-1.0",
      "EUPL-1.1",
      "EUPL-1.2",
      "Elastic-2.0",
      "Entessa",
      "ErlPL-1.1",
      "Eurosym",
      "FBM",
      "FDK-AAC",
      "FSFAP",
      "FSFAP-no-warranty-disclaimer",
      "FSFUL",
      "FSFULLR",
      "FSFULLRWD",
      "FTL",
      "Fair",
      "Ferguson-Twofish",
      "Frameworx-1.0",
      "FreeBSD-DOC",
      "FreeImage",
      "Furuseth",
      "GCR-docs",
      "GD",
      "GFDL-1.1-invariants-only",
      "GFDL-1.1-invariants-or-later",
      "GFDL-1.1-no-invariants-only",
      "GFDL-1.1-no-invariants-or-later",
      "GFDL-1.1-only",
      "GFDL-1.1-or-later",
      "GFDL-1.2-invariants-only",
      "GFDL-1.2-invariants-or-later",
      "GFDL-1.2-no-invariants-only",
      "GFDL-1.2-no-invariants-or-later",
      "GFDL-1.2-only",
      "GFDL-1.2-or-later",
      "GFDL-1.3-invariants-only",
      "GFDL-1.3-invariants-or-later",
      "GFDL-1.3-no-invariants-only",
      "GFDL-1.3-no-invariants-or-later",
      "GFDL-1.3-only",
      "GFDL-1.3-or-later",
      "GL2PS",
      "GLWTPL",
      "GPL-1.0-only",
      "GPL-1.0-or-later",
      "GPL-2.0-only",
      "GPL-2.0-or-later",
      "GPL-3.0-only",
      "GPL-3.0-or-later",
      "Giftware",
      "Glide",
      "Glulxe",
      "Graphics-Gems",
      "Gutmann",
      "HIDAPI",
      "HP-1986",
      "HP-1989",
      "HPND",
      "HPND-DEC",
      "HPND-Fenneberg-Livingston",
      "HPND-INRIA-IMAG",
      "HPND-Intel",
      "HPND-Kevlin-Henney",
      "HPND-MIT-disclaimer",
      "HPND-Markus-Kuhn",
      "HPND-Netrek",
      "HPND-Pbmplus",
      "HPND-UC",
      "HPND-UC-export-US",
      "HPND-doc",
      "HPND-doc-sell",
      "HPND-export-US",
      "HPND-export-US-acknowledgement",
      "HPND-export-US-modify",
      "HPND-export2-US",
      "HPND-merchantability-variant",
      "HPND-sell-MIT-disclaimer-xserver",
      "HPND-sell-regexpr",
      "HPND-sell-variant",
      "HPND-sell-variant-MIT-disclaimer",
      "HPND-sell-variant-MIT-disclaimer-rev",
      "HTMLTIDY",
      "HaskellReport",
      "Hippocratic-2.1",
      "IBM-pibs",
      "ICU",
      "IEC-Code-Components-EULA",
      "IJG",
      "IJG-short",
      "IPA",
      "IPL-1.0",
      "ISC",
      "ISC-Veillard",
      "ImageMagick",
      "Imlib2",
      "Info-ZIP",
      "Inner-Net-2.0",
      "InnoSetup",
      "Intel",
      "Intel-ACPI",
      "Interbase-1.0",
      "JPL-image",
      "JPNIC",
      "JSON",
      "Jam",
      "JasPer-2.0",
      "Kastrup",
      "Kazlib",
      "Knuth-CTAN",
      "LAL-1.2",
      "LAL-1.3",
      "LGPL-2.0-only",
      "LGPL-2.0-or-later",
      "LGPL-2.1-only",
      "LGPL-2.1-or-later",
      "LGPL-3.0-only",
      "LGPL-3.0-or-later",
      "LGPLLR",
      "LOOP",
      "LPD-document",
      "LPL-1.0",
      "LPL-1.02",
      "LPPL-1.0",
      "LPPL-1.1",
      "LPPL-1.2",
      "LPPL-1.3a",
      "LPPL-1.3c",
      "LZMA-SDK-9.11-to-9.20",
      "LZMA-SDK-9.22",
      "Latex2e",
      "Latex2e-translated-notice",
      "Leptonica",
      "LiLiQ-P-1.1",
      "LiLiQ-R-1.1",
      "LiLiQ-Rplus-1.1",
      "Libpng",
      "Linux-OpenIB",
      "Linux-man-pages-1-para",
      "Linux-man-pages-copyleft",
      "Linux-man-pages-copyleft-2-para",
      "Linux-man-pages-copyleft-var",
      "Lucida-Bitmap-Fonts",
      "MIPS",
      "MIT",
      "MIT-0",
      "MIT-CMU",
      "MIT-Click",
      "MIT-Festival",
      "MIT-Khronos-old",
      "MIT-Modern-Variant",
      "MIT-Wu",
      "MIT-advertising",
      "MIT-enna",
      "MIT-feh",
      "MIT-open-group",
      "MIT-testregex",
      "MITNFA",
      "MMIXware",
      "MPEG-SSG",
      "MPL-1.0",
      "MPL-1.1",
      "MPL-2.0",
      "MPL-2.0-no-copyleft-exception",
      "MS-LPL",
      "MS-PL",
      "MS-RL",
      "MTLL",
      "Mackerras-3-Clause",
      "Mackerras-3-Clause-acknowledgment",
      "MakeIndex",
      "Martin-Birgmeier",
      "McPhee-slideshow",
      "Minpack",
      "MirOS",
      "Motosoto",
      "MulanPSL-1.0",
      "MulanPSL-2.0",
      "Multics",
      "Mup",
      "NAIST-2003",
      "NASA-1.3",
      "NBPL-1.0",
      "NCBI-PD",
      "NCGL-UK-2.0",
      "NCL",
      "NCSA",
      "NGPL",
      "NICTA-1.0",
      "NIST-PD",
      "NIST-PD-fallback",
      "NIST-Software",
      "NLOD-1.0",
      "NLOD-2.0",
      "NLPL",
      "NOSL",
      "NPL-1.0",
      "NPL-1.1",
      "NPOSL-3.0",
      "NRL",
      "NTP",
      "NTP-0",
      "Naumen",
      "NetCDF",
      "Newsletr",
      "Nokia",
      "Noweb",
      "O-UDA-1.0",
      "OAR",
      "OCCT-PL",
      "OCLC-2.0",
      "ODC-By-1.0",
      "ODbL-1.0",
      "OFFIS",
      "OFL-1.0",
      "OFL-1.0-RFN",
      "OFL-1.0-no-RFN",
      "OFL-1.1",
      "OFL-1.1-RFN",
      "OFL-1.1-no-RFN",
      "OGC-1.0",
      "OGDL-Taiwan-1.0",
      "OGL-Canada-2.0",
      "OGL-UK-1.0",
      "OGL-UK-2.0",
      "OGL-UK-3.0",
      "OGTSL",
      "OLDAP-1.1",
      "OLDAP-1.2",
      "OLDAP-1.3",
      "OLDAP-1.4",
      "OLDAP-2.0",
      "OLDAP-2.0.1",
      "OLDAP-2.1",
      "OLDAP-2.2",
      "OLDAP-2.2.1",
      "OLDAP-2.2.2",
      "OLDAP-2.3",
      "OLDAP-2.4",
      "OLDAP-2.5",
      "OLDAP-2.6",
      "OLDAP-2.7",
      "OLDAP-2.8",
      "OLFL-1.3",
      "OML",
      "OPL-1.0",
      "OPL-UK-3.0",
      "OPUBL-1.0",
      "OSET-PL-2.1",
      "OSL-1.0",
      "OSL-1.1",
      "OSL-2.0",
      "OSL-2.1",
      "OSL-3.0",
      "OpenPBS-2.3",
      "OpenSSL",
      "OpenSSL-standalone",
      "OpenVision",
      "PADL",
      "PDDL-1.0",
      "PHP-3.0",
      "PHP-3.01",
      "PPL",
      "PSF-2.0",
      "Parity-6.0.0",
      "Parity-7.0.0",
      "Pixar",
      "Plexus",
      "PolyForm-Noncommercial-1.0.0",
      "PolyForm-Small-Business-1.0.0",
      "PostgreSQL",
      "Python-2.0",
      "Python-2.0.1",
      "QPL-1.0",
      "QPL-1.0-INRIA-2004",
      "Qhull",
      "RHeCos-1.1",
      "RPL-1.1",
      "RPL-1.5",
      "RPSL-1.0",
      "RSA-MD",
      "RSCPL",
      "Rdisc",
      "Ruby",
      "Ruby-pty",
      "SAX-PD",
      "SAX-PD-2.0",
      "SCEA",
      "SGI-B-1.0",
      "SGI-B-1.1",
      "SGI-B-2.0",
      "SGI-OpenGL",
      "SGP4",
      "SHL-0.5",
      "SHL-0.51",
      "SISSL",
      "SISSL-1.2",
      "SL",
      "SMAIL-GPL",
      "SMLNJ",
      "SMPPL",
      "SNIA",
      "SPL-1.0",
      "SSH-OpenSSH",
      "SSH-short",
      "SSLeay-standalone",
      "SSPL-1.0",
      "SWL",
      "Saxpath",
      "SchemeReport",
      "Sendmail",
      "Sendmail-8.23",
      "Sendmail-Open-Source-1.1",
      "SimPL-2.0",
      "Sleepycat",
      "Soundex",
      "Spencer-86",
      "Spencer-94",
      "Spencer-99",
      "SugarCRM-1.1.3",
      "Sun-PPP",
      "Sun-PPP-2000",
      "SunPro",
      "Symlinks",
      "TAPR-OHL-1.0",
      "TCL",
      "TCP-wrappers",
      "TGPPL-1.0",
      "TMate",
      "TORQUE-1.1",
      "TOSL",
      "TPDL",
      "TPL-1.0",
      "TTWL",
      "TTYP0",
      "TU-Berlin-1.0",
      "TU-Berlin-2.0",
      "TermReadKey",
      "ThirdEye",
      "TrustedQSL",
      "UCAR",
      "UCL-1.0",
      "UMich-Merit",
      "UPL-1.0",
      "URT-RLE",
      "Ubuntu-font-1.0",
      "Unicode-3.0",
      "Unicode-DFS-2015",
      "Unicode-DFS-2016",
      "Unicode-TOU",
      "UnixCrypt",
      "Unlicense",
      "VOSTROM",
      "VSL-1.0",
      "Vim",
      "W3C",
      "W3C-19980720",
      "W3C-20150513",
      "WTFPL",
      "Watcom-1.0",
      "Widget-Workshop",
      "Wsuipa",
      "X11",
      "X11-distribute-modifications-variant",
      "X11-swapped",
      "XFree86-1.1",
      "XSkat",
      "Xdebug-1.03",
      "Xerox",
      "Xfig",
      "Xnet",
      "YPL-1.0",
      "YPL-1.1",
      "ZPL-1.1",
      "ZPL-2.0",
      "ZPL-2.1",
      "Zed",
      "Zeeff",
      "Zend-2.0",
      "Zimbra-1.3",
      "Zimbra-1.4",
      "Zlib",
      "any-OSI",
      "any-OSI-perl-modules",
      "bcrypt-Solar-Designer",
      "blessing",
      "bzip2-1.0.6",
      "check-cvs",
      "checkmk",
      "copyleft-next-0.3.0",
      "copyleft-next-0.3.1",
      "curl",
      "cve-tou",
      "diffmark",
      "dtoa",
      "dvipdfm",
      "eGenix",
      "etalab-2.0",
      "fwlw",
      "gSOAP-1.3b",
      "generic-xts",
      "gnuplot",
      "gtkbook",
      "hdparm",
      "iMatix",
      "libpng-2.0",
      "libselinux-1.0",
      "libtiff",
      "libutil-David-Nugent",
      "lsof",
      "magaz",
      "mailprio",
      "metamail",
      "mpi-permissive",
      "mpich2",
      "mplus",
      "pkgconf",
      "pnmstitch",
      "psfrag",
      "psutils",
      "python-ldap",
      "radvd",
      "snprintf",
      "softSurfer",
      "ssh-keyscan",
      "swrule",
      "threeparttable",
      "ulem",
      "w3m",
      "wwl",
      "xinetd",
      "xkeyboard-config-Zinoviev",
      "xlock",
      "xpp",
      "xzoom",
      "zlib-acknowledgement"
    ];
  }
});

// node_modules/spdx-license-ids/deprecated.json
var require_deprecated = __commonJS({
  "node_modules/spdx-license-ids/deprecated.json"(exports2, module2) {
    module2.exports = [
      "AGPL-1.0",
      "AGPL-3.0",
      "BSD-2-Clause-FreeBSD",
      "BSD-2-Clause-NetBSD",
      "GFDL-1.1",
      "GFDL-1.2",
      "GFDL-1.3",
      "GPL-1.0",
      "GPL-2.0",
      "GPL-2.0-with-GCC-exception",
      "GPL-2.0-with-autoconf-exception",
      "GPL-2.0-with-bison-exception",
      "GPL-2.0-with-classpath-exception",
      "GPL-2.0-with-font-exception",
      "GPL-3.0",
      "GPL-3.0-with-GCC-exception",
      "GPL-3.0-with-autoconf-exception",
      "LGPL-2.0",
      "LGPL-2.1",
      "LGPL-3.0",
      "Net-SNMP",
      "Nunit",
      "StandardML-NJ",
      "bzip2-1.0.5",
      "eCos-2.0",
      "wxWindows"
    ];
  }
});

// node_modules/spdx-exceptions/index.json
var require_spdx_exceptions = __commonJS({
  "node_modules/spdx-exceptions/index.json"(exports2, module2) {
    module2.exports = [
      "389-exception",
      "Asterisk-exception",
      "Autoconf-exception-2.0",
      "Autoconf-exception-3.0",
      "Autoconf-exception-generic",
      "Autoconf-exception-generic-3.0",
      "Autoconf-exception-macro",
      "Bison-exception-1.24",
      "Bison-exception-2.2",
      "Bootloader-exception",
      "Classpath-exception-2.0",
      "CLISP-exception-2.0",
      "cryptsetup-OpenSSL-exception",
      "DigiRule-FOSS-exception",
      "eCos-exception-2.0",
      "Fawkes-Runtime-exception",
      "FLTK-exception",
      "fmt-exception",
      "Font-exception-2.0",
      "freertos-exception-2.0",
      "GCC-exception-2.0",
      "GCC-exception-2.0-note",
      "GCC-exception-3.1",
      "Gmsh-exception",
      "GNAT-exception",
      "GNOME-examples-exception",
      "GNU-compiler-exception",
      "gnu-javamail-exception",
      "GPL-3.0-interface-exception",
      "GPL-3.0-linking-exception",
      "GPL-3.0-linking-source-exception",
      "GPL-CC-1.0",
      "GStreamer-exception-2005",
      "GStreamer-exception-2008",
      "i2p-gpl-java-exception",
      "KiCad-libraries-exception",
      "LGPL-3.0-linking-exception",
      "libpri-OpenH323-exception",
      "Libtool-exception",
      "Linux-syscall-note",
      "LLGPL",
      "LLVM-exception",
      "LZMA-exception",
      "mif-exception",
      "OCaml-LGPL-linking-exception",
      "OCCT-exception-1.0",
      "OpenJDK-assembly-exception-1.0",
      "openvpn-openssl-exception",
      "PS-or-PDF-font-exception-20170817",
      "QPL-1.0-INRIA-2004-exception",
      "Qt-GPL-exception-1.0",
      "Qt-LGPL-exception-1.1",
      "Qwt-exception-1.0",
      "SANE-exception",
      "SHL-2.0",
      "SHL-2.1",
      "stunnel-exception",
      "SWI-exception",
      "Swift-exception",
      "Texinfo-exception",
      "u-boot-exception-2.0",
      "UBDL-exception",
      "Universal-FOSS-exception-1.0",
      "vsftpd-openssl-exception",
      "WxWindows-exception-3.1",
      "x11vnc-openssl-exception"
    ];
  }
});

// node_modules/spdx-expression-parse/scan.js
var require_scan = __commonJS({
  "node_modules/spdx-expression-parse/scan.js"(exports2, module2) {
    "use strict";
    var licenses = [].concat(require_spdx_license_ids()).concat(require_deprecated());
    var exceptions = require_spdx_exceptions();
    module2.exports = function(source) {
      var index = 0;
      function hasMore() {
        return index < source.length;
      }
      function read(value) {
        if (value instanceof RegExp) {
          var chars = source.slice(index);
          var match = chars.match(value);
          if (match) {
            index += match[0].length;
            return match[0];
          }
        } else {
          if (source.indexOf(value, index) === index) {
            index += value.length;
            return value;
          }
        }
      }
      function skipWhitespace() {
        read(/[ ]*/);
      }
      function operator() {
        var string;
        var possibilities = ["WITH", "AND", "OR", "(", ")", ":", "+"];
        for (var i = 0; i < possibilities.length; i++) {
          string = read(possibilities[i]);
          if (string) {
            break;
          }
        }
        if (string === "+" && index > 1 && source[index - 2] === " ") {
          throw new Error("Space before `+`");
        }
        return string && {
          type: "OPERATOR",
          string
        };
      }
      function idstring() {
        return read(/[A-Za-z0-9-.]+/);
      }
      function expectIdstring() {
        var string = idstring();
        if (!string) {
          throw new Error("Expected idstring at offset " + index);
        }
        return string;
      }
      function documentRef() {
        if (read("DocumentRef-")) {
          var string = expectIdstring();
          return { type: "DOCUMENTREF", string };
        }
      }
      function licenseRef() {
        if (read("LicenseRef-")) {
          var string = expectIdstring();
          return { type: "LICENSEREF", string };
        }
      }
      function identifier() {
        var begin = index;
        var string = idstring();
        if (licenses.indexOf(string) !== -1) {
          return {
            type: "LICENSE",
            string
          };
        } else if (exceptions.indexOf(string) !== -1) {
          return {
            type: "EXCEPTION",
            string
          };
        }
        index = begin;
      }
      function parseToken() {
        return operator() || documentRef() || licenseRef() || identifier();
      }
      var tokens = [];
      while (hasMore()) {
        skipWhitespace();
        if (!hasMore()) {
          break;
        }
        var token = parseToken();
        if (!token) {
          throw new Error("Unexpected `" + source[index] + "` at offset " + index);
        }
        tokens.push(token);
      }
      return tokens;
    };
  }
});

// node_modules/spdx-expression-parse/parse.js
var require_parse2 = __commonJS({
  "node_modules/spdx-expression-parse/parse.js"(exports2, module2) {
    "use strict";
    module2.exports = function(tokens) {
      var index = 0;
      function hasMore() {
        return index < tokens.length;
      }
      function token() {
        return hasMore() ? tokens[index] : null;
      }
      function next() {
        if (!hasMore()) {
          throw new Error();
        }
        index++;
      }
      function parseOperator(operator) {
        var t = token();
        if (t && t.type === "OPERATOR" && operator === t.string) {
          next();
          return t.string;
        }
      }
      function parseWith() {
        if (parseOperator("WITH")) {
          var t = token();
          if (t && t.type === "EXCEPTION") {
            next();
            return t.string;
          }
          throw new Error("Expected exception after `WITH`");
        }
      }
      function parseLicenseRef() {
        var begin = index;
        var string = "";
        var t = token();
        if (t.type === "DOCUMENTREF") {
          next();
          string += "DocumentRef-" + t.string + ":";
          if (!parseOperator(":")) {
            throw new Error("Expected `:` after `DocumentRef-...`");
          }
        }
        t = token();
        if (t.type === "LICENSEREF") {
          next();
          string += "LicenseRef-" + t.string;
          return { license: string };
        }
        index = begin;
      }
      function parseLicense() {
        var t = token();
        if (t && t.type === "LICENSE") {
          next();
          var node2 = { license: t.string };
          if (parseOperator("+")) {
            node2.plus = true;
          }
          var exception = parseWith();
          if (exception) {
            node2.exception = exception;
          }
          return node2;
        }
      }
      function parseParenthesizedExpression() {
        var left = parseOperator("(");
        if (!left) {
          return;
        }
        var expr = parseExpression();
        if (!parseOperator(")")) {
          throw new Error("Expected `)`");
        }
        return expr;
      }
      function parseAtom() {
        return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();
      }
      function makeBinaryOpParser(operator, nextParser) {
        return function parseBinaryOp() {
          var left = nextParser();
          if (!left) {
            return;
          }
          if (!parseOperator(operator)) {
            return left;
          }
          var right = parseBinaryOp();
          if (!right) {
            throw new Error("Expected expression");
          }
          return {
            left,
            conjunction: operator.toLowerCase(),
            right
          };
        };
      }
      var parseAnd = makeBinaryOpParser("AND", parseAtom);
      var parseExpression = makeBinaryOpParser("OR", parseAnd);
      var node = parseExpression();
      if (!node || hasMore()) {
        throw new Error("Syntax error");
      }
      return node;
    };
  }
});

// node_modules/spdx-expression-parse/index.js
var require_spdx_expression_parse = __commonJS({
  "node_modules/spdx-expression-parse/index.js"(exports2, module2) {
    "use strict";
    var scan = require_scan();
    var parse = require_parse2();
    module2.exports = function(source) {
      return parse(scan(source));
    };
  }
});

// node_modules/spdx-correct/index.js
var require_spdx_correct = __commonJS({
  "node_modules/spdx-correct/index.js"(exports2, module2) {
    var parse = require_spdx_expression_parse();
    var spdxLicenseIds = require_spdx_license_ids();
    function valid(string) {
      try {
        parse(string);
        return true;
      } catch (error) {
        return false;
      }
    }
    function sortTranspositions(a, b) {
      var length = b[0].length - a[0].length;
      if (length !== 0) return length;
      return a[0].toUpperCase().localeCompare(b[0].toUpperCase());
    }
    var transpositions = [
      ["APGL", "AGPL"],
      ["Gpl", "GPL"],
      ["GLP", "GPL"],
      ["APL", "Apache"],
      ["ISD", "ISC"],
      ["GLP", "GPL"],
      ["IST", "ISC"],
      ["Claude", "Clause"],
      [" or later", "+"],
      [" International", ""],
      ["GNU", "GPL"],
      ["GUN", "GPL"],
      ["+", ""],
      ["GNU GPL", "GPL"],
      ["GNU LGPL", "LGPL"],
      ["GNU/GPL", "GPL"],
      ["GNU GLP", "GPL"],
      ["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL"],
      ["GNU Lesser General Public License", "LGPL"],
      ["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
      ["GNU Lesser General Public License", "LGPL-2.1"],
      ["LESSER GENERAL PUBLIC LICENSE", "LGPL"],
      ["Lesser General Public License", "LGPL"],
      ["LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
      ["Lesser General Public License", "LGPL-2.1"],
      ["GNU General Public License", "GPL"],
      ["Gnu public license", "GPL"],
      ["GNU Public License", "GPL"],
      ["GNU GENERAL PUBLIC LICENSE", "GPL"],
      ["MTI", "MIT"],
      ["Mozilla Public License", "MPL"],
      ["Universal Permissive License", "UPL"],
      ["WTH", "WTF"],
      ["WTFGPL", "WTFPL"],
      ["-License", ""]
    ].sort(sortTranspositions);
    var TRANSPOSED = 0;
    var CORRECT = 1;
    var transforms = [
      // e.g. 'mit'
      function(argument) {
        return argument.toUpperCase();
      },
      // e.g. 'MIT '
      function(argument) {
        return argument.trim();
      },
      // e.g. 'M.I.T.'
      function(argument) {
        return argument.replace(/\./g, "");
      },
      // e.g. 'Apache- 2.0'
      function(argument) {
        return argument.replace(/\s+/g, "");
      },
      // e.g. 'CC BY 4.0''
      function(argument) {
        return argument.replace(/\s+/g, "-");
      },
      // e.g. 'LGPLv2.1'
      function(argument) {
        return argument.replace("v", "-");
      },
      // e.g. 'Apache 2.0'
      function(argument) {
        return argument.replace(/,?\s*(\d)/, "-$1");
      },
      // e.g. 'GPL 2'
      function(argument) {
        return argument.replace(/,?\s*(\d)/, "-$1.0");
      },
      // e.g. 'Apache Version 2.0'
      function(argument) {
        return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2");
      },
      // e.g. 'Apache Version 2'
      function(argument) {
        return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2.0");
      },
      // e.g. 'ZLIB'
      function(argument) {
        return argument[0].toUpperCase() + argument.slice(1);
      },
      // e.g. 'MPL/2.0'
      function(argument) {
        return argument.replace("/", "-");
      },
      // e.g. 'Apache 2'
      function(argument) {
        return argument.replace(/\s*V\s*(\d)/, "-$1").replace(/(\d)$/, "$1.0");
      },
      // e.g. 'GPL-2.0', 'GPL-3.0'
      function(argument) {
        if (argument.indexOf("3.0") !== -1) {
          return argument + "-or-later";
        } else {
          return argument + "-only";
        }
      },
      // e.g. 'GPL-2.0-'
      function(argument) {
        return argument + "only";
      },
      // e.g. 'GPL2'
      function(argument) {
        return argument.replace(/(\d)$/, "-$1.0");
      },
      // e.g. 'BSD 3'
      function(argument) {
        return argument.replace(/(-| )?(\d)$/, "-$2-Clause");
      },
      // e.g. 'BSD clause 3'
      function(argument) {
        return argument.replace(/(-| )clause(-| )(\d)/, "-$3-Clause");
      },
      // e.g. 'New BSD license'
      function(argument) {
        return argument.replace(/\b(Modified|New|Revised)(-| )?BSD((-| )License)?/i, "BSD-3-Clause");
      },
      // e.g. 'Simplified BSD license'
      function(argument) {
        return argument.replace(/\bSimplified(-| )?BSD((-| )License)?/i, "BSD-2-Clause");
      },
      // e.g. 'Free BSD license'
      function(argument) {
        return argument.replace(/\b(Free|Net)(-| )?BSD((-| )License)?/i, "BSD-2-Clause-$1BSD");
      },
      // e.g. 'Clear BSD license'
      function(argument) {
        return argument.replace(/\bClear(-| )?BSD((-| )License)?/i, "BSD-3-Clause-Clear");
      },
      // e.g. 'Old BSD License'
      function(argument) {
        return argument.replace(/\b(Old|Original)(-| )?BSD((-| )License)?/i, "BSD-4-Clause");
      },
      // e.g. 'BY-NC-4.0'
      function(argument) {
        return "CC-" + argument;
      },
      // e.g. 'BY-NC'
      function(argument) {
        return "CC-" + argument + "-4.0";
      },
      // e.g. 'Attribution-NonCommercial'
      function(argument) {
        return argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "");
      },
      // e.g. 'Attribution-NonCommercial'
      function(argument) {
        return "CC-" + argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "") + "-4.0";
      }
    ];
    var licensesWithVersions = spdxLicenseIds.map(function(id) {
      var match = /^(.*)-\d+\.\d+$/.exec(id);
      return match ? [match[0], match[1]] : [id, null];
    }).reduce(function(objectMap, item) {
      var key = item[1];
      objectMap[key] = objectMap[key] || [];
      objectMap[key].push(item[0]);
      return objectMap;
    }, {});
    var licensesWithOneVersion = Object.keys(licensesWithVersions).map(function makeEntries(key) {
      return [key, licensesWithVersions[key]];
    }).filter(function identifySoleVersions(item) {
      return (
        // Licenses has just one valid version suffix.
        item[1].length === 1 && item[0] !== null && // APL will be considered Apache, rather than APL-1.0
        item[0] !== "APL"
      );
    }).map(function createLastResorts(item) {
      return [item[0], item[1][0]];
    });
    licensesWithVersions = void 0;
    var lastResorts = [
      ["UNLI", "Unlicense"],
      ["WTF", "WTFPL"],
      ["2 CLAUSE", "BSD-2-Clause"],
      ["2-CLAUSE", "BSD-2-Clause"],
      ["3 CLAUSE", "BSD-3-Clause"],
      ["3-CLAUSE", "BSD-3-Clause"],
      ["AFFERO", "AGPL-3.0-or-later"],
      ["AGPL", "AGPL-3.0-or-later"],
      ["APACHE", "Apache-2.0"],
      ["ARTISTIC", "Artistic-2.0"],
      ["Affero", "AGPL-3.0-or-later"],
      ["BEER", "Beerware"],
      ["BOOST", "BSL-1.0"],
      ["BSD", "BSD-2-Clause"],
      ["CDDL", "CDDL-1.1"],
      ["ECLIPSE", "EPL-1.0"],
      ["FUCK", "WTFPL"],
      ["GNU", "GPL-3.0-or-later"],
      ["LGPL", "LGPL-3.0-or-later"],
      ["GPLV1", "GPL-1.0-only"],
      ["GPL-1", "GPL-1.0-only"],
      ["GPLV2", "GPL-2.0-only"],
      ["GPL-2", "GPL-2.0-only"],
      ["GPL", "GPL-3.0-or-later"],
      ["MIT +NO-FALSE-ATTRIBS", "MITNFA"],
      ["MIT", "MIT"],
      ["MPL", "MPL-2.0"],
      ["X11", "X11"],
      ["ZLIB", "Zlib"]
    ].concat(licensesWithOneVersion).sort(sortTranspositions);
    var SUBSTRING = 0;
    var IDENTIFIER = 1;
    var validTransformation = function(identifier) {
      for (var i = 0; i < transforms.length; i++) {
        var transformed = transforms[i](identifier).trim();
        if (transformed !== identifier && valid(transformed)) {
          return transformed;
        }
      }
      return null;
    };
    var validLastResort = function(identifier) {
      var upperCased = identifier.toUpperCase();
      for (var i = 0; i < lastResorts.length; i++) {
        var lastResort = lastResorts[i];
        if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) {
          return lastResort[IDENTIFIER];
        }
      }
      return null;
    };
    var anyCorrection = function(identifier, check) {
      for (var i = 0; i < transpositions.length; i++) {
        var transposition = transpositions[i];
        var transposed = transposition[TRANSPOSED];
        if (identifier.indexOf(transposed) > -1) {
          var corrected = identifier.replace(
            transposed,
            transposition[CORRECT]
          );
          var checked = check(corrected);
          if (checked !== null) {
            return checked;
          }
        }
      }
      return null;
    };
    module2.exports = function(identifier, options) {
      options = options || {};
      var upgrade = options.upgrade === void 0 ? true : !!options.upgrade;
      function postprocess(value) {
        return upgrade ? upgradeGPLs(value) : value;
      }
      var validArugment = typeof identifier === "string" && identifier.trim().length !== 0;
      if (!validArugment) {
        throw Error("Invalid argument. Expected non-empty string.");
      }
      identifier = identifier.trim();
      if (valid(identifier)) {
        return postprocess(identifier);
      }
      var noPlus = identifier.replace(/\+$/, "").trim();
      if (valid(noPlus)) {
        return postprocess(noPlus);
      }
      var transformed = validTransformation(identifier);
      if (transformed !== null) {
        return postprocess(transformed);
      }
      transformed = anyCorrection(identifier, function(argument) {
        if (valid(argument)) {
          return argument;
        }
        return validTransformation(argument);
      });
      if (transformed !== null) {
        return postprocess(transformed);
      }
      transformed = validLastResort(identifier);
      if (transformed !== null) {
        return postprocess(transformed);
      }
      transformed = anyCorrection(identifier, validLastResort);
      if (transformed !== null) {
        return postprocess(transformed);
      }
      return null;
    };
    function upgradeGPLs(value) {
      if ([
        "GPL-1.0",
        "LGPL-1.0",
        "AGPL-1.0",
        "GPL-2.0",
        "LGPL-2.0",
        "AGPL-2.0",
        "LGPL-2.1"
      ].indexOf(value) !== -1) {
        return value + "-only";
      } else if ([
        "GPL-1.0+",
        "GPL-2.0+",
        "GPL-3.0+",
        "LGPL-2.0+",
        "LGPL-2.1+",
        "LGPL-3.0+",
        "AGPL-1.0+",
        "AGPL-3.0+"
      ].indexOf(value) !== -1) {
        return value.replace(/\+$/, "-or-later");
      } else if (["GPL-3.0", "LGPL-3.0", "AGPL-3.0"].indexOf(value) !== -1) {
        return value + "-or-later";
      } else {
        return value;
      }
    }
  }
});

// node_modules/validate-npm-package-license/index.js
var require_validate_npm_package_license = __commonJS({
  "node_modules/validate-npm-package-license/index.js"(exports2, module2) {
    var parse = require_spdx_expression_parse();
    var correct = require_spdx_correct();
    var genericWarning = 'license should be a valid SPDX license expression (without "LicenseRef"), "UNLICENSED", or "SEE LICENSE IN <filename>"';
    var fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;
    function startsWith(prefix, string) {
      return string.slice(0, prefix.length) === prefix;
    }
    function usesLicenseRef(ast) {
      if (ast.hasOwnProperty("license")) {
        var license = ast.license;
        return startsWith("LicenseRef", license) || startsWith("DocumentRef", license);
      } else {
        return usesLicenseRef(ast.left) || usesLicenseRef(ast.right);
      }
    }
    module2.exports = function(argument) {
      var ast;
      try {
        ast = parse(argument);
      } catch (e) {
        var match;
        if (argument === "UNLICENSED" || argument === "UNLICENCED") {
          return {
            validForOldPackages: true,
            validForNewPackages: true,
            unlicensed: true
          };
        } else if (match = fileReferenceRE.exec(argument)) {
          return {
            validForOldPackages: true,
            validForNewPackages: true,
            inFile: match[1]
          };
        } else {
          var result = {
            validForOldPackages: false,
            validForNewPackages: false,
            warnings: [genericWarning]
          };
          if (argument.trim().length !== 0) {
            var corrected = correct(argument);
            if (corrected) {
              result.warnings.push(
                'license is similar to the valid expression "' + corrected + '"'
              );
            }
          }
          return result;
        }
      }
      if (usesLicenseRef(ast)) {
        return {
          validForNewPackages: false,
          validForOldPackages: false,
          spdx: true,
          warnings: [genericWarning]
        };
      } else {
        return {
          validForNewPackages: true,
          validForOldPackages: true,
          spdx: true
        };
      }
    };
  }
});

// node_modules/@npmcli/package-json/lib/normalize-data.js
var require_normalize_data = __commonJS({
  "node_modules/@npmcli/package-json/lib/normalize-data.js"(exports2, module2) {
    var url = require("node:url");
    var hostedGitInfo = require_lib5();
    var validateLicense = require_validate_npm_package_license();
    var typos = {
      dependancies: "dependencies",
      dependecies: "dependencies",
      depdenencies: "dependencies",
      devEependencies: "devDependencies",
      depends: "dependencies",
      "dev-dependencies": "devDependencies",
      devDependences: "devDependencies",
      devDepenencies: "devDependencies",
      devdependencies: "devDependencies",
      repostitory: "repository",
      repo: "repository",
      prefereGlobal: "preferGlobal",
      hompage: "homepage",
      hampage: "homepage",
      autohr: "author",
      autor: "author",
      contributers: "contributors",
      publicationConfig: "publishConfig",
      script: "scripts"
    };
    var isEmail = (str) => str.includes("@") && str.indexOf("@") < str.lastIndexOf(".");
    function extractDescription(description) {
      const lines = description.trim().split("\n");
      let start = 0;
      while (lines[start]?.trim().match(/^(#|$)/)) {
        start++;
      }
      let end = start + 1;
      while (end < lines.length && lines[end].trim()) {
        end++;
      }
      return lines.slice(start, end).join(" ").trim();
    }
    function stringifyPerson(person) {
      if (typeof person !== "string") {
        const name = person.name || "";
        const u = person.url || person.web;
        const wrappedUrl = u ? " (" + u + ")" : "";
        const e = person.email || person.mail;
        const wrappedEmail = e ? " <" + e + ">" : "";
        person = name + wrappedEmail + wrappedUrl;
      }
      const matchedName = person.match(/^([^(<]+)/);
      const matchedUrl = person.match(/\(([^()]+)\)/);
      const matchedEmail = person.match(/<([^<>]+)>/);
      const parsed = {};
      if (matchedName?.[0].trim()) {
        parsed.name = matchedName[0].trim();
      }
      if (matchedEmail) {
        parsed.email = matchedEmail[1];
      }
      if (matchedUrl) {
        parsed.url = matchedUrl[1];
      }
      return parsed;
    }
    function normalizeData(data, changes) {
      if (data.description && typeof data.description !== "string") {
        changes?.push(`'description' field should be a string`);
        delete data.description;
      }
      if (data.readme && !data.description && data.readme !== "ERROR: No README data found!") {
        data.description = extractDescription(data.readme);
      }
      if (data.description === void 0) {
        delete data.description;
      }
      if (!data.description) {
        changes?.push("No description");
      }
      if (data.modules) {
        changes?.push(`modules field is deprecated`);
        delete data.modules;
      }
      const files = data.files;
      if (files && !Array.isArray(files)) {
        changes?.push(`Invalid 'files' member`);
        delete data.files;
      } else if (data.files) {
        data.files = data.files.filter(function(file) {
          if (!file || typeof file !== "string") {
            changes?.push(`Invalid filename in 'files' list: ${file}`);
            return false;
          } else {
            return true;
          }
        });
      }
      if (data.man && typeof data.man === "string") {
        data.man = [data.man];
      }
      if (!data.bugs && data.repository?.url) {
        const hosted = hostedGitInfo.fromUrl(data.repository.url);
        if (hosted && hosted.bugs()) {
          data.bugs = { url: hosted.bugs() };
        }
      } else if (data.bugs) {
        if (typeof data.bugs === "string") {
          if (isEmail(data.bugs)) {
            data.bugs = { email: data.bugs };
          } else if (url.parse(data.bugs).protocol) {
            data.bugs = { url: data.bugs };
          } else {
            changes?.push(`Bug string field must be url, email, or {email,url}`);
          }
        } else {
          for (const k in data.bugs) {
            if (["web", "name"].includes(k)) {
              changes?.push(`bugs['${k}'] should probably be bugs['url'].`);
              data.bugs.url = data.bugs[k];
              delete data.bugs[k];
            }
          }
          const oldBugs = data.bugs;
          data.bugs = {};
          if (oldBugs.url) {
            if (typeof oldBugs.url === "string" && url.parse(oldBugs.url).protocol) {
              data.bugs.url = oldBugs.url;
            } else {
              changes?.push("bugs.url field must be a string url. Deleted.");
            }
          }
          if (oldBugs.email) {
            if (typeof oldBugs.email === "string" && isEmail(oldBugs.email)) {
              data.bugs.email = oldBugs.email;
            } else {
              changes?.push("bugs.email field must be a string email. Deleted.");
            }
          }
        }
        if (!data.bugs.email && !data.bugs.url) {
          delete data.bugs;
          changes?.push("Normalized value of bugs field is an empty object. Deleted.");
        }
      }
      if (typeof data.keywords === "string") {
        data.keywords = data.keywords.split(/,\s+/);
      }
      if (data.keywords && !Array.isArray(data.keywords)) {
        delete data.keywords;
        changes?.push(`keywords should be an array of strings`);
      } else if (data.keywords) {
        data.keywords = data.keywords.filter(function(kw) {
          if (typeof kw !== "string" || !kw) {
            changes?.push(`keywords should be an array of strings`);
            return false;
          } else {
            return true;
          }
        });
      }
      const bdd = "bundledDependencies";
      const bd = "bundleDependencies";
      if (data[bdd] && !data[bd]) {
        data[bd] = data[bdd];
        delete data[bdd];
      }
      if (data[bd] && !Array.isArray(data[bd])) {
        changes?.push(`Invalid 'bundleDependencies' list. Must be array of package names`);
        delete data[bd];
      } else if (data[bd]) {
        data[bd] = data[bd].filter(function(filtered) {
          if (!filtered || typeof filtered !== "string") {
            changes?.push(`Invalid bundleDependencies member: ${filtered}`);
            return false;
          } else {
            if (!data.dependencies) {
              data.dependencies = {};
            }
            if (!Object.prototype.hasOwnProperty.call(data.dependencies, filtered)) {
              changes?.push(`Non-dependency in bundleDependencies: ${filtered}`);
              data.dependencies[filtered] = "*";
            }
            return true;
          }
        });
      }
      if (!data.homepage && data.repository && data.repository.url) {
        const hosted = hostedGitInfo.fromUrl(data.repository.url);
        if (hosted) {
          data.homepage = hosted.docs();
        }
      }
      if (data.homepage) {
        if (typeof data.homepage !== "string") {
          changes?.push("homepage field must be a string url. Deleted.");
          delete data.homepage;
        } else {
          if (!url.parse(data.homepage).protocol) {
            data.homepage = "http://" + data.homepage;
          }
        }
      }
      if (!data.readme) {
        changes?.push("No README data");
        data.readme = "ERROR: No README data found!";
      }
      const license = data.license || data.licence;
      if (!license) {
        changes?.push("No license field.");
      } else if (typeof license !== "string" || license.length < 1 || license.trim() === "") {
        changes?.push("license should be a valid SPDX license expression");
      } else if (!validateLicense(license).validForNewPackages) {
        changes?.push("license should be a valid SPDX license expression");
      }
      if (data.author) {
        data.author = stringifyPerson(data.author);
      }
      ["maintainers", "contributors"].forEach(function(set) {
        if (!Array.isArray(data[set])) {
          return;
        }
        data[set] = data[set].map(stringifyPerson);
      });
      for (const d in typos) {
        if (Object.prototype.hasOwnProperty.call(data, d)) {
          changes?.push(`${d} should probably be ${typos[d]}.`);
        }
      }
    }
    module2.exports = { normalizeData };
  }
});

// node_modules/@npmcli/package-json/lib/normalize.js
var require_normalize = __commonJS({
  "node_modules/@npmcli/package-json/lib/normalize.js"(exports2, module2) {
    var valid = require_valid();
    var clean = require_clean();
    var fs2 = require("node:fs/promises");
    var path = require("node:path");
    var { log } = require_lib4();
    var _hostedGitInfo;
    function lazyHostedGitInfo() {
      if (!_hostedGitInfo) {
        _hostedGitInfo = require_lib5();
      }
      return _hostedGitInfo;
    }
    var _glob;
    function lazyLoadGlob() {
      if (!_glob) {
        _glob = require_commonjs5().glob;
      }
      return _glob;
    }
    function normalizePackageBin(pkg, changes) {
      if (pkg.bin) {
        if (typeof pkg.bin === "string" && pkg.name) {
          changes?.push('"bin" was converted to an object');
          pkg.bin = { [pkg.name]: pkg.bin };
        } else if (Array.isArray(pkg.bin)) {
          changes?.push('"bin" was converted to an object');
          pkg.bin = pkg.bin.reduce((acc, k) => {
            acc[path.basename(k)] = k;
            return acc;
          }, {});
        }
        if (typeof pkg.bin === "object") {
          for (const binKey in pkg.bin) {
            if (typeof pkg.bin[binKey] !== "string") {
              delete pkg.bin[binKey];
              changes?.push(`removed invalid "bin[${binKey}]"`);
              continue;
            }
            const base = path.basename(secureAndUnixifyPath(binKey));
            if (!base) {
              delete pkg.bin[binKey];
              changes?.push(`removed invalid "bin[${binKey}]"`);
              continue;
            }
            const binTarget = secureAndUnixifyPath(pkg.bin[binKey]);
            if (!binTarget) {
              delete pkg.bin[binKey];
              changes?.push(`removed invalid "bin[${binKey}]"`);
              continue;
            }
            if (base !== binKey) {
              delete pkg.bin[binKey];
              changes?.push(`"bin[${binKey}]" was renamed to "bin[${base}]"`);
            }
            if (binTarget !== pkg.bin[binKey]) {
              changes?.push(`"bin[${base}]" script name was cleaned`);
            }
            pkg.bin[base] = binTarget;
          }
          if (Object.keys(pkg.bin).length === 0) {
            changes?.push('empty "bin" was removed');
            delete pkg.bin;
          }
          return pkg;
        }
      }
      delete pkg.bin;
    }
    function normalizePackageMan(pkg, changes) {
      if (pkg.man) {
        const mans = [];
        for (const man of Array.isArray(pkg.man) ? pkg.man : [pkg.man]) {
          if (typeof man !== "string") {
            changes?.push(`removed invalid "man [${man}]"`);
          } else {
            mans.push(secureAndUnixifyPath(man));
          }
        }
        if (!mans.length) {
          changes?.push('empty "man" was removed');
        } else {
          pkg.man = mans;
          return pkg;
        }
      }
      delete pkg.man;
    }
    function isCorrectlyEncodedName(spec) {
      return !spec.match(/[/@\s+%:]/) && spec === encodeURIComponent(spec);
    }
    function isValidScopedPackageName(spec) {
      if (spec.charAt(0) !== "@") {
        return false;
      }
      const rest = spec.slice(1).split("/");
      if (rest.length !== 2) {
        return false;
      }
      return rest[0] && rest[1] && rest[0] === encodeURIComponent(rest[0]) && rest[1] === encodeURIComponent(rest[1]);
    }
    function unixifyPath(ref) {
      return ref.replace(/\\|:/g, "/");
    }
    function secureAndUnixifyPath(ref) {
      const secured = unixifyPath(path.join(".", path.join("/", unixifyPath(ref))));
      return secured.startsWith("./") ? "" : secured;
    }
    var normalize = async (pkg, { strict, steps, root, changes, allowLegacyCase }) => {
      if (!pkg.content) {
        throw new Error("Can not normalize without content");
      }
      const data = pkg.content;
      const scripts = data.scripts || {};
      const pkgId = `${data.name ?? ""}@${data.version ?? ""}`;
      if (steps.includes("fixNameField") || steps.includes("normalizeData")) {
        if (!data.name && !strict) {
          changes?.push('Missing "name" field was set to an empty string');
          data.name = "";
        } else {
          if (typeof data.name !== "string") {
            throw new Error("name field must be a string.");
          }
          if (!strict) {
            const name = data.name.trim();
            if (data.name !== name) {
              changes?.push(`Whitespace was trimmed from "name"`);
              data.name = name;
            }
          }
          if (data.name.startsWith(".") || !(isValidScopedPackageName(data.name) || isCorrectlyEncodedName(data.name)) || strict && !allowLegacyCase && data.name !== data.name.toLowerCase() || data.name.toLowerCase() === "node_modules" || data.name.toLowerCase() === "favicon.ico") {
            throw new Error("Invalid name: " + JSON.stringify(data.name));
          }
        }
      }
      if (steps.includes("fixVersionField") || steps.includes("normalizeData")) {
        const loose = !strict;
        if (!data.version) {
          data.version = "";
        } else {
          if (!valid(data.version, loose)) {
            throw new Error(`Invalid version: "${data.version}"`);
          }
          const version = clean(data.version, loose);
          if (version !== data.version) {
            changes?.push(`"version" was cleaned and set to "${version}"`);
            data.version = version;
          }
        }
      }
      if (steps.includes("_attributes")) {
        for (const key in data) {
          if (key.startsWith("_")) {
            changes?.push(`"${key}" was removed`);
            delete pkg.content[key];
          }
        }
      }
      if (steps.includes("_id")) {
        if (data.name && data.version) {
          changes?.push(`"_id" was set to ${pkgId}`);
          data._id = pkgId;
        }
      }
      if (steps.includes("bundledDependencies")) {
        if (data.bundleDependencies === void 0 && data.bundledDependencies !== void 0) {
          data.bundleDependencies = data.bundledDependencies;
        }
        changes?.push(`Deleted incorrect "bundledDependencies"`);
        delete data.bundledDependencies;
      }
      if (steps.includes("bundleDependencies")) {
        const bd = data.bundleDependencies;
        if (bd === false && !steps.includes("bundleDependenciesDeleteFalse")) {
          changes?.push(`"bundleDependencies" was changed from "false" to "[]"`);
          data.bundleDependencies = [];
        } else if (bd === true) {
          changes?.push(`"bundleDependencies" was auto-populated from "dependencies"`);
          data.bundleDependencies = Object.keys(data.dependencies || {});
        } else if (bd && typeof bd === "object") {
          if (!Array.isArray(bd)) {
            changes?.push(`"bundleDependencies" was changed from an object to an array`);
            data.bundleDependencies = Object.keys(bd);
          }
        } else if ("bundleDependencies" in data) {
          changes?.push(`"bundleDependencies" was removed`);
          delete data.bundleDependencies;
        }
      }
      if (steps.includes("optionalDedupe")) {
        if (data.dependencies && data.optionalDependencies && typeof data.optionalDependencies === "object") {
          for (const name in data.optionalDependencies) {
            changes?.push(`optionalDependencies."${name}" was removed`);
            delete data.dependencies[name];
          }
          if (!Object.keys(data.dependencies).length) {
            changes?.push(`Empty "optionalDependencies" was removed`);
            delete data.dependencies;
          }
        }
      }
      if (steps.includes("gypfile")) {
        if (!scripts.install && !scripts.preinstall && data.gypfile !== false) {
          const files = await lazyLoadGlob()("*.gyp", { cwd: pkg.path });
          if (files.length) {
            scripts.install = "node-gyp rebuild";
            data.scripts = scripts;
            data.gypfile = true;
            changes?.push(`"scripts.install" was set to "node-gyp rebuild"`);
            changes?.push(`"gypfile" was set to "true"`);
          }
        }
      }
      if (steps.includes("serverjs") && !scripts.start) {
        try {
          await fs2.access(path.join(pkg.path, "server.js"));
          scripts.start = "node server.js";
          data.scripts = scripts;
          changes?.push('"scripts.start" was set to "node server.js"');
        } catch {
        }
      }
      if ((steps.includes("scripts") || steps.includes("scriptpath")) && data.scripts !== void 0) {
        const spre = /^(\.[/\\])?node_modules[/\\].bin[\\/]/;
        if (typeof data.scripts === "object") {
          for (const name in data.scripts) {
            if (typeof data.scripts[name] !== "string") {
              delete data.scripts[name];
              changes?.push(`Invalid scripts."${name}" was removed`);
            } else if (steps.includes("scriptpath") && spre.test(data.scripts[name])) {
              data.scripts[name] = data.scripts[name].replace(spre, "");
              changes?.push(`scripts entry "${name}" was fixed to remove node_modules/.bin reference`);
            }
          }
        } else {
          changes?.push(`Removed invalid "scripts"`);
          delete data.scripts;
        }
      }
      if (steps.includes("funding")) {
        if (data.funding && typeof data.funding === "string") {
          data.funding = { url: data.funding };
          changes?.push(`"funding" was changed to an object with a url attribute`);
        }
      }
      if (steps.includes("authors") && !data.contributors) {
        try {
          const authorData = await fs2.readFile(path.join(pkg.path, "AUTHORS"), "utf8");
          const authors = authorData.split(/\r?\n/g).map((line) => line.replace(/^\s*#.*$/, "").trim()).filter((line) => line);
          data.contributors = authors;
          changes?.push('"contributors" was auto-populated with the contents of the "AUTHORS" file');
        } catch {
        }
      }
      if (steps.includes("readme") && !data.readme) {
        const mdre = /\.m?a?r?k?d?o?w?n?$/i;
        const files = await lazyLoadGlob()("{README,README.*}", {
          cwd: pkg.path,
          nocase: true,
          mark: true
        });
        let readmeFile;
        for (const file of files) {
          if (!file.endsWith(path.sep)) {
            if (file.match(mdre)) {
              readmeFile = file;
              break;
            }
            if (file.endsWith("README")) {
              readmeFile = file;
            }
          }
        }
        if (readmeFile) {
          const readmeData = await fs2.readFile(path.join(pkg.path, readmeFile), "utf8");
          data.readme = readmeData;
          data.readmeFilename = readmeFile;
          changes?.push(`"readme" was set to the contents of ${readmeFile}`);
          changes?.push(`"readmeFilename" was set to ${readmeFile}`);
        }
        if (!data.readme) {
          data.readme = "ERROR: No README data found!";
        }
      }
      if (steps.includes("mans")) {
        if (data.directories?.man && !data.man) {
          const manDir = secureAndUnixifyPath(data.directories.man);
          const cwd = path.resolve(pkg.path, manDir);
          const files = await lazyLoadGlob()("**/*.[0-9]", { cwd });
          data.man = files.map(
            (man) => path.relative(pkg.path, path.join(cwd, man)).split(path.sep).join("/")
          );
        }
        normalizePackageMan(data, changes);
      }
      if (steps.includes("bin") || steps.includes("binDir") || steps.includes("binRefs")) {
        normalizePackageBin(data, changes);
      }
      if (steps.includes("binDir") && data.directories?.bin && !data.bin) {
        const binsDir = path.resolve(pkg.path, secureAndUnixifyPath(data.directories.bin));
        const bins = await lazyLoadGlob()("**", { cwd: binsDir });
        data.bin = bins.reduce((acc, binFile) => {
          if (binFile && !binFile.startsWith(".")) {
            const binName = path.basename(binFile);
            acc[binName] = path.join(data.directories.bin, binFile);
          }
          return acc;
        }, {});
        normalizePackageBin(data, changes);
      }
      if (steps.includes("gitHead") && !data.gitHead) {
        const git = require_lib12();
        const gitRoot = await git.find({ cwd: pkg.path, root });
        let head;
        if (gitRoot) {
          try {
            head = await fs2.readFile(path.resolve(gitRoot, ".git/HEAD"), "utf8");
          } catch (err) {
          }
        }
        let headData;
        if (head) {
          if (head.startsWith("ref: ")) {
            const headRef = head.replace(/^ref: /, "").trim();
            const headFile = path.resolve(gitRoot, ".git", headRef);
            try {
              headData = await fs2.readFile(headFile, "utf8");
              headData = headData.replace(/^ref: /, "").trim();
            } catch (err) {
            }
            if (!headData) {
              const packFile = path.resolve(gitRoot, ".git/packed-refs");
              try {
                let refs = await fs2.readFile(packFile, "utf8");
                if (refs) {
                  refs = refs.split("\n");
                  for (let i = 0; i < refs.length; i++) {
                    const match = refs[i].match(/^([0-9a-f]{40}) (.+)$/);
                    if (match && match[2].trim() === headRef) {
                      headData = match[1];
                      break;
                    }
                  }
                }
              } catch {
              }
            }
          } else {
            headData = head.trim();
          }
        }
        if (headData) {
          data.gitHead = headData;
        }
      }
      if (steps.includes("fillTypes")) {
        const index = data.main || "index.js";
        if (typeof index !== "string") {
          throw new TypeError('The "main" attribute must be of type string.');
        }
        const extless = path.join(path.dirname(index), path.basename(index, path.extname(index)));
        const dts = `./${extless}.d.ts`;
        const hasDTSFields = "types" in data || "typings" in data;
        if (!hasDTSFields) {
          try {
            await fs2.access(path.join(pkg.path, dts));
            data.types = dts.split(path.sep).join("/");
          } catch {
          }
        }
      }
      if (steps.includes("fixRepositoryField") || steps.includes("normalizeData")) {
        if (data.repositories) {
          changes?.push(`"repository" was set to the first entry in "repositories" (${data.repository})`);
          data.repository = data.repositories[0];
        }
        if (data.repository) {
          if (typeof data.repository === "string") {
            changes?.push('"repository" was changed from a string to an object');
            data.repository = {
              type: "git",
              url: data.repository
            };
          }
          if (data.repository.url) {
            const hosted = lazyHostedGitInfo().fromUrl(data.repository.url);
            let r;
            if (hosted) {
              if (hosted.getDefaultRepresentation() === "shortcut") {
                r = hosted.https();
              } else {
                r = hosted.toString();
              }
              if (r !== data.repository.url) {
                changes?.push(`"repository.url" was normalized to "${r}"`);
                data.repository.url = r;
              }
            }
          }
        }
      }
      if (steps.includes("fixDependencies") || steps.includes("normalizeData")) {
        for (const type of ["dependencies", "devDependencies", "optionalDependencies"]) {
          if (data[type]) {
            let secondWarning = true;
            if (typeof data[type] === "string") {
              changes?.push(`"${type}" was converted from a string into an object`);
              data[type] = data[type].trim().split(/[\n\r\s\t ,]+/);
              secondWarning = false;
            }
            if (Array.isArray(data[type])) {
              if (secondWarning) {
                changes?.push(`"${type}" was converted from an array into an object`);
              }
              const o = {};
              for (const d of data[type]) {
                if (typeof d === "string") {
                  const dep = d.trim().split(/(:?[@\s><=])/);
                  const dn = dep.shift();
                  const dv = dep.join("").replace(/^@/, "").trim();
                  o[dn] = dv;
                }
              }
              data[type] = o;
            }
          }
        }
        for (const deps of ["dependencies", "devDependencies"]) {
          if (deps in data) {
            if (!data[deps] || typeof data[deps] !== "object") {
              changes?.push(`Removed invalid "${deps}"`);
              delete data[deps];
            } else {
              for (const d in data[deps]) {
                const r = data[deps][d];
                if (typeof r !== "string") {
                  changes?.push(`Removed invalid "${deps}.${d}"`);
                  delete data[deps][d];
                }
                const hosted = lazyHostedGitInfo().fromUrl(data[deps][d])?.toString();
                if (hosted && hosted !== data[deps][d]) {
                  changes?.push(`Normalized git reference to "${deps}.${d}"`);
                  data[deps][d] = hosted.toString();
                }
              }
            }
          }
        }
      }
      if (steps.includes("normalizeData")) {
        const { normalizeData } = require_normalize_data();
        normalizeData(data, changes);
      }
      if (steps.includes("binRefs") && data.bin instanceof Object) {
        for (const key in data.bin) {
          try {
            await fs2.access(path.resolve(pkg.path, data.bin[key]));
          } catch {
            log.warn("package-json", pkgId, `No bin file found at ${data.bin[key]}`);
          }
        }
      }
    };
    module2.exports = normalize;
  }
});

// node_modules/@npmcli/package-json/lib/read-package.js
var require_read_package = __commonJS({
  "node_modules/@npmcli/package-json/lib/read-package.js"(exports2, module2) {
    var { readFile } = require("fs/promises");
    var parseJSON = require_lib3();
    async function read(filename) {
      try {
        const data = await readFile(filename, "utf8");
        return data;
      } catch (err) {
        err.message = `Could not read package.json: ${err}`;
        throw err;
      }
    }
    function parse(data) {
      try {
        const content = parseJSON(data);
        return content;
      } catch (err) {
        err.message = `Invalid package.json: ${err}`;
        throw err;
      }
    }
    async function readPackage(filename) {
      const data = await read(filename);
      const content = parse(data);
      return content;
    }
    module2.exports = {
      read,
      parse,
      readPackage
    };
  }
});

// node_modules/@npmcli/package-json/lib/sort.js
var require_sort2 = __commonJS({
  "node_modules/@npmcli/package-json/lib/sort.js"(exports2, module2) {
    function packageSort(json) {
      const {
        name,
        version,
        private: isPrivate,
        description,
        keywords,
        homepage,
        bugs,
        repository,
        funding,
        license,
        author,
        maintainers,
        contributors,
        type,
        imports,
        exports: exports3,
        main,
        browser,
        types,
        bin,
        man,
        directories,
        files,
        workspaces,
        scripts,
        config,
        dependencies,
        devDependencies,
        peerDependencies,
        peerDependenciesMeta,
        optionalDependencies,
        bundledDependencies,
        bundleDependencies,
        engines,
        os,
        cpu,
        publishConfig,
        devEngines,
        licenses,
        overrides,
        ...rest
      } = json;
      return {
        ...typeof name !== "undefined" ? { name } : {},
        ...typeof version !== "undefined" ? { version } : {},
        ...typeof isPrivate !== "undefined" ? { private: isPrivate } : {},
        ...typeof description !== "undefined" ? { description } : {},
        ...typeof keywords !== "undefined" ? { keywords } : {},
        ...typeof homepage !== "undefined" ? { homepage } : {},
        ...typeof bugs !== "undefined" ? { bugs } : {},
        ...typeof repository !== "undefined" ? { repository } : {},
        ...typeof funding !== "undefined" ? { funding } : {},
        ...typeof license !== "undefined" ? { license } : {},
        ...typeof author !== "undefined" ? { author } : {},
        ...typeof maintainers !== "undefined" ? { maintainers } : {},
        ...typeof contributors !== "undefined" ? { contributors } : {},
        ...typeof type !== "undefined" ? { type } : {},
        ...typeof imports !== "undefined" ? { imports } : {},
        ...typeof exports3 !== "undefined" ? { exports: exports3 } : {},
        ...typeof main !== "undefined" ? { main } : {},
        ...typeof browser !== "undefined" ? { browser } : {},
        ...typeof types !== "undefined" ? { types } : {},
        ...typeof bin !== "undefined" ? { bin } : {},
        ...typeof man !== "undefined" ? { man } : {},
        ...typeof directories !== "undefined" ? { directories } : {},
        ...typeof files !== "undefined" ? { files } : {},
        ...typeof workspaces !== "undefined" ? { workspaces } : {},
        ...typeof scripts !== "undefined" ? { scripts } : {},
        ...typeof config !== "undefined" ? { config } : {},
        ...typeof dependencies !== "undefined" ? { dependencies } : {},
        ...typeof devDependencies !== "undefined" ? { devDependencies } : {},
        ...typeof peerDependencies !== "undefined" ? { peerDependencies } : {},
        ...typeof peerDependenciesMeta !== "undefined" ? { peerDependenciesMeta } : {},
        ...typeof optionalDependencies !== "undefined" ? { optionalDependencies } : {},
        ...typeof bundledDependencies !== "undefined" ? { bundledDependencies } : {},
        ...typeof bundleDependencies !== "undefined" ? { bundleDependencies } : {},
        ...typeof engines !== "undefined" ? { engines } : {},
        ...typeof os !== "undefined" ? { os } : {},
        ...typeof cpu !== "undefined" ? { cpu } : {},
        ...typeof publishConfig !== "undefined" ? { publishConfig } : {},
        ...typeof devEngines !== "undefined" ? { devEngines } : {},
        ...typeof licenses !== "undefined" ? { licenses } : {},
        ...typeof overrides !== "undefined" ? { overrides } : {},
        ...rest
      };
    }
    module2.exports = {
      packageSort
    };
  }
});

// node_modules/@npmcli/package-json/lib/index.js
var require_lib13 = __commonJS({
  "node_modules/@npmcli/package-json/lib/index.js"(exports2, module2) {
    var { readFile, writeFile } = require("node:fs/promises");
    var { resolve } = require("node:path");
    var parseJSON = require_lib3();
    var updateDeps = require_update_dependencies();
    var updateScripts = require_update_scripts();
    var updateWorkspaces = require_update_workspaces();
    var normalize = require_normalize();
    var { read, parse } = require_read_package();
    var { packageSort } = require_sort2();
    var knownSteps = /* @__PURE__ */ new Set([
      updateDeps,
      updateScripts,
      updateWorkspaces
    ]);
    var knownKeys = /* @__PURE__ */ new Set([
      ...updateDeps.knownKeys,
      "scripts",
      "workspaces"
    ]);
    var PackageJson = class _PackageJson {
      static normalizeSteps = Object.freeze([
        "_id",
        "_attributes",
        "bundledDependencies",
        "bundleDependencies",
        "optionalDedupe",
        "scripts",
        "funding",
        "bin"
      ]);
      // npm pkg fix
      static fixSteps = Object.freeze([
        "binRefs",
        "bundleDependencies",
        "bundleDependenciesFalse",
        "fixNameField",
        "fixVersionField",
        "fixRepositoryField",
        "fixDependencies",
        "devDependencies",
        "scriptpath"
      ]);
      static prepareSteps = Object.freeze([
        "_id",
        "_attributes",
        "bundledDependencies",
        "bundleDependencies",
        "bundleDependenciesDeleteFalse",
        "gypfile",
        "serverjs",
        "scriptpath",
        "authors",
        "readme",
        "mans",
        "binDir",
        "gitHead",
        "fillTypes",
        "normalizeData",
        "binRefs"
      ]);
      // create a new empty package.json, so we can save at the given path even
      // though we didn't start from a parsed file
      static async create(path, opts = {}) {
        const p = new _PackageJson();
        await p.create(path);
        if (opts.data) {
          return p.update(opts.data);
        }
        return p;
      }
      // Loads a package.json at given path and JSON parses
      static async load(path, opts = {}) {
        const p = new _PackageJson();
        if (!opts.create) {
          return p.load(path);
        }
        try {
          return await p.load(path);
        } catch (err) {
          if (!err.message.startsWith("Could not read package.json")) {
            throw err;
          }
          return await p.create(path);
        }
      }
      // npm pkg fix
      static async fix(path, opts) {
        const p = new _PackageJson();
        await p.load(path, true);
        return p.fix(opts);
      }
      // read-package-json compatible behavior
      static async prepare(path, opts) {
        const p = new _PackageJson();
        await p.load(path, true);
        return p.prepare(opts);
      }
      // read-package-json-fast compatible behavior
      static async normalize(path, opts) {
        const p = new _PackageJson();
        await p.load(path);
        return p.normalize(opts);
      }
      #path;
      #manifest;
      #readFileContent = "";
      #canSave = true;
      // Load content from given path
      async load(path, parseIndex) {
        this.#path = path;
        let parseErr;
        try {
          this.#readFileContent = await read(this.filename);
        } catch (err) {
          if (!parseIndex) {
            throw err;
          }
          parseErr = err;
        }
        if (parseErr) {
          const indexFile = resolve(this.path, "index.js");
          let indexFileContent;
          try {
            indexFileContent = await readFile(indexFile, "utf8");
          } catch (err) {
            throw parseErr;
          }
          try {
            this.fromComment(indexFileContent);
          } catch (err) {
            throw parseErr;
          }
          this.#canSave = false;
          return this;
        }
        return this.fromJSON(this.#readFileContent);
      }
      // Load data from a JSON string/buffer
      fromJSON(data) {
        this.#manifest = parse(data);
        return this;
      }
      fromContent(data) {
        this.#manifest = data;
        this.#canSave = false;
        return this;
      }
      // Load data from a comment
      // /**package { "name": "foo", "version": "1.2.3", ... } **/
      fromComment(data) {
        data = data.split(/^\/\*\*package(?:\s|$)/m);
        if (data.length < 2) {
          throw new Error("File has no package in comments");
        }
        data = data[1];
        data = data.split(/\*\*\/$/m);
        if (data.length < 2) {
          throw new Error("File has no package in comments");
        }
        data = data[0];
        data = data.replace(/^\s*\*/mg, "");
        this.#manifest = parseJSON(data);
        return this;
      }
      get content() {
        return this.#manifest;
      }
      get path() {
        return this.#path;
      }
      get filename() {
        if (this.path) {
          return resolve(this.path, "package.json");
        }
        return void 0;
      }
      create(path) {
        this.#path = path;
        this.#manifest = {};
        return this;
      }
      // This should be the ONLY way to set content in the manifest
      update(content) {
        if (!this.content) {
          throw new Error("Can not update without content.  Please `load` or `create`");
        }
        for (const step of knownSteps) {
          this.#manifest = step({ content, originalContent: this.content });
        }
        for (const [key, value] of Object.entries(content)) {
          if (!knownKeys.has(key)) {
            this.content[key] = value;
          }
        }
        return this;
      }
      async save({ sort } = {}) {
        if (!this.#canSave) {
          throw new Error("No package.json to save to");
        }
        const {
          [Symbol.for("indent")]: indent,
          [Symbol.for("newline")]: newline,
          ...rest
        } = this.content;
        const format = indent === void 0 ? "  " : indent;
        const eol = newline === void 0 ? "\n" : newline;
        const content = sort ? packageSort(rest) : rest;
        const fileContent = `${JSON.stringify(content, null, format)}
`.replace(/\n/g, eol);
        if (fileContent.trim() !== this.#readFileContent.trim()) {
          const written = await writeFile(this.filename, fileContent);
          this.#readFileContent = fileContent;
          return written;
        }
      }
      async normalize(opts = {}) {
        if (!opts.steps) {
          opts.steps = this.constructor.normalizeSteps;
        }
        await normalize(this, opts);
        return this;
      }
      async prepare(opts = {}) {
        if (!opts.steps) {
          opts.steps = this.constructor.prepareSteps;
        }
        await normalize(this, opts);
        return this;
      }
      async fix(opts = {}) {
        opts.steps = this.constructor.fixSteps;
        await normalize(this, opts);
        return this;
      }
    };
    module2.exports = PackageJson;
  }
});

// node_modules/@npmcli/map-workspaces/lib/index.js
var require_lib14 = __commonJS({
  "node_modules/@npmcli/map-workspaces/lib/index.js"(exports2, module2) {
    var path = require("path");
    var getName = require_lib2();
    var { minimatch } = require_commonjs();
    var pkgJson = require_lib13();
    var { glob } = require_commonjs5();
    function appendNegatedPatterns(allPatterns) {
      const patterns = [];
      const negatedPatterns = [];
      for (let pattern of allPatterns) {
        const excl = pattern.match(/^!+/);
        if (excl) {
          pattern = pattern.slice(excl[0].length);
        }
        pattern = pattern.replace(/^\.?\/+/, "");
        const negate = excl && excl[0].length % 2 === 1;
        if (negate) {
          negatedPatterns.push(pattern);
        } else {
          for (let i = 0; i < negatedPatterns.length; ++i) {
            const negatedPattern = negatedPatterns[i];
            if (minimatch(pattern, negatedPattern)) {
              negatedPatterns.splice(i, 1);
            }
          }
          patterns.push(pattern);
        }
      }
      for (const negated of negatedPatterns) {
        for (const pattern of minimatch.match(patterns, negated)) {
          patterns.splice(patterns.indexOf(pattern), 1);
        }
      }
      return { patterns, negatedPatterns };
    }
    function getPatterns(workspaces) {
      const workspacesDeclaration = Array.isArray(workspaces.packages) ? workspaces.packages : workspaces;
      if (!Array.isArray(workspacesDeclaration)) {
        throw getError({
          message: "workspaces config expects an Array",
          code: "EWORKSPACESCONFIG"
        });
      }
      return appendNegatedPatterns(workspacesDeclaration);
    }
    function getPackageName(pkg, pathname) {
      return pkg.name || getName(pathname);
    }
    function getGlobPattern(pattern) {
      pattern = pattern.replace(/\\/g, "/");
      return pattern.endsWith("/") ? pattern : `${pattern}/`;
    }
    function getError({ Type = TypeError, message, code }) {
      return Object.assign(new Type(message), { code });
    }
    function reverseResultMap(map) {
      return new Map(Array.from(map, (item) => item.reverse()));
    }
    async function mapWorkspaces(opts = {}) {
      if (!opts || !opts.pkg) {
        throw getError({
          message: "mapWorkspaces missing pkg info",
          code: "EMAPWORKSPACESPKG"
        });
      }
      if (!opts.cwd) {
        opts.cwd = process.cwd();
      }
      const { workspaces = [] } = opts.pkg;
      const { patterns, negatedPatterns } = getPatterns(workspaces);
      const results = /* @__PURE__ */ new Map();
      if (!patterns.length && !negatedPatterns.length) {
        return results;
      }
      const seen = /* @__PURE__ */ new Map();
      const getGlobOpts = () => ({
        ...opts,
        ignore: [
          ...opts.ignore || [],
          "**/node_modules/**",
          // just ignore the negated patterns to avoid unnecessary crawling
          ...negatedPatterns
        ]
      });
      let matches = await glob(patterns.map((p) => getGlobPattern(p)), getGlobOpts());
      matches = matches.sort((a, b) => a.localeCompare(b, "en"));
      const orderedMatches = [];
      for (const pattern of patterns) {
        orderedMatches.push(...matches.filter((m) => {
          return minimatch(m, pattern, { partial: true, windowsPathsNoEscape: true });
        }));
      }
      for (const match of orderedMatches) {
        let pkg;
        try {
          pkg = await pkgJson.normalize(path.join(opts.cwd, match));
        } catch (err) {
          if (err.code === "ENOENT" || err.code === "ENOTDIR") {
            continue;
          } else {
            throw err;
          }
        }
        const name = getPackageName(pkg.content, pkg.path);
        let seenPackagePathnames = seen.get(name);
        if (!seenPackagePathnames) {
          seenPackagePathnames = /* @__PURE__ */ new Set();
          seen.set(name, seenPackagePathnames);
        }
        seenPackagePathnames.add(pkg.path);
      }
      const errorMessageArray = ["must not have multiple workspaces with the same name"];
      for (const [packageName, seenPackagePathnames] of seen) {
        if (seenPackagePathnames.size > 1) {
          addDuplicateErrorMessages(errorMessageArray, packageName, seenPackagePathnames);
        } else {
          results.set(packageName, seenPackagePathnames.values().next().value);
        }
      }
      if (errorMessageArray.length > 1) {
        throw getError({
          Type: Error,
          message: errorMessageArray.join("\n"),
          code: "EDUPLICATEWORKSPACE"
        });
      }
      return results;
    }
    function addDuplicateErrorMessages(messageArray, packageName, packagePathnames) {
      messageArray.push(
        `package '${packageName}' has conflicts in the following paths:`
      );
      for (const packagePathname of packagePathnames) {
        messageArray.push(
          "    " + packagePathname
        );
      }
    }
    mapWorkspaces.virtual = function(opts = {}) {
      if (!opts || !opts.lockfile) {
        throw getError({
          message: "mapWorkspaces.virtual missing lockfile info",
          code: "EMAPWORKSPACESLOCKFILE"
        });
      }
      if (!opts.cwd) {
        opts.cwd = process.cwd();
      }
      const { packages = {} } = opts.lockfile;
      const { workspaces = [] } = packages[""] || {};
      const results = /* @__PURE__ */ new Map();
      const { patterns, negatedPatterns } = getPatterns(workspaces);
      if (!patterns.length && !negatedPatterns.length) {
        return results;
      }
      negatedPatterns.push("**/node_modules/**");
      const packageKeys = Object.keys(packages);
      for (const pattern of negatedPatterns) {
        for (const packageKey of minimatch.match(packageKeys, pattern)) {
          packageKeys.splice(packageKeys.indexOf(packageKey), 1);
        }
      }
      for (const pattern of patterns) {
        for (const packageKey of minimatch.match(packageKeys, pattern)) {
          const packagePathname = path.join(opts.cwd, packageKey);
          const name = getPackageName(packages[packageKey], packagePathname);
          results.set(packagePathname, name);
        }
      }
      return reverseResultMap(results);
    };
    module2.exports = mapWorkspaces;
  }
});

// node_modules/@isaacs/string-locale-compare/index.js
var require_string_locale_compare = __commonJS({
  "node_modules/@isaacs/string-locale-compare/index.js"(exports2, module2) {
    var hasIntl = typeof Intl === "object" && !!Intl;
    var Collator = hasIntl && Intl.Collator;
    var cache = /* @__PURE__ */ new Map();
    var collatorCompare = (locale, opts) => {
      const collator = new Collator(locale, opts);
      return (a, b) => collator.compare(a, b);
    };
    var localeCompare = (locale, opts) => (a, b) => a.localeCompare(b, locale, opts);
    var knownOptions = [
      "sensitivity",
      "numeric",
      "ignorePunctuation",
      "caseFirst"
    ];
    var { hasOwnProperty } = Object.prototype;
    module2.exports = (locale, options = {}) => {
      if (!locale || typeof locale !== "string")
        throw new TypeError("locale required");
      const opts = knownOptions.reduce((opts2, k) => {
        if (hasOwnProperty.call(options, k)) {
          opts2[k] = options[k];
        }
        return opts2;
      }, {});
      const key = `${locale}
${JSON.stringify(opts)}`;
      if (cache.has(key))
        return cache.get(key);
      const compare = hasIntl ? collatorCompare(locale, opts) : localeCompare(locale, opts);
      cache.set(key, compare);
      return compare;
    };
  }
});

// node_modules/@npmcli/arborist/lib/add-rm-pkg-deps.js
var require_add_rm_pkg_deps = __commonJS({
  "node_modules/@npmcli/arborist/lib/add-rm-pkg-deps.js"(exports2, module2) {
    var { log } = require_lib4();
    var localeCompare = require_string_locale_compare()("en");
    var add = ({ pkg, add: add2, saveBundle, saveType }) => {
      for (const { name, rawSpec } of add2) {
        let addSaveType = saveType;
        if (!addSaveType) {
          addSaveType = inferSaveType(pkg, name);
        }
        if (addSaveType === "prod") {
          deleteSubKey(pkg, "devDependencies", name, "dependencies");
          deleteSubKey(pkg, "peerDependencies", name, "dependencies");
        } else if (addSaveType === "dev") {
          deleteSubKey(pkg, "dependencies", name, "devDependencies");
        } else if (addSaveType === "optional") {
          deleteSubKey(pkg, "peerDependencies", name, "optionalDependencies");
        } else {
          deleteSubKey(pkg, "dependencies", name, "peerDependencies");
          deleteSubKey(pkg, "optionalDependencies", name, "peerDependencies");
        }
        const depType = saveTypeMap.get(addSaveType);
        pkg[depType] = pkg[depType] || {};
        if (rawSpec !== "*" || pkg[depType][name] === void 0) {
          pkg[depType][name] = rawSpec;
        }
        if (addSaveType === "optional") {
          pkg.dependencies = pkg.dependencies || {};
          pkg.dependencies[name] = pkg.optionalDependencies[name];
        }
        if (addSaveType === "peer" || addSaveType === "peerOptional") {
          const pdm = pkg.peerDependenciesMeta || {};
          if (addSaveType === "peer" && pdm[name] && pdm[name].optional) {
            pdm[name].optional = false;
          } else if (addSaveType === "peerOptional") {
            pdm[name] = pdm[name] || {};
            pdm[name].optional = true;
            pkg.peerDependenciesMeta = pdm;
          }
          if (pkg.devDependencies && pkg.devDependencies[name] !== void 0) {
            pkg.devDependencies[name] = pkg.peerDependencies[name];
          }
        }
        if (saveBundle && addSaveType !== "peer" && addSaveType !== "peerOptional") {
          const bd = new Set(pkg.bundleDependencies || []);
          bd.add(name);
          pkg.bundleDependencies = [...bd].sort(localeCompare);
        }
      }
      return pkg;
    };
    var saveTypeMap = /* @__PURE__ */ new Map([
      ["dev", "devDependencies"],
      ["optional", "optionalDependencies"],
      ["prod", "dependencies"],
      ["peerOptional", "peerDependencies"],
      ["peer", "peerDependencies"]
    ]);
    var inferSaveType = (pkg, name) => {
      for (const saveType of saveTypeMap.keys()) {
        if (hasSubKey(pkg, saveTypeMap.get(saveType), name)) {
          if (saveType === "peerOptional" && (!hasSubKey(pkg, "peerDependenciesMeta", name) || !pkg.peerDependenciesMeta[name].optional)) {
            return "peer";
          }
          return saveType;
        }
      }
      return "prod";
    };
    var hasSubKey = (pkg, depType, name) => {
      return pkg[depType] && Object.prototype.hasOwnProperty.call(pkg[depType], name);
    };
    var deleteSubKey = (pkg, depType, name, replacedBy) => {
      if (hasSubKey(pkg, depType, name)) {
        if (replacedBy) {
          log.warn("idealTree", `Removing ${depType}.${name} in favor of ${replacedBy}.${name}`);
        }
        delete pkg[depType][name];
        if (depType === "peerDependencies" && pkg.peerDependenciesMeta) {
          delete pkg.peerDependenciesMeta[name];
          if (!Object.keys(pkg.peerDependenciesMeta).length) {
            delete pkg.peerDependenciesMeta;
          }
        }
        if (!Object.keys(pkg[depType]).length) {
          delete pkg[depType];
        }
      }
    };
    var rm = (pkg, rm2) => {
      for (const depType of new Set(saveTypeMap.values())) {
        for (const name of rm2) {
          deleteSubKey(pkg, depType, name);
        }
      }
      if (pkg.bundleDependencies) {
        pkg.bundleDependencies = pkg.bundleDependencies.filter((name) => !rm2.includes(name));
        if (!pkg.bundleDependencies.length) {
          delete pkg.bundleDependencies;
        }
      }
      return pkg;
    };
    module2.exports = { add, rm, saveTypeMap, hasSubKey };
  }
});

// node_modules/@npmcli/arborist/lib/vuln.js
var require_vuln = __commonJS({
  "node_modules/@npmcli/arborist/lib/vuln.js"(exports2, module2) {
    var { satisfies, simplifyRange } = require_semver2();
    var semverOpt = { loose: true, includePrerelease: true };
    var localeCompare = require_string_locale_compare()("en");
    var npa = require_npa();
    var severities = /* @__PURE__ */ new Map([
      ["info", 0],
      [0, "info"],
      ["low", 1],
      [1, "low"],
      ["moderate", 2],
      [2, "moderate"],
      ["high", 3],
      [3, "high"],
      ["critical", 4],
      [4, "critical"],
      [null, -1],
      [-1, null]
    ]);
    var Vuln = class {
      #range = null;
      #simpleRange = null;
      // assume a fix is available unless it hits a top node
      // that locks it in place, setting this false or {isSemVerMajor, version}.
      #fixAvailable = true;
      constructor({ name, advisory }) {
        this.name = name;
        this.via = /* @__PURE__ */ new Set();
        this.advisories = /* @__PURE__ */ new Set();
        this.severity = null;
        this.effects = /* @__PURE__ */ new Set();
        this.topNodes = /* @__PURE__ */ new Set();
        this.nodes = /* @__PURE__ */ new Set();
        this.addAdvisory(advisory);
        this.packument = advisory.packument;
        this.versions = advisory.versions;
      }
      get fixAvailable() {
        return this.#fixAvailable;
      }
      set fixAvailable(f) {
        this.#fixAvailable = f;
        for (const v of this.via) {
          if (v.fixAvailable === f) {
            continue;
          }
          if (f === false) {
            v.fixAvailable = f;
          } else if (v.fixAvailable === true) {
            v.fixAvailable = f;
          } else if (typeof f === "object" && (typeof v.fixAvailable !== "object" || !v.fixAvailable.isSemVerMajor)) {
            v.fixAvailable = f;
          }
        }
      }
      get isDirect() {
        for (const node of this.nodes.values()) {
          for (const edge of node.edgesIn) {
            if (edge.from.isProjectRoot || edge.from.isWorkspace) {
              return true;
            }
          }
        }
        return false;
      }
      testSpec(spec) {
        const specObj = npa(spec);
        if (!specObj.registry) {
          return true;
        }
        if (specObj.subSpec) {
          spec = specObj.subSpec.rawSpec;
        }
        for (const v of this.versions) {
          if (satisfies(v, spec) && !satisfies(v, this.range, semverOpt)) {
            return false;
          }
        }
        return true;
      }
      toJSON() {
        return {
          name: this.name,
          severity: this.severity,
          isDirect: this.isDirect,
          // just loop over the advisories, since via is only Vuln objects,
          // and calculated advisories have all the info we need
          via: [...this.advisories].map((v) => v.type === "metavuln" ? v.dependency : {
            ...v,
            versions: void 0,
            vulnerableVersions: void 0,
            id: void 0
          }).sort((a, b) => localeCompare(String(a.source || a), String(b.source || b))),
          effects: [...this.effects].map((v) => v.name).sort(localeCompare),
          range: this.simpleRange,
          nodes: [...this.nodes].map((n) => n.location).sort(localeCompare),
          fixAvailable: this.#fixAvailable
        };
      }
      addVia(v) {
        this.via.add(v);
        v.effects.add(this);
        this.fixAvailable = this.fixAvailable;
      }
      deleteVia(v) {
        this.via.delete(v);
        v.effects.delete(this);
      }
      deleteAdvisory(advisory) {
        this.advisories.delete(advisory);
        this.severity = null;
        this.#range = null;
        this.#simpleRange = null;
        for (const advisory2 of this.advisories) {
          this.addAdvisory(advisory2);
        }
        const vias = new Set([...this.advisories].map((a) => a.dependency));
        for (const via of this.via) {
          if (!vias.has(via.name)) {
            this.deleteVia(via);
          }
        }
      }
      addAdvisory(advisory) {
        this.advisories.add(advisory);
        const sev = severities.get(advisory.severity);
        this.#range = null;
        this.#simpleRange = null;
        if (sev > severities.get(this.severity)) {
          this.severity = advisory.severity;
        }
      }
      get range() {
        if (!this.#range) {
          this.#range = [...this.advisories].map((v) => v.range).join(" || ");
        }
        return this.#range;
      }
      get simpleRange() {
        if (this.#simpleRange && this.#simpleRange === this.#range) {
          return this.#simpleRange;
        }
        const versions = [...this.advisories][0].versions;
        const range = this.range;
        this.#simpleRange = simplifyRange(versions, range, semverOpt);
        this.#range = this.#simpleRange;
        return this.#simpleRange;
      }
      isVulnerable(node) {
        if (this.nodes.has(node)) {
          return true;
        }
        const { version } = node.package;
        if (!version) {
          return false;
        }
        for (const v of this.advisories) {
          if (v.testVersion(version)) {
            this.nodes.add(node);
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Vuln;
  }
});

// node_modules/minipass-collect/index.js
var require_minipass_collect = __commonJS({
  "node_modules/minipass-collect/index.js"(exports2, module2) {
    var { Minipass } = require_commonjs3();
    var _data = Symbol("_data");
    var _length = Symbol("_length");
    var Collect = class extends Minipass {
      constructor(options) {
        super(options);
        this[_data] = [];
        this[_length] = 0;
      }
      write(chunk, encoding, cb) {
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const c = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
        this[_data].push(c);
        this[_length] += c.length;
        if (cb)
          cb();
        return true;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        const result = Buffer.concat(this[_data], this[_length]);
        super.write(result);
        return super.end(cb);
      }
    };
    module2.exports = Collect;
    var CollectPassThrough = class extends Minipass {
      constructor(options) {
        super(options);
        this[_data] = [];
        this[_length] = 0;
      }
      write(chunk, encoding, cb) {
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const c = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
        this[_data].push(c);
        this[_length] += c.length;
        return super.write(chunk, encoding, cb);
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        const result = Buffer.concat(this[_data], this[_length]);
        this.emit("collect", result);
        return super.end(cb);
      }
    };
    module2.exports.PassThrough = CollectPassThrough;
  }
});

// node_modules/minipass-pipeline/node_modules/minipass/index.js
var require_minipass = __commonJS({
  "node_modules/minipass-pipeline/node_modules/minipass/index.js"(exports2, module2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    module2.exports = class Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = [this.buffer.join("")];
          else
            this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer[0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this.pipes.find((p2) => p2.dest === dest);
        if (p) {
          this.pipes.splice(this.pipes.indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          const ret2 = super.emit("error", data);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this.pipes) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this.pipes) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this.pipes) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || // readable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/minipass-pipeline/index.js
var require_minipass_pipeline = __commonJS({
  "node_modules/minipass-pipeline/index.js"(exports2, module2) {
    var Minipass = require_minipass();
    var EE = require("events");
    var isStream = (s) => s && s instanceof EE && (typeof s.pipe === "function" || // readable
    typeof s.write === "function" && typeof s.end === "function");
    var _head = Symbol("_head");
    var _tail = Symbol("_tail");
    var _linkStreams = Symbol("_linkStreams");
    var _setHead = Symbol("_setHead");
    var _setTail = Symbol("_setTail");
    var _onError = Symbol("_onError");
    var _onData = Symbol("_onData");
    var _onEnd = Symbol("_onEnd");
    var _onDrain = Symbol("_onDrain");
    var _streams = Symbol("_streams");
    var Pipeline = class extends Minipass {
      constructor(opts, ...streams) {
        if (isStream(opts)) {
          streams.unshift(opts);
          opts = {};
        }
        super(opts);
        this[_streams] = [];
        if (streams.length)
          this.push(...streams);
      }
      [_linkStreams](streams) {
        return streams.reduce((src, dest) => {
          src.on("error", (er) => dest.emit("error", er));
          src.pipe(dest);
          return dest;
        });
      }
      push(...streams) {
        this[_streams].push(...streams);
        if (this[_tail])
          streams.unshift(this[_tail]);
        const linkRet = this[_linkStreams](streams);
        this[_setTail](linkRet);
        if (!this[_head])
          this[_setHead](streams[0]);
      }
      unshift(...streams) {
        this[_streams].unshift(...streams);
        if (this[_head])
          streams.push(this[_head]);
        const linkRet = this[_linkStreams](streams);
        this[_setHead](streams[0]);
        if (!this[_tail])
          this[_setTail](linkRet);
      }
      destroy(er) {
        this[_streams].forEach((s) => typeof s.destroy === "function" && s.destroy());
        return super.destroy(er);
      }
      // readable interface -> tail
      [_setTail](stream) {
        this[_tail] = stream;
        stream.on("error", (er) => this[_onError](stream, er));
        stream.on("data", (chunk) => this[_onData](stream, chunk));
        stream.on("end", () => this[_onEnd](stream));
        stream.on("finish", () => this[_onEnd](stream));
      }
      // errors proxied down the pipeline
      // they're considered part of the "read" interface
      [_onError](stream, er) {
        if (stream === this[_tail])
          this.emit("error", er);
      }
      [_onData](stream, chunk) {
        if (stream === this[_tail])
          super.write(chunk);
      }
      [_onEnd](stream) {
        if (stream === this[_tail])
          super.end();
      }
      pause() {
        super.pause();
        return this[_tail] && this[_tail].pause && this[_tail].pause();
      }
      // NB: Minipass calls its internal private [RESUME] method during
      // pipe drains, to avoid hazards where stream.resume() is overridden.
      // Thus, we need to listen to the resume *event*, not override the
      // resume() method, and proxy *that* to the tail.
      emit(ev, ...args) {
        if (ev === "resume" && this[_tail] && this[_tail].resume)
          this[_tail].resume();
        return super.emit(ev, ...args);
      }
      // writable interface -> head
      [_setHead](stream) {
        this[_head] = stream;
        stream.on("drain", () => this[_onDrain](stream));
      }
      [_onDrain](stream) {
        if (stream === this[_head])
          this.emit("drain");
      }
      write(chunk, enc, cb) {
        return this[_head].write(chunk, enc, cb) && (this.flowing || this.buffer.length === 0);
      }
      end(chunk, enc, cb) {
        this[_head].end(chunk, enc, cb);
        return this;
      }
    };
    module2.exports = Pipeline;
  }
});

// node_modules/ssri/lib/index.js
var require_lib15 = __commonJS({
  "node_modules/ssri/lib/index.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    var { Minipass } = require_commonjs3();
    var SPEC_ALGORITHMS = ["sha512", "sha384", "sha256"];
    var DEFAULT_ALGORITHMS = ["sha512"];
    var BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;
    var SRI_REGEX = /^([a-z0-9]+)-([^?]+)([?\S*]*)$/;
    var STRICT_SRI_REGEX = /^([a-z0-9]+)-([A-Za-z0-9+/=]{44,88})(\?[\x21-\x7E]*)?$/;
    var VCHAR_REGEX = /^[\x21-\x7E]+$/;
    var getOptString = (options) => options?.length ? `?${options.join("?")}` : "";
    var IntegrityStream = class extends Minipass {
      #emittedIntegrity;
      #emittedSize;
      #emittedVerified;
      constructor(opts) {
        super();
        this.size = 0;
        this.opts = opts;
        this.#getOptions();
        if (opts?.algorithms) {
          this.algorithms = [...opts.algorithms];
        } else {
          this.algorithms = [...DEFAULT_ALGORITHMS];
        }
        if (this.algorithm !== null && !this.algorithms.includes(this.algorithm)) {
          this.algorithms.push(this.algorithm);
        }
        this.hashes = this.algorithms.map(crypto.createHash);
      }
      #getOptions() {
        this.sri = this.opts?.integrity ? parse(this.opts?.integrity, this.opts) : null;
        this.expectedSize = this.opts?.size;
        if (!this.sri) {
          this.algorithm = null;
        } else if (this.sri.isHash) {
          this.goodSri = true;
          this.algorithm = this.sri.algorithm;
        } else {
          this.goodSri = !this.sri.isEmpty();
          this.algorithm = this.sri.pickAlgorithm(this.opts);
        }
        this.digests = this.goodSri ? this.sri[this.algorithm] : null;
        this.optString = getOptString(this.opts?.options);
      }
      on(ev, handler) {
        if (ev === "size" && this.#emittedSize) {
          return handler(this.#emittedSize);
        }
        if (ev === "integrity" && this.#emittedIntegrity) {
          return handler(this.#emittedIntegrity);
        }
        if (ev === "verified" && this.#emittedVerified) {
          return handler(this.#emittedVerified);
        }
        return super.on(ev, handler);
      }
      emit(ev, data) {
        if (ev === "end") {
          this.#onEnd();
        }
        return super.emit(ev, data);
      }
      write(data) {
        this.size += data.length;
        this.hashes.forEach((h) => h.update(data));
        return super.write(data);
      }
      #onEnd() {
        if (!this.goodSri) {
          this.#getOptions();
        }
        const newSri = parse(this.hashes.map((h, i) => {
          return `${this.algorithms[i]}-${h.digest("base64")}${this.optString}`;
        }).join(" "), this.opts);
        const match = this.goodSri && newSri.match(this.sri, this.opts);
        if (typeof this.expectedSize === "number" && this.size !== this.expectedSize) {
          const err = new Error(`stream size mismatch when checking ${this.sri}.
  Wanted: ${this.expectedSize}
  Found: ${this.size}`);
          err.code = "EBADSIZE";
          err.found = this.size;
          err.expected = this.expectedSize;
          err.sri = this.sri;
          this.emit("error", err);
        } else if (this.sri && !match) {
          const err = new Error(`${this.sri} integrity checksum failed when using ${this.algorithm}: wanted ${this.digests} but got ${newSri}. (${this.size} bytes)`);
          err.code = "EINTEGRITY";
          err.found = newSri;
          err.expected = this.digests;
          err.algorithm = this.algorithm;
          err.sri = this.sri;
          this.emit("error", err);
        } else {
          this.#emittedSize = this.size;
          this.emit("size", this.size);
          this.#emittedIntegrity = newSri;
          this.emit("integrity", newSri);
          if (match) {
            this.#emittedVerified = match;
            this.emit("verified", match);
          }
        }
      }
    };
    var Hash = class {
      get isHash() {
        return true;
      }
      constructor(hash, opts) {
        const strict = opts?.strict;
        this.source = hash.trim();
        this.digest = "";
        this.algorithm = "";
        this.options = [];
        const match = this.source.match(
          strict ? STRICT_SRI_REGEX : SRI_REGEX
        );
        if (!match) {
          return;
        }
        if (strict && !SPEC_ALGORITHMS.includes(match[1])) {
          return;
        }
        this.algorithm = match[1];
        this.digest = match[2];
        const rawOpts = match[3];
        if (rawOpts) {
          this.options = rawOpts.slice(1).split("?");
        }
      }
      hexDigest() {
        return this.digest && Buffer.from(this.digest, "base64").toString("hex");
      }
      toJSON() {
        return this.toString();
      }
      match(integrity, opts) {
        const other = parse(integrity, opts);
        if (!other) {
          return false;
        }
        if (other.isIntegrity) {
          const algo = other.pickAlgorithm(opts, [this.algorithm]);
          if (!algo) {
            return false;
          }
          const foundHash = other[algo].find((hash) => hash.digest === this.digest);
          if (foundHash) {
            return foundHash;
          }
          return false;
        }
        return other.digest === this.digest ? other : false;
      }
      toString(opts) {
        if (opts?.strict) {
          if (!// The spec has very restricted productions for algorithms.
          // https://www.w3.org/TR/CSP2/#source-list-syntax
          (SPEC_ALGORITHMS.includes(this.algorithm) && // Usually, if someone insists on using a "different" base64, we
          // leave it as-is, since there's multiple standards, and the
          // specified is not a URL-safe variant.
          // https://www.w3.org/TR/CSP2/#base64_value
          this.digest.match(BASE64_REGEX) && // Option syntax is strictly visual chars.
          // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression
          // https://tools.ietf.org/html/rfc5234#appendix-B.1
          this.options.every((opt) => opt.match(VCHAR_REGEX)))) {
            return "";
          }
        }
        return `${this.algorithm}-${this.digest}${getOptString(this.options)}`;
      }
    };
    function integrityHashToString(toString, sep, opts, hashes) {
      const toStringIsNotEmpty = toString !== "";
      let shouldAddFirstSep = false;
      let complement = "";
      const lastIndex = hashes.length - 1;
      for (let i = 0; i < lastIndex; i++) {
        const hashString = Hash.prototype.toString.call(hashes[i], opts);
        if (hashString) {
          shouldAddFirstSep = true;
          complement += hashString;
          complement += sep;
        }
      }
      const finalHashString = Hash.prototype.toString.call(hashes[lastIndex], opts);
      if (finalHashString) {
        shouldAddFirstSep = true;
        complement += finalHashString;
      }
      if (toStringIsNotEmpty && shouldAddFirstSep) {
        return toString + sep + complement;
      }
      return toString + complement;
    }
    var Integrity = class {
      get isIntegrity() {
        return true;
      }
      toJSON() {
        return this.toString();
      }
      isEmpty() {
        return Object.keys(this).length === 0;
      }
      toString(opts) {
        let sep = opts?.sep || " ";
        let toString = "";
        if (opts?.strict) {
          sep = sep.replace(/\S+/g, " ");
          for (const hash of SPEC_ALGORITHMS) {
            if (this[hash]) {
              toString = integrityHashToString(toString, sep, opts, this[hash]);
            }
          }
        } else {
          for (const hash of Object.keys(this)) {
            toString = integrityHashToString(toString, sep, opts, this[hash]);
          }
        }
        return toString;
      }
      concat(integrity, opts) {
        const other = typeof integrity === "string" ? integrity : stringify(integrity, opts);
        return parse(`${this.toString(opts)} ${other}`, opts);
      }
      hexDigest() {
        return parse(this, { single: true }).hexDigest();
      }
      // add additional hashes to an integrity value, but prevent
      // *changing* an existing integrity hash.
      merge(integrity, opts) {
        const other = parse(integrity, opts);
        for (const algo in other) {
          if (this[algo]) {
            if (!this[algo].find((hash) => other[algo].find((otherhash) => hash.digest === otherhash.digest))) {
              throw new Error("hashes do not match, cannot update integrity");
            }
          } else {
            this[algo] = other[algo];
          }
        }
      }
      match(integrity, opts) {
        const other = parse(integrity, opts);
        if (!other) {
          return false;
        }
        const algo = other.pickAlgorithm(opts, Object.keys(this));
        return !!algo && this[algo] && other[algo] && this[algo].find(
          (hash) => other[algo].find(
            (otherhash) => hash.digest === otherhash.digest
          )
        ) || false;
      }
      // Pick the highest priority algorithm present, optionally also limited to a
      // set of hashes found in another integrity.  When limiting it may return
      // nothing.
      pickAlgorithm(opts, hashes) {
        const pickAlgorithm = opts?.pickAlgorithm || getPrioritizedHash;
        const keys = Object.keys(this).filter((k) => {
          if (hashes?.length) {
            return hashes.includes(k);
          }
          return true;
        });
        if (keys.length) {
          return keys.reduce((acc, algo) => pickAlgorithm(acc, algo) || acc);
        }
        return null;
      }
    };
    module2.exports.parse = parse;
    function parse(sri, opts) {
      if (!sri) {
        return null;
      }
      if (typeof sri === "string") {
        return _parse(sri, opts);
      } else if (sri.algorithm && sri.digest) {
        const fullSri = new Integrity();
        fullSri[sri.algorithm] = [sri];
        return _parse(stringify(fullSri, opts), opts);
      } else {
        return _parse(stringify(sri, opts), opts);
      }
    }
    function _parse(integrity, opts) {
      if (opts?.single) {
        return new Hash(integrity, opts);
      }
      const hashes = integrity.trim().split(/\s+/).reduce((acc, string) => {
        const hash = new Hash(string, opts);
        if (hash.algorithm && hash.digest) {
          const algo = hash.algorithm;
          if (!acc[algo]) {
            acc[algo] = [];
          }
          acc[algo].push(hash);
        }
        return acc;
      }, new Integrity());
      return hashes.isEmpty() ? null : hashes;
    }
    module2.exports.stringify = stringify;
    function stringify(obj, opts) {
      if (obj.algorithm && obj.digest) {
        return Hash.prototype.toString.call(obj, opts);
      } else if (typeof obj === "string") {
        return stringify(parse(obj, opts), opts);
      } else {
        return Integrity.prototype.toString.call(obj, opts);
      }
    }
    module2.exports.fromHex = fromHex;
    function fromHex(hexDigest, algorithm, opts) {
      const optString = getOptString(opts?.options);
      return parse(
        `${algorithm}-${Buffer.from(hexDigest, "hex").toString("base64")}${optString}`,
        opts
      );
    }
    module2.exports.fromData = fromData;
    function fromData(data, opts) {
      const algorithms = opts?.algorithms || [...DEFAULT_ALGORITHMS];
      const optString = getOptString(opts?.options);
      return algorithms.reduce((acc, algo) => {
        const digest = crypto.createHash(algo).update(data).digest("base64");
        const hash = new Hash(
          `${algo}-${digest}${optString}`,
          opts
        );
        if (hash.algorithm && hash.digest) {
          const hashAlgo = hash.algorithm;
          if (!acc[hashAlgo]) {
            acc[hashAlgo] = [];
          }
          acc[hashAlgo].push(hash);
        }
        return acc;
      }, new Integrity());
    }
    module2.exports.fromStream = fromStream;
    function fromStream(stream, opts) {
      const istream = integrityStream(opts);
      return new Promise((resolve, reject) => {
        stream.pipe(istream);
        stream.on("error", reject);
        istream.on("error", reject);
        let sri;
        istream.on("integrity", (s) => {
          sri = s;
        });
        istream.on("end", () => resolve(sri));
        istream.resume();
      });
    }
    module2.exports.checkData = checkData;
    function checkData(data, sri, opts) {
      sri = parse(sri, opts);
      if (!sri || !Object.keys(sri).length) {
        if (opts?.error) {
          throw Object.assign(
            new Error("No valid integrity hashes to check against"),
            {
              code: "EINTEGRITY"
            }
          );
        } else {
          return false;
        }
      }
      const algorithm = sri.pickAlgorithm(opts);
      const digest = crypto.createHash(algorithm).update(data).digest("base64");
      const newSri = parse({ algorithm, digest });
      const match = newSri.match(sri, opts);
      opts = opts || {};
      if (match || !opts.error) {
        return match;
      } else if (typeof opts.size === "number" && data.length !== opts.size) {
        const err = new Error(`data size mismatch when checking ${sri}.
  Wanted: ${opts.size}
  Found: ${data.length}`);
        err.code = "EBADSIZE";
        err.found = data.length;
        err.expected = opts.size;
        err.sri = sri;
        throw err;
      } else {
        const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`);
        err.code = "EINTEGRITY";
        err.found = newSri;
        err.expected = sri;
        err.algorithm = algorithm;
        err.sri = sri;
        throw err;
      }
    }
    module2.exports.checkStream = checkStream;
    function checkStream(stream, sri, opts) {
      opts = opts || /* @__PURE__ */ Object.create(null);
      opts.integrity = sri;
      sri = parse(sri, opts);
      if (!sri || !Object.keys(sri).length) {
        return Promise.reject(Object.assign(
          new Error("No valid integrity hashes to check against"),
          {
            code: "EINTEGRITY"
          }
        ));
      }
      const checker = integrityStream(opts);
      return new Promise((resolve, reject) => {
        stream.pipe(checker);
        stream.on("error", reject);
        checker.on("error", reject);
        let verified;
        checker.on("verified", (s) => {
          verified = s;
        });
        checker.on("end", () => resolve(verified));
        checker.resume();
      });
    }
    module2.exports.integrityStream = integrityStream;
    function integrityStream(opts = /* @__PURE__ */ Object.create(null)) {
      return new IntegrityStream(opts);
    }
    module2.exports.create = createIntegrity;
    function createIntegrity(opts) {
      const algorithms = opts?.algorithms || [...DEFAULT_ALGORITHMS];
      const optString = getOptString(opts?.options);
      const hashes = algorithms.map(crypto.createHash);
      return {
        update: function(chunk, enc) {
          hashes.forEach((h) => h.update(chunk, enc));
          return this;
        },
        digest: function() {
          const integrity = algorithms.reduce((acc, algo) => {
            const digest = hashes.shift().digest("base64");
            const hash = new Hash(
              `${algo}-${digest}${optString}`,
              opts
            );
            if (hash.algorithm && hash.digest) {
              const hashAlgo = hash.algorithm;
              if (!acc[hashAlgo]) {
                acc[hashAlgo] = [];
              }
              acc[hashAlgo].push(hash);
            }
            return acc;
          }, new Integrity());
          return integrity;
        }
      };
    }
    var NODE_HASHES = crypto.getHashes();
    var DEFAULT_PRIORITY = [
      "md5",
      "whirlpool",
      "sha1",
      "sha224",
      "sha256",
      "sha384",
      "sha512",
      // TODO - it's unclear _which_ of these Node will actually use as its name
      //        for the algorithm, so we guesswork it based on the OpenSSL names.
      "sha3",
      "sha3-256",
      "sha3-384",
      "sha3-512",
      "sha3_256",
      "sha3_384",
      "sha3_512"
    ].filter((algo) => NODE_HASHES.includes(algo));
    function getPrioritizedHash(algo1, algo2) {
      return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;
    }
  }
});

// node_modules/imurmurhash/imurmurhash.js
var require_imurmurhash = __commonJS({
  "node_modules/imurmurhash/imurmurhash.js"(exports2, module2) {
    (function() {
      var cache;
      function MurmurHash3(key, seed) {
        var m = this instanceof MurmurHash3 ? this : cache;
        m.reset(seed);
        if (typeof key === "string" && key.length > 0) {
          m.hash(key);
        }
        if (m !== this) {
          return m;
        }
      }
      ;
      MurmurHash3.prototype.hash = function(key) {
        var h1, k1, i, top, len;
        len = key.length;
        this.len += len;
        k1 = this.k1;
        i = 0;
        switch (this.rem) {
          case 0:
            k1 ^= len > i ? key.charCodeAt(i++) & 65535 : 0;
          case 1:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 8 : 0;
          case 2:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 16 : 0;
          case 3:
            k1 ^= len > i ? (key.charCodeAt(i) & 255) << 24 : 0;
            k1 ^= len > i ? (key.charCodeAt(i++) & 65280) >> 8 : 0;
        }
        this.rem = len + this.rem & 3;
        len -= this.rem;
        if (len > 0) {
          h1 = this.h1;
          while (1) {
            k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
            h1 ^= k1;
            h1 = h1 << 13 | h1 >>> 19;
            h1 = h1 * 5 + 3864292196 & 4294967295;
            if (i >= len) {
              break;
            }
            k1 = key.charCodeAt(i++) & 65535 ^ (key.charCodeAt(i++) & 65535) << 8 ^ (key.charCodeAt(i++) & 65535) << 16;
            top = key.charCodeAt(i++);
            k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
          }
          k1 = 0;
          switch (this.rem) {
            case 3:
              k1 ^= (key.charCodeAt(i + 2) & 65535) << 16;
            case 2:
              k1 ^= (key.charCodeAt(i + 1) & 65535) << 8;
            case 1:
              k1 ^= key.charCodeAt(i) & 65535;
          }
          this.h1 = h1;
        }
        this.k1 = k1;
        return this;
      };
      MurmurHash3.prototype.result = function() {
        var k1, h1;
        k1 = this.k1;
        h1 = this.h1;
        if (k1 > 0) {
          k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
          h1 ^= k1;
        }
        h1 ^= this.len;
        h1 ^= h1 >>> 16;
        h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295;
        h1 ^= h1 >>> 13;
        h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295;
        h1 ^= h1 >>> 16;
        return h1 >>> 0;
      };
      MurmurHash3.prototype.reset = function(seed) {
        this.h1 = typeof seed === "number" ? seed : 0;
        this.rem = this.k1 = this.len = 0;
        return this;
      };
      cache = new MurmurHash3();
      if (typeof module2 != "undefined") {
        module2.exports = MurmurHash3;
      } else {
        this.MurmurHash3 = MurmurHash3;
      }
    })();
  }
});

// node_modules/unique-slug/lib/index.js
var require_lib16 = __commonJS({
  "node_modules/unique-slug/lib/index.js"(exports2, module2) {
    "use strict";
    var MurmurHash3 = require_imurmurhash();
    module2.exports = function(uniq) {
      if (uniq) {
        var hash = new MurmurHash3(uniq);
        return ("00000000" + hash.result().toString(16)).slice(-8);
      } else {
        return (Math.random().toString(16) + "0000000").slice(2, 10);
      }
    };
  }
});

// node_modules/unique-filename/lib/index.js
var require_lib17 = __commonJS({
  "node_modules/unique-filename/lib/index.js"(exports2, module2) {
    var path = require("path");
    var uniqueSlug = require_lib16();
    module2.exports = function(filepath, prefix, uniq) {
      return path.join(filepath, (prefix ? prefix + "-" : "") + uniqueSlug(uniq));
    };
  }
});

// node_modules/cacache/package.json
var require_package = __commonJS({
  "node_modules/cacache/package.json"(exports2, module2) {
    module2.exports = {
      name: "cacache",
      version: "19.0.1",
      "cache-version": {
        content: "2",
        index: "5"
      },
      description: "Fast, fault-tolerant, cross-platform, disk-based, data-agnostic, content-addressable cache.",
      main: "lib/index.js",
      files: [
        "bin/",
        "lib/"
      ],
      scripts: {
        test: "tap",
        snap: "tap",
        coverage: "tap",
        "test-docker": 'docker run -it --rm --name pacotest -v "$PWD":/tmp -w /tmp node:latest npm test',
        lint: "npm run eslint",
        npmclilint: "npmcli-lint",
        lintfix: "npm run eslint -- --fix",
        postsnap: "npm run lintfix --",
        postlint: "template-oss-check",
        posttest: "npm run lint",
        "template-oss-apply": "template-oss-apply --force",
        eslint: 'eslint "**/*.{js,cjs,ts,mjs,jsx,tsx}"'
      },
      repository: {
        type: "git",
        url: "git+https://github.com/npm/cacache.git"
      },
      keywords: [
        "cache",
        "caching",
        "content-addressable",
        "sri",
        "sri hash",
        "subresource integrity",
        "cache",
        "storage",
        "store",
        "file store",
        "filesystem",
        "disk cache",
        "disk storage"
      ],
      license: "ISC",
      dependencies: {
        "@npmcli/fs": "^4.0.0",
        "fs-minipass": "^3.0.0",
        glob: "^10.2.2",
        "lru-cache": "^10.0.1",
        minipass: "^7.0.3",
        "minipass-collect": "^2.0.1",
        "minipass-flush": "^1.0.5",
        "minipass-pipeline": "^1.2.4",
        "p-map": "^7.0.2",
        ssri: "^12.0.0",
        tar: "^7.4.3",
        "unique-filename": "^4.0.0"
      },
      devDependencies: {
        "@npmcli/eslint-config": "^5.0.0",
        "@npmcli/template-oss": "4.23.3",
        tap: "^16.0.0"
      },
      engines: {
        node: "^18.17.0 || >=20.5.0"
      },
      templateOSS: {
        "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
        windowsCI: false,
        version: "4.23.3",
        publish: "true"
      },
      author: "GitHub Inc.",
      tap: {
        "nyc-arg": [
          "--exclude",
          "tap-snapshots/**"
        ]
      }
    };
  }
});

// node_modules/cacache/lib/util/hash-to-segments.js
var require_hash_to_segments = __commonJS({
  "node_modules/cacache/lib/util/hash-to-segments.js"(exports2, module2) {
    "use strict";
    module2.exports = hashToSegments;
    function hashToSegments(hash) {
      return [hash.slice(0, 2), hash.slice(2, 4), hash.slice(4)];
    }
  }
});

// node_modules/cacache/lib/content/path.js
var require_path = __commonJS({
  "node_modules/cacache/lib/content/path.js"(exports2, module2) {
    "use strict";
    var contentVer = require_package()["cache-version"].content;
    var hashToSegments = require_hash_to_segments();
    var path = require("path");
    var ssri = require_lib15();
    module2.exports = contentPath;
    function contentPath(cache, integrity) {
      const sri = ssri.parse(integrity, { single: true });
      return path.join(
        contentDir(cache),
        sri.algorithm,
        ...hashToSegments(sri.hexDigest())
      );
    }
    module2.exports.contentDir = contentDir;
    function contentDir(cache) {
      return path.join(cache, `content-v${contentVer}`);
    }
  }
});

// node_modules/@npmcli/fs/lib/common/get-options.js
var require_get_options = __commonJS({
  "node_modules/@npmcli/fs/lib/common/get-options.js"(exports2, module2) {
    var getOptions = (input, { copy, wrap }) => {
      const result = {};
      if (input && typeof input === "object") {
        for (const prop of copy) {
          if (input[prop] !== void 0) {
            result[prop] = input[prop];
          }
        }
      } else {
        result[wrap] = input;
      }
      return result;
    };
    module2.exports = getOptions;
  }
});

// node_modules/@npmcli/fs/lib/common/node.js
var require_node = __commonJS({
  "node_modules/@npmcli/fs/lib/common/node.js"(exports2, module2) {
    var semver = require_semver2();
    var satisfies = (range) => {
      return semver.satisfies(process.version, range, { includePrerelease: true });
    };
    module2.exports = {
      satisfies
    };
  }
});

// node_modules/@npmcli/fs/lib/cp/errors.js
var require_errors2 = __commonJS({
  "node_modules/@npmcli/fs/lib/cp/errors.js"(exports2, module2) {
    "use strict";
    var { inspect } = require("util");
    var SystemError = class {
      constructor(code, prefix, context) {
        let message = `${prefix}: ${context.syscall} returned ${context.code} (${context.message})`;
        if (context.path !== void 0) {
          message += ` ${context.path}`;
        }
        if (context.dest !== void 0) {
          message += ` => ${context.dest}`;
        }
        this.code = code;
        Object.defineProperties(this, {
          name: {
            value: "SystemError",
            enumerable: false,
            writable: true,
            configurable: true
          },
          message: {
            value: message,
            enumerable: false,
            writable: true,
            configurable: true
          },
          info: {
            value: context,
            enumerable: true,
            configurable: true,
            writable: false
          },
          errno: {
            get() {
              return context.errno;
            },
            set(value) {
              context.errno = value;
            },
            enumerable: true,
            configurable: true
          },
          syscall: {
            get() {
              return context.syscall;
            },
            set(value) {
              context.syscall = value;
            },
            enumerable: true,
            configurable: true
          }
        });
        if (context.path !== void 0) {
          Object.defineProperty(this, "path", {
            get() {
              return context.path;
            },
            set(value) {
              context.path = value;
            },
            enumerable: true,
            configurable: true
          });
        }
        if (context.dest !== void 0) {
          Object.defineProperty(this, "dest", {
            get() {
              return context.dest;
            },
            set(value) {
              context.dest = value;
            },
            enumerable: true,
            configurable: true
          });
        }
      }
      toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
      }
      [Symbol.for("nodejs.util.inspect.custom")](_recurseTimes, ctx) {
        return inspect(this, {
          ...ctx,
          getters: true,
          customInspect: false
        });
      }
    };
    function E(code, message) {
      module2.exports[code] = class NodeError extends SystemError {
        constructor(ctx) {
          super(code, message, ctx);
        }
      };
    }
    E("ERR_FS_CP_DIR_TO_NON_DIR", "Cannot overwrite directory with non-directory");
    E("ERR_FS_CP_EEXIST", "Target already exists");
    E("ERR_FS_CP_EINVAL", "Invalid src or dest");
    E("ERR_FS_CP_FIFO_PIPE", "Cannot copy a FIFO pipe");
    E("ERR_FS_CP_NON_DIR_TO_DIR", "Cannot overwrite non-directory with directory");
    E("ERR_FS_CP_SOCKET", "Cannot copy a socket file");
    E("ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY", "Cannot overwrite symlink in subdirectory of self");
    E("ERR_FS_CP_UNKNOWN", "Cannot copy an unknown file type");
    E("ERR_FS_EISDIR", "Path is a directory");
    module2.exports.ERR_INVALID_ARG_TYPE = class ERR_INVALID_ARG_TYPE extends Error {
      constructor(name, expected, actual) {
        super();
        this.code = "ERR_INVALID_ARG_TYPE";
        this.message = `The ${name} argument must be ${expected}. Received ${typeof actual}`;
      }
    };
  }
});

// node_modules/@npmcli/fs/lib/cp/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/@npmcli/fs/lib/cp/polyfill.js"(exports2, module2) {
    "use strict";
    var {
      ERR_FS_CP_DIR_TO_NON_DIR,
      ERR_FS_CP_EEXIST,
      ERR_FS_CP_EINVAL,
      ERR_FS_CP_FIFO_PIPE,
      ERR_FS_CP_NON_DIR_TO_DIR,
      ERR_FS_CP_SOCKET,
      ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,
      ERR_FS_CP_UNKNOWN,
      ERR_FS_EISDIR,
      ERR_INVALID_ARG_TYPE
    } = require_errors2();
    var {
      constants: {
        errno: {
          EEXIST,
          EISDIR,
          EINVAL,
          ENOTDIR
        }
      }
    } = require("os");
    var {
      chmod,
      copyFile,
      lstat,
      mkdir,
      readdir,
      readlink,
      stat,
      symlink,
      unlink,
      utimes
    } = require("fs/promises");
    var {
      dirname,
      isAbsolute,
      join,
      parse,
      resolve,
      sep,
      toNamespacedPath
    } = require("path");
    var { fileURLToPath } = require("url");
    var defaultOptions = {
      dereference: false,
      errorOnExist: false,
      filter: void 0,
      force: true,
      preserveTimestamps: false,
      recursive: false
    };
    async function cp(src, dest, opts) {
      if (opts != null && typeof opts !== "object") {
        throw new ERR_INVALID_ARG_TYPE("options", ["Object"], opts);
      }
      return cpFn(
        toNamespacedPath(getValidatedPath(src)),
        toNamespacedPath(getValidatedPath(dest)),
        { ...defaultOptions, ...opts }
      );
    }
    function getValidatedPath(fileURLOrPath) {
      const path = fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin ? fileURLToPath(fileURLOrPath) : fileURLOrPath;
      return path;
    }
    async function cpFn(src, dest, opts) {
      if (opts.preserveTimestamps && process.arch === "ia32") {
        const warning = "Using the preserveTimestamps option in 32-bit node is not recommended";
        process.emitWarning(warning, "TimestampPrecisionWarning");
      }
      const stats = await checkPaths(src, dest, opts);
      const { srcStat, destStat } = stats;
      await checkParentPaths(src, srcStat, dest);
      if (opts.filter) {
        return handleFilter(checkParentDir, destStat, src, dest, opts);
      }
      return checkParentDir(destStat, src, dest, opts);
    }
    async function checkPaths(src, dest, opts) {
      const { 0: srcStat, 1: destStat } = await getStats(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          throw new ERR_FS_CP_EINVAL({
            message: "src and dest cannot be the same",
            path: dest,
            syscall: "cp",
            errno: EINVAL
          });
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new ERR_FS_CP_DIR_TO_NON_DIR({
            message: `cannot overwrite directory ${src} with non-directory ${dest}`,
            path: dest,
            syscall: "cp",
            errno: EISDIR
          });
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new ERR_FS_CP_NON_DIR_TO_DIR({
            message: `cannot overwrite non-directory ${src} with directory ${dest}`,
            path: dest,
            syscall: "cp",
            errno: ENOTDIR
          });
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new ERR_FS_CP_EINVAL({
          message: `cannot copy ${src} to a subdirectory of self ${dest}`,
          path: dest,
          syscall: "cp",
          errno: EINVAL
        });
      }
      return { srcStat, destStat };
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => stat(file, { bigint: true }) : (file) => lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT") {
            return null;
          }
          throw err;
        })
      ]);
    }
    async function checkParentDir(destStat, src, dest, opts) {
      const destParent = dirname(dest);
      const dirExists = await pathExists(destParent);
      if (dirExists) {
        return getStatsForCopy(destStat, src, dest, opts);
      }
      await mkdir(destParent, { recursive: true });
      return getStatsForCopy(destStat, src, dest, opts);
    }
    function pathExists(dest) {
      return stat(dest).then(
        () => true,
        // istanbul ignore next: not sure when this would occur
        (err) => err.code === "ENOENT" ? false : Promise.reject(err)
      );
    }
    async function checkParentPaths(src, srcStat, dest) {
      const srcParent = resolve(dirname(src));
      const destParent = resolve(dirname(dest));
      if (destParent === srcParent || destParent === parse(destParent).root) {
        return;
      }
      let destStat;
      try {
        destStat = await stat(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT") {
          return;
        }
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new ERR_FS_CP_EINVAL({
          message: `cannot copy ${src} to a subdirectory of self ${dest}`,
          path: dest,
          syscall: "cp",
          errno: EINVAL
        });
      }
      return checkParentPaths(src, srcStat, destParent);
    }
    var normalizePathToArray = (path) => resolve(path).split(sep).filter(Boolean);
    function isSrcSubdir(src, dest) {
      const srcArr = normalizePathToArray(src);
      const destArr = normalizePathToArray(dest);
      return srcArr.every((cur, i) => destArr[i] === cur);
    }
    async function handleFilter(onInclude, destStat, src, dest, opts, cb) {
      const include = await opts.filter(src, dest);
      if (include) {
        return onInclude(destStat, src, dest, opts, cb);
      }
    }
    function startCopy(destStat, src, dest, opts) {
      if (opts.filter) {
        return handleFilter(getStatsForCopy, destStat, src, dest, opts);
      }
      return getStatsForCopy(destStat, src, dest, opts);
    }
    async function getStatsForCopy(destStat, src, dest, opts) {
      const statFn = opts.dereference ? stat : lstat;
      const srcStat = await statFn(src);
      if (srcStat.isDirectory() && opts.recursive) {
        return onDir(srcStat, destStat, src, dest, opts);
      } else if (srcStat.isDirectory()) {
        throw new ERR_FS_EISDIR({
          message: `${src} is a directory (not copied)`,
          path: src,
          syscall: "cp",
          errno: EINVAL
        });
      } else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) {
        return onFile(srcStat, destStat, src, dest, opts);
      } else if (srcStat.isSymbolicLink()) {
        return onLink(destStat, src, dest);
      } else if (srcStat.isSocket()) {
        throw new ERR_FS_CP_SOCKET({
          message: `cannot copy a socket file: ${dest}`,
          path: dest,
          syscall: "cp",
          errno: EINVAL
        });
      } else if (srcStat.isFIFO()) {
        throw new ERR_FS_CP_FIFO_PIPE({
          message: `cannot copy a FIFO pipe: ${dest}`,
          path: dest,
          syscall: "cp",
          errno: EINVAL
        });
      }
      throw new ERR_FS_CP_UNKNOWN({
        message: `cannot copy an unknown file type: ${dest}`,
        path: dest,
        syscall: "cp",
        errno: EINVAL
      });
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) {
        return _copyFile(srcStat, src, dest, opts);
      }
      return mayCopyFile(srcStat, src, dest, opts);
    }
    async function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.force) {
        await unlink(dest);
        return _copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new ERR_FS_CP_EEXIST({
          message: `${dest} already exists`,
          path: dest,
          syscall: "cp",
          errno: EEXIST
        });
      }
    }
    async function _copyFile(srcStat, src, dest, opts) {
      await copyFile(src, dest);
      if (opts.preserveTimestamps) {
        return handleTimestampsAndMode(srcStat.mode, src, dest);
      }
      return setDestMode(dest, srcStat.mode);
    }
    async function handleTimestampsAndMode(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode)) {
        await makeFileWritable(dest, srcMode);
        return setDestTimestampsAndMode(srcMode, src, dest);
      }
      return setDestTimestampsAndMode(srcMode, src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    async function setDestTimestampsAndMode(srcMode, src, dest) {
      await setDestTimestamps(src, dest);
      return setDestMode(dest, srcMode);
    }
    function setDestMode(dest, srcMode) {
      return chmod(dest, srcMode);
    }
    async function setDestTimestamps(src, dest) {
      const updatedSrcStat = await stat(src);
      return utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) {
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      }
      return copyDir(src, dest, opts);
    }
    async function mkDirAndCopy(srcMode, src, dest, opts) {
      await mkdir(dest);
      await copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    async function copyDir(src, dest, opts) {
      const dir = await readdir(src);
      for (let i = 0; i < dir.length; i++) {
        const item = dir[i];
        const srcItem = join(src, item);
        const destItem = join(dest, item);
        const { destStat } = await checkPaths(srcItem, destItem, opts);
        await startCopy(destStat, srcItem, destItem, opts);
      }
    }
    async function onLink(destStat, src, dest) {
      let resolvedSrc = await readlink(src);
      if (!isAbsolute(resolvedSrc)) {
        resolvedSrc = resolve(dirname(src), resolvedSrc);
      }
      if (!destStat) {
        return symlink(resolvedSrc, dest);
      }
      let resolvedDest;
      try {
        resolvedDest = await readlink(dest);
      } catch (err) {
        if (err.code === "EINVAL" || err.code === "UNKNOWN") {
          return symlink(resolvedSrc, dest);
        }
        throw err;
      }
      if (!isAbsolute(resolvedDest)) {
        resolvedDest = resolve(dirname(dest), resolvedDest);
      }
      if (isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new ERR_FS_CP_EINVAL({
          message: `cannot copy ${resolvedSrc} to a subdirectory of self ${resolvedDest}`,
          path: dest,
          syscall: "cp",
          errno: EINVAL
        });
      }
      const srcStat = await stat(src);
      if (srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({
          message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,
          path: dest,
          syscall: "cp",
          errno: EINVAL
        });
      }
      return copyLink(resolvedSrc, dest);
    }
    async function copyLink(resolvedSrc, dest) {
      await unlink(dest);
      return symlink(resolvedSrc, dest);
    }
    module2.exports = cp;
  }
});

// node_modules/@npmcli/fs/lib/cp/index.js
var require_cp = __commonJS({
  "node_modules/@npmcli/fs/lib/cp/index.js"(exports2, module2) {
    var fs2 = require("fs/promises");
    var getOptions = require_get_options();
    var node = require_node();
    var polyfill = require_polyfill();
    var useNative = node.satisfies(">=16.7.0");
    var cp = async (src, dest, opts) => {
      const options = getOptions(opts, {
        copy: ["dereference", "errorOnExist", "filter", "force", "preserveTimestamps", "recursive"]
      });
      return useNative ? fs2.cp(src, dest, options) : polyfill(src, dest, options);
    };
    module2.exports = cp;
  }
});

// node_modules/@npmcli/fs/lib/with-temp-dir.js
var require_with_temp_dir = __commonJS({
  "node_modules/@npmcli/fs/lib/with-temp-dir.js"(exports2, module2) {
    var { join, sep } = require("path");
    var getOptions = require_get_options();
    var { mkdir, mkdtemp, rm } = require("fs/promises");
    var withTempDir = async (root, fn, opts) => {
      const options = getOptions(opts, {
        copy: ["tmpPrefix"]
      });
      await mkdir(root, { recursive: true });
      const target = await mkdtemp(join(`${root}${sep}`, options.tmpPrefix || ""));
      let err;
      let result;
      try {
        result = await fn(target);
      } catch (_err) {
        err = _err;
      }
      try {
        await rm(target, { force: true, recursive: true });
      } catch {
      }
      if (err) {
        throw err;
      }
      return result;
    };
    module2.exports = withTempDir;
  }
});

// node_modules/@npmcli/fs/lib/readdir-scoped.js
var require_readdir_scoped = __commonJS({
  "node_modules/@npmcli/fs/lib/readdir-scoped.js"(exports2, module2) {
    var { readdir } = require("fs/promises");
    var { join } = require("path");
    var readdirScoped = async (dir) => {
      const results = [];
      for (const item of await readdir(dir)) {
        if (item.startsWith("@")) {
          for (const scopedItem of await readdir(join(dir, item))) {
            results.push(join(item, scopedItem));
          }
        } else {
          results.push(item);
        }
      }
      return results;
    };
    module2.exports = readdirScoped;
  }
});

// node_modules/@npmcli/fs/lib/move-file.js
var require_move_file = __commonJS({
  "node_modules/@npmcli/fs/lib/move-file.js"(exports2, module2) {
    var { dirname, join, resolve, relative, isAbsolute } = require("path");
    var fs2 = require("fs/promises");
    var pathExists = async (path) => {
      try {
        await fs2.access(path);
        return true;
      } catch (er) {
        return er.code !== "ENOENT";
      }
    };
    var moveFile = async (source, destination, options = {}, root = true, symlinks = []) => {
      if (!source || !destination) {
        throw new TypeError("`source` and `destination` file required");
      }
      options = {
        overwrite: true,
        ...options
      };
      if (!options.overwrite && await pathExists(destination)) {
        throw new Error(`The destination file exists: ${destination}`);
      }
      await fs2.mkdir(dirname(destination), { recursive: true });
      try {
        await fs2.rename(source, destination);
      } catch (error) {
        if (error.code === "EXDEV" || error.code === "EPERM") {
          const sourceStat = await fs2.lstat(source);
          if (sourceStat.isDirectory()) {
            const files = await fs2.readdir(source);
            await Promise.all(files.map(
              (file) => moveFile(join(source, file), join(destination, file), options, false, symlinks)
            ));
          } else if (sourceStat.isSymbolicLink()) {
            symlinks.push({ source, destination });
          } else {
            await fs2.copyFile(source, destination);
          }
        } else {
          throw error;
        }
      }
      if (root) {
        await Promise.all(symlinks.map(async ({ source: symSource, destination: symDestination }) => {
          let target = await fs2.readlink(symSource);
          if (isAbsolute(target)) {
            target = resolve(symDestination, relative(symSource, target));
          }
          let targetStat = "file";
          try {
            targetStat = await fs2.stat(resolve(dirname(symSource), target));
            if (targetStat.isDirectory()) {
              targetStat = "junction";
            }
          } catch {
          }
          await fs2.symlink(
            target,
            symDestination,
            targetStat
          );
        }));
        await fs2.rm(source, { recursive: true, force: true });
      }
    };
    module2.exports = moveFile;
  }
});

// node_modules/@npmcli/fs/lib/index.js
var require_lib18 = __commonJS({
  "node_modules/@npmcli/fs/lib/index.js"(exports2, module2) {
    "use strict";
    var cp = require_cp();
    var withTempDir = require_with_temp_dir();
    var readdirScoped = require_readdir_scoped();
    var moveFile = require_move_file();
    module2.exports = {
      cp,
      withTempDir,
      readdirScoped,
      moveFile
    };
  }
});

// node_modules/p-map/index.js
var p_map_exports = {};
__export(p_map_exports, {
  default: () => pMap,
  pMapIterable: () => pMapIterable,
  pMapSkip: () => pMapSkip
});
async function pMap(iterable, mapper, {
  concurrency = Number.POSITIVE_INFINITY,
  stopOnError = true,
  signal
} = {}) {
  return new Promise((resolve_, reject_) => {
    if (iterable[Symbol.iterator] === void 0 && iterable[Symbol.asyncIterator] === void 0) {
      throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof iterable})`);
    }
    if (typeof mapper !== "function") {
      throw new TypeError("Mapper function is required");
    }
    if (!(Number.isSafeInteger(concurrency) && concurrency >= 1 || concurrency === Number.POSITIVE_INFINITY)) {
      throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
    }
    const result = [];
    const errors = [];
    const skippedIndexesMap = /* @__PURE__ */ new Map();
    let isRejected = false;
    let isResolved = false;
    let isIterableDone = false;
    let resolvingCount = 0;
    let currentIndex = 0;
    const iterator = iterable[Symbol.iterator] === void 0 ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
    const signalListener = () => {
      reject(signal.reason);
    };
    const cleanup = () => {
      signal?.removeEventListener("abort", signalListener);
    };
    const resolve = (value) => {
      resolve_(value);
      cleanup();
    };
    const reject = (reason) => {
      isRejected = true;
      isResolved = true;
      reject_(reason);
      cleanup();
    };
    if (signal) {
      if (signal.aborted) {
        reject(signal.reason);
      }
      signal.addEventListener("abort", signalListener, { once: true });
    }
    const next = async () => {
      if (isResolved) {
        return;
      }
      const nextItem = await iterator.next();
      const index = currentIndex;
      currentIndex++;
      if (nextItem.done) {
        isIterableDone = true;
        if (resolvingCount === 0 && !isResolved) {
          if (!stopOnError && errors.length > 0) {
            reject(new AggregateError(errors));
            return;
          }
          isResolved = true;
          if (skippedIndexesMap.size === 0) {
            resolve(result);
            return;
          }
          const pureResult = [];
          for (const [index2, value] of result.entries()) {
            if (skippedIndexesMap.get(index2) === pMapSkip) {
              continue;
            }
            pureResult.push(value);
          }
          resolve(pureResult);
        }
        return;
      }
      resolvingCount++;
      (async () => {
        try {
          const element = await nextItem.value;
          if (isResolved) {
            return;
          }
          const value = await mapper(element, index);
          if (value === pMapSkip) {
            skippedIndexesMap.set(index, value);
          }
          result[index] = value;
          resolvingCount--;
          await next();
        } catch (error) {
          if (stopOnError) {
            reject(error);
          } else {
            errors.push(error);
            resolvingCount--;
            try {
              await next();
            } catch (error2) {
              reject(error2);
            }
          }
        }
      })();
    };
    (async () => {
      for (let index = 0; index < concurrency; index++) {
        try {
          await next();
        } catch (error) {
          reject(error);
          break;
        }
        if (isIterableDone || isRejected) {
          break;
        }
      }
    })();
  });
}
function pMapIterable(iterable, mapper, {
  concurrency = Number.POSITIVE_INFINITY,
  backpressure = concurrency
} = {}) {
  if (iterable[Symbol.iterator] === void 0 && iterable[Symbol.asyncIterator] === void 0) {
    throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof iterable})`);
  }
  if (typeof mapper !== "function") {
    throw new TypeError("Mapper function is required");
  }
  if (!(Number.isSafeInteger(concurrency) && concurrency >= 1 || concurrency === Number.POSITIVE_INFINITY)) {
    throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
  }
  if (!(Number.isSafeInteger(backpressure) && backpressure >= concurrency || backpressure === Number.POSITIVE_INFINITY)) {
    throw new TypeError(`Expected \`backpressure\` to be an integer from \`concurrency\` (${concurrency}) and up or \`Infinity\`, got \`${backpressure}\` (${typeof backpressure})`);
  }
  return {
    async *[Symbol.asyncIterator]() {
      const iterator = iterable[Symbol.asyncIterator] === void 0 ? iterable[Symbol.iterator]() : iterable[Symbol.asyncIterator]();
      const promises = [];
      let runningMappersCount = 0;
      let isDone = false;
      let index = 0;
      function trySpawn() {
        if (isDone || !(runningMappersCount < concurrency && promises.length < backpressure)) {
          return;
        }
        const promise = (async () => {
          const { done, value } = await iterator.next();
          if (done) {
            return { done: true };
          }
          runningMappersCount++;
          trySpawn();
          try {
            const returnValue = await mapper(await value, index++);
            runningMappersCount--;
            if (returnValue === pMapSkip) {
              const index2 = promises.indexOf(promise);
              if (index2 > 0) {
                promises.splice(index2, 1);
              }
            }
            trySpawn();
            return { done: false, value: returnValue };
          } catch (error) {
            isDone = true;
            return { error };
          }
        })();
        promises.push(promise);
      }
      trySpawn();
      while (promises.length > 0) {
        const { error, done, value } = await promises[0];
        promises.shift();
        if (error) {
          throw error;
        }
        if (done) {
          return;
        }
        trySpawn();
        if (value === pMapSkip) {
          continue;
        }
        yield value;
      }
    }
  };
}
var pMapSkip;
var init_p_map = __esm({
  "node_modules/p-map/index.js"() {
    pMapSkip = Symbol("skip");
  }
});

// node_modules/cacache/lib/entry-index.js
var require_entry_index = __commonJS({
  "node_modules/cacache/lib/entry-index.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    var {
      appendFile,
      mkdir,
      readFile,
      readdir,
      rm,
      writeFile
    } = require("fs/promises");
    var { Minipass } = require_commonjs3();
    var path = require("path");
    var ssri = require_lib15();
    var uniqueFilename = require_lib17();
    var contentPath = require_path();
    var hashToSegments = require_hash_to_segments();
    var indexV = require_package()["cache-version"].index;
    var { moveFile } = require_lib18();
    var lsStreamConcurrency = 5;
    module2.exports.NotFoundError = class NotFoundError extends Error {
      constructor(cache, key) {
        super(`No cache entry for ${key} found in ${cache}`);
        this.code = "ENOENT";
        this.cache = cache;
        this.key = key;
      }
    };
    module2.exports.compact = compact;
    async function compact(cache, key, matchFn, opts = {}) {
      const bucket = bucketPath(cache, key);
      const entries = await bucketEntries(bucket);
      const newEntries = [];
      for (let i = entries.length - 1; i >= 0; --i) {
        const entry = entries[i];
        if (entry.integrity === null && !opts.validateEntry) {
          break;
        }
        if ((!opts.validateEntry || opts.validateEntry(entry) === true) && (newEntries.length === 0 || !newEntries.find((oldEntry) => matchFn(oldEntry, entry)))) {
          newEntries.unshift(entry);
        }
      }
      const newIndex = "\n" + newEntries.map((entry) => {
        const stringified = JSON.stringify(entry);
        const hash2 = hashEntry(stringified);
        return `${hash2}	${stringified}`;
      }).join("\n");
      const setup = async () => {
        const target = uniqueFilename(path.join(cache, "tmp"), opts.tmpPrefix);
        await mkdir(path.dirname(target), { recursive: true });
        return {
          target,
          moved: false
        };
      };
      const teardown = async (tmp2) => {
        if (!tmp2.moved) {
          return rm(tmp2.target, { recursive: true, force: true });
        }
      };
      const write = async (tmp2) => {
        await writeFile(tmp2.target, newIndex, { flag: "wx" });
        await mkdir(path.dirname(bucket), { recursive: true });
        await moveFile(tmp2.target, bucket);
        tmp2.moved = true;
      };
      const tmp = await setup();
      try {
        await write(tmp);
      } finally {
        await teardown(tmp);
      }
      return newEntries.reverse().map((entry) => formatEntry(cache, entry, true));
    }
    module2.exports.insert = insert;
    async function insert(cache, key, integrity, opts = {}) {
      const { metadata, size, time } = opts;
      const bucket = bucketPath(cache, key);
      const entry = {
        key,
        integrity: integrity && ssri.stringify(integrity),
        time: time || Date.now(),
        size,
        metadata
      };
      try {
        await mkdir(path.dirname(bucket), { recursive: true });
        const stringified = JSON.stringify(entry);
        await appendFile(bucket, `
${hashEntry(stringified)}	${stringified}`);
      } catch (err) {
        if (err.code === "ENOENT") {
          return void 0;
        }
        throw err;
      }
      return formatEntry(cache, entry);
    }
    module2.exports.find = find;
    async function find(cache, key) {
      const bucket = bucketPath(cache, key);
      try {
        const entries = await bucketEntries(bucket);
        return entries.reduce((latest, next) => {
          if (next && next.key === key) {
            return formatEntry(cache, next);
          } else {
            return latest;
          }
        }, null);
      } catch (err) {
        if (err.code === "ENOENT") {
          return null;
        } else {
          throw err;
        }
      }
    }
    module2.exports.delete = del;
    function del(cache, key, opts = {}) {
      if (!opts.removeFully) {
        return insert(cache, key, null, opts);
      }
      const bucket = bucketPath(cache, key);
      return rm(bucket, { recursive: true, force: true });
    }
    module2.exports.lsStream = lsStream;
    function lsStream(cache) {
      const indexDir = bucketDir(cache);
      const stream = new Minipass({ objectMode: true });
      Promise.resolve().then(async () => {
        const { default: pMap2 } = await Promise.resolve().then(() => (init_p_map(), p_map_exports));
        const buckets = await readdirOrEmpty(indexDir);
        await pMap2(
          buckets,
          async (bucket) => {
            const bucketPath2 = path.join(indexDir, bucket);
            const subbuckets = await readdirOrEmpty(bucketPath2);
            await pMap2(
              subbuckets,
              async (subbucket) => {
                const subbucketPath = path.join(bucketPath2, subbucket);
                const subbucketEntries = await readdirOrEmpty(subbucketPath);
                await pMap2(
                  subbucketEntries,
                  async (entry) => {
                    const entryPath = path.join(subbucketPath, entry);
                    try {
                      const entries = await bucketEntries(entryPath);
                      const reduced = entries.reduce((acc, entry2) => {
                        acc.set(entry2.key, entry2);
                        return acc;
                      }, /* @__PURE__ */ new Map());
                      for (const entry2 of reduced.values()) {
                        const formatted = formatEntry(cache, entry2);
                        if (formatted) {
                          stream.write(formatted);
                        }
                      }
                    } catch (err) {
                      if (err.code === "ENOENT") {
                        return void 0;
                      }
                      throw err;
                    }
                  },
                  { concurrency: lsStreamConcurrency }
                );
              },
              { concurrency: lsStreamConcurrency }
            );
          },
          { concurrency: lsStreamConcurrency }
        );
        stream.end();
        return stream;
      }).catch((err) => stream.emit("error", err));
      return stream;
    }
    module2.exports.ls = ls;
    async function ls(cache) {
      const entries = await lsStream(cache).collect();
      return entries.reduce((acc, xs) => {
        acc[xs.key] = xs;
        return acc;
      }, {});
    }
    module2.exports.bucketEntries = bucketEntries;
    async function bucketEntries(bucket, filter) {
      const data = await readFile(bucket, "utf8");
      return _bucketEntries(data, filter);
    }
    function _bucketEntries(data) {
      const entries = [];
      data.split("\n").forEach((entry) => {
        if (!entry) {
          return;
        }
        const pieces = entry.split("	");
        if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {
          return;
        }
        let obj;
        try {
          obj = JSON.parse(pieces[1]);
        } catch (_) {
        }
        if (obj) {
          entries.push(obj);
        }
      });
      return entries;
    }
    module2.exports.bucketDir = bucketDir;
    function bucketDir(cache) {
      return path.join(cache, `index-v${indexV}`);
    }
    module2.exports.bucketPath = bucketPath;
    function bucketPath(cache, key) {
      const hashed = hashKey(key);
      return path.join.apply(
        path,
        [bucketDir(cache)].concat(hashToSegments(hashed))
      );
    }
    module2.exports.hashKey = hashKey;
    function hashKey(key) {
      return hash(key, "sha256");
    }
    module2.exports.hashEntry = hashEntry;
    function hashEntry(str) {
      return hash(str, "sha1");
    }
    function hash(str, digest) {
      return crypto.createHash(digest).update(str).digest("hex");
    }
    function formatEntry(cache, entry, keepAll) {
      if (!entry.integrity && !keepAll) {
        return null;
      }
      return {
        key: entry.key,
        integrity: entry.integrity,
        path: entry.integrity ? contentPath(cache, entry.integrity) : void 0,
        size: entry.size,
        time: entry.time,
        metadata: entry.metadata
      };
    }
    function readdirOrEmpty(dir) {
      return readdir(dir).catch((err) => {
        if (err.code === "ENOENT" || err.code === "ENOTDIR") {
          return [];
        }
        throw err;
      });
    }
  }
});

// node_modules/cacache/lib/memoization.js
var require_memoization = __commonJS({
  "node_modules/cacache/lib/memoization.js"(exports2, module2) {
    "use strict";
    var { LRUCache } = require_commonjs2();
    var MEMOIZED = new LRUCache({
      max: 500,
      maxSize: 50 * 1024 * 1024,
      // 50MB
      ttl: 3 * 60 * 1e3,
      // 3 minutes
      sizeCalculation: (entry, key) => key.startsWith("key:") ? entry.data.length : entry.length
    });
    module2.exports.clearMemoized = clearMemoized;
    function clearMemoized() {
      const old = {};
      MEMOIZED.forEach((v, k) => {
        old[k] = v;
      });
      MEMOIZED.clear();
      return old;
    }
    module2.exports.put = put;
    function put(cache, entry, data, opts) {
      pickMem(opts).set(`key:${cache}:${entry.key}`, { entry, data });
      putDigest(cache, entry.integrity, data, opts);
    }
    module2.exports.put.byDigest = putDigest;
    function putDigest(cache, integrity, data, opts) {
      pickMem(opts).set(`digest:${cache}:${integrity}`, data);
    }
    module2.exports.get = get;
    function get(cache, key, opts) {
      return pickMem(opts).get(`key:${cache}:${key}`);
    }
    module2.exports.get.byDigest = getDigest;
    function getDigest(cache, integrity, opts) {
      return pickMem(opts).get(`digest:${cache}:${integrity}`);
    }
    var ObjProxy = class {
      constructor(obj) {
        this.obj = obj;
      }
      get(key) {
        return this.obj[key];
      }
      set(key, val) {
        this.obj[key] = val;
      }
    };
    function pickMem(opts) {
      if (!opts || !opts.memoize) {
        return MEMOIZED;
      } else if (opts.memoize.get && opts.memoize.set) {
        return opts.memoize;
      } else if (typeof opts.memoize === "object") {
        return new ObjProxy(opts.memoize);
      } else {
        return MEMOIZED;
      }
    }
  }
});

// node_modules/fs-minipass/lib/index.js
var require_lib19 = __commonJS({
  "node_modules/fs-minipass/lib/index.js"(exports2) {
    "use strict";
    var { Minipass } = require_commonjs3();
    var EE = require("events").EventEmitter;
    var fs2 = require("fs");
    var writev = fs2.writev;
    var _autoClose = Symbol("_autoClose");
    var _close = Symbol("_close");
    var _ended = Symbol("_ended");
    var _fd = Symbol("_fd");
    var _finished = Symbol("_finished");
    var _flags = Symbol("_flags");
    var _flush = Symbol("_flush");
    var _handleChunk = Symbol("_handleChunk");
    var _makeBuf = Symbol("_makeBuf");
    var _mode = Symbol("_mode");
    var _needDrain = Symbol("_needDrain");
    var _onerror = Symbol("_onerror");
    var _onopen = Symbol("_onopen");
    var _onread = Symbol("_onread");
    var _onwrite = Symbol("_onwrite");
    var _open = Symbol("_open");
    var _path = Symbol("_path");
    var _pos = Symbol("_pos");
    var _queue = Symbol("_queue");
    var _read = Symbol("_read");
    var _readSize = Symbol("_readSize");
    var _reading = Symbol("_reading");
    var _remain = Symbol("_remain");
    var _size = Symbol("_size");
    var _write = Symbol("_write");
    var _writing = Symbol("_writing");
    var _defaultFlag = Symbol("_defaultFlag");
    var _errored = Symbol("_errored");
    var ReadStream = class extends Minipass {
      constructor(path, opt) {
        opt = opt || {};
        super(opt);
        this.readable = true;
        this.writable = false;
        if (typeof path !== "string") {
          throw new TypeError("path must be a string");
        }
        this[_errored] = false;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_path] = path;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        if (typeof this[_fd] === "number") {
          this[_read]();
        } else {
          this[_open]();
        }
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      write() {
        throw new TypeError("this is a readable stream");
      }
      end() {
        throw new TypeError("this is a readable stream");
      }
      [_open]() {
        fs2.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (er) {
          this[_onerror](er);
        } else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_read]();
        }
      }
      [_makeBuf]() {
        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
      }
      [_read]() {
        if (!this[_reading]) {
          this[_reading] = true;
          const buf = this[_makeBuf]();
          if (buf.length === 0) {
            return process.nextTick(() => this[_onread](null, 0, buf));
          }
          fs2.read(this[_fd], buf, 0, buf.length, null, (er, br, b) => this[_onread](er, br, b));
        }
      }
      [_onread](er, br, buf) {
        this[_reading] = false;
        if (er) {
          this[_onerror](er);
        } else if (this[_handleChunk](br, buf)) {
          this[_read]();
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
      [_onerror](er) {
        this[_reading] = true;
        this[_close]();
        this.emit("error", er);
      }
      [_handleChunk](br, buf) {
        let ret = false;
        this[_remain] -= br;
        if (br > 0) {
          ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
        }
        if (br === 0 || this[_remain] <= 0) {
          ret = false;
          this[_close]();
          super.end();
        }
        return ret;
      }
      emit(ev, data) {
        switch (ev) {
          case "prefinish":
          case "finish":
            break;
          case "drain":
            if (typeof this[_fd] === "number") {
              this[_read]();
            }
            break;
          case "error":
            if (this[_errored]) {
              return;
            }
            this[_errored] = true;
            return super.emit(ev, data);
          default:
            return super.emit(ev, data);
        }
      }
    };
    var ReadStreamSync = class extends ReadStream {
      [_open]() {
        let threw = true;
        try {
          this[_onopen](null, fs2.openSync(this[_path], "r"));
          threw = false;
        } finally {
          if (threw) {
            this[_close]();
          }
        }
      }
      [_read]() {
        let threw = true;
        try {
          if (!this[_reading]) {
            this[_reading] = true;
            do {
              const buf = this[_makeBuf]();
              const br = buf.length === 0 ? 0 : fs2.readSync(this[_fd], buf, 0, buf.length, null);
              if (!this[_handleChunk](br, buf)) {
                break;
              }
            } while (true);
            this[_reading] = false;
          }
          threw = false;
        } finally {
          if (threw) {
            this[_close]();
          }
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.closeSync(fd);
          this.emit("close");
        }
      }
    };
    var WriteStream = class extends EE {
      constructor(path, opt) {
        opt = opt || {};
        super(opt);
        this.readable = false;
        this.writable = true;
        this[_errored] = false;
        this[_writing] = false;
        this[_ended] = false;
        this[_needDrain] = false;
        this[_queue] = [];
        this[_path] = path;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
        this[_pos] = typeof opt.start === "number" ? opt.start : null;
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        const defaultFlag = this[_pos] !== null ? "r+" : "w";
        this[_defaultFlag] = opt.flags === void 0;
        this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
        if (this[_fd] === null) {
          this[_open]();
        }
      }
      emit(ev, data) {
        if (ev === "error") {
          if (this[_errored]) {
            return;
          }
          this[_errored] = true;
        }
        return super.emit(ev, data);
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      [_onerror](er) {
        this[_close]();
        this[_writing] = true;
        this.emit("error", er);
      }
      [_open]() {
        fs2.open(
          this[_path],
          this[_flags],
          this[_mode],
          (er, fd) => this[_onopen](er, fd)
        );
      }
      [_onopen](er, fd) {
        if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
          this[_flags] = "w";
          this[_open]();
        } else if (er) {
          this[_onerror](er);
        } else {
          this[_fd] = fd;
          this.emit("open", fd);
          if (!this[_writing]) {
            this[_flush]();
          }
        }
      }
      end(buf, enc) {
        if (buf) {
          this.write(buf, enc);
        }
        this[_ended] = true;
        if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number") {
          this[_onwrite](null, 0);
        }
        return this;
      }
      write(buf, enc) {
        if (typeof buf === "string") {
          buf = Buffer.from(buf, enc);
        }
        if (this[_ended]) {
          this.emit("error", new Error("write() after end()"));
          return false;
        }
        if (this[_fd] === null || this[_writing] || this[_queue].length) {
          this[_queue].push(buf);
          this[_needDrain] = true;
          return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
      }
      [_write](buf) {
        fs2.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
      [_onwrite](er, bw) {
        if (er) {
          this[_onerror](er);
        } else {
          if (this[_pos] !== null) {
            this[_pos] += bw;
          }
          if (this[_queue].length) {
            this[_flush]();
          } else {
            this[_writing] = false;
            if (this[_ended] && !this[_finished]) {
              this[_finished] = true;
              this[_close]();
              this.emit("finish");
            } else if (this[_needDrain]) {
              this[_needDrain] = false;
              this.emit("drain");
            }
          }
        }
      }
      [_flush]() {
        if (this[_queue].length === 0) {
          if (this[_ended]) {
            this[_onwrite](null, 0);
          }
        } else if (this[_queue].length === 1) {
          this[_write](this[_queue].pop());
        } else {
          const iovec = this[_queue];
          this[_queue] = [];
          writev(
            this[_fd],
            iovec,
            this[_pos],
            (er, bw) => this[_onwrite](er, bw)
          );
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
    };
    var WriteStreamSync = class extends WriteStream {
      [_open]() {
        let fd;
        if (this[_defaultFlag] && this[_flags] === "r+") {
          try {
            fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
          } catch (er) {
            if (er.code === "ENOENT") {
              this[_flags] = "w";
              return this[_open]();
            } else {
              throw er;
            }
          }
        } else {
          fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
        }
        this[_onopen](null, fd);
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.closeSync(fd);
          this.emit("close");
        }
      }
      [_write](buf) {
        let threw = true;
        try {
          this[_onwrite](
            null,
            fs2.writeSync(this[_fd], buf, 0, buf.length, this[_pos])
          );
          threw = false;
        } finally {
          if (threw) {
            try {
              this[_close]();
            } catch {
            }
          }
        }
      }
    };
    exports2.ReadStream = ReadStream;
    exports2.ReadStreamSync = ReadStreamSync;
    exports2.WriteStream = WriteStream;
    exports2.WriteStreamSync = WriteStreamSync;
  }
});

// node_modules/cacache/lib/content/read.js
var require_read = __commonJS({
  "node_modules/cacache/lib/content/read.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs/promises");
    var fsm = require_lib19();
    var ssri = require_lib15();
    var contentPath = require_path();
    var Pipeline = require_minipass_pipeline();
    module2.exports = read;
    var MAX_SINGLE_READ_SIZE = 64 * 1024 * 1024;
    async function read(cache, integrity, opts = {}) {
      const { size } = opts;
      const { stat, cpath, sri } = await withContentSri(cache, integrity, async (cpath2, sri2) => {
        const stat2 = size ? { size } : await fs2.stat(cpath2);
        return { stat: stat2, cpath: cpath2, sri: sri2 };
      });
      if (stat.size > MAX_SINGLE_READ_SIZE) {
        return readPipeline(cpath, stat.size, sri, new Pipeline()).concat();
      }
      const data = await fs2.readFile(cpath, { encoding: null });
      if (stat.size !== data.length) {
        throw sizeError(stat.size, data.length);
      }
      if (!ssri.checkData(data, sri)) {
        throw integrityError(sri, cpath);
      }
      return data;
    }
    var readPipeline = (cpath, size, sri, stream) => {
      stream.push(
        new fsm.ReadStream(cpath, {
          size,
          readSize: MAX_SINGLE_READ_SIZE
        }),
        ssri.integrityStream({
          integrity: sri,
          size
        })
      );
      return stream;
    };
    module2.exports.stream = readStream;
    module2.exports.readStream = readStream;
    function readStream(cache, integrity, opts = {}) {
      const { size } = opts;
      const stream = new Pipeline();
      Promise.resolve().then(async () => {
        const { stat, cpath, sri } = await withContentSri(cache, integrity, async (cpath2, sri2) => {
          const stat2 = size ? { size } : await fs2.stat(cpath2);
          return { stat: stat2, cpath: cpath2, sri: sri2 };
        });
        return readPipeline(cpath, stat.size, sri, stream);
      }).catch((err) => stream.emit("error", err));
      return stream;
    }
    module2.exports.copy = copy;
    function copy(cache, integrity, dest) {
      return withContentSri(cache, integrity, (cpath) => {
        return fs2.copyFile(cpath, dest);
      });
    }
    module2.exports.hasContent = hasContent;
    async function hasContent(cache, integrity) {
      if (!integrity) {
        return false;
      }
      try {
        return await withContentSri(cache, integrity, async (cpath, sri) => {
          const stat = await fs2.stat(cpath);
          return { size: stat.size, sri, stat };
        });
      } catch (err) {
        if (err.code === "ENOENT") {
          return false;
        }
        if (err.code === "EPERM") {
          if (process.platform !== "win32") {
            throw err;
          } else {
            return false;
          }
        }
      }
    }
    async function withContentSri(cache, integrity, fn) {
      const sri = ssri.parse(integrity);
      const algo = sri.pickAlgorithm();
      const digests = sri[algo];
      if (digests.length <= 1) {
        const cpath = contentPath(cache, digests[0]);
        return fn(cpath, digests[0]);
      } else {
        const results = await Promise.all(digests.map(async (meta) => {
          try {
            return await withContentSri(cache, meta, fn);
          } catch (err) {
            if (err.code === "ENOENT") {
              return Object.assign(
                new Error("No matching content found for " + sri.toString()),
                { code: "ENOENT" }
              );
            }
            return err;
          }
        }));
        const result = results.find((r) => !(r instanceof Error));
        if (result) {
          return result;
        }
        const enoentError = results.find((r) => r.code === "ENOENT");
        if (enoentError) {
          throw enoentError;
        }
        throw results.find((r) => r instanceof Error);
      }
    }
    function sizeError(expected, found) {
      const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`);
      err.expected = expected;
      err.found = found;
      err.code = "EBADSIZE";
      return err;
    }
    function integrityError(sri, path) {
      const err = new Error(`Integrity verification failed for ${sri} (${path})`);
      err.code = "EINTEGRITY";
      err.sri = sri;
      err.path = path;
      return err;
    }
  }
});

// node_modules/cacache/lib/get.js
var require_get = __commonJS({
  "node_modules/cacache/lib/get.js"(exports2, module2) {
    "use strict";
    var Collect = require_minipass_collect();
    var { Minipass } = require_commonjs3();
    var Pipeline = require_minipass_pipeline();
    var index = require_entry_index();
    var memo = require_memoization();
    var read = require_read();
    async function getData(cache, key, opts = {}) {
      const { integrity, memoize, size } = opts;
      const memoized = memo.get(cache, key, opts);
      if (memoized && memoize !== false) {
        return {
          metadata: memoized.entry.metadata,
          data: memoized.data,
          integrity: memoized.entry.integrity,
          size: memoized.entry.size
        };
      }
      const entry = await index.find(cache, key, opts);
      if (!entry) {
        throw new index.NotFoundError(cache, key);
      }
      const data = await read(cache, entry.integrity, { integrity, size });
      if (memoize) {
        memo.put(cache, entry, data, opts);
      }
      return {
        data,
        metadata: entry.metadata,
        size: entry.size,
        integrity: entry.integrity
      };
    }
    module2.exports = getData;
    async function getDataByDigest(cache, key, opts = {}) {
      const { integrity, memoize, size } = opts;
      const memoized = memo.get.byDigest(cache, key, opts);
      if (memoized && memoize !== false) {
        return memoized;
      }
      const res = await read(cache, key, { integrity, size });
      if (memoize) {
        memo.put.byDigest(cache, key, res, opts);
      }
      return res;
    }
    module2.exports.byDigest = getDataByDigest;
    var getMemoizedStream = (memoized) => {
      const stream = new Minipass();
      stream.on("newListener", function(ev, cb) {
        ev === "metadata" && cb(memoized.entry.metadata);
        ev === "integrity" && cb(memoized.entry.integrity);
        ev === "size" && cb(memoized.entry.size);
      });
      stream.end(memoized.data);
      return stream;
    };
    function getStream(cache, key, opts = {}) {
      const { memoize, size } = opts;
      const memoized = memo.get(cache, key, opts);
      if (memoized && memoize !== false) {
        return getMemoizedStream(memoized);
      }
      const stream = new Pipeline();
      Promise.resolve().then(async () => {
        const entry = await index.find(cache, key);
        if (!entry) {
          throw new index.NotFoundError(cache, key);
        }
        stream.emit("metadata", entry.metadata);
        stream.emit("integrity", entry.integrity);
        stream.emit("size", entry.size);
        stream.on("newListener", function(ev, cb) {
          ev === "metadata" && cb(entry.metadata);
          ev === "integrity" && cb(entry.integrity);
          ev === "size" && cb(entry.size);
        });
        const src = read.readStream(
          cache,
          entry.integrity,
          { ...opts, size: typeof size !== "number" ? entry.size : size }
        );
        if (memoize) {
          const memoStream = new Collect.PassThrough();
          memoStream.on("collect", (data) => memo.put(cache, entry, data, opts));
          stream.unshift(memoStream);
        }
        stream.unshift(src);
        return stream;
      }).catch((err) => stream.emit("error", err));
      return stream;
    }
    module2.exports.stream = getStream;
    function getStreamDigest(cache, integrity, opts = {}) {
      const { memoize } = opts;
      const memoized = memo.get.byDigest(cache, integrity, opts);
      if (memoized && memoize !== false) {
        const stream = new Minipass();
        stream.end(memoized);
        return stream;
      } else {
        const stream = read.readStream(cache, integrity, opts);
        if (!memoize) {
          return stream;
        }
        const memoStream = new Collect.PassThrough();
        memoStream.on("collect", (data) => memo.put.byDigest(
          cache,
          integrity,
          data,
          opts
        ));
        return new Pipeline(stream, memoStream);
      }
    }
    module2.exports.stream.byDigest = getStreamDigest;
    function info(cache, key, opts = {}) {
      const { memoize } = opts;
      const memoized = memo.get(cache, key, opts);
      if (memoized && memoize !== false) {
        return Promise.resolve(memoized.entry);
      } else {
        return index.find(cache, key);
      }
    }
    module2.exports.info = info;
    async function copy(cache, key, dest, opts = {}) {
      const entry = await index.find(cache, key, opts);
      if (!entry) {
        throw new index.NotFoundError(cache, key);
      }
      await read.copy(cache, entry.integrity, dest, opts);
      return {
        metadata: entry.metadata,
        size: entry.size,
        integrity: entry.integrity
      };
    }
    module2.exports.copy = copy;
    async function copyByDigest(cache, key, dest, opts = {}) {
      await read.copy(cache, key, dest, opts);
      return key;
    }
    module2.exports.copy.byDigest = copyByDigest;
    module2.exports.hasContent = read.hasContent;
  }
});

// node_modules/minipass-flush/node_modules/minipass/index.js
var require_minipass2 = __commonJS({
  "node_modules/minipass-flush/node_modules/minipass/index.js"(exports2, module2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    module2.exports = class Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = [this.buffer.join("")];
          else
            this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer[0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this.pipes.find((p2) => p2.dest === dest);
        if (p) {
          this.pipes.splice(this.pipes.indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          const ret2 = super.emit("error", data);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this.pipes) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this.pipes) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this.pipes) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || // readable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/minipass-flush/index.js
var require_minipass_flush = __commonJS({
  "node_modules/minipass-flush/index.js"(exports2, module2) {
    var Minipass = require_minipass2();
    var _flush = Symbol("_flush");
    var _flushed = Symbol("_flushed");
    var _flushing = Symbol("_flushing");
    var Flush = class extends Minipass {
      constructor(opt = {}) {
        if (typeof opt === "function")
          opt = { flush: opt };
        super(opt);
        if (typeof opt.flush !== "function" && typeof this.flush !== "function")
          throw new TypeError("must provide flush function in options");
        this[_flush] = opt.flush || this.flush;
      }
      emit(ev, ...data) {
        if (ev !== "end" && ev !== "finish" || this[_flushed])
          return super.emit(ev, ...data);
        if (this[_flushing])
          return;
        this[_flushing] = true;
        const afterFlush = (er) => {
          this[_flushed] = true;
          er ? super.emit("error", er) : super.emit("end");
        };
        const ret = this[_flush](afterFlush);
        if (ret && ret.then)
          ret.then(() => afterFlush(), (er) => afterFlush(er));
      }
    };
    module2.exports = Flush;
  }
});

// node_modules/cacache/lib/content/write.js
var require_write = __commonJS({
  "node_modules/cacache/lib/content/write.js"(exports2, module2) {
    "use strict";
    var events = require("events");
    var contentPath = require_path();
    var fs2 = require("fs/promises");
    var { moveFile } = require_lib18();
    var { Minipass } = require_commonjs3();
    var Pipeline = require_minipass_pipeline();
    var Flush = require_minipass_flush();
    var path = require("path");
    var ssri = require_lib15();
    var uniqueFilename = require_lib17();
    var fsm = require_lib19();
    module2.exports = write;
    var moveOperations = /* @__PURE__ */ new Map();
    async function write(cache, data, opts = {}) {
      const { algorithms, size, integrity } = opts;
      if (typeof size === "number" && data.length !== size) {
        throw sizeError(size, data.length);
      }
      const sri = ssri.fromData(data, algorithms ? { algorithms } : {});
      if (integrity && !ssri.checkData(data, integrity, opts)) {
        throw checksumError(integrity, sri);
      }
      for (const algo in sri) {
        const tmp = await makeTmp(cache, opts);
        const hash = sri[algo].toString();
        try {
          await fs2.writeFile(tmp.target, data, { flag: "wx" });
          await moveToDestination(tmp, cache, hash, opts);
        } finally {
          if (!tmp.moved) {
            await fs2.rm(tmp.target, { recursive: true, force: true });
          }
        }
      }
      return { integrity: sri, size: data.length };
    }
    module2.exports.stream = writeStream;
    var CacacheWriteStream = class extends Flush {
      constructor(cache, opts) {
        super();
        this.opts = opts;
        this.cache = cache;
        this.inputStream = new Minipass();
        this.inputStream.on("error", (er) => this.emit("error", er));
        this.inputStream.on("drain", () => this.emit("drain"));
        this.handleContentP = null;
      }
      write(chunk, encoding, cb) {
        if (!this.handleContentP) {
          this.handleContentP = handleContent(
            this.inputStream,
            this.cache,
            this.opts
          );
          this.handleContentP.catch((error) => this.emit("error", error));
        }
        return this.inputStream.write(chunk, encoding, cb);
      }
      flush(cb) {
        this.inputStream.end(() => {
          if (!this.handleContentP) {
            const e = new Error("Cache input stream was empty");
            e.code = "ENODATA";
            return Promise.reject(e).catch(cb);
          }
          this.handleContentP.then(
            (res) => {
              res.integrity && this.emit("integrity", res.integrity);
              res.size !== null && this.emit("size", res.size);
              cb();
            },
            (er) => cb(er)
          );
        });
      }
    };
    function writeStream(cache, opts = {}) {
      return new CacacheWriteStream(cache, opts);
    }
    async function handleContent(inputStream, cache, opts) {
      const tmp = await makeTmp(cache, opts);
      try {
        const res = await pipeToTmp(inputStream, cache, tmp.target, opts);
        await moveToDestination(
          tmp,
          cache,
          res.integrity,
          opts
        );
        return res;
      } finally {
        if (!tmp.moved) {
          await fs2.rm(tmp.target, { recursive: true, force: true });
        }
      }
    }
    async function pipeToTmp(inputStream, cache, tmpTarget, opts) {
      const outStream = new fsm.WriteStream(tmpTarget, {
        flags: "wx"
      });
      if (opts.integrityEmitter) {
        const [integrity2, size2] = await Promise.all([
          events.once(opts.integrityEmitter, "integrity").then((res) => res[0]),
          events.once(opts.integrityEmitter, "size").then((res) => res[0]),
          new Pipeline(inputStream, outStream).promise()
        ]);
        return { integrity: integrity2, size: size2 };
      }
      let integrity;
      let size;
      const hashStream = ssri.integrityStream({
        integrity: opts.integrity,
        algorithms: opts.algorithms,
        size: opts.size
      });
      hashStream.on("integrity", (i) => {
        integrity = i;
      });
      hashStream.on("size", (s) => {
        size = s;
      });
      const pipeline = new Pipeline(inputStream, hashStream, outStream);
      await pipeline.promise();
      return { integrity, size };
    }
    async function makeTmp(cache, opts) {
      const tmpTarget = uniqueFilename(path.join(cache, "tmp"), opts.tmpPrefix);
      await fs2.mkdir(path.dirname(tmpTarget), { recursive: true });
      return {
        target: tmpTarget,
        moved: false
      };
    }
    async function moveToDestination(tmp, cache, sri) {
      const destination = contentPath(cache, sri);
      const destDir = path.dirname(destination);
      if (moveOperations.has(destination)) {
        return moveOperations.get(destination);
      }
      moveOperations.set(
        destination,
        fs2.mkdir(destDir, { recursive: true }).then(async () => {
          await moveFile(tmp.target, destination, { overwrite: false });
          tmp.moved = true;
          return tmp.moved;
        }).catch((err) => {
          if (!err.message.startsWith("The destination file exists")) {
            throw Object.assign(err, { code: "EEXIST" });
          }
        }).finally(() => {
          moveOperations.delete(destination);
        })
      );
      return moveOperations.get(destination);
    }
    function sizeError(expected, found) {
      const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`);
      err.expected = expected;
      err.found = found;
      err.code = "EBADSIZE";
      return err;
    }
    function checksumError(expected, found) {
      const err = new Error(`Integrity check failed:
  Wanted: ${expected}
   Found: ${found}`);
      err.code = "EINTEGRITY";
      err.expected = expected;
      err.found = found;
      return err;
    }
  }
});

// node_modules/cacache/lib/put.js
var require_put = __commonJS({
  "node_modules/cacache/lib/put.js"(exports2, module2) {
    "use strict";
    var index = require_entry_index();
    var memo = require_memoization();
    var write = require_write();
    var Flush = require_minipass_flush();
    var { PassThrough } = require_minipass_collect();
    var Pipeline = require_minipass_pipeline();
    var putOpts = (opts) => ({
      algorithms: ["sha512"],
      ...opts
    });
    module2.exports = putData;
    async function putData(cache, key, data, opts = {}) {
      const { memoize } = opts;
      opts = putOpts(opts);
      const res = await write(cache, data, opts);
      const entry = await index.insert(cache, key, res.integrity, { ...opts, size: res.size });
      if (memoize) {
        memo.put(cache, entry, data, opts);
      }
      return res.integrity;
    }
    module2.exports.stream = putStream;
    function putStream(cache, key, opts = {}) {
      const { memoize } = opts;
      opts = putOpts(opts);
      let integrity;
      let size;
      let error;
      let memoData;
      const pipeline = new Pipeline();
      if (memoize) {
        const memoizer = new PassThrough().on("collect", (data) => {
          memoData = data;
        });
        pipeline.push(memoizer);
      }
      const contentStream = write.stream(cache, opts).on("integrity", (int) => {
        integrity = int;
      }).on("size", (s) => {
        size = s;
      }).on("error", (err) => {
        error = err;
      });
      pipeline.push(contentStream);
      pipeline.push(new Flush({
        async flush() {
          if (!error) {
            const entry = await index.insert(cache, key, integrity, { ...opts, size });
            if (memoize && memoData) {
              memo.put(cache, entry, memoData, opts);
            }
            pipeline.emit("integrity", integrity);
            pipeline.emit("size", size);
          }
        }
      }));
      return pipeline;
    }
  }
});

// node_modules/cacache/lib/util/glob.js
var require_glob2 = __commonJS({
  "node_modules/cacache/lib/util/glob.js"(exports2, module2) {
    "use strict";
    var { glob } = require_commonjs5();
    var path = require("path");
    var globify = (pattern) => pattern.split(path.win32.sep).join(path.posix.sep);
    module2.exports = (path2, options) => glob(globify(path2), options);
  }
});

// node_modules/cacache/lib/content/rm.js
var require_rm = __commonJS({
  "node_modules/cacache/lib/content/rm.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs/promises");
    var contentPath = require_path();
    var { hasContent } = require_read();
    module2.exports = rm;
    async function rm(cache, integrity) {
      const content = await hasContent(cache, integrity);
      if (content && content.sri) {
        await fs2.rm(contentPath(cache, content.sri), { recursive: true, force: true });
        return true;
      } else {
        return false;
      }
    }
  }
});

// node_modules/cacache/lib/rm.js
var require_rm2 = __commonJS({
  "node_modules/cacache/lib/rm.js"(exports2, module2) {
    "use strict";
    var { rm } = require("fs/promises");
    var glob = require_glob2();
    var index = require_entry_index();
    var memo = require_memoization();
    var path = require("path");
    var rmContent = require_rm();
    module2.exports = entry;
    module2.exports.entry = entry;
    function entry(cache, key, opts) {
      memo.clearMemoized();
      return index.delete(cache, key, opts);
    }
    module2.exports.content = content;
    function content(cache, integrity) {
      memo.clearMemoized();
      return rmContent(cache, integrity);
    }
    module2.exports.all = all;
    async function all(cache) {
      memo.clearMemoized();
      const paths = await glob(path.join(cache, "*(content-*|index-*)"), { silent: true, nosort: true });
      return Promise.all(paths.map((p) => rm(p, { recursive: true, force: true })));
    }
  }
});

// node_modules/cacache/lib/verify.js
var require_verify = __commonJS({
  "node_modules/cacache/lib/verify.js"(exports2, module2) {
    "use strict";
    var {
      mkdir,
      readFile,
      rm,
      stat,
      truncate,
      writeFile
    } = require("fs/promises");
    var contentPath = require_path();
    var fsm = require_lib19();
    var glob = require_glob2();
    var index = require_entry_index();
    var path = require("path");
    var ssri = require_lib15();
    var hasOwnProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
    var verifyOpts = (opts) => ({
      concurrency: 20,
      log: { silly() {
      } },
      ...opts
    });
    module2.exports = verify;
    async function verify(cache, opts) {
      opts = verifyOpts(opts);
      opts.log.silly("verify", "verifying cache at", cache);
      const steps = [
        markStartTime,
        fixPerms,
        garbageCollect,
        rebuildIndex,
        cleanTmp,
        writeVerifile,
        markEndTime
      ];
      const stats = {};
      for (const step of steps) {
        const label = step.name;
        const start = /* @__PURE__ */ new Date();
        const s = await step(cache, opts);
        if (s) {
          Object.keys(s).forEach((k) => {
            stats[k] = s[k];
          });
        }
        const end = /* @__PURE__ */ new Date();
        if (!stats.runTime) {
          stats.runTime = {};
        }
        stats.runTime[label] = end - start;
      }
      stats.runTime.total = stats.endTime - stats.startTime;
      opts.log.silly(
        "verify",
        "verification finished for",
        cache,
        "in",
        `${stats.runTime.total}ms`
      );
      return stats;
    }
    async function markStartTime() {
      return { startTime: /* @__PURE__ */ new Date() };
    }
    async function markEndTime() {
      return { endTime: /* @__PURE__ */ new Date() };
    }
    async function fixPerms(cache, opts) {
      opts.log.silly("verify", "fixing cache permissions");
      await mkdir(cache, { recursive: true });
      return null;
    }
    async function garbageCollect(cache, opts) {
      opts.log.silly("verify", "garbage collecting content");
      const { default: pMap2 } = await Promise.resolve().then(() => (init_p_map(), p_map_exports));
      const indexStream = index.lsStream(cache);
      const liveContent = /* @__PURE__ */ new Set();
      indexStream.on("data", (entry) => {
        if (opts.filter && !opts.filter(entry)) {
          return;
        }
        const integrity = ssri.parse(entry.integrity);
        for (const algo in integrity) {
          liveContent.add(integrity[algo].toString());
        }
      });
      await new Promise((resolve, reject) => {
        indexStream.on("end", resolve).on("error", reject);
      });
      const contentDir = contentPath.contentDir(cache);
      const files = await glob(path.join(contentDir, "**"), {
        follow: false,
        nodir: true,
        nosort: true
      });
      const stats = {
        verifiedContent: 0,
        reclaimedCount: 0,
        reclaimedSize: 0,
        badContentCount: 0,
        keptSize: 0
      };
      await pMap2(
        files,
        async (f) => {
          const split = f.split(/[/\\]/);
          const digest = split.slice(split.length - 3).join("");
          const algo = split[split.length - 4];
          const integrity = ssri.fromHex(digest, algo);
          if (liveContent.has(integrity.toString())) {
            const info = await verifyContent(f, integrity);
            if (!info.valid) {
              stats.reclaimedCount++;
              stats.badContentCount++;
              stats.reclaimedSize += info.size;
            } else {
              stats.verifiedContent++;
              stats.keptSize += info.size;
            }
          } else {
            stats.reclaimedCount++;
            const s = await stat(f);
            await rm(f, { recursive: true, force: true });
            stats.reclaimedSize += s.size;
          }
          return stats;
        },
        { concurrency: opts.concurrency }
      );
      return stats;
    }
    async function verifyContent(filepath, sri) {
      const contentInfo = {};
      try {
        const { size } = await stat(filepath);
        contentInfo.size = size;
        contentInfo.valid = true;
        await ssri.checkStream(new fsm.ReadStream(filepath), sri);
      } catch (err) {
        if (err.code === "ENOENT") {
          return { size: 0, valid: false };
        }
        if (err.code !== "EINTEGRITY") {
          throw err;
        }
        await rm(filepath, { recursive: true, force: true });
        contentInfo.valid = false;
      }
      return contentInfo;
    }
    async function rebuildIndex(cache, opts) {
      opts.log.silly("verify", "rebuilding index");
      const { default: pMap2 } = await Promise.resolve().then(() => (init_p_map(), p_map_exports));
      const entries = await index.ls(cache);
      const stats = {
        missingContent: 0,
        rejectedEntries: 0,
        totalEntries: 0
      };
      const buckets = {};
      for (const k in entries) {
        if (hasOwnProperty(entries, k)) {
          const hashed = index.hashKey(k);
          const entry = entries[k];
          const excluded = opts.filter && !opts.filter(entry);
          excluded && stats.rejectedEntries++;
          if (buckets[hashed] && !excluded) {
            buckets[hashed].push(entry);
          } else if (buckets[hashed] && excluded) {
          } else if (excluded) {
            buckets[hashed] = [];
            buckets[hashed]._path = index.bucketPath(cache, k);
          } else {
            buckets[hashed] = [entry];
            buckets[hashed]._path = index.bucketPath(cache, k);
          }
        }
      }
      await pMap2(
        Object.keys(buckets),
        (key) => {
          return rebuildBucket(cache, buckets[key], stats, opts);
        },
        { concurrency: opts.concurrency }
      );
      return stats;
    }
    async function rebuildBucket(cache, bucket, stats) {
      await truncate(bucket._path);
      for (const entry of bucket) {
        const content = contentPath(cache, entry.integrity);
        try {
          await stat(content);
          await index.insert(cache, entry.key, entry.integrity, {
            metadata: entry.metadata,
            size: entry.size,
            time: entry.time
          });
          stats.totalEntries++;
        } catch (err) {
          if (err.code === "ENOENT") {
            stats.rejectedEntries++;
            stats.missingContent++;
          } else {
            throw err;
          }
        }
      }
    }
    function cleanTmp(cache, opts) {
      opts.log.silly("verify", "cleaning tmp directory");
      return rm(path.join(cache, "tmp"), { recursive: true, force: true });
    }
    async function writeVerifile(cache, opts) {
      const verifile = path.join(cache, "_lastverified");
      opts.log.silly("verify", "writing verifile to " + verifile);
      return writeFile(verifile, `${Date.now()}`);
    }
    module2.exports.lastRun = lastRun;
    async function lastRun(cache) {
      const data = await readFile(path.join(cache, "_lastverified"), { encoding: "utf8" });
      return /* @__PURE__ */ new Date(+data);
    }
  }
});

// node_modules/cacache/lib/util/tmp.js
var require_tmp = __commonJS({
  "node_modules/cacache/lib/util/tmp.js"(exports2, module2) {
    "use strict";
    var { withTempDir } = require_lib18();
    var fs2 = require("fs/promises");
    var path = require("path");
    module2.exports.mkdir = mktmpdir;
    async function mktmpdir(cache, opts = {}) {
      const { tmpPrefix } = opts;
      const tmpDir = path.join(cache, "tmp");
      await fs2.mkdir(tmpDir, { recursive: true, owner: "inherit" });
      const target = `${tmpDir}${path.sep}${tmpPrefix || ""}`;
      return fs2.mkdtemp(target, { owner: "inherit" });
    }
    module2.exports.withTmp = withTmp;
    function withTmp(cache, opts, cb) {
      if (!cb) {
        cb = opts;
        opts = {};
      }
      return withTempDir(path.join(cache, "tmp"), cb, opts);
    }
  }
});

// node_modules/cacache/lib/index.js
var require_lib20 = __commonJS({
  "node_modules/cacache/lib/index.js"(exports2, module2) {
    "use strict";
    var get = require_get();
    var put = require_put();
    var rm = require_rm2();
    var verify = require_verify();
    var { clearMemoized } = require_memoization();
    var tmp = require_tmp();
    var index = require_entry_index();
    module2.exports.index = {};
    module2.exports.index.compact = index.compact;
    module2.exports.index.insert = index.insert;
    module2.exports.ls = index.ls;
    module2.exports.ls.stream = index.lsStream;
    module2.exports.get = get;
    module2.exports.get.byDigest = get.byDigest;
    module2.exports.get.stream = get.stream;
    module2.exports.get.stream.byDigest = get.stream.byDigest;
    module2.exports.get.copy = get.copy;
    module2.exports.get.copy.byDigest = get.copy.byDigest;
    module2.exports.get.info = get.info;
    module2.exports.get.hasContent = get.hasContent;
    module2.exports.put = put;
    module2.exports.put.stream = put.stream;
    module2.exports.rm = rm.entry;
    module2.exports.rm.all = rm.all;
    module2.exports.rm.entry = module2.exports.rm;
    module2.exports.rm.content = rm.content;
    module2.exports.clearMemoized = clearMemoized;
    module2.exports.tmp = {};
    module2.exports.tmp.mkdir = tmp.mkdir;
    module2.exports.tmp.withTmp = tmp.withTmp;
    module2.exports.verify = verify;
    module2.exports.verify.lastRun = verify.lastRun;
  }
});

// node_modules/npm-bundled/lib/index.js
var require_lib21 = __commonJS({
  "node_modules/npm-bundled/lib/index.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var path = require("path");
    var EE = require("events").EventEmitter;
    var normalizePackageBin = require_lib10();
    var BundleWalker = class _BundleWalker extends EE {
      constructor(opt) {
        opt = opt || {};
        super(opt);
        this.path = path.resolve(opt.path || process.cwd());
        this.parent = opt.parent || null;
        if (this.parent) {
          this.result = this.parent.result;
          if (!this.parent.parent) {
            const base = path.basename(this.path);
            const scope = path.basename(path.dirname(this.path));
            this.result.add(/^@/.test(scope) ? scope + "/" + base : base);
          }
          this.root = this.parent.root;
          this.packageJsonCache = this.parent.packageJsonCache;
        } else {
          this.result = /* @__PURE__ */ new Set();
          this.root = this.path;
          this.packageJsonCache = opt.packageJsonCache || /* @__PURE__ */ new Map();
        }
        this.seen = /* @__PURE__ */ new Set();
        this.didDone = false;
        this.children = 0;
        this.node_modules = [];
        this.package = null;
        this.bundle = null;
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "done" && this.didDone) {
          this.emit("done", this.result);
        }
        return ret;
      }
      done() {
        if (!this.didDone) {
          this.didDone = true;
          if (!this.parent) {
            const res = Array.from(this.result);
            this.result = res;
            this.emit("done", res);
          } else {
            this.emit("done");
          }
        }
      }
      start() {
        const pj = path.resolve(this.path, "package.json");
        if (this.packageJsonCache.has(pj)) {
          this.onPackage(this.packageJsonCache.get(pj));
        } else {
          this.readPackageJson(pj);
        }
        return this;
      }
      readPackageJson(pj) {
        fs2.readFile(pj, (er, data) => er ? this.done() : this.onPackageJson(pj, data));
      }
      onPackageJson(pj, data) {
        try {
          this.package = normalizePackageBin(JSON.parse(data + ""));
        } catch (er) {
          return this.done();
        }
        this.packageJsonCache.set(pj, this.package);
        this.onPackage(this.package);
      }
      allDepsBundled(pkg) {
        return Object.keys(pkg.dependencies || {}).concat(
          Object.keys(pkg.optionalDependencies || {})
        );
      }
      onPackage(pkg) {
        const bdRaw = this.parent ? this.allDepsBundled(pkg) : pkg.bundleDependencies || pkg.bundledDependencies || [];
        const bd = Array.from(new Set(
          Array.isArray(bdRaw) ? bdRaw : bdRaw === true ? this.allDepsBundled(pkg) : Object.keys(bdRaw)
        ));
        if (!bd.length) {
          return this.done();
        }
        this.bundle = bd;
        this.readModules();
      }
      readModules() {
        readdirNodeModules(this.path + "/node_modules", (er, nm) => er ? this.onReaddir([]) : this.onReaddir(nm));
      }
      onReaddir(nm) {
        this.node_modules = nm;
        this.bundle.forEach((dep) => this.childDep(dep));
        if (this.children === 0) {
          this.done();
        }
      }
      childDep(dep) {
        if (this.node_modules.indexOf(dep) !== -1) {
          if (!this.seen.has(dep)) {
            this.seen.add(dep);
            this.child(dep);
          }
        } else if (this.parent) {
          this.parent.childDep(dep);
        }
      }
      child(dep) {
        const p = this.path + "/node_modules/" + dep;
        this.children += 1;
        const child = new _BundleWalker({
          path: p,
          parent: this
        });
        child.on("done", () => {
          if (--this.children === 0) {
            this.done();
          }
        });
        child.start();
      }
    };
    var BundleWalkerSync = class _BundleWalkerSync extends BundleWalker {
      start() {
        super.start();
        this.done();
        return this;
      }
      readPackageJson(pj) {
        try {
          this.onPackageJson(pj, fs2.readFileSync(pj));
        } catch {
        }
        return this;
      }
      readModules() {
        try {
          this.onReaddir(readdirNodeModulesSync(this.path + "/node_modules"));
        } catch {
          this.onReaddir([]);
        }
      }
      child(dep) {
        new _BundleWalkerSync({
          path: this.path + "/node_modules/" + dep,
          parent: this
        }).start();
      }
    };
    var readdirNodeModules = (nm, cb) => {
      fs2.readdir(nm, (er, set) => {
        if (er) {
          cb(er);
        } else {
          const scopes = set.filter((f) => /^@/.test(f));
          if (!scopes.length) {
            cb(null, set);
          } else {
            const unscoped = set.filter((f) => !/^@/.test(f));
            let count = scopes.length;
            scopes.forEach((scope) => {
              fs2.readdir(nm + "/" + scope, (readdirEr, pkgs) => {
                if (readdirEr || !pkgs.length) {
                  unscoped.push(scope);
                } else {
                  unscoped.push.apply(unscoped, pkgs.map((p) => scope + "/" + p));
                }
                if (--count === 0) {
                  cb(null, unscoped);
                }
              });
            });
          }
        }
      });
    };
    var readdirNodeModulesSync = (nm) => {
      const set = fs2.readdirSync(nm);
      const unscoped = set.filter((f) => !/^@/.test(f));
      const scopes = set.filter((f) => /^@/.test(f)).map((scope) => {
        try {
          const pkgs = fs2.readdirSync(nm + "/" + scope);
          return pkgs.length ? pkgs.map((p) => scope + "/" + p) : [scope];
        } catch (er) {
          return [scope];
        }
      }).reduce((a, b) => a.concat(b), []);
      return unscoped.concat(scopes);
    };
    var walk = (options, callback) => {
      const p = new Promise((resolve, reject) => {
        new BundleWalker(options).on("done", resolve).on("error", reject).start();
      });
      return callback ? p.then((res) => callback(null, res), callback) : p;
    };
    var walkSync = (options) => {
      return new BundleWalkerSync(options).start().result;
    };
    module2.exports = walk;
    walk.sync = walkSync;
    walk.BundleWalker = BundleWalker;
    walk.BundleWalkerSync = BundleWalkerSync;
  }
});

// node_modules/@npmcli/installed-package-contents/lib/index.js
var require_lib22 = __commonJS({
  "node_modules/@npmcli/installed-package-contents/lib/index.js"(exports2, module2) {
    var bundled = require_lib21();
    var { readFile, readdir, stat } = require("fs/promises");
    var { resolve, basename, dirname } = require("path");
    var normalizePackageBin = require_lib10();
    var readPackage = ({ path, packageJsonCache }) => packageJsonCache.has(path) ? Promise.resolve(packageJsonCache.get(path)) : readFile(path).then((json) => {
      const pkg = normalizePackageBin(JSON.parse(json));
      packageJsonCache.set(path, pkg);
      return pkg;
    }).catch(() => null);
    var normalized = Symbol("package data has been normalized");
    var rpj = ({ path, packageJsonCache }) => readPackage({ path, packageJsonCache }).then((pkg) => {
      if (!pkg || pkg[normalized]) {
        return pkg;
      }
      if (pkg.bundledDependencies && !pkg.bundleDependencies) {
        pkg.bundleDependencies = pkg.bundledDependencies;
        delete pkg.bundledDependencies;
      }
      const bd = pkg.bundleDependencies;
      if (bd === true) {
        pkg.bundleDependencies = [
          ...Object.keys(pkg.dependencies || {}),
          ...Object.keys(pkg.optionalDependencies || {})
        ];
      }
      if (typeof bd === "object" && !Array.isArray(bd)) {
        pkg.bundleDependencies = Object.keys(bd);
      }
      pkg[normalized] = true;
      return pkg;
    });
    var pkgContents = async ({
      path,
      depth = 1,
      currentDepth = 0,
      pkg = null,
      result = null,
      packageJsonCache = null
    }) => {
      if (!result) {
        result = /* @__PURE__ */ new Set();
      }
      if (!packageJsonCache) {
        packageJsonCache = /* @__PURE__ */ new Map();
      }
      if (pkg === true) {
        return rpj({ path: path + "/package.json", packageJsonCache }).then((p) => pkgContents({
          path,
          depth,
          currentDepth,
          pkg: p,
          result,
          packageJsonCache
        }));
      }
      if (pkg) {
        if (pkg.bin) {
          const dir = dirname(path);
          const scope = basename(dir);
          const nm = /^@.+/.test(scope) ? dirname(dir) : dir;
          const binFiles = [];
          Object.keys(pkg.bin).forEach((b) => {
            const base = resolve(nm, ".bin", b);
            binFiles.push(base, base + ".cmd", base + ".ps1");
          });
          const bins = await Promise.all(
            binFiles.map((b) => stat(b).then(() => b).catch(() => null))
          );
          bins.filter((b) => b).forEach((b) => result.add(b));
        }
      }
      if (currentDepth >= depth) {
        result.add(path);
        return result;
      }
      const [dirEntries, bundleDeps] = await Promise.all([
        readdir(path, { withFileTypes: true }),
        currentDepth === 0 && pkg && pkg.bundleDependencies ? bundled({ path, packageJsonCache }) : null
      ]).catch(() => []);
      if (!dirEntries) {
        return result;
      }
      if (!dirEntries.length && !bundleDeps && currentDepth !== 0) {
        result.add(path);
        return result;
      }
      const recursePromises = [];
      for (const entry of dirEntries) {
        const p = resolve(path, entry.name);
        if (entry.isDirectory() === false) {
          result.add(p);
          continue;
        }
        if (currentDepth !== 0 || entry.name !== "node_modules") {
          if (currentDepth < depth - 1) {
            recursePromises.push(pkgContents({
              path: p,
              packageJsonCache,
              depth,
              currentDepth: currentDepth + 1,
              result
            }));
          } else {
            result.add(p);
          }
          continue;
        }
      }
      if (bundleDeps) {
        recursePromises.push(...bundleDeps.map((dep) => {
          const p = resolve(path, "node_modules", dep);
          return pkgContents({
            path: p,
            packageJsonCache,
            pkg: true,
            depth,
            currentDepth: currentDepth + 1,
            result
          });
        }));
      }
      if (recursePromises.length) {
        await Promise.all(recursePromises);
      }
      return result;
    };
    module2.exports = ({ path, ...opts }) => pkgContents({
      path: resolve(path),
      ...opts,
      pkg: true
    }).then((results) => [...results]);
  }
});

// node_modules/pacote/node_modules/tar/lib/high-level-opt.js
var require_high_level_opt = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/high-level-opt.js"(exports2, module2) {
    "use strict";
    var argmap = /* @__PURE__ */ new Map([
      ["C", "cwd"],
      ["f", "file"],
      ["z", "gzip"],
      ["P", "preservePaths"],
      ["U", "unlink"],
      ["strip-components", "strip"],
      ["stripComponents", "strip"],
      ["keep-newer", "newer"],
      ["keepNewer", "newer"],
      ["keep-newer-files", "newer"],
      ["keepNewerFiles", "newer"],
      ["k", "keep"],
      ["keep-existing", "keep"],
      ["keepExisting", "keep"],
      ["m", "noMtime"],
      ["no-mtime", "noMtime"],
      ["p", "preserveOwner"],
      ["L", "follow"],
      ["h", "follow"]
    ]);
    module2.exports = (opt) => opt ? Object.keys(opt).map((k) => [
      argmap.has(k) ? argmap.get(k) : k,
      opt[k]
    ]).reduce((set, kv) => (set[kv[0]] = kv[1], set), /* @__PURE__ */ Object.create(null)) : {};
  }
});

// node_modules/pacote/node_modules/tar/node_modules/minipass/index.js
var require_minipass3 = __commonJS({
  "node_modules/pacote/node_modules/tar/node_modules/minipass/index.js"(exports2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var stringdecoder = require("string_decoder");
    var SD = stringdecoder.StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFER = Symbol("buffer");
    var PIPES = Symbol("pipes");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var ERROR = Symbol("error");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var ABORT = Symbol("abort");
    var ABORTED = Symbol("aborted");
    var SIGNAL = Symbol("signal");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end) this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    var Minipass = class _Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this[PIPES] = [];
        this[BUFFER] = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE]) this[ENCODING] = null;
        else this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer") this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
        if (options && options.debugExposeBuffer === true) {
          Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
        }
        if (options && options.debugExposePipes === true) {
          Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
        }
        this[SIGNAL] = options && options.signal;
        this[ABORTED] = false;
        if (this[SIGNAL]) {
          this[SIGNAL].addEventListener("abort", () => this[ABORT]());
          if (this[SIGNAL].aborted) {
            this[ABORT]();
          }
        }
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE]) throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this[BUFFER].length)
            this[BUFFER] = this[BUFFER].map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      // drop everything and get out of the flow completely
      [ABORT]() {
        this[ABORTED] = true;
        this.emit("abort", this[SIGNAL].reason);
        this.destroy(this[SIGNAL].reason);
      }
      get aborted() {
        return this[ABORTED];
      }
      set aborted(_) {
      }
      write(chunk, encoding, cb) {
        if (this[ABORTED]) return false;
        if (this[EOF]) throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit(
            "error",
            Object.assign(
              new Error("Cannot call write after a stream was destroyed"),
              { code: "ERR_STREAM_DESTROYED" }
            )
          );
          return true;
        }
        if (typeof encoding === "function") cb = encoding, encoding = "utf8";
        if (!encoding) encoding = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
          if (this.flowing) this.emit("data", chunk);
          else this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
        if (this.flowing) this.emit("data", chunk);
        else this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0) this.emit("readable");
        if (cb) fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED]) return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE]) n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
          if (this.encoding) this[BUFFER] = [this[BUFFER].join("")];
          else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null) this[BUFFERSHIFT]();
        else {
          this[BUFFER][0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF]) this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function") cb = chunk, chunk = null;
        if (typeof encoding === "function") cb = encoding, encoding = "utf8";
        if (chunk) this.write(chunk, encoding);
        if (cb) this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED]) return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length) this[FLUSH]();
        else if (this[EOF]) this[MAYBE_EMIT_END]();
        else this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
        else this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
        else this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        this.emit("data", chunk);
        return this.flowing;
      }
      pipe(dest, opts) {
        if (this[DESTROYED]) return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
        else opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end) dest.end();
        } else {
          this[PIPES].push(
            !opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts)
          );
          if (this[ASYNC]) defer(() => this[RESUME]());
          else this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this[PIPES].find((p2) => p2.dest === dest);
        if (p) {
          this[PIPES].splice(this[PIPES].indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this[PIPES].length && !this.flowing) this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));
          else fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED]) this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED]) return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          super.emit(ERROR, data);
          const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this[PIPES]) {
          if (p.dest.write(data) === false) this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END]) return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC]) defer(() => this[EMITEND2]());
        else this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this[PIPES]) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this[PIPES]) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE]) buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE]) buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then(
          (buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength)
        );
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        let stopped = false;
        const stop = () => {
          this.pause();
          stopped = true;
          return Promise.resolve({ done: true });
        };
        const next = () => {
          if (stopped) return stop();
          const res = this.read();
          if (res !== null) return Promise.resolve({ done: false, value: res });
          if (this[EOF]) return stop();
          let resolve = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            this.removeListener(DESTROYED, ondestroy);
            stop();
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.removeListener(DESTROYED, ondestroy);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            this.removeListener(DESTROYED, ondestroy);
            stop();
            resolve({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return {
          next,
          throw: stop,
          return: stop,
          [ASYNCITERATOR]() {
            return this;
          }
        };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        let stopped = false;
        const stop = () => {
          this.pause();
          this.removeListener(ERROR, stop);
          this.removeListener(DESTROYED, stop);
          this.removeListener("end", stop);
          stopped = true;
          return { done: true };
        };
        const next = () => {
          if (stopped) return stop();
          const value = this.read();
          return value === null ? stop() : { value };
        };
        this.once("end", stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
          next,
          throw: stop,
          return: stop,
          [ITERATOR]() {
            return this;
          }
        };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er) this.emit("error", er);
          else this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED]) this.close();
        if (er) this.emit("error", er);
        else this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof _Minipass || s instanceof Stream || s instanceof EE && // readable
        (typeof s.pipe === "function" || // writable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
    exports2.Minipass = Minipass;
  }
});

// node_modules/pacote/node_modules/minizlib/constants.js
var require_constants2 = __commonJS({
  "node_modules/pacote/node_modules/minizlib/constants.js"(exports2, module2) {
    var realZlibConstants = require("zlib").constants || /* istanbul ignore next */
    { ZLIB_VERNUM: 4736 };
    module2.exports = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31
    }, realZlibConstants));
  }
});

// node_modules/pacote/node_modules/minizlib/node_modules/minipass/index.js
var require_minipass4 = __commonJS({
  "node_modules/pacote/node_modules/minizlib/node_modules/minipass/index.js"(exports2, module2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    module2.exports = class Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = [this.buffer.join("")];
          else
            this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer[0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this.pipes.find((p2) => p2.dest === dest);
        if (p) {
          this.pipes.splice(this.pipes.indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          const ret2 = super.emit("error", data);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this.pipes) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this.pipes) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this.pipes) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || // readable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/pacote/node_modules/minizlib/index.js
var require_minizlib = __commonJS({
  "node_modules/pacote/node_modules/minizlib/index.js"(exports2) {
    "use strict";
    var assert = require("assert");
    var Buffer2 = require("buffer").Buffer;
    var realZlib = require("zlib");
    var constants = exports2.constants = require_constants2();
    var Minipass = require_minipass4();
    var OriginalBufferConcat = Buffer2.concat;
    var _superWrite = Symbol("_superWrite");
    var ZlibError = class extends Error {
      constructor(err) {
        super("zlib: " + err.message);
        this.code = err.code;
        this.errno = err.errno;
        if (!this.code)
          this.code = "ZLIB_ERROR";
        this.message = "zlib: " + err.message;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "ZlibError";
      }
    };
    var _opts = Symbol("opts");
    var _flushFlag = Symbol("flushFlag");
    var _finishFlushFlag = Symbol("finishFlushFlag");
    var _fullFlushFlag = Symbol("fullFlushFlag");
    var _handle = Symbol("handle");
    var _onError = Symbol("onError");
    var _sawError = Symbol("sawError");
    var _level = Symbol("level");
    var _strategy = Symbol("strategy");
    var _ended = Symbol("ended");
    var _defaultFullFlush = Symbol("_defaultFullFlush");
    var ZlibBase = class extends Minipass {
      constructor(opts, mode) {
        if (!opts || typeof opts !== "object")
          throw new TypeError("invalid options for ZlibBase constructor");
        super(opts);
        this[_sawError] = false;
        this[_ended] = false;
        this[_opts] = opts;
        this[_flushFlag] = opts.flush;
        this[_finishFlushFlag] = opts.finishFlush;
        try {
          this[_handle] = new realZlib[mode](opts);
        } catch (er) {
          throw new ZlibError(er);
        }
        this[_onError] = (err) => {
          if (this[_sawError])
            return;
          this[_sawError] = true;
          this.close();
          this.emit("error", err);
        };
        this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        this.once("end", () => this.close);
      }
      close() {
        if (this[_handle]) {
          this[_handle].close();
          this[_handle] = null;
          this.emit("close");
        }
      }
      reset() {
        if (!this[_sawError]) {
          assert(this[_handle], "zlib binding closed");
          return this[_handle].reset();
        }
      }
      flush(flushFlag) {
        if (this.ended)
          return;
        if (typeof flushFlag !== "number")
          flushFlag = this[_fullFlushFlag];
        this.write(Object.assign(Buffer2.alloc(0), { [_flushFlag]: flushFlag }));
      }
      end(chunk, encoding, cb) {
        if (chunk)
          this.write(chunk, encoding);
        this.flush(this[_finishFlushFlag]);
        this[_ended] = true;
        return super.end(null, null, cb);
      }
      get ended() {
        return this[_ended];
      }
      write(chunk, encoding, cb) {
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (typeof chunk === "string")
          chunk = Buffer2.from(chunk, encoding);
        if (this[_sawError])
          return;
        assert(this[_handle], "zlib binding closed");
        const nativeHandle = this[_handle]._handle;
        const originalNativeClose = nativeHandle.close;
        nativeHandle.close = () => {
        };
        const originalClose = this[_handle].close;
        this[_handle].close = () => {
        };
        Buffer2.concat = (args) => args;
        let result;
        try {
          const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
          result = this[_handle]._processChunk(chunk, flushFlag);
          Buffer2.concat = OriginalBufferConcat;
        } catch (err) {
          Buffer2.concat = OriginalBufferConcat;
          this[_onError](new ZlibError(err));
        } finally {
          if (this[_handle]) {
            this[_handle]._handle = nativeHandle;
            nativeHandle.close = originalNativeClose;
            this[_handle].close = originalClose;
            this[_handle].removeAllListeners("error");
          }
        }
        if (this[_handle])
          this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        let writeReturn;
        if (result) {
          if (Array.isArray(result) && result.length > 0) {
            writeReturn = this[_superWrite](Buffer2.from(result[0]));
            for (let i = 1; i < result.length; i++) {
              writeReturn = this[_superWrite](result[i]);
            }
          } else {
            writeReturn = this[_superWrite](Buffer2.from(result));
          }
        }
        if (cb)
          cb();
        return writeReturn;
      }
      [_superWrite](data) {
        return super.write(data);
      }
    };
    var Zlib = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.Z_NO_FLUSH;
        opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
        this[_level] = opts.level;
        this[_strategy] = opts.strategy;
      }
      params(level, strategy) {
        if (this[_sawError])
          return;
        if (!this[_handle])
          throw new Error("cannot switch params when binding is closed");
        if (!this[_handle].params)
          throw new Error("not supported in this implementation");
        if (this[_level] !== level || this[_strategy] !== strategy) {
          this.flush(constants.Z_SYNC_FLUSH);
          assert(this[_handle], "zlib binding closed");
          const origFlush = this[_handle].flush;
          this[_handle].flush = (flushFlag, cb) => {
            this.flush(flushFlag);
            cb();
          };
          try {
            this[_handle].params(level, strategy);
          } finally {
            this[_handle].flush = origFlush;
          }
          if (this[_handle]) {
            this[_level] = level;
            this[_strategy] = strategy;
          }
        }
      }
    };
    var Deflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Deflate");
      }
    };
    var Inflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Inflate");
      }
    };
    var _portable = Symbol("_portable");
    var Gzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gzip");
        this[_portable] = opts && !!opts.portable;
      }
      [_superWrite](data) {
        if (!this[_portable])
          return super[_superWrite](data);
        this[_portable] = false;
        data[9] = 255;
        return super[_superWrite](data);
      }
    };
    var Gunzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gunzip");
      }
    };
    var DeflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "DeflateRaw");
      }
    };
    var InflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "InflateRaw");
      }
    };
    var Unzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Unzip");
      }
    };
    var Brotli = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
        opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
      }
    };
    var BrotliCompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliCompress");
      }
    };
    var BrotliDecompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliDecompress");
      }
    };
    exports2.Deflate = Deflate;
    exports2.Inflate = Inflate;
    exports2.Gzip = Gzip;
    exports2.Gunzip = Gunzip;
    exports2.DeflateRaw = DeflateRaw;
    exports2.InflateRaw = InflateRaw;
    exports2.Unzip = Unzip;
    if (typeof realZlib.BrotliCompress === "function") {
      exports2.BrotliCompress = BrotliCompress;
      exports2.BrotliDecompress = BrotliDecompress;
    } else {
      exports2.BrotliCompress = exports2.BrotliDecompress = class {
        constructor() {
          throw new Error("Brotli is not supported in this version of Node.js");
        }
      };
    }
  }
});

// node_modules/pacote/node_modules/tar/lib/normalize-windows-path.js
var require_normalize_windows_path = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/normalize-windows-path.js"(exports2, module2) {
    var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    module2.exports = platform !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");
  }
});

// node_modules/pacote/node_modules/tar/lib/read-entry.js
var require_read_entry = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/read-entry.js"(exports2, module2) {
    "use strict";
    var { Minipass } = require_minipass3();
    var normPath = require_normalize_windows_path();
    var SLURP = Symbol("slurp");
    module2.exports = class ReadEntry extends Minipass {
      constructor(header, ex, gex) {
        super();
        this.pause();
        this.extended = ex;
        this.globalExtended = gex;
        this.header = header;
        this.startBlockSize = 512 * Math.ceil(header.size / 512);
        this.blockRemain = this.startBlockSize;
        this.remain = header.size;
        this.type = header.type;
        this.meta = false;
        this.ignore = false;
        switch (this.type) {
          case "File":
          case "OldFile":
          case "Link":
          case "SymbolicLink":
          case "CharacterDevice":
          case "BlockDevice":
          case "Directory":
          case "FIFO":
          case "ContiguousFile":
          case "GNUDumpDir":
            break;
          case "NextFileHasLongLinkpath":
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
          case "GlobalExtendedHeader":
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this.meta = true;
            break;
          // NOTE: gnutar and bsdtar treat unrecognized types as 'File'
          // it may be worth doing the same, but with a warning.
          default:
            this.ignore = true;
        }
        this.path = normPath(header.path);
        this.mode = header.mode;
        if (this.mode) {
          this.mode = this.mode & 4095;
        }
        this.uid = header.uid;
        this.gid = header.gid;
        this.uname = header.uname;
        this.gname = header.gname;
        this.size = header.size;
        this.mtime = header.mtime;
        this.atime = header.atime;
        this.ctime = header.ctime;
        this.linkpath = normPath(header.linkpath);
        this.uname = header.uname;
        this.gname = header.gname;
        if (ex) {
          this[SLURP](ex);
        }
        if (gex) {
          this[SLURP](gex, true);
        }
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain) {
          throw new Error("writing more to entry than is appropriate");
        }
        const r = this.remain;
        const br = this.blockRemain;
        this.remain = Math.max(0, r - writeLen);
        this.blockRemain = Math.max(0, br - writeLen);
        if (this.ignore) {
          return true;
        }
        if (r >= writeLen) {
          return super.write(data);
        }
        return super.write(data.slice(0, r));
      }
      [SLURP](ex, global2) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path")) {
            this[k] = k === "path" || k === "linkpath" ? normPath(ex[k]) : ex[k];
          }
        }
      }
    };
  }
});

// node_modules/pacote/node_modules/tar/lib/types.js
var require_types = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/types.js"(exports2) {
    "use strict";
    exports2.name = /* @__PURE__ */ new Map([
      ["0", "File"],
      // same as File
      ["", "OldFile"],
      ["1", "Link"],
      ["2", "SymbolicLink"],
      // Devices and FIFOs aren't fully supported
      // they are parsed, but skipped when unpacking
      ["3", "CharacterDevice"],
      ["4", "BlockDevice"],
      ["5", "Directory"],
      ["6", "FIFO"],
      // same as File
      ["7", "ContiguousFile"],
      // pax headers
      ["g", "GlobalExtendedHeader"],
      ["x", "ExtendedHeader"],
      // vendor-specific stuff
      // skip
      ["A", "SolarisACL"],
      // like 5, but with data, which should be skipped
      ["D", "GNUDumpDir"],
      // metadata only, skip
      ["I", "Inode"],
      // data = link path of next file
      ["K", "NextFileHasLongLinkpath"],
      // data = path of next file
      ["L", "NextFileHasLongPath"],
      // skip
      ["M", "ContinuationFile"],
      // like L
      ["N", "OldGnuLongPath"],
      // skip
      ["S", "SparseFile"],
      // skip
      ["V", "TapeVolumeHeader"],
      // like x
      ["X", "OldExtendedHeader"]
    ]);
    exports2.code = new Map(Array.from(exports2.name).map((kv) => [kv[1], kv[0]]));
  }
});

// node_modules/pacote/node_modules/tar/lib/large-numbers.js
var require_large_numbers = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/large-numbers.js"(exports2, module2) {
    "use strict";
    var encode = (num, buf) => {
      if (!Number.isSafeInteger(num)) {
        throw Error("cannot encode number outside of javascript safe integer range");
      } else if (num < 0) {
        encodeNegative(num, buf);
      } else {
        encodePositive(num, buf);
      }
      return buf;
    };
    var encodePositive = (num, buf) => {
      buf[0] = 128;
      for (var i = buf.length; i > 1; i--) {
        buf[i - 1] = num & 255;
        num = Math.floor(num / 256);
      }
    };
    var encodeNegative = (num, buf) => {
      buf[0] = 255;
      var flipped = false;
      num = num * -1;
      for (var i = buf.length; i > 1; i--) {
        var byte = num & 255;
        num = Math.floor(num / 256);
        if (flipped) {
          buf[i - 1] = onesComp(byte);
        } else if (byte === 0) {
          buf[i - 1] = 0;
        } else {
          flipped = true;
          buf[i - 1] = twosComp(byte);
        }
      }
    };
    var parse = (buf) => {
      const pre = buf[0];
      const value = pre === 128 ? pos(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
      if (value === null) {
        throw Error("invalid base256 encoding");
      }
      if (!Number.isSafeInteger(value)) {
        throw Error("parsed number outside of javascript safe integer range");
      }
      return value;
    };
    var twos = (buf) => {
      var len = buf.length;
      var sum = 0;
      var flipped = false;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        var f;
        if (flipped) {
          f = onesComp(byte);
        } else if (byte === 0) {
          f = byte;
        } else {
          flipped = true;
          f = twosComp(byte);
        }
        if (f !== 0) {
          sum -= f * Math.pow(256, len - i - 1);
        }
      }
      return sum;
    };
    var pos = (buf) => {
      var len = buf.length;
      var sum = 0;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        if (byte !== 0) {
          sum += byte * Math.pow(256, len - i - 1);
        }
      }
      return sum;
    };
    var onesComp = (byte) => (255 ^ byte) & 255;
    var twosComp = (byte) => (255 ^ byte) + 1 & 255;
    module2.exports = {
      encode,
      parse
    };
  }
});

// node_modules/pacote/node_modules/tar/lib/header.js
var require_header = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/header.js"(exports2, module2) {
    "use strict";
    var types = require_types();
    var pathModule = require("path").posix;
    var large = require_large_numbers();
    var SLURP = Symbol("slurp");
    var TYPE = Symbol("type");
    var Header = class {
      constructor(data, off, ex, gex) {
        this.cksumValid = false;
        this.needPax = false;
        this.nullBlock = false;
        this.block = null;
        this.path = null;
        this.mode = null;
        this.uid = null;
        this.gid = null;
        this.size = null;
        this.mtime = null;
        this.cksum = null;
        this[TYPE] = "0";
        this.linkpath = null;
        this.uname = null;
        this.gname = null;
        this.devmaj = 0;
        this.devmin = 0;
        this.atime = null;
        this.ctime = null;
        if (Buffer.isBuffer(data)) {
          this.decode(data, off || 0, ex, gex);
        } else if (data) {
          this.set(data);
        }
      }
      decode(buf, off, ex, gex) {
        if (!off) {
          off = 0;
        }
        if (!buf || !(buf.length >= off + 512)) {
          throw new Error("need 512 bytes for header");
        }
        this.path = decString(buf, off, 100);
        this.mode = decNumber(buf, off + 100, 8);
        this.uid = decNumber(buf, off + 108, 8);
        this.gid = decNumber(buf, off + 116, 8);
        this.size = decNumber(buf, off + 124, 12);
        this.mtime = decDate(buf, off + 136, 12);
        this.cksum = decNumber(buf, off + 148, 12);
        this[SLURP](ex);
        this[SLURP](gex, true);
        this[TYPE] = decString(buf, off + 156, 1);
        if (this[TYPE] === "") {
          this[TYPE] = "0";
        }
        if (this[TYPE] === "0" && this.path.slice(-1) === "/") {
          this[TYPE] = "5";
        }
        if (this[TYPE] === "5") {
          this.size = 0;
        }
        this.linkpath = decString(buf, off + 157, 100);
        if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
          this.uname = decString(buf, off + 265, 32);
          this.gname = decString(buf, off + 297, 32);
          this.devmaj = decNumber(buf, off + 329, 8);
          this.devmin = decNumber(buf, off + 337, 8);
          if (buf[off + 475] !== 0) {
            const prefix = decString(buf, off + 345, 155);
            this.path = prefix + "/" + this.path;
          } else {
            const prefix = decString(buf, off + 345, 130);
            if (prefix) {
              this.path = prefix + "/" + this.path;
            }
            this.atime = decDate(buf, off + 476, 12);
            this.ctime = decDate(buf, off + 488, 12);
          }
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++) {
          sum += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
          sum += buf[i];
        }
        this.cksumValid = sum === this.cksum;
        if (this.cksum === null && sum === 8 * 32) {
          this.nullBlock = true;
        }
      }
      [SLURP](ex, global2) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path")) {
            this[k] = ex[k];
          }
        }
      }
      encode(buf, off) {
        if (!buf) {
          buf = this.block = Buffer.alloc(512);
          off = 0;
        }
        if (!off) {
          off = 0;
        }
        if (!(buf.length >= off + 512)) {
          throw new Error("need 512 bytes for header");
        }
        const prefixSize = this.ctime || this.atime ? 130 : 155;
        const split = splitPrefix(this.path || "", prefixSize);
        const path = split[0];
        const prefix = split[1];
        this.needPax = split[2];
        this.needPax = encString(buf, off, 100, path) || this.needPax;
        this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
        this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
        this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
        this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
        this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
        buf[off + 156] = this[TYPE].charCodeAt(0);
        this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
        buf.write("ustar\x0000", off + 257, 8);
        this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
        this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
        this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
        this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
        this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
        if (buf[off + 475] !== 0) {
          this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
        } else {
          this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
          this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
          this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++) {
          sum += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
          sum += buf[i];
        }
        this.cksum = sum;
        encNumber(buf, off + 148, 8, this.cksum);
        this.cksumValid = true;
        return this.needPax;
      }
      set(data) {
        for (const i in data) {
          if (data[i] !== null && data[i] !== void 0) {
            this[i] = data[i];
          }
        }
      }
      get type() {
        return types.name.get(this[TYPE]) || this[TYPE];
      }
      get typeKey() {
        return this[TYPE];
      }
      set type(type) {
        if (types.code.has(type)) {
          this[TYPE] = types.code.get(type);
        } else {
          this[TYPE] = type;
        }
      }
    };
    var splitPrefix = (p, prefixSize) => {
      const pathSize = 100;
      let pp = p;
      let prefix = "";
      let ret;
      const root = pathModule.parse(p).root || ".";
      if (Buffer.byteLength(pp) < pathSize) {
        ret = [pp, prefix, false];
      } else {
        prefix = pathModule.dirname(pp);
        pp = pathModule.basename(pp);
        do {
          if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize) {
            ret = [pp, prefix, false];
          } else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize) {
            ret = [pp.slice(0, pathSize - 1), prefix, true];
          } else {
            pp = pathModule.join(pathModule.basename(prefix), pp);
            prefix = pathModule.dirname(prefix);
          }
        } while (prefix !== root && !ret);
        if (!ret) {
          ret = [p.slice(0, pathSize - 1), "", true];
        }
      }
      return ret;
    };
    var decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
    var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
    var numToDate = (num) => num === null ? null : new Date(num * 1e3);
    var decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
    var nanNull = (value) => isNaN(value) ? null : value;
    var decSmallNumber = (buf, off, size) => nanNull(parseInt(
      buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(),
      8
    ));
    var MAXNUM = {
      12: 8589934591,
      8: 2097151
    };
    var encNumber = (buf, off, size, number) => number === null ? false : number > MAXNUM[size] || number < 0 ? (large.encode(number, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number), false);
    var encSmallNumber = (buf, off, size, number) => buf.write(octalString(number, size), off, size, "ascii");
    var octalString = (number, size) => padOctal(Math.floor(number).toString(8), size);
    var padOctal = (string, size) => (string.length === size - 1 ? string : new Array(size - string.length - 1).join("0") + string + " ") + "\0";
    var encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1e3);
    var NULLS = new Array(156).join("\0");
    var encString = (buf, off, size, string) => string === null ? false : (buf.write(string + NULLS, off, size, "utf8"), string.length !== Buffer.byteLength(string) || string.length > size);
    module2.exports = Header;
  }
});

// node_modules/pacote/node_modules/tar/lib/pax.js
var require_pax = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/pax.js"(exports2, module2) {
    "use strict";
    var Header = require_header();
    var path = require("path");
    var Pax = class {
      constructor(obj, global2) {
        this.atime = obj.atime || null;
        this.charset = obj.charset || null;
        this.comment = obj.comment || null;
        this.ctime = obj.ctime || null;
        this.gid = obj.gid || null;
        this.gname = obj.gname || null;
        this.linkpath = obj.linkpath || null;
        this.mtime = obj.mtime || null;
        this.path = obj.path || null;
        this.size = obj.size || null;
        this.uid = obj.uid || null;
        this.uname = obj.uname || null;
        this.dev = obj.dev || null;
        this.ino = obj.ino || null;
        this.nlink = obj.nlink || null;
        this.global = global2 || false;
      }
      encode() {
        const body = this.encodeBody();
        if (body === "") {
          return null;
        }
        const bodyLen = Buffer.byteLength(body);
        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
        const buf = Buffer.allocUnsafe(bufLen);
        for (let i = 0; i < 512; i++) {
          buf[i] = 0;
        }
        new Header({
          // XXX split the path
          // then the path should be PaxHeader + basename, but less than 99,
          // prepend with the dirname
          path: ("PaxHeader/" + path.basename(this.path)).slice(0, 99),
          mode: this.mode || 420,
          uid: this.uid || null,
          gid: this.gid || null,
          size: bodyLen,
          mtime: this.mtime || null,
          type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
          linkpath: "",
          uname: this.uname || "",
          gname: this.gname || "",
          devmaj: 0,
          devmin: 0,
          atime: this.atime || null,
          ctime: this.ctime || null
        }).encode(buf);
        buf.write(body, 512, bodyLen, "utf8");
        for (let i = bodyLen + 512; i < buf.length; i++) {
          buf[i] = 0;
        }
        return buf;
      }
      encodeBody() {
        return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
      }
      encodeField(field) {
        if (this[field] === null || this[field] === void 0) {
          return "";
        }
        const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
        const s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
        const byteLen = Buffer.byteLength(s);
        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
        if (byteLen + digits >= Math.pow(10, digits)) {
          digits += 1;
        }
        const len = digits + byteLen;
        return len + s;
      }
    };
    Pax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g);
    var merge = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a;
    var parseKV = (string) => string.replace(/\n$/, "").split("\n").reduce(parseKVLine, /* @__PURE__ */ Object.create(null));
    var parseKVLine = (set, line) => {
      const n = parseInt(line, 10);
      if (n !== Buffer.byteLength(line) + 1) {
        return set;
      }
      line = line.slice((n + " ").length);
      const kv = line.split("=");
      const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
      if (!k) {
        return set;
      }
      const v = kv.join("=");
      set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
      return set;
    };
    module2.exports = Pax;
  }
});

// node_modules/pacote/node_modules/tar/lib/strip-trailing-slashes.js
var require_strip_trailing_slashes = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/strip-trailing-slashes.js"(exports2, module2) {
    module2.exports = (str) => {
      let i = str.length - 1;
      let slashesStart = -1;
      while (i > -1 && str.charAt(i) === "/") {
        slashesStart = i;
        i--;
      }
      return slashesStart === -1 ? str : str.slice(0, slashesStart);
    };
  }
});

// node_modules/pacote/node_modules/tar/lib/warn-mixin.js
var require_warn_mixin = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/warn-mixin.js"(exports2, module2) {
    "use strict";
    module2.exports = (Base) => class extends Base {
      warn(code, message, data = {}) {
        if (this.file) {
          data.file = this.file;
        }
        if (this.cwd) {
          data.cwd = this.cwd;
        }
        data.code = message instanceof Error && message.code || code;
        data.tarCode = code;
        if (!this.strict && data.recoverable !== false) {
          if (message instanceof Error) {
            data = Object.assign(message, data);
            message = message.message;
          }
          this.emit("warn", data.tarCode, message, data);
        } else if (message instanceof Error) {
          this.emit("error", Object.assign(message, data));
        } else {
          this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
        }
      }
    };
  }
});

// node_modules/pacote/node_modules/tar/lib/winchars.js
var require_winchars = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/winchars.js"(exports2, module2) {
    "use strict";
    var raw = [
      "|",
      "<",
      ">",
      "?",
      ":"
    ];
    var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
    var toWin = new Map(raw.map((char, i) => [char, win[i]]));
    var toRaw = new Map(win.map((char, i) => [char, raw[i]]));
    module2.exports = {
      encode: (s) => raw.reduce((s2, c) => s2.split(c).join(toWin.get(c)), s),
      decode: (s) => win.reduce((s2, c) => s2.split(c).join(toRaw.get(c)), s)
    };
  }
});

// node_modules/pacote/node_modules/tar/lib/strip-absolute-path.js
var require_strip_absolute_path = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/strip-absolute-path.js"(exports2, module2) {
    var { isAbsolute, parse } = require("path").win32;
    module2.exports = (path) => {
      let r = "";
      let parsed = parse(path);
      while (isAbsolute(path) || parsed.root) {
        const root = path.charAt(0) === "/" && path.slice(0, 4) !== "//?/" ? "/" : parsed.root;
        path = path.slice(root.length);
        r += root;
        parsed = parse(path);
      }
      return [r, path];
    };
  }
});

// node_modules/pacote/node_modules/tar/lib/mode-fix.js
var require_mode_fix = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/mode-fix.js"(exports2, module2) {
    "use strict";
    module2.exports = (mode, isDir, portable) => {
      mode &= 4095;
      if (portable) {
        mode = (mode | 384) & ~18;
      }
      if (isDir) {
        if (mode & 256) {
          mode |= 64;
        }
        if (mode & 32) {
          mode |= 8;
        }
        if (mode & 4) {
          mode |= 1;
        }
      }
      return mode;
    };
  }
});

// node_modules/pacote/node_modules/tar/lib/write-entry.js
var require_write_entry = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/write-entry.js"(exports2, module2) {
    "use strict";
    var { Minipass } = require_minipass3();
    var Pax = require_pax();
    var Header = require_header();
    var fs2 = require("fs");
    var path = require("path");
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var prefixPath = (path2, prefix) => {
      if (!prefix) {
        return normPath(path2);
      }
      path2 = normPath(path2).replace(/^\.(\/|$)/, "");
      return stripSlash(prefix) + "/" + path2;
    };
    var maxReadSize = 16 * 1024 * 1024;
    var PROCESS = Symbol("process");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var HEADER = Symbol("header");
    var READ = Symbol("read");
    var LSTAT = Symbol("lstat");
    var ONLSTAT = Symbol("onlstat");
    var ONREAD = Symbol("onread");
    var ONREADLINK = Symbol("onreadlink");
    var OPENFILE = Symbol("openfile");
    var ONOPENFILE = Symbol("onopenfile");
    var CLOSE = Symbol("close");
    var MODE = Symbol("mode");
    var AWAITDRAIN = Symbol("awaitDrain");
    var ONDRAIN = Symbol("ondrain");
    var PREFIX = Symbol("prefix");
    var HAD_ERROR = Symbol("hadError");
    var warner = require_warn_mixin();
    var winchars = require_winchars();
    var stripAbsolutePath = require_strip_absolute_path();
    var modeFix = require_mode_fix();
    var WriteEntry = warner(class WriteEntry extends Minipass {
      constructor(p, opt) {
        opt = opt || {};
        super(opt);
        if (typeof p !== "string") {
          throw new TypeError("path is required");
        }
        this.path = normPath(p);
        this.portable = !!opt.portable;
        this.myuid = process.getuid && process.getuid() || 0;
        this.myuser = process.env.USER || "";
        this.maxReadSize = opt.maxReadSize || maxReadSize;
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.preservePaths = !!opt.preservePaths;
        this.cwd = normPath(opt.cwd || process.cwd());
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.prefix = opt.prefix ? normPath(opt.prefix) : null;
        this.fd = null;
        this.blockLen = null;
        this.blockRemain = null;
        this.buf = null;
        this.offset = null;
        this.length = null;
        this.pos = null;
        this.remain = null;
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.win32 = !!opt.win32 || process.platform === "win32";
        if (this.win32) {
          this.path = winchars.decode(this.path.replace(/\\/g, "/"));
          p = p.replace(/\\/g, "/");
        }
        this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p));
        if (this.path === "") {
          this.path = "./";
        }
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.statCache.has(this.absolute)) {
          this[ONLSTAT](this.statCache.get(this.absolute));
        } else {
          this[LSTAT]();
        }
      }
      emit(ev, ...data) {
        if (ev === "error") {
          this[HAD_ERROR] = true;
        }
        return super.emit(ev, ...data);
      }
      [LSTAT]() {
        fs2.lstat(this.absolute, (er, stat) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONLSTAT](stat);
        });
      }
      [ONLSTAT](stat) {
        this.statCache.set(this.absolute, stat);
        this.stat = stat;
        if (!stat.isFile()) {
          stat.size = 0;
        }
        this.type = getType(stat);
        this.emit("stat", stat);
        this[PROCESS]();
      }
      [PROCESS]() {
        switch (this.type) {
          case "File":
            return this[FILE]();
          case "Directory":
            return this[DIRECTORY]();
          case "SymbolicLink":
            return this[SYMLINK]();
          // unsupported types are ignored.
          default:
            return this.end();
        }
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      [PREFIX](path2) {
        return prefixPath(path2, this.prefix);
      }
      [HEADER]() {
        if (this.type === "Directory" && this.portable) {
          this.noMtime = true;
        }
        this.header = new Header({
          path: this[PREFIX](this.path),
          // only apply the prefix to hard links.
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          // only the permissions and setuid/setgid/sticky bitflags
          // not the higher-order bits that specify file type
          mode: this[MODE](this.stat.mode),
          uid: this.portable ? null : this.stat.uid,
          gid: this.portable ? null : this.stat.gid,
          size: this.stat.size,
          mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
          type: this.type,
          uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
          atime: this.portable ? null : this.stat.atime,
          ctime: this.portable ? null : this.stat.ctime
        });
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.header.atime,
            ctime: this.portable ? null : this.header.ctime,
            gid: this.portable ? null : this.header.gid,
            mtime: this.noMtime ? null : this.mtime || this.header.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.header.size,
            uid: this.portable ? null : this.header.uid,
            uname: this.portable ? null : this.header.uname,
            dev: this.portable ? null : this.stat.dev,
            ino: this.portable ? null : this.stat.ino,
            nlink: this.portable ? null : this.stat.nlink
          }).encode());
        }
        super.write(this.header.block);
      }
      [DIRECTORY]() {
        if (this.path.slice(-1) !== "/") {
          this.path += "/";
        }
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [SYMLINK]() {
        fs2.readlink(this.absolute, (er, linkpath) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONREADLINK](linkpath);
        });
      }
      [ONREADLINK](linkpath) {
        this.linkpath = normPath(linkpath);
        this[HEADER]();
        this.end();
      }
      [HARDLINK](linkpath) {
        this.type = "Link";
        this.linkpath = normPath(path.relative(this.cwd, linkpath));
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [FILE]() {
        if (this.stat.nlink > 1) {
          const linkKey = this.stat.dev + ":" + this.stat.ino;
          if (this.linkCache.has(linkKey)) {
            const linkpath = this.linkCache.get(linkKey);
            if (linkpath.indexOf(this.cwd) === 0) {
              return this[HARDLINK](linkpath);
            }
          }
          this.linkCache.set(linkKey, this.absolute);
        }
        this[HEADER]();
        if (this.stat.size === 0) {
          return this.end();
        }
        this[OPENFILE]();
      }
      [OPENFILE]() {
        fs2.open(this.absolute, "r", (er, fd) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONOPENFILE](fd);
        });
      }
      [ONOPENFILE](fd) {
        this.fd = fd;
        if (this[HAD_ERROR]) {
          return this[CLOSE]();
        }
        this.blockLen = 512 * Math.ceil(this.stat.size / 512);
        this.blockRemain = this.blockLen;
        const bufLen = Math.min(this.blockLen, this.maxReadSize);
        this.buf = Buffer.allocUnsafe(bufLen);
        this.offset = 0;
        this.pos = 0;
        this.remain = this.stat.size;
        this.length = this.buf.length;
        this[READ]();
      }
      [READ]() {
        const { fd, buf, offset, length, pos } = this;
        fs2.read(fd, buf, offset, length, pos, (er, bytesRead) => {
          if (er) {
            return this[CLOSE](() => this.emit("error", er));
          }
          this[ONREAD](bytesRead);
        });
      }
      [CLOSE](cb) {
        fs2.close(this.fd, cb);
      }
      [ONREAD](bytesRead) {
        if (bytesRead <= 0 && this.remain > 0) {
          const er = new Error("encountered unexpected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead > this.remain) {
          const er = new Error("did not encounter expected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead === this.remain) {
          for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
            this.buf[i + this.offset] = 0;
            bytesRead++;
            this.remain++;
          }
        }
        const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
        const flushed = this.write(writeBuf);
        if (!flushed) {
          this[AWAITDRAIN](() => this[ONDRAIN]());
        } else {
          this[ONDRAIN]();
        }
      }
      [AWAITDRAIN](cb) {
        this.once("drain", cb);
      }
      write(writeBuf) {
        if (this.blockRemain < writeBuf.length) {
          const er = new Error("writing more data than expected");
          er.path = this.absolute;
          return this.emit("error", er);
        }
        this.remain -= writeBuf.length;
        this.blockRemain -= writeBuf.length;
        this.pos += writeBuf.length;
        this.offset += writeBuf.length;
        return super.write(writeBuf);
      }
      [ONDRAIN]() {
        if (!this.remain) {
          if (this.blockRemain) {
            super.write(Buffer.alloc(this.blockRemain));
          }
          return this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
        }
        if (this.offset >= this.length) {
          this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
          this.offset = 0;
        }
        this.length = this.buf.length - this.offset;
        this[READ]();
      }
    });
    var WriteEntrySync = class extends WriteEntry {
      [LSTAT]() {
        this[ONLSTAT](fs2.lstatSync(this.absolute));
      }
      [SYMLINK]() {
        this[ONREADLINK](fs2.readlinkSync(this.absolute));
      }
      [OPENFILE]() {
        this[ONOPENFILE](fs2.openSync(this.absolute, "r"));
      }
      [READ]() {
        let threw = true;
        try {
          const { fd, buf, offset, length, pos } = this;
          const bytesRead = fs2.readSync(fd, buf, offset, length, pos);
          this[ONREAD](bytesRead);
          threw = false;
        } finally {
          if (threw) {
            try {
              this[CLOSE](() => {
              });
            } catch (er) {
            }
          }
        }
      }
      [AWAITDRAIN](cb) {
        cb();
      }
      [CLOSE](cb) {
        fs2.closeSync(this.fd);
        cb();
      }
    };
    var WriteEntryTar = warner(class WriteEntryTar extends Minipass {
      constructor(readEntry, opt) {
        opt = opt || {};
        super(opt);
        this.preservePaths = !!opt.preservePaths;
        this.portable = !!opt.portable;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.readEntry = readEntry;
        this.type = readEntry.type;
        if (this.type === "Directory" && this.portable) {
          this.noMtime = true;
        }
        this.prefix = opt.prefix || null;
        this.path = normPath(readEntry.path);
        this.mode = this[MODE](readEntry.mode);
        this.uid = this.portable ? null : readEntry.uid;
        this.gid = this.portable ? null : readEntry.gid;
        this.uname = this.portable ? null : readEntry.uname;
        this.gname = this.portable ? null : readEntry.gname;
        this.size = readEntry.size;
        this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
        this.atime = this.portable ? null : readEntry.atime;
        this.ctime = this.portable ? null : readEntry.ctime;
        this.linkpath = normPath(readEntry.linkpath);
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.remain = readEntry.size;
        this.blockRemain = readEntry.startBlockSize;
        this.header = new Header({
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          // only the permissions and setuid/setgid/sticky bitflags
          // not the higher-order bits that specify file type
          mode: this.mode,
          uid: this.portable ? null : this.uid,
          gid: this.portable ? null : this.gid,
          size: this.size,
          mtime: this.noMtime ? null : this.mtime,
          type: this.type,
          uname: this.portable ? null : this.uname,
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime
        });
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.atime,
            ctime: this.portable ? null : this.ctime,
            gid: this.portable ? null : this.gid,
            mtime: this.noMtime ? null : this.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.size,
            uid: this.portable ? null : this.uid,
            uname: this.portable ? null : this.uname,
            dev: this.portable ? null : this.readEntry.dev,
            ino: this.portable ? null : this.readEntry.ino,
            nlink: this.portable ? null : this.readEntry.nlink
          }).encode());
        }
        super.write(this.header.block);
        readEntry.pipe(this);
      }
      [PREFIX](path2) {
        return prefixPath(path2, this.prefix);
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain) {
          throw new Error("writing more to entry than is appropriate");
        }
        this.blockRemain -= writeLen;
        return super.write(data);
      }
      end() {
        if (this.blockRemain) {
          super.write(Buffer.alloc(this.blockRemain));
        }
        return super.end();
      }
    });
    WriteEntry.Sync = WriteEntrySync;
    WriteEntry.Tar = WriteEntryTar;
    var getType = (stat) => stat.isFile() ? "File" : stat.isDirectory() ? "Directory" : stat.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
    module2.exports = WriteEntry;
  }
});

// node_modules/pacote/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/pacote/node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/pacote/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/pacote/node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self = this;
      if (!(self instanceof Yallist)) {
        self = new Yallist();
      }
      self.tail = null;
      self.head = null;
      self.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self.push(arguments[i]);
        }
      }
      return self;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self, node, value) {
      var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
      if (inserted.next === null) {
        self.tail = inserted;
      }
      if (inserted.prev === null) {
        self.head = inserted;
      }
      self.length++;
      return inserted;
    }
    function push(self, item) {
      self.tail = new Node(item, self.tail, null, self);
      if (!self.head) {
        self.head = self.tail;
      }
      self.length++;
    }
    function unshift(self, item) {
      self.head = new Node(item, null, self.head, self);
      if (!self.tail) {
        self.tail = self.head;
      }
      self.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/pacote/node_modules/tar/lib/pack.js
var require_pack = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/pack.js"(exports2, module2) {
    "use strict";
    var PackJob = class {
      constructor(path2, absolute) {
        this.path = path2 || "./";
        this.absolute = absolute;
        this.entry = null;
        this.stat = null;
        this.readdir = null;
        this.pending = false;
        this.ignore = false;
        this.piped = false;
      }
    };
    var { Minipass } = require_minipass3();
    var zlib = require_minizlib();
    var ReadEntry = require_read_entry();
    var WriteEntry = require_write_entry();
    var WriteEntrySync = WriteEntry.Sync;
    var WriteEntryTar = WriteEntry.Tar;
    var Yallist = require_yallist();
    var EOF = Buffer.alloc(1024);
    var ONSTAT = Symbol("onStat");
    var ENDED = Symbol("ended");
    var QUEUE = Symbol("queue");
    var CURRENT = Symbol("current");
    var PROCESS = Symbol("process");
    var PROCESSING = Symbol("processing");
    var PROCESSJOB = Symbol("processJob");
    var JOBS = Symbol("jobs");
    var JOBDONE = Symbol("jobDone");
    var ADDFSENTRY = Symbol("addFSEntry");
    var ADDTARENTRY = Symbol("addTarEntry");
    var STAT = Symbol("stat");
    var READDIR = Symbol("readdir");
    var ONREADDIR = Symbol("onreaddir");
    var PIPE = Symbol("pipe");
    var ENTRY = Symbol("entry");
    var ENTRYOPT = Symbol("entryOpt");
    var WRITEENTRYCLASS = Symbol("writeEntryClass");
    var WRITE = Symbol("write");
    var ONDRAIN = Symbol("ondrain");
    var fs2 = require("fs");
    var path = require("path");
    var warner = require_warn_mixin();
    var normPath = require_normalize_windows_path();
    var Pack = warner(class Pack extends Minipass {
      constructor(opt) {
        super(opt);
        opt = opt || /* @__PURE__ */ Object.create(null);
        this.opt = opt;
        this.file = opt.file || "";
        this.cwd = opt.cwd || process.cwd();
        this.maxReadSize = opt.maxReadSize;
        this.preservePaths = !!opt.preservePaths;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.prefix = normPath(opt.prefix || "");
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.readdirCache = opt.readdirCache || /* @__PURE__ */ new Map();
        this[WRITEENTRYCLASS] = WriteEntry;
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        this.portable = !!opt.portable;
        this.zip = null;
        if (opt.gzip || opt.brotli) {
          if (opt.gzip && opt.brotli) {
            throw new TypeError("gzip and brotli are mutually exclusive");
          }
          if (opt.gzip) {
            if (typeof opt.gzip !== "object") {
              opt.gzip = {};
            }
            if (this.portable) {
              opt.gzip.portable = true;
            }
            this.zip = new zlib.Gzip(opt.gzip);
          }
          if (opt.brotli) {
            if (typeof opt.brotli !== "object") {
              opt.brotli = {};
            }
            this.zip = new zlib.BrotliCompress(opt.brotli);
          }
          this.zip.on("data", (chunk) => super.write(chunk));
          this.zip.on("end", (_) => super.end());
          this.zip.on("drain", (_) => this[ONDRAIN]());
          this.on("resume", (_) => this.zip.resume());
        } else {
          this.on("drain", this[ONDRAIN]);
        }
        this.noDirRecurse = !!opt.noDirRecurse;
        this.follow = !!opt.follow;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;
        this[QUEUE] = new Yallist();
        this[JOBS] = 0;
        this.jobs = +opt.jobs || 4;
        this[PROCESSING] = false;
        this[ENDED] = false;
      }
      [WRITE](chunk) {
        return super.write(chunk);
      }
      add(path2) {
        this.write(path2);
        return this;
      }
      end(path2) {
        if (path2) {
          this.write(path2);
        }
        this[ENDED] = true;
        this[PROCESS]();
        return this;
      }
      write(path2) {
        if (this[ENDED]) {
          throw new Error("write after end");
        }
        if (path2 instanceof ReadEntry) {
          this[ADDTARENTRY](path2);
        } else {
          this[ADDFSENTRY](path2);
        }
        return this.flowing;
      }
      [ADDTARENTRY](p) {
        const absolute = normPath(path.resolve(this.cwd, p.path));
        if (!this.filter(p.path, p)) {
          p.resume();
        } else {
          const job = new PackJob(p.path, absolute, false);
          job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
          job.entry.on("end", (_) => this[JOBDONE](job));
          this[JOBS] += 1;
          this[QUEUE].push(job);
        }
        this[PROCESS]();
      }
      [ADDFSENTRY](p) {
        const absolute = normPath(path.resolve(this.cwd, p));
        this[QUEUE].push(new PackJob(p, absolute));
        this[PROCESS]();
      }
      [STAT](job) {
        job.pending = true;
        this[JOBS] += 1;
        const stat = this.follow ? "stat" : "lstat";
        fs2[stat](job.absolute, (er, stat2) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er) {
            this.emit("error", er);
          } else {
            this[ONSTAT](job, stat2);
          }
        });
      }
      [ONSTAT](job, stat) {
        this.statCache.set(job.absolute, stat);
        job.stat = stat;
        if (!this.filter(job.path, stat)) {
          job.ignore = true;
        }
        this[PROCESS]();
      }
      [READDIR](job) {
        job.pending = true;
        this[JOBS] += 1;
        fs2.readdir(job.absolute, (er, entries) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er) {
            return this.emit("error", er);
          }
          this[ONREADDIR](job, entries);
        });
      }
      [ONREADDIR](job, entries) {
        this.readdirCache.set(job.absolute, entries);
        job.readdir = entries;
        this[PROCESS]();
      }
      [PROCESS]() {
        if (this[PROCESSING]) {
          return;
        }
        this[PROCESSING] = true;
        for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {
          this[PROCESSJOB](w.value);
          if (w.value.ignore) {
            const p = w.next;
            this[QUEUE].removeNode(w);
            w.next = p;
          }
        }
        this[PROCESSING] = false;
        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
          if (this.zip) {
            this.zip.end(EOF);
          } else {
            super.write(EOF);
            super.end();
          }
        }
      }
      get [CURRENT]() {
        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
      }
      [JOBDONE](job) {
        this[QUEUE].shift();
        this[JOBS] -= 1;
        this[PROCESS]();
      }
      [PROCESSJOB](job) {
        if (job.pending) {
          return;
        }
        if (job.entry) {
          if (job === this[CURRENT] && !job.piped) {
            this[PIPE](job);
          }
          return;
        }
        if (!job.stat) {
          if (this.statCache.has(job.absolute)) {
            this[ONSTAT](job, this.statCache.get(job.absolute));
          } else {
            this[STAT](job);
          }
        }
        if (!job.stat) {
          return;
        }
        if (job.ignore) {
          return;
        }
        if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
          if (this.readdirCache.has(job.absolute)) {
            this[ONREADDIR](job, this.readdirCache.get(job.absolute));
          } else {
            this[READDIR](job);
          }
          if (!job.readdir) {
            return;
          }
        }
        job.entry = this[ENTRY](job);
        if (!job.entry) {
          job.ignore = true;
          return;
        }
        if (job === this[CURRENT] && !job.piped) {
          this[PIPE](job);
        }
      }
      [ENTRYOPT](job) {
        return {
          onwarn: (code, msg, data) => this.warn(code, msg, data),
          noPax: this.noPax,
          cwd: this.cwd,
          absolute: job.absolute,
          preservePaths: this.preservePaths,
          maxReadSize: this.maxReadSize,
          strict: this.strict,
          portable: this.portable,
          linkCache: this.linkCache,
          statCache: this.statCache,
          noMtime: this.noMtime,
          mtime: this.mtime,
          prefix: this.prefix
        };
      }
      [ENTRY](job) {
        this[JOBS] += 1;
        try {
          return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
        } catch (er) {
          this.emit("error", er);
        }
      }
      [ONDRAIN]() {
        if (this[CURRENT] && this[CURRENT].entry) {
          this[CURRENT].entry.resume();
        }
      }
      // like .pipe() but using super, because our write() is special
      [PIPE](job) {
        job.piped = true;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        const source = job.entry;
        const zip = this.zip;
        if (zip) {
          source.on("data", (chunk) => {
            if (!zip.write(chunk)) {
              source.pause();
            }
          });
        } else {
          source.on("data", (chunk) => {
            if (!super.write(chunk)) {
              source.pause();
            }
          });
        }
      }
      pause() {
        if (this.zip) {
          this.zip.pause();
        }
        return super.pause();
      }
    });
    var PackSync = class extends Pack {
      constructor(opt) {
        super(opt);
        this[WRITEENTRYCLASS] = WriteEntrySync;
      }
      // pause/resume are no-ops in sync streams.
      pause() {
      }
      resume() {
      }
      [STAT](job) {
        const stat = this.follow ? "statSync" : "lstatSync";
        this[ONSTAT](job, fs2[stat](job.absolute));
      }
      [READDIR](job, stat) {
        this[ONREADDIR](job, fs2.readdirSync(job.absolute));
      }
      // gotta get it all in this tick
      [PIPE](job) {
        const source = job.entry;
        const zip = this.zip;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        if (zip) {
          source.on("data", (chunk) => {
            zip.write(chunk);
          });
        } else {
          source.on("data", (chunk) => {
            super[WRITE](chunk);
          });
        }
      }
    };
    Pack.Sync = PackSync;
    module2.exports = Pack;
  }
});

// node_modules/pacote/node_modules/tar/node_modules/fs-minipass/node_modules/minipass/index.js
var require_minipass5 = __commonJS({
  "node_modules/pacote/node_modules/tar/node_modules/fs-minipass/node_modules/minipass/index.js"(exports2, module2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    module2.exports = class Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = [this.buffer.join("")];
          else
            this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer[0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this.pipes.find((p2) => p2.dest === dest);
        if (p) {
          this.pipes.splice(this.pipes.indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          const ret2 = super.emit("error", data);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this.pipes) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this.pipes) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this.pipes) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || // readable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/pacote/node_modules/tar/node_modules/fs-minipass/index.js
var require_fs_minipass = __commonJS({
  "node_modules/pacote/node_modules/tar/node_modules/fs-minipass/index.js"(exports2) {
    "use strict";
    var MiniPass = require_minipass5();
    var EE = require("events").EventEmitter;
    var fs2 = require("fs");
    var writev = fs2.writev;
    if (!writev) {
      const binding = process.binding("fs");
      const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
      writev = (fd, iovec, pos, cb) => {
        const done = (er, bw) => cb(er, bw, iovec);
        const req = new FSReqWrap();
        req.oncomplete = done;
        binding.writeBuffers(fd, iovec, pos, req);
      };
    }
    var _autoClose = Symbol("_autoClose");
    var _close = Symbol("_close");
    var _ended = Symbol("_ended");
    var _fd = Symbol("_fd");
    var _finished = Symbol("_finished");
    var _flags = Symbol("_flags");
    var _flush = Symbol("_flush");
    var _handleChunk = Symbol("_handleChunk");
    var _makeBuf = Symbol("_makeBuf");
    var _mode = Symbol("_mode");
    var _needDrain = Symbol("_needDrain");
    var _onerror = Symbol("_onerror");
    var _onopen = Symbol("_onopen");
    var _onread = Symbol("_onread");
    var _onwrite = Symbol("_onwrite");
    var _open = Symbol("_open");
    var _path = Symbol("_path");
    var _pos = Symbol("_pos");
    var _queue = Symbol("_queue");
    var _read = Symbol("_read");
    var _readSize = Symbol("_readSize");
    var _reading = Symbol("_reading");
    var _remain = Symbol("_remain");
    var _size = Symbol("_size");
    var _write = Symbol("_write");
    var _writing = Symbol("_writing");
    var _defaultFlag = Symbol("_defaultFlag");
    var _errored = Symbol("_errored");
    var ReadStream = class extends MiniPass {
      constructor(path, opt) {
        opt = opt || {};
        super(opt);
        this.readable = true;
        this.writable = false;
        if (typeof path !== "string")
          throw new TypeError("path must be a string");
        this[_errored] = false;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_path] = path;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        if (typeof this[_fd] === "number")
          this[_read]();
        else
          this[_open]();
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      write() {
        throw new TypeError("this is a readable stream");
      }
      end() {
        throw new TypeError("this is a readable stream");
      }
      [_open]() {
        fs2.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_read]();
        }
      }
      [_makeBuf]() {
        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
      }
      [_read]() {
        if (!this[_reading]) {
          this[_reading] = true;
          const buf = this[_makeBuf]();
          if (buf.length === 0)
            return process.nextTick(() => this[_onread](null, 0, buf));
          fs2.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
        }
      }
      [_onread](er, br, buf) {
        this[_reading] = false;
        if (er)
          this[_onerror](er);
        else if (this[_handleChunk](br, buf))
          this[_read]();
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
      [_onerror](er) {
        this[_reading] = true;
        this[_close]();
        this.emit("error", er);
      }
      [_handleChunk](br, buf) {
        let ret = false;
        this[_remain] -= br;
        if (br > 0)
          ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
        if (br === 0 || this[_remain] <= 0) {
          ret = false;
          this[_close]();
          super.end();
        }
        return ret;
      }
      emit(ev, data) {
        switch (ev) {
          case "prefinish":
          case "finish":
            break;
          case "drain":
            if (typeof this[_fd] === "number")
              this[_read]();
            break;
          case "error":
            if (this[_errored])
              return;
            this[_errored] = true;
            return super.emit(ev, data);
          default:
            return super.emit(ev, data);
        }
      }
    };
    var ReadStreamSync = class extends ReadStream {
      [_open]() {
        let threw = true;
        try {
          this[_onopen](null, fs2.openSync(this[_path], "r"));
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_read]() {
        let threw = true;
        try {
          if (!this[_reading]) {
            this[_reading] = true;
            do {
              const buf = this[_makeBuf]();
              const br = buf.length === 0 ? 0 : fs2.readSync(this[_fd], buf, 0, buf.length, null);
              if (!this[_handleChunk](br, buf))
                break;
            } while (true);
            this[_reading] = false;
          }
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.closeSync(fd);
          this.emit("close");
        }
      }
    };
    var WriteStream = class extends EE {
      constructor(path, opt) {
        opt = opt || {};
        super(opt);
        this.readable = false;
        this.writable = true;
        this[_errored] = false;
        this[_writing] = false;
        this[_ended] = false;
        this[_needDrain] = false;
        this[_queue] = [];
        this[_path] = path;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
        this[_pos] = typeof opt.start === "number" ? opt.start : null;
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        const defaultFlag = this[_pos] !== null ? "r+" : "w";
        this[_defaultFlag] = opt.flags === void 0;
        this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
        if (this[_fd] === null)
          this[_open]();
      }
      emit(ev, data) {
        if (ev === "error") {
          if (this[_errored])
            return;
          this[_errored] = true;
        }
        return super.emit(ev, data);
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      [_onerror](er) {
        this[_close]();
        this[_writing] = true;
        this.emit("error", er);
      }
      [_open]() {
        fs2.open(
          this[_path],
          this[_flags],
          this[_mode],
          (er, fd) => this[_onopen](er, fd)
        );
      }
      [_onopen](er, fd) {
        if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
          this[_flags] = "w";
          this[_open]();
        } else if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_flush]();
        }
      }
      end(buf, enc) {
        if (buf)
          this.write(buf, enc);
        this[_ended] = true;
        if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
          this[_onwrite](null, 0);
        return this;
      }
      write(buf, enc) {
        if (typeof buf === "string")
          buf = Buffer.from(buf, enc);
        if (this[_ended]) {
          this.emit("error", new Error("write() after end()"));
          return false;
        }
        if (this[_fd] === null || this[_writing] || this[_queue].length) {
          this[_queue].push(buf);
          this[_needDrain] = true;
          return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
      }
      [_write](buf) {
        fs2.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
      [_onwrite](er, bw) {
        if (er)
          this[_onerror](er);
        else {
          if (this[_pos] !== null)
            this[_pos] += bw;
          if (this[_queue].length)
            this[_flush]();
          else {
            this[_writing] = false;
            if (this[_ended] && !this[_finished]) {
              this[_finished] = true;
              this[_close]();
              this.emit("finish");
            } else if (this[_needDrain]) {
              this[_needDrain] = false;
              this.emit("drain");
            }
          }
        }
      }
      [_flush]() {
        if (this[_queue].length === 0) {
          if (this[_ended])
            this[_onwrite](null, 0);
        } else if (this[_queue].length === 1)
          this[_write](this[_queue].pop());
        else {
          const iovec = this[_queue];
          this[_queue] = [];
          writev(
            this[_fd],
            iovec,
            this[_pos],
            (er, bw) => this[_onwrite](er, bw)
          );
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
    };
    var WriteStreamSync = class extends WriteStream {
      [_open]() {
        let fd;
        if (this[_defaultFlag] && this[_flags] === "r+") {
          try {
            fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
          } catch (er) {
            if (er.code === "ENOENT") {
              this[_flags] = "w";
              return this[_open]();
            } else
              throw er;
          }
        } else
          fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
        this[_onopen](null, fd);
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.closeSync(fd);
          this.emit("close");
        }
      }
      [_write](buf) {
        let threw = true;
        try {
          this[_onwrite](
            null,
            fs2.writeSync(this[_fd], buf, 0, buf.length, this[_pos])
          );
          threw = false;
        } finally {
          if (threw)
            try {
              this[_close]();
            } catch (_) {
            }
        }
      }
    };
    exports2.ReadStream = ReadStream;
    exports2.ReadStreamSync = ReadStreamSync;
    exports2.WriteStream = WriteStream;
    exports2.WriteStreamSync = WriteStreamSync;
  }
});

// node_modules/pacote/node_modules/tar/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/parse.js"(exports2, module2) {
    "use strict";
    var warner = require_warn_mixin();
    var Header = require_header();
    var EE = require("events");
    var Yallist = require_yallist();
    var maxMetaEntrySize = 1024 * 1024;
    var Entry = require_read_entry();
    var Pax = require_pax();
    var zlib = require_minizlib();
    var { nextTick } = require("process");
    var gzipHeader = Buffer.from([31, 139]);
    var STATE = Symbol("state");
    var WRITEENTRY = Symbol("writeEntry");
    var READENTRY = Symbol("readEntry");
    var NEXTENTRY = Symbol("nextEntry");
    var PROCESSENTRY = Symbol("processEntry");
    var EX = Symbol("extendedHeader");
    var GEX = Symbol("globalExtendedHeader");
    var META = Symbol("meta");
    var EMITMETA = Symbol("emitMeta");
    var BUFFER = Symbol("buffer");
    var QUEUE = Symbol("queue");
    var ENDED = Symbol("ended");
    var EMITTEDEND = Symbol("emittedEnd");
    var EMIT = Symbol("emit");
    var UNZIP = Symbol("unzip");
    var CONSUMECHUNK = Symbol("consumeChunk");
    var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
    var CONSUMEBODY = Symbol("consumeBody");
    var CONSUMEMETA = Symbol("consumeMeta");
    var CONSUMEHEADER = Symbol("consumeHeader");
    var CONSUMING = Symbol("consuming");
    var BUFFERCONCAT = Symbol("bufferConcat");
    var MAYBEEND = Symbol("maybeEnd");
    var WRITING = Symbol("writing");
    var ABORTED = Symbol("aborted");
    var DONE = Symbol("onDone");
    var SAW_VALID_ENTRY = Symbol("sawValidEntry");
    var SAW_NULL_BLOCK = Symbol("sawNullBlock");
    var SAW_EOF = Symbol("sawEOF");
    var CLOSESTREAM = Symbol("closeStream");
    var noop = (_) => true;
    module2.exports = warner(class Parser extends EE {
      constructor(opt) {
        opt = opt || {};
        super(opt);
        this.file = opt.file || "";
        this[SAW_VALID_ENTRY] = null;
        this.on(DONE, (_) => {
          if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
            this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
          }
        });
        if (opt.ondone) {
          this.on(DONE, opt.ondone);
        } else {
          this.on(DONE, (_) => {
            this.emit("prefinish");
            this.emit("finish");
            this.emit("end");
          });
        }
        this.strict = !!opt.strict;
        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
        this.filter = typeof opt.filter === "function" ? opt.filter : noop;
        const isTBR = opt.file && (opt.file.endsWith(".tar.br") || opt.file.endsWith(".tbr"));
        this.brotli = !opt.gzip && opt.brotli !== void 0 ? opt.brotli : isTBR ? void 0 : false;
        this.writable = true;
        this.readable = false;
        this[QUEUE] = new Yallist();
        this[BUFFER] = null;
        this[READENTRY] = null;
        this[WRITEENTRY] = null;
        this[STATE] = "begin";
        this[META] = "";
        this[EX] = null;
        this[GEX] = null;
        this[ENDED] = false;
        this[UNZIP] = null;
        this[ABORTED] = false;
        this[SAW_NULL_BLOCK] = false;
        this[SAW_EOF] = false;
        this.on("end", () => this[CLOSESTREAM]());
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        if (typeof opt.onentry === "function") {
          this.on("entry", opt.onentry);
        }
      }
      [CONSUMEHEADER](chunk, position) {
        if (this[SAW_VALID_ENTRY] === null) {
          this[SAW_VALID_ENTRY] = false;
        }
        let header;
        try {
          header = new Header(chunk, position, this[EX], this[GEX]);
        } catch (er) {
          return this.warn("TAR_ENTRY_INVALID", er);
        }
        if (header.nullBlock) {
          if (this[SAW_NULL_BLOCK]) {
            this[SAW_EOF] = true;
            if (this[STATE] === "begin") {
              this[STATE] = "header";
            }
            this[EMIT]("eof");
          } else {
            this[SAW_NULL_BLOCK] = true;
            this[EMIT]("nullBlock");
          }
        } else {
          this[SAW_NULL_BLOCK] = false;
          if (!header.cksumValid) {
            this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
          } else if (!header.path) {
            this.warn("TAR_ENTRY_INVALID", "path is required", { header });
          } else {
            const type = header.type;
            if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {
              this.warn("TAR_ENTRY_INVALID", "linkpath required", { header });
            } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {
              this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header });
            } else {
              const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
              if (!this[SAW_VALID_ENTRY]) {
                if (entry.remain) {
                  const onend = () => {
                    if (!entry.invalid) {
                      this[SAW_VALID_ENTRY] = true;
                    }
                  };
                  entry.on("end", onend);
                } else {
                  this[SAW_VALID_ENTRY] = true;
                }
              }
              if (entry.meta) {
                if (entry.size > this.maxMetaEntrySize) {
                  entry.ignore = true;
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = "ignore";
                  entry.resume();
                } else if (entry.size > 0) {
                  this[META] = "";
                  entry.on("data", (c) => this[META] += c);
                  this[STATE] = "meta";
                }
              } else {
                this[EX] = null;
                entry.ignore = entry.ignore || !this.filter(entry.path, entry);
                if (entry.ignore) {
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = entry.remain ? "ignore" : "header";
                  entry.resume();
                } else {
                  if (entry.remain) {
                    this[STATE] = "body";
                  } else {
                    this[STATE] = "header";
                    entry.end();
                  }
                  if (!this[READENTRY]) {
                    this[QUEUE].push(entry);
                    this[NEXTENTRY]();
                  } else {
                    this[QUEUE].push(entry);
                  }
                }
              }
            }
          }
        }
      }
      [CLOSESTREAM]() {
        nextTick(() => this.emit("close"));
      }
      [PROCESSENTRY](entry) {
        let go = true;
        if (!entry) {
          this[READENTRY] = null;
          go = false;
        } else if (Array.isArray(entry)) {
          this.emit.apply(this, entry);
        } else {
          this[READENTRY] = entry;
          this.emit("entry", entry);
          if (!entry.emittedEnd) {
            entry.on("end", (_) => this[NEXTENTRY]());
            go = false;
          }
        }
        return go;
      }
      [NEXTENTRY]() {
        do {
        } while (this[PROCESSENTRY](this[QUEUE].shift()));
        if (!this[QUEUE].length) {
          const re = this[READENTRY];
          const drainNow = !re || re.flowing || re.size === re.remain;
          if (drainNow) {
            if (!this[WRITING]) {
              this.emit("drain");
            }
          } else {
            re.once("drain", (_) => this.emit("drain"));
          }
        }
      }
      [CONSUMEBODY](chunk, position) {
        const entry = this[WRITEENTRY];
        const br = entry.blockRemain;
        const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
        entry.write(c);
        if (!entry.blockRemain) {
          this[STATE] = "header";
          this[WRITEENTRY] = null;
          entry.end();
        }
        return c.length;
      }
      [CONSUMEMETA](chunk, position) {
        const entry = this[WRITEENTRY];
        const ret = this[CONSUMEBODY](chunk, position);
        if (!this[WRITEENTRY]) {
          this[EMITMETA](entry);
        }
        return ret;
      }
      [EMIT](ev, data, extra) {
        if (!this[QUEUE].length && !this[READENTRY]) {
          this.emit(ev, data, extra);
        } else {
          this[QUEUE].push([ev, data, extra]);
        }
      }
      [EMITMETA](entry) {
        this[EMIT]("meta", this[META]);
        switch (entry.type) {
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this[EX] = Pax.parse(this[META], this[EX], false);
            break;
          case "GlobalExtendedHeader":
            this[GEX] = Pax.parse(this[META], this[GEX], true);
            break;
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].path = this[META].replace(/\0.*/, "");
            break;
          case "NextFileHasLongLinkpath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].linkpath = this[META].replace(/\0.*/, "");
            break;
          /* istanbul ignore next */
          default:
            throw new Error("unknown meta: " + entry.type);
        }
      }
      abort(error) {
        this[ABORTED] = true;
        this.emit("abort", error);
        this.warn("TAR_ABORT", error, { recoverable: false });
      }
      write(chunk) {
        if (this[ABORTED]) {
          return;
        }
        const needSniff = this[UNZIP] === null || this.brotli === void 0 && this[UNZIP] === false;
        if (needSniff && chunk) {
          if (this[BUFFER]) {
            chunk = Buffer.concat([this[BUFFER], chunk]);
            this[BUFFER] = null;
          }
          if (chunk.length < gzipHeader.length) {
            this[BUFFER] = chunk;
            return true;
          }
          for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
            if (chunk[i] !== gzipHeader[i]) {
              this[UNZIP] = false;
            }
          }
          const maybeBrotli = this.brotli === void 0;
          if (this[UNZIP] === false && maybeBrotli) {
            if (chunk.length < 512) {
              if (this[ENDED]) {
                this.brotli = true;
              } else {
                this[BUFFER] = chunk;
                return true;
              }
            } else {
              try {
                new Header(chunk.slice(0, 512));
                this.brotli = false;
              } catch (_) {
                this.brotli = true;
              }
            }
          }
          if (this[UNZIP] === null || this[UNZIP] === false && this.brotli) {
            const ended = this[ENDED];
            this[ENDED] = false;
            this[UNZIP] = this[UNZIP] === null ? new zlib.Unzip() : new zlib.BrotliDecompress();
            this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
            this[UNZIP].on("error", (er) => this.abort(er));
            this[UNZIP].on("end", (_) => {
              this[ENDED] = true;
              this[CONSUMECHUNK]();
            });
            this[WRITING] = true;
            const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
            this[WRITING] = false;
            return ret2;
          }
        }
        this[WRITING] = true;
        if (this[UNZIP]) {
          this[UNZIP].write(chunk);
        } else {
          this[CONSUMECHUNK](chunk);
        }
        this[WRITING] = false;
        const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
        if (!ret && !this[QUEUE].length) {
          this[READENTRY].once("drain", (_) => this.emit("drain"));
        }
        return ret;
      }
      [BUFFERCONCAT](c) {
        if (c && !this[ABORTED]) {
          this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
        }
      }
      [MAYBEEND]() {
        if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
          this[EMITTEDEND] = true;
          const entry = this[WRITEENTRY];
          if (entry && entry.blockRemain) {
            const have = this[BUFFER] ? this[BUFFER].length : 0;
            this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
            if (this[BUFFER]) {
              entry.write(this[BUFFER]);
            }
            entry.end();
          }
          this[EMIT](DONE);
        }
      }
      [CONSUMECHUNK](chunk) {
        if (this[CONSUMING]) {
          this[BUFFERCONCAT](chunk);
        } else if (!chunk && !this[BUFFER]) {
          this[MAYBEEND]();
        } else {
          this[CONSUMING] = true;
          if (this[BUFFER]) {
            this[BUFFERCONCAT](chunk);
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          } else {
            this[CONSUMECHUNKSUB](chunk);
          }
          while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          }
          this[CONSUMING] = false;
        }
        if (!this[BUFFER] || this[ENDED]) {
          this[MAYBEEND]();
        }
      }
      [CONSUMECHUNKSUB](chunk) {
        let position = 0;
        const length = chunk.length;
        while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
          switch (this[STATE]) {
            case "begin":
            case "header":
              this[CONSUMEHEADER](chunk, position);
              position += 512;
              break;
            case "ignore":
            case "body":
              position += this[CONSUMEBODY](chunk, position);
              break;
            case "meta":
              position += this[CONSUMEMETA](chunk, position);
              break;
            /* istanbul ignore next */
            default:
              throw new Error("invalid state: " + this[STATE]);
          }
        }
        if (position < length) {
          if (this[BUFFER]) {
            this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
          } else {
            this[BUFFER] = chunk.slice(position);
          }
        }
      }
      end(chunk) {
        if (!this[ABORTED]) {
          if (this[UNZIP]) {
            this[UNZIP].end(chunk);
          } else {
            this[ENDED] = true;
            if (this.brotli === void 0) chunk = chunk || Buffer.alloc(0);
            this.write(chunk);
          }
        }
      }
    });
  }
});

// node_modules/pacote/node_modules/tar/lib/list.js
var require_list = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/list.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Parser = require_parse3();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var path = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function") {
        cb = opt_, files = null, opt_ = {};
      } else if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (typeof files === "function") {
        cb = files, files = null;
      }
      if (!files) {
        files = [];
      } else {
        files = Array.from(files);
      }
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      if (files.length) {
        filesFilter(opt, files);
      }
      if (!opt.noResume) {
        onentryFunction(opt);
      }
      return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list(opt);
    };
    var onentryFunction = (opt) => {
      const onentry = opt.onentry;
      opt.onentry = onentry ? (e) => {
        onentry(e);
        e.resume();
      } : (e) => e.resume();
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [stripSlash(f), true]));
      const filter = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var listFileSync = (opt) => {
      const p = list(opt);
      const file = opt.file;
      let threw = true;
      let fd;
      try {
        const stat = fs2.statSync(file);
        const readSize = opt.maxReadSize || 16 * 1024 * 1024;
        if (stat.size < readSize) {
          p.end(fs2.readFileSync(file));
        } else {
          let pos = 0;
          const buf = Buffer.allocUnsafe(readSize);
          fd = fs2.openSync(file, "r");
          while (pos < stat.size) {
            const bytesRead = fs2.readSync(fd, buf, 0, readSize, pos);
            pos += bytesRead;
            p.write(buf.slice(0, bytesRead));
          }
          p.end();
        }
        threw = false;
      } finally {
        if (threw && fd) {
          try {
            fs2.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var listFile = (opt, cb) => {
      const parse = new Parser(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve, reject) => {
        parse.on("error", reject);
        parse.on("end", resolve);
        fs2.stat(file, (er, stat) => {
          if (er) {
            reject(er);
          } else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(parse);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var list = (opt) => new Parser(opt);
  }
});

// node_modules/pacote/node_modules/tar/lib/create.js
var require_create = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/create.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fsm = require_fs_minipass();
    var t = require_list();
    var path = require("path");
    module2.exports = (opt_, files, cb) => {
      if (typeof files === "function") {
        cb = files;
      }
      if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
    };
    var createFileSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      const stream = new fsm.WriteStreamSync(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var createFile = (opt, files, cb) => {
      const p = new Pack(opt);
      const stream = new fsm.WriteStream(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      const promise = new Promise((res, rej) => {
        stream.on("error", rej);
        stream.on("close", res);
        p.on("error", rej);
      });
      addFilesAsync(p, files);
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path.resolve(p.cwd, file.slice(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else {
          p.add(file);
        }
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path.resolve(p.cwd, file.slice(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else {
          p.add(file);
        }
      }
      p.end();
    };
    var createSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      addFilesSync(p, files);
      return p;
    };
    var create = (opt, files) => {
      const p = new Pack(opt);
      addFilesAsync(p, files);
      return p;
    };
  }
});

// node_modules/pacote/node_modules/tar/lib/replace.js
var require_replace = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/replace.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var t = require_list();
    var path = require("path");
    var Header = require_header();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file) {
        throw new TypeError("file is required");
      }
      if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr")) {
        throw new TypeError("cannot append to compressed archives");
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
    };
    var replaceSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      let threw = true;
      let fd;
      let position;
      try {
        try {
          fd = fs2.openSync(opt.file, "r+");
        } catch (er) {
          if (er.code === "ENOENT") {
            fd = fs2.openSync(opt.file, "w+");
          } else {
            throw er;
          }
        }
        const st = fs2.fstatSync(fd);
        const headBuf = Buffer.alloc(512);
        POSITION: for (position = 0; position < st.size; position += 512) {
          for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
            bytes = fs2.readSync(
              fd,
              headBuf,
              bufPos,
              headBuf.length - bufPos,
              position + bufPos
            );
            if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
              throw new Error("cannot append to compressed archives");
            }
            if (!bytes) {
              break POSITION;
            }
          }
          const h = new Header(headBuf);
          if (!h.cksumValid) {
            break;
          }
          const entryBlockSize = 512 * Math.ceil(h.size / 512);
          if (position + entryBlockSize + 512 > st.size) {
            break;
          }
          position += entryBlockSize;
          if (opt.mtimeCache) {
            opt.mtimeCache.set(h.path, h.mtime);
          }
        }
        threw = false;
        streamSync(opt, p, position, fd, files);
      } finally {
        if (threw) {
          try {
            fs2.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var streamSync = (opt, p, position, fd, files) => {
      const stream = new fsm.WriteStreamSync(opt.file, {
        fd,
        start: position
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var replace = (opt, files, cb) => {
      files = Array.from(files);
      const p = new Pack(opt);
      const getPos = (fd, size, cb_) => {
        const cb2 = (er, pos) => {
          if (er) {
            fs2.close(fd, (_) => cb_(er));
          } else {
            cb_(null, pos);
          }
        };
        let position = 0;
        if (size === 0) {
          return cb2(null, 0);
        }
        let bufPos = 0;
        const headBuf = Buffer.alloc(512);
        const onread = (er, bytes) => {
          if (er) {
            return cb2(er);
          }
          bufPos += bytes;
          if (bufPos < 512 && bytes) {
            return fs2.read(
              fd,
              headBuf,
              bufPos,
              headBuf.length - bufPos,
              position + bufPos,
              onread
            );
          }
          if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
            return cb2(new Error("cannot append to compressed archives"));
          }
          if (bufPos < 512) {
            return cb2(null, position);
          }
          const h = new Header(headBuf);
          if (!h.cksumValid) {
            return cb2(null, position);
          }
          const entryBlockSize = 512 * Math.ceil(h.size / 512);
          if (position + entryBlockSize + 512 > size) {
            return cb2(null, position);
          }
          position += entryBlockSize + 512;
          if (position >= size) {
            return cb2(null, position);
          }
          if (opt.mtimeCache) {
            opt.mtimeCache.set(h.path, h.mtime);
          }
          bufPos = 0;
          fs2.read(fd, headBuf, 0, 512, position, onread);
        };
        fs2.read(fd, headBuf, 0, 512, position, onread);
      };
      const promise = new Promise((resolve, reject) => {
        p.on("error", reject);
        let flag = "r+";
        const onopen = (er, fd) => {
          if (er && er.code === "ENOENT" && flag === "r+") {
            flag = "w+";
            return fs2.open(opt.file, flag, onopen);
          }
          if (er) {
            return reject(er);
          }
          fs2.fstat(fd, (er2, st) => {
            if (er2) {
              return fs2.close(fd, () => reject(er2));
            }
            getPos(fd, st.size, (er3, position) => {
              if (er3) {
                return reject(er3);
              }
              const stream = new fsm.WriteStream(opt.file, {
                fd,
                start: position
              });
              p.pipe(stream);
              stream.on("error", reject);
              stream.on("close", resolve);
              addFilesAsync(p, files);
            });
          });
        };
        fs2.open(opt.file, flag, onopen);
      });
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path.resolve(p.cwd, file.slice(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else {
          p.add(file);
        }
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path.resolve(p.cwd, file.slice(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else {
          p.add(file);
        }
      }
      p.end();
    };
  }
});

// node_modules/pacote/node_modules/tar/lib/update.js
var require_update = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/update.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var r = require_replace();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file) {
        throw new TypeError("file is required");
      }
      if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr")) {
        throw new TypeError("cannot append to compressed archives");
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      mtimeFilter(opt);
      return r(opt, files, cb);
    };
    var mtimeFilter = (opt) => {
      const filter = opt.filter;
      if (!opt.mtimeCache) {
        opt.mtimeCache = /* @__PURE__ */ new Map();
      }
      opt.filter = filter ? (path, stat) => filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime) : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime);
    };
  }
});

// node_modules/pacote/node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS({
  "node_modules/pacote/node_modules/mkdirp/lib/opts-arg.js"(exports2, module2) {
    var { promisify } = require("util");
    var fs2 = require("fs");
    var optsArg = (opts) => {
      if (!opts)
        opts = { mode: 511, fs: fs2 };
      else if (typeof opts === "object")
        opts = { mode: 511, fs: fs2, ...opts };
      else if (typeof opts === "number")
        opts = { mode: opts, fs: fs2 };
      else if (typeof opts === "string")
        opts = { mode: parseInt(opts, 8), fs: fs2 };
      else
        throw new TypeError("invalid options argument");
      opts.mkdir = opts.mkdir || opts.fs.mkdir || fs2.mkdir;
      opts.mkdirAsync = promisify(opts.mkdir);
      opts.stat = opts.stat || opts.fs.stat || fs2.stat;
      opts.statAsync = promisify(opts.stat);
      opts.statSync = opts.statSync || opts.fs.statSync || fs2.statSync;
      opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs2.mkdirSync;
      return opts;
    };
    module2.exports = optsArg;
  }
});

// node_modules/pacote/node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS({
  "node_modules/pacote/node_modules/mkdirp/lib/path-arg.js"(exports2, module2) {
    var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
    var { resolve, parse } = require("path");
    var pathArg = (path) => {
      if (/\0/.test(path)) {
        throw Object.assign(
          new TypeError("path must be a string without null bytes"),
          {
            path,
            code: "ERR_INVALID_ARG_VALUE"
          }
        );
      }
      path = resolve(path);
      if (platform === "win32") {
        const badWinChars = /[*|"<>?:]/;
        const { root } = parse(path);
        if (badWinChars.test(path.substr(root.length))) {
          throw Object.assign(new Error("Illegal characters in path."), {
            path,
            code: "EINVAL"
          });
        }
      }
      return path;
    };
    module2.exports = pathArg;
  }
});

// node_modules/pacote/node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS({
  "node_modules/pacote/node_modules/mkdirp/lib/find-made.js"(exports2, module2) {
    var { dirname } = require("path");
    var findMade = (opts, parent, path = void 0) => {
      if (path === parent)
        return Promise.resolve();
      return opts.statAsync(parent).then(
        (st) => st.isDirectory() ? path : void 0,
        // will fail later
        (er) => er.code === "ENOENT" ? findMade(opts, dirname(parent), parent) : void 0
      );
    };
    var findMadeSync = (opts, parent, path = void 0) => {
      if (path === parent)
        return void 0;
      try {
        return opts.statSync(parent).isDirectory() ? path : void 0;
      } catch (er) {
        return er.code === "ENOENT" ? findMadeSync(opts, dirname(parent), parent) : void 0;
      }
    };
    module2.exports = { findMade, findMadeSync };
  }
});

// node_modules/pacote/node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS({
  "node_modules/pacote/node_modules/mkdirp/lib/mkdirp-manual.js"(exports2, module2) {
    var { dirname } = require("path");
    var mkdirpManual = (path, opts, made) => {
      opts.recursive = false;
      const parent = dirname(path);
      if (parent === path) {
        return opts.mkdirAsync(path, opts).catch((er) => {
          if (er.code !== "EISDIR")
            throw er;
        });
      }
      return opts.mkdirAsync(path, opts).then(() => made || path, (er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path, opts, made2));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        return opts.statAsync(path).then((st) => {
          if (st.isDirectory())
            return made;
          else
            throw er;
        }, () => {
          throw er;
        });
      });
    };
    var mkdirpManualSync = (path, opts, made) => {
      const parent = dirname(path);
      opts.recursive = false;
      if (parent === path) {
        try {
          return opts.mkdirSync(path, opts);
        } catch (er) {
          if (er.code !== "EISDIR")
            throw er;
          else
            return;
        }
      }
      try {
        opts.mkdirSync(path, opts);
        return made || path;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        try {
          if (!opts.statSync(path).isDirectory())
            throw er;
        } catch (_) {
          throw er;
        }
      }
    };
    module2.exports = { mkdirpManual, mkdirpManualSync };
  }
});

// node_modules/pacote/node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS({
  "node_modules/pacote/node_modules/mkdirp/lib/mkdirp-native.js"(exports2, module2) {
    var { dirname } = require("path");
    var { findMade, findMadeSync } = require_find_made();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var mkdirpNative = (path, opts) => {
      opts.recursive = true;
      const parent = dirname(path);
      if (parent === path)
        return opts.mkdirAsync(path, opts);
      return findMade(opts, path).then((made) => opts.mkdirAsync(path, opts).then(() => made).catch((er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(path, opts);
        else
          throw er;
      }));
    };
    var mkdirpNativeSync = (path, opts) => {
      opts.recursive = true;
      const parent = dirname(path);
      if (parent === path)
        return opts.mkdirSync(path, opts);
      const made = findMadeSync(opts, path);
      try {
        opts.mkdirSync(path, opts);
        return made;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path, opts);
        else
          throw er;
      }
    };
    module2.exports = { mkdirpNative, mkdirpNativeSync };
  }
});

// node_modules/pacote/node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS({
  "node_modules/pacote/node_modules/mkdirp/lib/use-native.js"(exports2, module2) {
    var fs2 = require("fs");
    var version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
    var versArr = version.replace(/^v/, "").split(".");
    var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
    var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs2.mkdir;
    var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs2.mkdirSync;
    module2.exports = { useNative, useNativeSync };
  }
});

// node_modules/pacote/node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "node_modules/pacote/node_modules/mkdirp/index.js"(exports2, module2) {
    var optsArg = require_opts_arg();
    var pathArg = require_path_arg();
    var { mkdirpNative, mkdirpNativeSync } = require_mkdirp_native();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var { useNative, useNativeSync } = require_use_native();
    var mkdirp = (path, opts) => {
      path = pathArg(path);
      opts = optsArg(opts);
      return useNative(opts) ? mkdirpNative(path, opts) : mkdirpManual(path, opts);
    };
    var mkdirpSync = (path, opts) => {
      path = pathArg(path);
      opts = optsArg(opts);
      return useNativeSync(opts) ? mkdirpNativeSync(path, opts) : mkdirpManualSync(path, opts);
    };
    mkdirp.sync = mkdirpSync;
    mkdirp.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts));
    mkdirp.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts));
    mkdirp.nativeSync = (path, opts) => mkdirpNativeSync(pathArg(path), optsArg(opts));
    mkdirp.manualSync = (path, opts) => mkdirpManualSync(pathArg(path), optsArg(opts));
    module2.exports = mkdirp;
  }
});

// node_modules/pacote/node_modules/chownr/chownr.js
var require_chownr = __commonJS({
  "node_modules/pacote/node_modules/chownr/chownr.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var path = require("path");
    var LCHOWN = fs2.lchown ? "lchown" : "chown";
    var LCHOWNSYNC = fs2.lchownSync ? "lchownSync" : "chownSync";
    var needEISDIRHandled = fs2.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
    var lchownSync = (path2, uid, gid) => {
      try {
        return fs2[LCHOWNSYNC](path2, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var chownSync = (path2, uid, gid) => {
      try {
        return fs2.chownSync(path2, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var handleEISDIR = needEISDIRHandled ? (path2, uid, gid, cb) => (er) => {
      if (!er || er.code !== "EISDIR")
        cb(er);
      else
        fs2.chown(path2, uid, gid, cb);
    } : (_, __, ___, cb) => cb;
    var handleEISDirSync = needEISDIRHandled ? (path2, uid, gid) => {
      try {
        return lchownSync(path2, uid, gid);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        chownSync(path2, uid, gid);
      }
    } : (path2, uid, gid) => lchownSync(path2, uid, gid);
    var nodeVersion = process.version;
    var readdir = (path2, options, cb) => fs2.readdir(path2, options, cb);
    var readdirSync = (path2, options) => fs2.readdirSync(path2, options);
    if (/^v4\./.test(nodeVersion))
      readdir = (path2, options, cb) => fs2.readdir(path2, cb);
    var chown = (cpath, uid, gid, cb) => {
      fs2[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
        cb(er && er.code !== "ENOENT" ? er : null);
      }));
    };
    var chownrKid = (p, child, uid, gid, cb) => {
      if (typeof child === "string")
        return fs2.lstat(path.resolve(p, child), (er, stats) => {
          if (er)
            return cb(er.code !== "ENOENT" ? er : null);
          stats.name = child;
          chownrKid(p, stats, uid, gid, cb);
        });
      if (child.isDirectory()) {
        chownr(path.resolve(p, child.name), uid, gid, (er) => {
          if (er)
            return cb(er);
          const cpath = path.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        });
      } else {
        const cpath = path.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      }
    };
    var chownr = (p, uid, gid, cb) => {
      readdir(p, { withFileTypes: true }, (er, children) => {
        if (er) {
          if (er.code === "ENOENT")
            return cb();
          else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
            return cb(er);
        }
        if (er || !children.length)
          return chown(p, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--len === 0)
            return chown(p, uid, gid, cb);
        };
        children.forEach((child) => chownrKid(p, child, uid, gid, then));
      });
    };
    var chownrKidSync = (p, child, uid, gid) => {
      if (typeof child === "string") {
        try {
          const stats = fs2.lstatSync(path.resolve(p, child));
          stats.name = child;
          child = stats;
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          else
            throw er;
        }
      }
      if (child.isDirectory())
        chownrSync(path.resolve(p, child.name), uid, gid);
      handleEISDirSync(path.resolve(p, child.name), uid, gid);
    };
    var chownrSync = (p, uid, gid) => {
      let children;
      try {
        children = readdirSync(p, { withFileTypes: true });
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
          return handleEISDirSync(p, uid, gid);
        else
          throw er;
      }
      if (children && children.length)
        children.forEach((child) => chownrKidSync(p, child, uid, gid));
      return handleEISDirSync(p, uid, gid);
    };
    module2.exports = chownr;
    chownr.sync = chownrSync;
  }
});

// node_modules/pacote/node_modules/tar/lib/mkdir.js
var require_mkdir = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/mkdir.js"(exports2, module2) {
    "use strict";
    var mkdirp = require_mkdirp();
    var fs2 = require("fs");
    var path = require("path");
    var chownr = require_chownr();
    var normPath = require_normalize_windows_path();
    var SymlinkError = class extends Error {
      constructor(symlink, path2) {
        super("Cannot extract through symbolic link");
        this.path = path2;
        this.symlink = symlink;
      }
      get name() {
        return "SylinkError";
      }
    };
    var CwdError = class extends Error {
      constructor(path2, code) {
        super(code + ": Cannot cd into '" + path2 + "'");
        this.path = path2;
        this.code = code;
      }
      get name() {
        return "CwdError";
      }
    };
    var cGet = (cache, key) => cache.get(normPath(key));
    var cSet = (cache, key, val) => cache.set(normPath(key), val);
    var checkCwd = (dir, cb) => {
      fs2.stat(dir, (er, st) => {
        if (er || !st.isDirectory()) {
          er = new CwdError(dir, er && er.code || "ENOTDIR");
        }
        cb(er);
      });
    };
    module2.exports = (dir, opt, cb) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd = normPath(opt.cwd);
      const done = (er, created) => {
        if (er) {
          cb(er);
        } else {
          cSet(cache, dir, true);
          if (created && doChown) {
            chownr(created, uid, gid, (er2) => done(er2));
          } else if (needChmod) {
            fs2.chmod(dir, mode, cb);
          } else {
            cb();
          }
        }
      };
      if (cache && cGet(cache, dir) === true) {
        return done();
      }
      if (dir === cwd) {
        return checkCwd(dir, done);
      }
      if (preserve) {
        return mkdirp(dir, { mode }).then((made) => done(null, made), done);
      }
      const sub = normPath(path.relative(cwd, dir));
      const parts = sub.split("/");
      mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);
    };
    var mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
      if (!parts.length) {
        return cb(null, created);
      }
      const p = parts.shift();
      const part = normPath(path.resolve(base + "/" + p));
      if (cGet(cache, part)) {
        return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
      }
      fs2.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
    };
    var onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => (er) => {
      if (er) {
        fs2.lstat(part, (statEr, st) => {
          if (statEr) {
            statEr.path = statEr.path && normPath(statEr.path);
            cb(statEr);
          } else if (st.isDirectory()) {
            mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
          } else if (unlink) {
            fs2.unlink(part, (er2) => {
              if (er2) {
                return cb(er2);
              }
              fs2.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
            });
          } else if (st.isSymbolicLink()) {
            return cb(new SymlinkError(part, part + "/" + parts.join("/")));
          } else {
            cb(er);
          }
        });
      } else {
        created = created || part;
        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
      }
    };
    var checkCwdSync = (dir) => {
      let ok = false;
      let code = "ENOTDIR";
      try {
        ok = fs2.statSync(dir).isDirectory();
      } catch (er) {
        code = er.code;
      } finally {
        if (!ok) {
          throw new CwdError(dir, code);
        }
      }
    };
    module2.exports.sync = (dir, opt) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd = normPath(opt.cwd);
      const done = (created2) => {
        cSet(cache, dir, true);
        if (created2 && doChown) {
          chownr.sync(created2, uid, gid);
        }
        if (needChmod) {
          fs2.chmodSync(dir, mode);
        }
      };
      if (cache && cGet(cache, dir) === true) {
        return done();
      }
      if (dir === cwd) {
        checkCwdSync(cwd);
        return done();
      }
      if (preserve) {
        return done(mkdirp.sync(dir, mode));
      }
      const sub = normPath(path.relative(cwd, dir));
      const parts = sub.split("/");
      let created = null;
      for (let p = parts.shift(), part = cwd; p && (part += "/" + p); p = parts.shift()) {
        part = normPath(path.resolve(part));
        if (cGet(cache, part)) {
          continue;
        }
        try {
          fs2.mkdirSync(part, mode);
          created = created || part;
          cSet(cache, part, true);
        } catch (er) {
          const st = fs2.lstatSync(part);
          if (st.isDirectory()) {
            cSet(cache, part, true);
            continue;
          } else if (unlink) {
            fs2.unlinkSync(part);
            fs2.mkdirSync(part, mode);
            created = created || part;
            cSet(cache, part, true);
            continue;
          } else if (st.isSymbolicLink()) {
            return new SymlinkError(part, part + "/" + parts.join("/"));
          }
        }
      }
      return done(created);
    };
  }
});

// node_modules/pacote/node_modules/tar/lib/normalize-unicode.js
var require_normalize_unicode = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/normalize-unicode.js"(exports2, module2) {
    var normalizeCache = /* @__PURE__ */ Object.create(null);
    var { hasOwnProperty } = Object.prototype;
    module2.exports = (s) => {
      if (!hasOwnProperty.call(normalizeCache, s)) {
        normalizeCache[s] = s.normalize("NFD");
      }
      return normalizeCache[s];
    };
  }
});

// node_modules/pacote/node_modules/tar/lib/path-reservations.js
var require_path_reservations = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/path-reservations.js"(exports2, module2) {
    var assert = require("assert");
    var normalize = require_normalize_unicode();
    var stripSlashes = require_strip_trailing_slashes();
    var { join } = require("path");
    var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows = platform === "win32";
    module2.exports = () => {
      const queues = /* @__PURE__ */ new Map();
      const reservations = /* @__PURE__ */ new Map();
      const getDirs = (path) => {
        const dirs = path.split("/").slice(0, -1).reduce((set, path2) => {
          if (set.length) {
            path2 = join(set[set.length - 1], path2);
          }
          set.push(path2 || "/");
          return set;
        }, []);
        return dirs;
      };
      const running = /* @__PURE__ */ new Set();
      const getQueues = (fn) => {
        const res = reservations.get(fn);
        if (!res) {
          throw new Error("function does not have any path reservations");
        }
        return {
          paths: res.paths.map((path) => queues.get(path)),
          dirs: [...res.dirs].map((path) => queues.get(path))
        };
      };
      const check = (fn) => {
        const { paths, dirs } = getQueues(fn);
        return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
      };
      const run = (fn) => {
        if (running.has(fn) || !check(fn)) {
          return false;
        }
        running.add(fn);
        fn(() => clear(fn));
        return true;
      };
      const clear = (fn) => {
        if (!running.has(fn)) {
          return false;
        }
        const { paths, dirs } = reservations.get(fn);
        const next = /* @__PURE__ */ new Set();
        paths.forEach((path) => {
          const q = queues.get(path);
          assert.equal(q[0], fn);
          if (q.length === 1) {
            queues.delete(path);
          } else {
            q.shift();
            if (typeof q[0] === "function") {
              next.add(q[0]);
            } else {
              q[0].forEach((fn2) => next.add(fn2));
            }
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          assert(q[0] instanceof Set);
          if (q[0].size === 1 && q.length === 1) {
            queues.delete(dir);
          } else if (q[0].size === 1) {
            q.shift();
            next.add(q[0]);
          } else {
            q[0].delete(fn);
          }
        });
        running.delete(fn);
        next.forEach((fn2) => run(fn2));
        return true;
      };
      const reserve = (paths, fn) => {
        paths = isWindows ? ["win32 parallelization disabled"] : paths.map((p) => {
          return stripSlashes(join(normalize(p))).toLowerCase();
        });
        const dirs = new Set(
          paths.map((path) => getDirs(path)).reduce((a, b) => a.concat(b))
        );
        reservations.set(fn, { dirs, paths });
        paths.forEach((path) => {
          const q = queues.get(path);
          if (!q) {
            queues.set(path, [fn]);
          } else {
            q.push(fn);
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          if (!q) {
            queues.set(dir, [/* @__PURE__ */ new Set([fn])]);
          } else if (q[q.length - 1] instanceof Set) {
            q[q.length - 1].add(fn);
          } else {
            q.push(/* @__PURE__ */ new Set([fn]));
          }
        });
        return run(fn);
      };
      return { check, reserve };
    };
  }
});

// node_modules/pacote/node_modules/tar/lib/get-write-flag.js
var require_get_write_flag = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/get-write-flag.js"(exports2, module2) {
    var platform = process.env.__FAKE_PLATFORM__ || process.platform;
    var isWindows = platform === "win32";
    var fs2 = global.__FAKE_TESTING_FS__ || require("fs");
    var { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs2.constants;
    var fMapEnabled = isWindows && !!UV_FS_O_FILEMAP;
    var fMapLimit = 512 * 1024;
    var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
    module2.exports = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
  }
});

// node_modules/pacote/node_modules/tar/lib/unpack.js
var require_unpack = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/unpack.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var Parser = require_parse3();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var path = require("path");
    var mkdir = require_mkdir();
    var wc = require_winchars();
    var pathReservations = require_path_reservations();
    var stripAbsolutePath = require_strip_absolute_path();
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var normalize = require_normalize_unicode();
    var ONENTRY = Symbol("onEntry");
    var CHECKFS = Symbol("checkFs");
    var CHECKFS2 = Symbol("checkFs2");
    var PRUNECACHE = Symbol("pruneCache");
    var ISREUSABLE = Symbol("isReusable");
    var MAKEFS = Symbol("makeFs");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var LINK = Symbol("link");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var UNSUPPORTED = Symbol("unsupported");
    var CHECKPATH = Symbol("checkPath");
    var MKDIR = Symbol("mkdir");
    var ONERROR = Symbol("onError");
    var PENDING = Symbol("pending");
    var PEND = Symbol("pend");
    var UNPEND = Symbol("unpend");
    var ENDED = Symbol("ended");
    var MAYBECLOSE = Symbol("maybeClose");
    var SKIP = Symbol("skip");
    var DOCHOWN = Symbol("doChown");
    var UID = Symbol("uid");
    var GID = Symbol("gid");
    var CHECKED_CWD = Symbol("checkedCwd");
    var crypto = require("crypto");
    var getFlag = require_get_write_flag();
    var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows = platform === "win32";
    var DEFAULT_MAX_DEPTH = 1024;
    var unlinkFile = (path2, cb) => {
      if (!isWindows) {
        return fs2.unlink(path2, cb);
      }
      const name = path2 + ".DELETE." + crypto.randomBytes(16).toString("hex");
      fs2.rename(path2, name, (er) => {
        if (er) {
          return cb(er);
        }
        fs2.unlink(name, cb);
      });
    };
    var unlinkFileSync = (path2) => {
      if (!isWindows) {
        return fs2.unlinkSync(path2);
      }
      const name = path2 + ".DELETE." + crypto.randomBytes(16).toString("hex");
      fs2.renameSync(path2, name);
      fs2.unlinkSync(name);
    };
    var uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
    var cacheKeyNormalize = (path2) => stripSlash(normPath(normalize(path2))).toLowerCase();
    var pruneCache = (cache, abs) => {
      abs = cacheKeyNormalize(abs);
      for (const path2 of cache.keys()) {
        const pnorm = cacheKeyNormalize(path2);
        if (pnorm === abs || pnorm.indexOf(abs + "/") === 0) {
          cache.delete(path2);
        }
      }
    };
    var dropCache = (cache) => {
      for (const key of cache.keys()) {
        cache.delete(key);
      }
    };
    var Unpack = class extends Parser {
      constructor(opt) {
        if (!opt) {
          opt = {};
        }
        opt.ondone = (_) => {
          this[ENDED] = true;
          this[MAYBECLOSE]();
        };
        super(opt);
        this[CHECKED_CWD] = false;
        this.reservations = pathReservations();
        this.transform = typeof opt.transform === "function" ? opt.transform : null;
        this.writable = true;
        this.readable = false;
        this[PENDING] = 0;
        this[ENDED] = false;
        this.dirCache = opt.dirCache || /* @__PURE__ */ new Map();
        if (typeof opt.uid === "number" || typeof opt.gid === "number") {
          if (typeof opt.uid !== "number" || typeof opt.gid !== "number") {
            throw new TypeError("cannot set owner without number uid and gid");
          }
          if (opt.preserveOwner) {
            throw new TypeError(
              "cannot preserve owner in archive and also set owner explicitly"
            );
          }
          this.uid = opt.uid;
          this.gid = opt.gid;
          this.setOwner = true;
        } else {
          this.uid = null;
          this.gid = null;
          this.setOwner = false;
        }
        if (opt.preserveOwner === void 0 && typeof opt.uid !== "number") {
          this.preserveOwner = process.getuid && process.getuid() === 0;
        } else {
          this.preserveOwner = !!opt.preserveOwner;
        }
        this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
        this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
        this.maxDepth = typeof opt.maxDepth === "number" ? opt.maxDepth : DEFAULT_MAX_DEPTH;
        this.forceChown = opt.forceChown === true;
        this.win32 = !!opt.win32 || isWindows;
        this.newer = !!opt.newer;
        this.keep = !!opt.keep;
        this.noMtime = !!opt.noMtime;
        this.preservePaths = !!opt.preservePaths;
        this.unlink = !!opt.unlink;
        this.cwd = normPath(path.resolve(opt.cwd || process.cwd()));
        this.strip = +opt.strip || 0;
        this.processUmask = opt.noChmod ? 0 : process.umask();
        this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
        this.dmode = opt.dmode || 511 & ~this.umask;
        this.fmode = opt.fmode || 438 & ~this.umask;
        this.on("entry", (entry) => this[ONENTRY](entry));
      }
      // a bad or damaged archive is a warning for Parser, but an error
      // when extracting.  Mark those errors as unrecoverable, because
      // the Unpack contract cannot be met.
      warn(code, msg, data = {}) {
        if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT") {
          data.recoverable = false;
        }
        return super.warn(code, msg, data);
      }
      [MAYBECLOSE]() {
        if (this[ENDED] && this[PENDING] === 0) {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
        }
      }
      [CHECKPATH](entry) {
        const p = normPath(entry.path);
        const parts = p.split("/");
        if (this.strip) {
          if (parts.length < this.strip) {
            return false;
          }
          if (entry.type === "Link") {
            const linkparts = normPath(entry.linkpath).split("/");
            if (linkparts.length >= this.strip) {
              entry.linkpath = linkparts.slice(this.strip).join("/");
            } else {
              return false;
            }
          }
          parts.splice(0, this.strip);
          entry.path = parts.join("/");
        }
        if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {
          this.warn("TAR_ENTRY_ERROR", "path excessively deep", {
            entry,
            path: p,
            depth: parts.length,
            maxDepth: this.maxDepth
          });
          return false;
        }
        if (!this.preservePaths) {
          if (parts.includes("..") || isWindows && /^[a-z]:\.\.$/i.test(parts[0])) {
            this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
              entry,
              path: p
            });
            return false;
          }
          const [root, stripped] = stripAbsolutePath(p);
          if (root) {
            entry.path = stripped;
            this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute path`, {
              entry,
              path: p
            });
          }
        }
        if (path.isAbsolute(entry.path)) {
          entry.absolute = normPath(path.resolve(entry.path));
        } else {
          entry.absolute = normPath(path.resolve(this.cwd, entry.path));
        }
        if (!this.preservePaths && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd) {
          this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
            entry,
            path: normPath(entry.path),
            resolvedPath: entry.absolute,
            cwd: this.cwd
          });
          return false;
        }
        if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir") {
          return false;
        }
        if (this.win32) {
          const { root: aRoot } = path.win32.parse(entry.absolute);
          entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));
          const { root: pRoot } = path.win32.parse(entry.path);
          entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));
        }
        return true;
      }
      [ONENTRY](entry) {
        if (!this[CHECKPATH](entry)) {
          return entry.resume();
        }
        assert.equal(typeof entry.absolute, "string");
        switch (entry.type) {
          case "Directory":
          case "GNUDumpDir":
            if (entry.mode) {
              entry.mode = entry.mode | 448;
            }
          // eslint-disable-next-line no-fallthrough
          case "File":
          case "OldFile":
          case "ContiguousFile":
          case "Link":
          case "SymbolicLink":
            return this[CHECKFS](entry);
          case "CharacterDevice":
          case "BlockDevice":
          case "FIFO":
          default:
            return this[UNSUPPORTED](entry);
        }
      }
      [ONERROR](er, entry) {
        if (er.name === "CwdError") {
          this.emit("error", er);
        } else {
          this.warn("TAR_ENTRY_ERROR", er, { entry });
          this[UNPEND]();
          entry.resume();
        }
      }
      [MKDIR](dir, mode, cb) {
        mkdir(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode,
          noChmod: this.noChmod
        }, cb);
      }
      [DOCHOWN](entry) {
        return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
      }
      [UID](entry) {
        return uint32(this.uid, entry.uid, this.processUid);
      }
      [GID](entry) {
        return uint32(this.gid, entry.gid, this.processGid);
      }
      [FILE](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.fmode;
        const stream = new fsm.WriteStream(entry.absolute, {
          flags: getFlag(entry.size),
          mode,
          autoClose: false
        });
        stream.on("error", (er) => {
          if (stream.fd) {
            fs2.close(stream.fd, () => {
            });
          }
          stream.write = () => true;
          this[ONERROR](er, entry);
          fullyDone();
        });
        let actions = 1;
        const done = (er) => {
          if (er) {
            if (stream.fd) {
              fs2.close(stream.fd, () => {
              });
            }
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          if (--actions === 0) {
            fs2.close(stream.fd, (er2) => {
              if (er2) {
                this[ONERROR](er2, entry);
              } else {
                this[UNPEND]();
              }
              fullyDone();
            });
          }
        };
        stream.on("finish", (_) => {
          const abs = entry.absolute;
          const fd = stream.fd;
          if (entry.mtime && !this.noMtime) {
            actions++;
            const atime = entry.atime || /* @__PURE__ */ new Date();
            const mtime = entry.mtime;
            fs2.futimes(fd, atime, mtime, (er) => er ? fs2.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            fs2.fchown(fd, uid, gid, (er) => er ? fs2.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
          }
          done();
        });
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => {
            this[ONERROR](er, entry);
            fullyDone();
          });
          entry.pipe(tx);
        }
        tx.pipe(stream);
      }
      [DIRECTORY](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.dmode;
        this[MKDIR](entry.absolute, mode, (er) => {
          if (er) {
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          let actions = 1;
          const done = (_) => {
            if (--actions === 0) {
              fullyDone();
              this[UNPEND]();
              entry.resume();
            }
          };
          if (entry.mtime && !this.noMtime) {
            actions++;
            fs2.utimes(entry.absolute, entry.atime || /* @__PURE__ */ new Date(), entry.mtime, done);
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            fs2.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
          }
          done();
        });
      }
      [UNSUPPORTED](entry) {
        entry.unsupported = true;
        this.warn(
          "TAR_ENTRY_UNSUPPORTED",
          `unsupported entry type: ${entry.type}`,
          { entry }
        );
        entry.resume();
      }
      [SYMLINK](entry, done) {
        this[LINK](entry, entry.linkpath, "symlink", done);
      }
      [HARDLINK](entry, done) {
        const linkpath = normPath(path.resolve(this.cwd, entry.linkpath));
        this[LINK](entry, linkpath, "link", done);
      }
      [PEND]() {
        this[PENDING]++;
      }
      [UNPEND]() {
        this[PENDING]--;
        this[MAYBECLOSE]();
      }
      [SKIP](entry) {
        this[UNPEND]();
        entry.resume();
      }
      // Check if we can reuse an existing filesystem entry safely and
      // overwrite it, rather than unlinking and recreating
      // Windows doesn't report a useful nlink, so we just never reuse entries
      [ISREUSABLE](entry, st) {
        return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows;
      }
      // check if a thing is there, and if so, try to clobber it
      [CHECKFS](entry) {
        this[PEND]();
        const paths = [entry.path];
        if (entry.linkpath) {
          paths.push(entry.linkpath);
        }
        this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
      }
      [PRUNECACHE](entry) {
        if (entry.type === "SymbolicLink") {
          dropCache(this.dirCache);
        } else if (entry.type !== "Directory") {
          pruneCache(this.dirCache, entry.absolute);
        }
      }
      [CHECKFS2](entry, fullyDone) {
        this[PRUNECACHE](entry);
        const done = (er) => {
          this[PRUNECACHE](entry);
          fullyDone(er);
        };
        const checkCwd = () => {
          this[MKDIR](this.cwd, this.dmode, (er) => {
            if (er) {
              this[ONERROR](er, entry);
              done();
              return;
            }
            this[CHECKED_CWD] = true;
            start();
          });
        };
        const start = () => {
          if (entry.absolute !== this.cwd) {
            const parent = normPath(path.dirname(entry.absolute));
            if (parent !== this.cwd) {
              return this[MKDIR](parent, this.dmode, (er) => {
                if (er) {
                  this[ONERROR](er, entry);
                  done();
                  return;
                }
                afterMakeParent();
              });
            }
          }
          afterMakeParent();
        };
        const afterMakeParent = () => {
          fs2.lstat(entry.absolute, (lstatEr, st) => {
            if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
              this[SKIP](entry);
              done();
              return;
            }
            if (lstatEr || this[ISREUSABLE](entry, st)) {
              return this[MAKEFS](null, entry, done);
            }
            if (st.isDirectory()) {
              if (entry.type === "Directory") {
                const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
                const afterChmod = (er) => this[MAKEFS](er, entry, done);
                if (!needChmod) {
                  return afterChmod();
                }
                return fs2.chmod(entry.absolute, entry.mode, afterChmod);
              }
              if (entry.absolute !== this.cwd) {
                return fs2.rmdir(entry.absolute, (er) => this[MAKEFS](er, entry, done));
              }
            }
            if (entry.absolute === this.cwd) {
              return this[MAKEFS](null, entry, done);
            }
            unlinkFile(entry.absolute, (er) => this[MAKEFS](er, entry, done));
          });
        };
        if (this[CHECKED_CWD]) {
          start();
        } else {
          checkCwd();
        }
      }
      [MAKEFS](er, entry, done) {
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        switch (entry.type) {
          case "File":
          case "OldFile":
          case "ContiguousFile":
            return this[FILE](entry, done);
          case "Link":
            return this[HARDLINK](entry, done);
          case "SymbolicLink":
            return this[SYMLINK](entry, done);
          case "Directory":
          case "GNUDumpDir":
            return this[DIRECTORY](entry, done);
        }
      }
      [LINK](entry, linkpath, link, done) {
        fs2[link](linkpath, entry.absolute, (er) => {
          if (er) {
            this[ONERROR](er, entry);
          } else {
            this[UNPEND]();
            entry.resume();
          }
          done();
        });
      }
    };
    var callSync = (fn) => {
      try {
        return [null, fn()];
      } catch (er) {
        return [er, null];
      }
    };
    var UnpackSync = class extends Unpack {
      [MAKEFS](er, entry) {
        return super[MAKEFS](er, entry, () => {
        });
      }
      [CHECKFS](entry) {
        this[PRUNECACHE](entry);
        if (!this[CHECKED_CWD]) {
          const er2 = this[MKDIR](this.cwd, this.dmode);
          if (er2) {
            return this[ONERROR](er2, entry);
          }
          this[CHECKED_CWD] = true;
        }
        if (entry.absolute !== this.cwd) {
          const parent = normPath(path.dirname(entry.absolute));
          if (parent !== this.cwd) {
            const mkParent = this[MKDIR](parent, this.dmode);
            if (mkParent) {
              return this[ONERROR](mkParent, entry);
            }
          }
        }
        const [lstatEr, st] = callSync(() => fs2.lstatSync(entry.absolute));
        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
          return this[SKIP](entry);
        }
        if (lstatEr || this[ISREUSABLE](entry, st)) {
          return this[MAKEFS](null, entry);
        }
        if (st.isDirectory()) {
          if (entry.type === "Directory") {
            const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
            const [er3] = needChmod ? callSync(() => {
              fs2.chmodSync(entry.absolute, entry.mode);
            }) : [];
            return this[MAKEFS](er3, entry);
          }
          const [er2] = callSync(() => fs2.rmdirSync(entry.absolute));
          this[MAKEFS](er2, entry);
        }
        const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));
        this[MAKEFS](er, entry);
      }
      [FILE](entry, done) {
        const mode = entry.mode & 4095 || this.fmode;
        const oner = (er) => {
          let closeError;
          try {
            fs2.closeSync(fd);
          } catch (e) {
            closeError = e;
          }
          if (er || closeError) {
            this[ONERROR](er || closeError, entry);
          }
          done();
        };
        let fd;
        try {
          fd = fs2.openSync(entry.absolute, getFlag(entry.size), mode);
        } catch (er) {
          return oner(er);
        }
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => this[ONERROR](er, entry));
          entry.pipe(tx);
        }
        tx.on("data", (chunk) => {
          try {
            fs2.writeSync(fd, chunk, 0, chunk.length);
          } catch (er) {
            oner(er);
          }
        });
        tx.on("end", (_) => {
          let er = null;
          if (entry.mtime && !this.noMtime) {
            const atime = entry.atime || /* @__PURE__ */ new Date();
            const mtime = entry.mtime;
            try {
              fs2.futimesSync(fd, atime, mtime);
            } catch (futimeser) {
              try {
                fs2.utimesSync(entry.absolute, atime, mtime);
              } catch (utimeser) {
                er = futimeser;
              }
            }
          }
          if (this[DOCHOWN](entry)) {
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            try {
              fs2.fchownSync(fd, uid, gid);
            } catch (fchowner) {
              try {
                fs2.chownSync(entry.absolute, uid, gid);
              } catch (chowner) {
                er = er || fchowner;
              }
            }
          }
          oner(er);
        });
      }
      [DIRECTORY](entry, done) {
        const mode = entry.mode & 4095 || this.dmode;
        const er = this[MKDIR](entry.absolute, mode);
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        if (entry.mtime && !this.noMtime) {
          try {
            fs2.utimesSync(entry.absolute, entry.atime || /* @__PURE__ */ new Date(), entry.mtime);
          } catch (er2) {
          }
        }
        if (this[DOCHOWN](entry)) {
          try {
            fs2.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
          } catch (er2) {
          }
        }
        done();
        entry.resume();
      }
      [MKDIR](dir, mode) {
        try {
          return mkdir.sync(normPath(dir), {
            uid: this.uid,
            gid: this.gid,
            processUid: this.processUid,
            processGid: this.processGid,
            umask: this.processUmask,
            preserve: this.preservePaths,
            unlink: this.unlink,
            cache: this.dirCache,
            cwd: this.cwd,
            mode
          });
        } catch (er) {
          return er;
        }
      }
      [LINK](entry, linkpath, link, done) {
        try {
          fs2[link + "Sync"](linkpath, entry.absolute);
          done();
          entry.resume();
        } catch (er) {
          return this[ONERROR](er, entry);
        }
      }
    };
    Unpack.Sync = UnpackSync;
    module2.exports = Unpack;
  }
});

// node_modules/pacote/node_modules/tar/lib/extract.js
var require_extract = __commonJS({
  "node_modules/pacote/node_modules/tar/lib/extract.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Unpack = require_unpack();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var path = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function") {
        cb = opt_, files = null, opt_ = {};
      } else if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (typeof files === "function") {
        cb = files, files = null;
      }
      if (!files) {
        files = [];
      } else {
        files = Array.from(files);
      }
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      if (files.length) {
        filesFilter(opt, files);
      }
      return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [stripSlash(f), true]));
      const filter = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var extractFileSync = (opt) => {
      const u = new Unpack.Sync(opt);
      const file = opt.file;
      const stat = fs2.statSync(file);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const stream = new fsm.ReadStreamSync(file, {
        readSize,
        size: stat.size
      });
      stream.pipe(u);
    };
    var extractFile = (opt, cb) => {
      const u = new Unpack(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve, reject) => {
        u.on("error", reject);
        u.on("close", resolve);
        fs2.stat(file, (er, stat) => {
          if (er) {
            reject(er);
          } else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(u);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var extractSync = (opt) => new Unpack.Sync(opt);
    var extract = (opt) => new Unpack(opt);
  }
});

// node_modules/pacote/node_modules/tar/index.js
var require_tar = __commonJS({
  "node_modules/pacote/node_modules/tar/index.js"(exports2) {
    "use strict";
    exports2.c = exports2.create = require_create();
    exports2.r = exports2.replace = require_replace();
    exports2.t = exports2.list = require_list();
    exports2.u = exports2.update = require_update();
    exports2.x = exports2.extract = require_extract();
    exports2.Pack = require_pack();
    exports2.Unpack = require_unpack();
    exports2.Parse = require_parse3();
    exports2.ReadEntry = require_read_entry();
    exports2.WriteEntry = require_write_entry();
    exports2.Header = require_header();
    exports2.Pax = require_pax();
    exports2.types = require_types();
  }
});

// node_modules/pacote/lib/util/protected.js
var require_protected = __commonJS({
  "node_modules/pacote/lib/util/protected.js"(exports2, module2) {
    module2.exports = {
      cacheFetches: Symbol.for("pacote.Fetcher._cacheFetches"),
      readPackageJson: Symbol.for("package.Fetcher._readPackageJson"),
      tarballFromResolved: Symbol.for("pacote.Fetcher._tarballFromResolved")
    };
  }
});

// node_modules/pacote/lib/util/cache-dir.js
var require_cache_dir = __commonJS({
  "node_modules/pacote/lib/util/cache-dir.js"(exports2, module2) {
    var { resolve } = require("node:path");
    var { tmpdir, homedir } = require("node:os");
    module2.exports = (fakePlatform = false) => {
      const temp = tmpdir();
      const uidOrPid = process.getuid ? process.getuid() : process.pid;
      const home = homedir() || resolve(temp, "npm-" + uidOrPid);
      const platform = fakePlatform || process.platform;
      const cacheExtra = platform === "win32" ? "npm-cache" : ".npm";
      const cacheRoot = platform === "win32" && process.env.LOCALAPPDATA || home;
      return {
        cacache: resolve(cacheRoot, cacheExtra, "_cacache"),
        tufcache: resolve(cacheRoot, cacheExtra, "_tuf")
      };
    };
  }
});

// node_modules/pacote/lib/util/is-package-bin.js
var require_is_package_bin = __commonJS({
  "node_modules/pacote/lib/util/is-package-bin.js"(exports2, module2) {
    var binObj = (name, bin) => typeof bin === "string" ? { [name]: bin } : bin;
    var hasBin = (pkg, path) => {
      const bin = binObj(pkg.name, pkg.bin);
      const p = path.replace(/^[^\\/]*\//, "");
      for (const kv of Object.entries(bin)) {
        if (kv[1] === p) {
          return true;
        }
      }
      return false;
    };
    module2.exports = (pkg, path) => pkg && pkg.bin ? hasBin(pkg, path) : false;
  }
});

// node_modules/pacote/lib/util/trailing-slashes.js
var require_trailing_slashes = __commonJS({
  "node_modules/pacote/lib/util/trailing-slashes.js"(exports2, module2) {
    var removeTrailingSlashes = (input) => {
      let output = input;
      while (output.endsWith("/")) {
        output = output.slice(0, -1);
      }
      return output;
    };
    module2.exports = removeTrailingSlashes;
  }
});

// node_modules/ignore-walk/lib/index.js
var require_lib23 = __commonJS({
  "node_modules/ignore-walk/lib/index.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var path = require("path");
    var EE = require("events").EventEmitter;
    var Minimatch = require_commonjs().Minimatch;
    var Walker = class _Walker extends EE {
      constructor(opts) {
        opts = opts || {};
        super(opts);
        this.isSymbolicLink = opts.isSymbolicLink;
        this.path = opts.path || process.cwd();
        this.basename = path.basename(this.path);
        this.ignoreFiles = opts.ignoreFiles || [".ignore"];
        this.ignoreRules = {};
        this.parent = opts.parent || null;
        this.includeEmpty = !!opts.includeEmpty;
        this.root = this.parent ? this.parent.root : this.path;
        this.follow = !!opts.follow;
        this.result = this.parent ? this.parent.result : /* @__PURE__ */ new Set();
        this.entries = null;
        this.sawError = false;
        this.exact = opts.exact;
      }
      sort(a, b) {
        return a.localeCompare(b, "en");
      }
      emit(ev, data) {
        let ret = false;
        if (!(this.sawError && ev === "error")) {
          if (ev === "error") {
            this.sawError = true;
          } else if (ev === "done" && !this.parent) {
            data = Array.from(data).map((e) => /^@/.test(e) ? `./${e}` : e).sort(this.sort);
            this.result = data;
          }
          if (ev === "error" && this.parent) {
            ret = this.parent.emit("error", data);
          } else {
            ret = super.emit(ev, data);
          }
        }
        return ret;
      }
      start() {
        fs2.readdir(this.path, (er, entries) => er ? this.emit("error", er) : this.onReaddir(entries));
        return this;
      }
      isIgnoreFile(e) {
        return e !== "." && e !== ".." && this.ignoreFiles.indexOf(e) !== -1;
      }
      onReaddir(entries) {
        this.entries = entries;
        if (entries.length === 0) {
          if (this.includeEmpty) {
            this.result.add(this.path.slice(this.root.length + 1));
          }
          this.emit("done", this.result);
        } else {
          const hasIg = this.entries.some((e) => this.isIgnoreFile(e));
          if (hasIg) {
            this.addIgnoreFiles();
          } else {
            this.filterEntries();
          }
        }
      }
      addIgnoreFiles() {
        const newIg = this.entries.filter((e) => this.isIgnoreFile(e));
        let igCount = newIg.length;
        const then = () => {
          if (--igCount === 0) {
            this.filterEntries();
          }
        };
        newIg.forEach((e) => this.addIgnoreFile(e, then));
      }
      addIgnoreFile(file, then) {
        const ig = path.resolve(this.path, file);
        fs2.readFile(ig, "utf8", (er, data) => er ? this.emit("error", er) : this.onReadIgnoreFile(file, data, then));
      }
      onReadIgnoreFile(file, data, then) {
        const mmopt = {
          matchBase: true,
          dot: true,
          flipNegate: true,
          nocase: true
        };
        const rules = data.split(/\r?\n/).filter((line) => !/^#|^$/.test(line.trim())).map((rule) => {
          return new Minimatch(rule.trim(), mmopt);
        });
        this.ignoreRules[file] = rules;
        then();
      }
      filterEntries() {
        const filtered = this.entries.map((entry) => {
          const passFile = this.filterEntry(entry);
          const passDir = this.filterEntry(entry, true);
          return passFile || passDir ? [entry, passFile, passDir] : false;
        }).filter((e) => e);
        let entryCount = filtered.length;
        if (entryCount === 0) {
          this.emit("done", this.result);
        } else {
          const then = () => {
            if (--entryCount === 0) {
              this.emit("done", this.result);
            }
          };
          filtered.forEach((filt) => {
            const entry = filt[0];
            const file = filt[1];
            const dir = filt[2];
            this.stat({ entry, file, dir }, then);
          });
        }
      }
      onstat({ st, entry, file, dir, isSymbolicLink }, then) {
        const abs = this.path + "/" + entry;
        if (!st.isDirectory()) {
          if (file) {
            this.result.add(abs.slice(this.root.length + 1));
          }
          then();
        } else {
          if (dir) {
            this.walker(entry, { isSymbolicLink, exact: file || this.filterEntry(entry + "/") }, then);
          } else {
            then();
          }
        }
      }
      stat({ entry, file, dir }, then) {
        const abs = this.path + "/" + entry;
        fs2.lstat(abs, (lstatErr, lstatResult) => {
          if (lstatErr) {
            this.emit("error", lstatErr);
          } else {
            const isSymbolicLink = lstatResult.isSymbolicLink();
            if (this.follow && isSymbolicLink) {
              fs2.stat(abs, (statErr, statResult) => {
                if (statErr) {
                  this.emit("error", statErr);
                } else {
                  this.onstat({ st: statResult, entry, file, dir, isSymbolicLink }, then);
                }
              });
            } else {
              this.onstat({ st: lstatResult, entry, file, dir, isSymbolicLink }, then);
            }
          }
        });
      }
      walkerOpt(entry, opts) {
        return {
          path: this.path + "/" + entry,
          parent: this,
          ignoreFiles: this.ignoreFiles,
          follow: this.follow,
          includeEmpty: this.includeEmpty,
          ...opts
        };
      }
      walker(entry, opts, then) {
        new _Walker(this.walkerOpt(entry, opts)).on("done", then).start();
      }
      filterEntry(entry, partial, entryBasename) {
        let included = true;
        if (this.parent && this.parent.filterEntry) {
          const parentEntry = this.basename + "/" + entry;
          const parentBasename = entryBasename || entry;
          included = this.parent.filterEntry(parentEntry, partial, parentBasename);
          if (!included && !this.exact) {
            return false;
          }
        }
        this.ignoreFiles.forEach((f) => {
          if (this.ignoreRules[f]) {
            this.ignoreRules[f].forEach((rule) => {
              if (rule.negate !== included) {
                const isRelativeRule = entryBasename && rule.globParts.some(
                  (part) => part.length <= (part.slice(-1)[0] ? 1 : 2)
                );
                const match = rule.match("/" + entry) || rule.match(entry) || !!partial && (rule.match("/" + entry + "/") || rule.match(entry + "/") || rule.negate && (rule.match("/" + entry, true) || rule.match(entry, true)) || isRelativeRule && (rule.match("/" + entryBasename + "/") || rule.match(entryBasename + "/") || rule.negate && (rule.match("/" + entryBasename, true) || rule.match(entryBasename, true))));
                if (match) {
                  included = rule.negate;
                }
              }
            });
          }
        });
        return included;
      }
    };
    var WalkerSync = class _WalkerSync extends Walker {
      start() {
        this.onReaddir(fs2.readdirSync(this.path));
        return this;
      }
      addIgnoreFile(file, then) {
        const ig = path.resolve(this.path, file);
        this.onReadIgnoreFile(file, fs2.readFileSync(ig, "utf8"), then);
      }
      stat({ entry, file, dir }, then) {
        const abs = this.path + "/" + entry;
        let st = fs2.lstatSync(abs);
        const isSymbolicLink = st.isSymbolicLink();
        if (this.follow && isSymbolicLink) {
          st = fs2.statSync(abs);
        }
        this.onstat({ st, entry, file, dir, isSymbolicLink }, then);
      }
      walker(entry, opts, then) {
        new _WalkerSync(this.walkerOpt(entry, opts)).start();
        then();
      }
    };
    var walk = (opts, callback) => {
      const p = new Promise((resolve, reject) => {
        new Walker(opts).on("done", resolve).on("error", reject).start();
      });
      return callback ? p.then((res) => callback(null, res), callback) : p;
    };
    var walkSync = (opts) => new WalkerSync(opts).start().result;
    module2.exports = walk;
    walk.sync = walkSync;
    walk.Walker = Walker;
    walk.WalkerSync = WalkerSync;
  }
});

// node_modules/npm-packlist/lib/index.js
var require_lib24 = __commonJS({
  "node_modules/npm-packlist/lib/index.js"(exports2, module2) {
    "use strict";
    var { Walker: IgnoreWalker } = require_lib23();
    var { lstatSync: lstat, readFileSync: readFile } = require("fs");
    var { basename, dirname, extname, join, relative, resolve, sep } = require("path");
    var defaultRules = Symbol("npm-packlist.rules.default");
    var strictRules = Symbol("npm-packlist.rules.strict");
    var nameIsBadForWindows = (file) => /\*/.test(file);
    var defaults = [
      ".npmignore",
      ".gitignore",
      "**/.git",
      "**/.svn",
      "**/.hg",
      "**/CVS",
      "**/.git/**",
      "**/.svn/**",
      "**/.hg/**",
      "**/CVS/**",
      "/.lock-wscript",
      "/.wafpickle-*",
      "/build/config.gypi",
      "npm-debug.log",
      "**/.npmrc",
      ".*.swp",
      ".DS_Store",
      "**/.DS_Store/**",
      "._*",
      "**/._*/**",
      "*.orig",
      "/archived-packages/**"
    ];
    var strictDefaults = [
      // these are forcibly excluded
      "/.git"
    ];
    var normalizePath = (path) => path.split("\\").join("/");
    var readOutOfTreeIgnoreFiles = (root, rel, result = []) => {
      for (const file of [".npmignore", ".gitignore"]) {
        try {
          const ignoreContent = readFile(join(root, file), { encoding: "utf8" });
          result.push(ignoreContent);
          break;
        } catch (err) {
          if (err.code !== "ENOENT") {
            throw err;
          }
        }
      }
      if (!rel) {
        return result;
      }
      const firstRel = rel.split(sep, 1)[0];
      const newRoot = join(root, firstRel);
      const newRel = relative(newRoot, join(root, rel));
      return readOutOfTreeIgnoreFiles(newRoot, newRel, result);
    };
    var PackWalker = class _PackWalker extends IgnoreWalker {
      constructor(tree, opts) {
        const options = {
          ...opts,
          includeEmpty: false,
          follow: false,
          // we path.resolve() here because ignore-walk doesn't do it and we want full paths
          path: resolve(opts?.path || tree.path).replace(/\\/g, "/"),
          ignoreFiles: opts?.ignoreFiles || [
            defaultRules,
            "package.json",
            ".npmignore",
            ".gitignore",
            strictRules
          ]
        };
        super(options);
        this.isPackage = options.isPackage;
        this.seen = options.seen || /* @__PURE__ */ new Set();
        this.tree = tree;
        this.requiredFiles = options.requiredFiles || [];
        const additionalDefaults = [];
        if (options.prefix && options.workspaces) {
          const path = normalizePath(options.path);
          const prefix = normalizePath(options.prefix);
          const workspaces = options.workspaces.map((ws) => normalizePath(ws));
          if (path !== prefix && workspaces.includes(path)) {
            const relpath = relative(options.prefix, dirname(options.path));
            additionalDefaults.push(...readOutOfTreeIgnoreFiles(options.prefix, relpath));
          } else if (path === prefix) {
            additionalDefaults.push(...workspaces.map((w) => normalizePath(relative(options.path, w))));
          }
        }
        this.injectRules(defaultRules, [...defaults, ...additionalDefaults]);
        if (!this.isPackage) {
          this.injectRules(strictRules, [
            ...strictDefaults,
            ...this.requiredFiles.map((file) => `!${file}`)
          ]);
        }
      }
      // overridden method: we intercept the reading of the package.json file here so that we can
      // process it into both the package.json file rules as well as the strictRules synthetic rule set
      addIgnoreFile(file, callback) {
        if (file !== "package.json" || !this.isPackage) {
          return super.addIgnoreFile(file, callback);
        }
        return this.processPackage(callback);
      }
      // overridden method: if we're done, but we're a package, then we also need to evaluate bundles
      // before we actually emit our done event
      emit(ev, data) {
        if (ev !== "done" || !this.isPackage) {
          return super.emit(ev, data);
        }
        this.gatherBundles().then(() => {
          super.emit("done", this.result);
        });
        return true;
      }
      // overridden method: before actually filtering, we make sure that we've removed the rules for
      // files that should no longer take effect due to our order of precedence
      filterEntries() {
        if (this.ignoreRules["package.json"]) {
          this.ignoreRules[".npmignore"] = null;
          this.ignoreRules[".gitignore"] = null;
        } else if (this.ignoreRules[".npmignore"]) {
          this.ignoreRules[".gitignore"] = null;
        }
        return super.filterEntries();
      }
      // overridden method: we never want to include anything that isn't a file or directory
      onstat(opts, callback) {
        if (!opts.st.isFile() && !opts.st.isDirectory()) {
          return callback();
        }
        return super.onstat(opts, callback);
      }
      // overridden method: we want to refuse to pack files that are invalid, node-tar protects us from
      // a lot of them but not all
      stat(opts, callback) {
        if (nameIsBadForWindows(opts.entry)) {
          return callback();
        }
        return super.stat(opts, callback);
      }
      // overridden method: this is called to create options for a child walker when we step
      // in to a normal child directory (this will never be a bundle). the default method here
      // copies the root's `ignoreFiles` value, but we don't want to respect package.json for
      // subdirectories, so we override it with a list that intentionally omits package.json
      walkerOpt(entry, opts) {
        let ignoreFiles = null;
        if (this.tree.workspaces) {
          const workspaceDirs = [...this.tree.workspaces.values()].map((dir) => dir.replace(/\\/g, "/"));
          const entryPath = join(this.path, entry).replace(/\\/g, "/");
          if (workspaceDirs.includes(entryPath)) {
            ignoreFiles = [
              defaultRules,
              "package.json",
              ".npmignore",
              ".gitignore",
              strictRules
            ];
          }
        } else {
          ignoreFiles = [
            defaultRules,
            ".npmignore",
            ".gitignore",
            strictRules
          ];
        }
        return {
          ...super.walkerOpt(entry, opts),
          ignoreFiles,
          // we map over our own requiredFiles and pass ones that are within this entry
          requiredFiles: this.requiredFiles.map((file) => {
            if (relative(file, entry) === "..") {
              return relative(entry, file).replace(/\\/g, "/");
            }
            return false;
          }).filter(Boolean)
        };
      }
      // overridden method: we want child walkers to be instances of this class, not ignore-walk
      walker(entry, opts, callback) {
        new _PackWalker(this.tree, this.walkerOpt(entry, opts)).on("done", callback).start();
      }
      // overridden method: we use a custom sort method to help compressibility
      sort(a, b) {
        const exta = extname(a).toLowerCase();
        const extb = extname(b).toLowerCase();
        const basea = basename(a).toLowerCase();
        const baseb = basename(b).toLowerCase();
        return exta.localeCompare(extb, "en") || basea.localeCompare(baseb, "en") || a.localeCompare(b, "en");
      }
      // convenience method: this joins the given rules with newlines, appends a trailing newline,
      // and calls the internal onReadIgnoreFile method
      injectRules(filename, rules, callback = () => {
      }) {
        this.onReadIgnoreFile(filename, `${rules.join("\n")}
`, callback);
      }
      // custom method: this is called by addIgnoreFile when we find a package.json, it uses the
      // arborist tree to pull both default rules and strict rules for the package
      processPackage(callback) {
        const {
          bin,
          browser,
          files,
          main
        } = this.tree.package;
        const ignores = [];
        const strict = [
          ...strictDefaults,
          "!/package.json",
          "!/readme{,.*[^~$]}",
          "!/copying{,.*[^~$]}",
          "!/license{,.*[^~$]}",
          "!/licence{,.*[^~$]}",
          "/.git",
          "/node_modules",
          ".npmrc",
          "/package-lock.json",
          "/yarn.lock",
          "/pnpm-lock.yaml",
          "/bun.lockb"
        ];
        if (files) {
          for (let file of files) {
            if (file.startsWith("./")) {
              file = file.slice(1);
            }
            if (file.endsWith("/*")) {
              file += "*";
            }
            const inverse = `!${file}`;
            try {
              const stat = lstat(join(this.path, file.replace(/^!+/, "")).replace(/\\/g, "/"));
              if (stat.isFile()) {
                strict.unshift(inverse);
                this.requiredFiles.push(file.startsWith("/") ? file.slice(1) : file);
              } else if (stat.isDirectory()) {
                ignores.push(inverse);
                ignores.push(`${inverse}/**`);
              }
            } catch (err) {
              ignores.push(inverse);
            }
          }
          this.injectRules("package.json", ["*", ...ignores]);
        }
        if (browser) {
          strict.push(`!/${browser}`);
        }
        if (main) {
          strict.push(`!/${main}`);
        }
        if (bin) {
          for (const key in bin) {
            strict.push(`!/${bin[key]}`);
          }
        }
        this.injectRules(strictRules, strict, callback);
      }
      // custom method: after we've finished gathering the files for the root package, we call this
      // before emitting the 'done' event in order to gather all of the files for bundled deps
      async gatherBundles() {
        if (this.seen.has(this.tree)) {
          return;
        }
        this.seen.add(this.tree);
        let toBundle;
        if (this.tree.isProjectRoot) {
          const { bundleDependencies } = this.tree.package;
          toBundle = bundleDependencies || [];
        } else {
          const { dependencies, optionalDependencies } = this.tree.package;
          toBundle = Object.keys(dependencies || {}).concat(Object.keys(optionalDependencies || {}));
        }
        for (const dep of toBundle) {
          const edge = this.tree.edgesOut.get(dep);
          if (!edge || edge.peer || edge.dev) {
            continue;
          }
          const node = this.tree.edgesOut.get(dep).to;
          if (!node) {
            continue;
          }
          const path = node.path;
          const tree = node.target;
          const walkerOpts = {
            path,
            isPackage: true,
            ignoreFiles: [],
            seen: this.seen
            // pass through seen so we can prevent infinite circular loops
          };
          if (node.isLink) {
            walkerOpts.ignoreFiles.push(defaultRules);
          }
          walkerOpts.ignoreFiles.push("package.json");
          if (node.isLink) {
            walkerOpts.ignoreFiles.push(".npmignore");
            walkerOpts.ignoreFiles.push(".gitignore");
          }
          walkerOpts.ignoreFiles.push(strictRules);
          const walker = new _PackWalker(tree, walkerOpts);
          const bundled = await new Promise((pResolve, pReject) => {
            walker.on("error", pReject);
            walker.on("done", pResolve);
            walker.start();
          });
          const relativeFrom = relative(this.root, walker.path);
          for (const file of bundled) {
            this.result.add(join(relativeFrom, file).replace(/\\/g, "/"));
          }
        }
      }
    };
    var walk = (tree, options, callback) => {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      const p = new Promise((pResolve, pReject) => {
        new PackWalker(tree, { ...options, isPackage: true }).on("done", pResolve).on("error", pReject).start();
      });
      return callback ? p.then((res) => callback(null, res), callback) : p;
    };
    module2.exports = walk;
    walk.Walker = PackWalker;
  }
});

// node_modules/@npmcli/run-script/lib/set-path.js
var require_set_path = __commonJS({
  "node_modules/@npmcli/run-script/lib/set-path.js"(exports2, module2) {
    var { resolve, dirname, delimiter } = require("path");
    var nodeGypPath = resolve(__dirname, "../lib/node-gyp-bin");
    var setPATH = (projectPath, binPaths, env) => {
      const PATH = Object.keys(env).filter((p2) => /^path$/i.test(p2) && env[p2]).map((p2) => env[p2].split(delimiter)).reduce((set, p2) => set.concat(p2.filter((concatted) => !set.includes(concatted))), []).join(delimiter);
      const pathArr = [];
      if (binPaths) {
        pathArr.push(...binPaths);
      }
      let p = projectPath;
      let pp;
      do {
        pathArr.push(resolve(p, "node_modules", ".bin"));
        pp = p;
        p = dirname(p);
      } while (p !== pp);
      pathArr.push(nodeGypPath, PATH);
      const pathVal = pathArr.join(delimiter);
      for (const key of Object.keys(env)) {
        if (/^path$/i.test(key)) {
          env[key] = pathVal;
        }
      }
      return env;
    };
    module2.exports = setPATH;
  }
});

// node_modules/@npmcli/run-script/lib/make-spawn-args.js
var require_make_spawn_args = __commonJS({
  "node_modules/@npmcli/run-script/lib/make-spawn-args.js"(exports2, module2) {
    var setPATH = require_set_path();
    var { resolve } = require("path");
    var npm_config_node_gyp;
    var makeSpawnArgs = (options) => {
      const {
        args,
        binPaths,
        cmd,
        env,
        event,
        nodeGyp,
        path,
        scriptShell = true,
        stdio,
        stdioString
      } = options;
      if (nodeGyp) {
        npm_config_node_gyp = nodeGyp;
      } else if (env.npm_config_node_gyp) {
        npm_config_node_gyp = env.npm_config_node_gyp;
      } else {
        npm_config_node_gyp = require.resolve("node-gyp/bin/node-gyp.js");
      }
      const spawnEnv = setPATH(path, binPaths, {
        // we need to at least save the PATH environment var
        ...process.env,
        ...env,
        npm_package_json: resolve(path, "package.json"),
        npm_lifecycle_event: event,
        npm_lifecycle_script: cmd,
        npm_config_node_gyp
      });
      const spawnOpts = {
        env: spawnEnv,
        stdioString,
        stdio,
        cwd: path,
        shell: scriptShell
      };
      return [cmd, args, spawnOpts];
    };
    module2.exports = makeSpawnArgs;
  }
});

// node_modules/@npmcli/run-script/lib/package-envs.js
var require_package_envs = __commonJS({
  "node_modules/@npmcli/run-script/lib/package-envs.js"(exports2, module2) {
    var packageEnvs = (vals, prefix, env = {}) => {
      for (const [key, val] of Object.entries(vals)) {
        if (val === void 0) {
          continue;
        } else if (val === null || val === false) {
          env[`${prefix}${key}`] = "";
        } else if (Array.isArray(val)) {
          val.forEach((item, index) => {
            packageEnvs({ [`${key}_${index}`]: item }, `${prefix}`, env);
          });
        } else if (typeof val === "object") {
          packageEnvs(val, `${prefix}${key}_`, env);
        } else {
          env[`${prefix}${key}`] = String(val);
        }
      }
      return env;
    };
    module2.exports = (pkg) => {
      return packageEnvs({
        name: pkg.name,
        version: pkg.version,
        config: pkg.config,
        engines: pkg.engines,
        bin: pkg.bin
      }, "npm_package_");
    };
  }
});

// node_modules/@npmcli/node-gyp/lib/index.js
var require_lib25 = __commonJS({
  "node_modules/@npmcli/node-gyp/lib/index.js"(exports2, module2) {
    var util = require("util");
    var fs2 = require("fs");
    var { stat } = fs2.promises || { stat: util.promisify(fs2.stat) };
    async function isNodeGypPackage(path) {
      return await stat(`${path}/binding.gyp`).then((st) => st.isFile()).catch(() => false);
    }
    module2.exports = {
      isNodeGypPackage,
      defaultGypInstallScript: "node-gyp rebuild"
    };
  }
});

// node_modules/@npmcli/run-script/lib/signal-manager.js
var require_signal_manager = __commonJS({
  "node_modules/@npmcli/run-script/lib/signal-manager.js"(exports2, module2) {
    var runningProcs = /* @__PURE__ */ new Set();
    var handlersInstalled = false;
    var forwardedSignals = [
      "SIGINT",
      "SIGTERM"
    ];
    var handleSignal = (signal) => {
      for (const proc of runningProcs) {
        proc.kill(signal);
      }
    };
    var setupListeners = () => {
      for (const signal of forwardedSignals) {
        process.on(signal, handleSignal);
      }
      handlersInstalled = true;
    };
    var cleanupListeners = () => {
      if (runningProcs.size === 0) {
        for (const signal of forwardedSignals) {
          process.removeListener(signal, handleSignal);
        }
        handlersInstalled = false;
      }
    };
    var add = (proc) => {
      runningProcs.add(proc);
      if (!handlersInstalled) {
        setupListeners();
      }
      proc.once("exit", () => {
        runningProcs.delete(proc);
        cleanupListeners();
      });
    };
    module2.exports = {
      add,
      handleSignal,
      forwardedSignals
    };
  }
});

// node_modules/@npmcli/run-script/lib/is-server-package.js
var require_is_server_package = __commonJS({
  "node_modules/@npmcli/run-script/lib/is-server-package.js"(exports2, module2) {
    var { stat } = require("node:fs/promises");
    var { resolve } = require("node:path");
    module2.exports = async (path) => {
      try {
        const st = await stat(resolve(path, "server.js"));
        return st.isFile();
      } catch (er) {
        return false;
      }
    };
  }
});

// node_modules/@npmcli/run-script/lib/run-script-pkg.js
var require_run_script_pkg = __commonJS({
  "node_modules/@npmcli/run-script/lib/run-script-pkg.js"(exports2, module2) {
    var makeSpawnArgs = require_make_spawn_args();
    var promiseSpawn = require_lib7();
    var packageEnvs = require_package_envs();
    var { isNodeGypPackage, defaultGypInstallScript } = require_lib25();
    var signalManager = require_signal_manager();
    var isServerPackage = require_is_server_package();
    var runScriptPkg = async (options) => {
      const {
        args = [],
        binPaths = false,
        env = {},
        event,
        nodeGyp,
        path,
        pkg,
        scriptShell,
        // how long to wait for a process.kill signal
        // only exposed here so that we can make the test go a bit faster.
        signalTimeout = 500,
        stdio = "pipe",
        stdioString
      } = options;
      const { scripts = {}, gypfile } = pkg;
      let cmd = null;
      if (options.cmd) {
        cmd = options.cmd;
      } else if (pkg.scripts && pkg.scripts[event]) {
        cmd = pkg.scripts[event];
      } else if (
        // If there is no preinstall or install script, default to rebuilding node-gyp packages.
        event === "install" && !scripts.install && !scripts.preinstall && gypfile !== false && await isNodeGypPackage(path)
      ) {
        cmd = defaultGypInstallScript;
      } else if (event === "start" && await isServerPackage(path)) {
        cmd = "node server.js";
      }
      if (!cmd) {
        return { code: 0, signal: null };
      }
      let inputEnd = () => {
      };
      if (stdio === "inherit") {
        let banner;
        if (pkg._id) {
          banner = `
> ${pkg._id} ${event}
`;
        } else {
          banner = `
> ${event}
`;
        }
        banner += `> ${cmd.trim().replace(/\n/g, "\n> ")}`;
        if (args.length) {
          banner += ` ${args.join(" ")}`;
        }
        banner += "\n";
        const { output, input } = require_lib4();
        output.standard(banner);
        inputEnd = input.start();
      }
      const [spawnShell, spawnArgs, spawnOpts] = makeSpawnArgs({
        args,
        binPaths,
        cmd,
        env: { ...env, ...packageEnvs(pkg) },
        event,
        nodeGyp,
        path,
        scriptShell,
        stdio,
        stdioString
      });
      const p = promiseSpawn(spawnShell, spawnArgs, spawnOpts, {
        event,
        script: cmd,
        pkgid: pkg._id,
        path
      });
      if (stdio === "inherit") {
        signalManager.add(p.process);
      }
      if (p.stdin) {
        p.stdin.end();
      }
      return p.catch((er) => {
        const { signal } = er;
        if (stdio === "inherit" && signal) {
          process.kill(process.pid, signal);
          return new Promise((res, rej) => setTimeout(() => rej(er), signalTimeout));
        } else {
          throw er;
        }
      }).finally(inputEnd);
    };
    module2.exports = runScriptPkg;
  }
});

// node_modules/@npmcli/run-script/lib/validate-options.js
var require_validate_options = __commonJS({
  "node_modules/@npmcli/run-script/lib/validate-options.js"(exports2, module2) {
    var validateOptions = (options) => {
      if (typeof options !== "object" || !options) {
        throw new TypeError("invalid options object provided to runScript");
      }
      const {
        event,
        path,
        scriptShell,
        env = {},
        stdio = "pipe",
        args = [],
        cmd
      } = options;
      if (!event || typeof event !== "string") {
        throw new TypeError("valid event not provided to runScript");
      }
      if (!path || typeof path !== "string") {
        throw new TypeError("valid path not provided to runScript");
      }
      if (scriptShell !== void 0 && typeof scriptShell !== "string") {
        throw new TypeError("invalid scriptShell option provided to runScript");
      }
      if (typeof env !== "object" || !env) {
        throw new TypeError("invalid env option provided to runScript");
      }
      if (typeof stdio !== "string" && !Array.isArray(stdio)) {
        throw new TypeError("invalid stdio option provided to runScript");
      }
      if (!Array.isArray(args) || args.some((a) => typeof a !== "string")) {
        throw new TypeError("invalid args option provided to runScript");
      }
      if (cmd !== void 0 && typeof cmd !== "string") {
        throw new TypeError("invalid cmd option provided to runScript");
      }
    };
    module2.exports = validateOptions;
  }
});

// node_modules/@npmcli/run-script/lib/run-script.js
var require_run_script = __commonJS({
  "node_modules/@npmcli/run-script/lib/run-script.js"(exports2, module2) {
    var PackageJson = require_lib13();
    var runScriptPkg = require_run_script_pkg();
    var validateOptions = require_validate_options();
    var isServerPackage = require_is_server_package();
    var runScript = async (options) => {
      validateOptions(options);
      if (options.pkg) {
        return runScriptPkg(options);
      }
      const { content: pkg } = await PackageJson.normalize(options.path);
      return runScriptPkg({ ...options, pkg });
    };
    module2.exports = Object.assign(runScript, { isServerPackage });
  }
});

// node_modules/pacote/lib/file.js
var require_file = __commonJS({
  "node_modules/pacote/lib/file.js"(exports2, module2) {
    var { resolve } = require("node:path");
    var { stat, chmod } = require("node:fs/promises");
    var cacache = require_lib20();
    var fsm = require_lib19();
    var Fetcher = require_fetcher2();
    var _ = require_protected();
    var FileFetcher = class extends Fetcher {
      constructor(spec, opts) {
        super(spec, opts);
        this.resolved = this.spec.fetchSpec;
      }
      get types() {
        return ["file"];
      }
      manifest() {
        if (this.package) {
          return Promise.resolve(this.package);
        }
        return cacache.tmp.withTmp(this.cache, this.opts, (dir) => this.extract(dir).then(() => this[_.readPackageJson](dir)).then((mani) => this.package = {
          ...mani,
          _integrity: this.integrity && String(this.integrity),
          _resolved: this.resolved,
          _from: this.from
        }));
      }
      #exeBins(pkg, dest) {
        if (!pkg.bin) {
          return Promise.resolve();
        }
        return Promise.all(Object.keys(pkg.bin).map(async (k) => {
          const script = resolve(dest, pkg.bin[k]);
          try {
            const st = await stat(script);
            const mode = st.mode | 73;
            if (mode === st.mode) {
              return;
            }
            await chmod(script, mode);
          } catch {
          }
        }));
      }
      extract(dest) {
        return super.extract(dest).then((result) => this.package ? result : this[_.readPackageJson](dest).then((pkg) => this.#exeBins(pkg, dest)).then(() => result));
      }
      [_.tarballFromResolved]() {
        return new fsm.ReadStream(this.resolved);
      }
      packument() {
        return this.manifest().then((mani) => ({
          name: mani.name,
          "dist-tags": {
            [this.defaultTag]: mani.version
          },
          versions: {
            [mani.version]: {
              ...mani,
              dist: {
                tarball: `file:${this.resolved}`,
                integrity: this.integrity && String(this.integrity)
              }
            }
          }
        }));
      }
    };
    module2.exports = FileFetcher;
  }
});

// node_modules/pacote/lib/util/tar-create-options.js
var require_tar_create_options = __commonJS({
  "node_modules/pacote/lib/util/tar-create-options.js"(exports2, module2) {
    var isPackageBin = require_is_package_bin();
    var tarCreateOptions = (manifest) => ({
      cwd: manifest._resolved,
      prefix: "package/",
      portable: true,
      gzip: {
        // forcing the level to 9 seems to avoid some
        // platform specific optimizations that cause
        // integrity mismatch errors due to differing
        // end results after compression
        level: 9
      },
      // ensure that package bins are always executable
      // Note that npm-packlist is already filtering out
      // anything that is not a regular file, ignored by
      // .npmignore or package.json "files", etc.
      filter: (path, stat) => {
        if (isPackageBin(manifest, path)) {
          stat.mode |= 73;
        }
        return true;
      },
      // Provide a specific date in the 1980s for the benefit of zip,
      // which is confounded by files dated at the Unix epoch 0.
      mtime: /* @__PURE__ */ new Date("1985-10-26T08:15:00.000Z")
    });
    module2.exports = tarCreateOptions;
  }
});

// node_modules/pacote/lib/dir.js
var require_dir = __commonJS({
  "node_modules/pacote/lib/dir.js"(exports2, module2) {
    var { resolve } = require("node:path");
    var packlist = require_lib24();
    var runScript = require_run_script();
    var tar = require_tar();
    var { Minipass } = require_commonjs3();
    var Fetcher = require_fetcher2();
    var FileFetcher = require_file();
    var _ = require_protected();
    var tarCreateOptions = require_tar_create_options();
    var DirFetcher = class extends Fetcher {
      constructor(spec, opts) {
        super(spec, opts);
        this.resolved = this.spec.fetchSpec;
        this.tree = opts.tree || null;
        this.Arborist = opts.Arborist || null;
      }
      // exposes tarCreateOptions as public API
      static tarCreateOptions(manifest) {
        return tarCreateOptions(manifest);
      }
      get types() {
        return ["directory"];
      }
      #prepareDir() {
        return this.manifest().then((mani) => {
          if (!mani.scripts || !mani.scripts.prepare) {
            return;
          }
          if (this.opts.ignoreScripts) {
            return;
          }
          const stdio = this.opts.foregroundScripts ? "inherit" : "pipe";
          return runScript({
            // this || undefined is because runScript will be unhappy with the default null value
            scriptShell: this.opts.scriptShell || void 0,
            pkg: mani,
            event: "prepare",
            path: this.resolved,
            stdio,
            env: {
              npm_package_resolved: this.resolved,
              npm_package_integrity: this.integrity,
              npm_package_json: resolve(this.resolved, "package.json")
            }
          });
        });
      }
      [_.tarballFromResolved]() {
        if (!this.tree && !this.Arborist) {
          throw new Error("DirFetcher requires either a tree or an Arborist constructor to pack");
        }
        const stream = new Minipass();
        stream.resolved = this.resolved;
        stream.integrity = this.integrity;
        const { prefix, workspaces } = this.opts;
        this.#prepareDir().then(async () => {
          if (!this.tree) {
            const arb = new this.Arborist({ path: this.resolved });
            this.tree = await arb.loadActual();
          }
          return packlist(this.tree, { path: this.resolved, prefix, workspaces });
        }).then((files) => tar.c(tarCreateOptions(this.package), files).on("error", (er) => stream.emit("error", er)).pipe(stream)).catch((er) => stream.emit("error", er));
        return stream;
      }
      manifest() {
        if (this.package) {
          return Promise.resolve(this.package);
        }
        return this[_.readPackageJson](this.resolved).then((mani) => this.package = {
          ...mani,
          _integrity: this.integrity && String(this.integrity),
          _resolved: this.resolved,
          _from: this.from
        });
      }
      packument() {
        return FileFetcher.prototype.packument.apply(this);
      }
    };
    module2.exports = DirFetcher;
  }
});

// node_modules/npm-registry-fetch/lib/errors.js
var require_errors3 = __commonJS({
  "node_modules/npm-registry-fetch/lib/errors.js"(exports2, module2) {
    "use strict";
    var { URL: URL2 } = require("node:url");
    function packageName(href) {
      try {
        let basePath = new URL2(href).pathname.slice(1);
        if (!basePath.match(/^-/)) {
          basePath = basePath.split("/");
          var index = basePath.indexOf("_rewrite");
          if (index === -1) {
            index = basePath.length - 1;
          } else {
            index++;
          }
          return decodeURIComponent(basePath[index]);
        }
      } catch {
      }
    }
    var HttpErrorBase = class extends Error {
      constructor(method, res, body, spec) {
        super();
        this.name = this.constructor.name;
        this.headers = typeof res.headers?.raw === "function" ? res.headers.raw() : res.headers;
        this.statusCode = res.status;
        this.code = `E${res.status}`;
        this.method = method;
        this.uri = res.url;
        this.body = body;
        this.pkgid = spec ? spec.toString() : packageName(res.url);
        Error.captureStackTrace(this, this.constructor);
      }
    };
    var HttpErrorGeneral = class extends HttpErrorBase {
      constructor(method, res, body, spec) {
        super(method, res, body, spec);
        this.message = `${res.status} ${res.statusText} - ${this.method.toUpperCase()} ${this.spec || this.uri}${body && body.error ? " - " + body.error : ""}`;
      }
    };
    var HttpErrorAuthOTP = class extends HttpErrorBase {
      constructor(method, res, body, spec) {
        super(method, res, body, spec);
        this.message = "OTP required for authentication";
        this.code = "EOTP";
      }
    };
    var HttpErrorAuthIPAddress = class extends HttpErrorBase {
      constructor(method, res, body, spec) {
        super(method, res, body, spec);
        this.message = "Login is not allowed from your IP address";
        this.code = "EAUTHIP";
      }
    };
    var HttpErrorAuthUnknown = class extends HttpErrorBase {
      constructor(method, res, body, spec) {
        super(method, res, body, spec);
        this.message = "Unable to authenticate, need: " + res.headers.get("www-authenticate");
      }
    };
    module2.exports = {
      HttpErrorBase,
      HttpErrorGeneral,
      HttpErrorAuthOTP,
      HttpErrorAuthIPAddress,
      HttpErrorAuthUnknown
    };
  }
});

// node_modules/minizlib/dist/commonjs/constants.js
var require_constants3 = __commonJS({
  "node_modules/minizlib/dist/commonjs/constants.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.constants = void 0;
    var zlib_1 = __importDefault(require("zlib"));
    var realZlibConstants = zlib_1.default.constants || { ZLIB_VERNUM: 4736 };
    exports2.constants = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31
    }, realZlibConstants));
  }
});

// node_modules/minizlib/dist/commonjs/index.js
var require_commonjs6 = __commonJS({
  "node_modules/minizlib/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc2 = Object.getOwnPropertyDescriptor(m, k);
      if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc2);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrotliDecompress = exports2.BrotliCompress = exports2.Brotli = exports2.Unzip = exports2.InflateRaw = exports2.DeflateRaw = exports2.Gunzip = exports2.Gzip = exports2.Inflate = exports2.Deflate = exports2.Zlib = exports2.ZlibError = exports2.constants = void 0;
    var assert_1 = __importDefault(require("assert"));
    var buffer_1 = require("buffer");
    var minipass_1 = require_commonjs3();
    var realZlib = __importStar(require("zlib"));
    var constants_js_1 = require_constants3();
    var constants_js_2 = require_constants3();
    Object.defineProperty(exports2, "constants", { enumerable: true, get: function() {
      return constants_js_2.constants;
    } });
    var OriginalBufferConcat = buffer_1.Buffer.concat;
    var desc = Object.getOwnPropertyDescriptor(buffer_1.Buffer, "concat");
    var noop = (args) => args;
    var passthroughBufferConcat = desc?.writable === true || desc?.set !== void 0 ? (makeNoOp) => {
      buffer_1.Buffer.concat = makeNoOp ? noop : OriginalBufferConcat;
    } : (_) => {
    };
    var _superWrite = Symbol("_superWrite");
    var ZlibError = class extends Error {
      code;
      errno;
      constructor(err) {
        super("zlib: " + err.message);
        this.code = err.code;
        this.errno = err.errno;
        if (!this.code)
          this.code = "ZLIB_ERROR";
        this.message = "zlib: " + err.message;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "ZlibError";
      }
    };
    exports2.ZlibError = ZlibError;
    var _flushFlag = Symbol("flushFlag");
    var ZlibBase = class extends minipass_1.Minipass {
      #sawError = false;
      #ended = false;
      #flushFlag;
      #finishFlushFlag;
      #fullFlushFlag;
      #handle;
      #onError;
      get sawError() {
        return this.#sawError;
      }
      get handle() {
        return this.#handle;
      }
      /* c8 ignore start */
      get flushFlag() {
        return this.#flushFlag;
      }
      /* c8 ignore stop */
      constructor(opts, mode) {
        if (!opts || typeof opts !== "object")
          throw new TypeError("invalid options for ZlibBase constructor");
        super(opts);
        this.#flushFlag = opts.flush ?? 0;
        this.#finishFlushFlag = opts.finishFlush ?? 0;
        this.#fullFlushFlag = opts.fullFlushFlag ?? 0;
        try {
          this.#handle = new realZlib[mode](opts);
        } catch (er) {
          throw new ZlibError(er);
        }
        this.#onError = (err) => {
          if (this.#sawError)
            return;
          this.#sawError = true;
          this.close();
          this.emit("error", err);
        };
        this.#handle?.on("error", (er) => this.#onError(new ZlibError(er)));
        this.once("end", () => this.close);
      }
      close() {
        if (this.#handle) {
          this.#handle.close();
          this.#handle = void 0;
          this.emit("close");
        }
      }
      reset() {
        if (!this.#sawError) {
          (0, assert_1.default)(this.#handle, "zlib binding closed");
          return this.#handle.reset?.();
        }
      }
      flush(flushFlag) {
        if (this.ended)
          return;
        if (typeof flushFlag !== "number")
          flushFlag = this.#fullFlushFlag;
        this.write(Object.assign(buffer_1.Buffer.alloc(0), { [_flushFlag]: flushFlag }));
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function") {
          cb = chunk;
          encoding = void 0;
          chunk = void 0;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = void 0;
        }
        if (chunk) {
          if (encoding)
            this.write(chunk, encoding);
          else
            this.write(chunk);
        }
        this.flush(this.#finishFlushFlag);
        this.#ended = true;
        return super.end(cb);
      }
      get ended() {
        return this.#ended;
      }
      // overridden in the gzip classes to do portable writes
      [_superWrite](data) {
        return super.write(data);
      }
      write(chunk, encoding, cb) {
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (typeof chunk === "string")
          chunk = buffer_1.Buffer.from(chunk, encoding);
        if (this.#sawError)
          return;
        (0, assert_1.default)(this.#handle, "zlib binding closed");
        const nativeHandle = this.#handle._handle;
        const originalNativeClose = nativeHandle.close;
        nativeHandle.close = () => {
        };
        const originalClose = this.#handle.close;
        this.#handle.close = () => {
        };
        passthroughBufferConcat(true);
        let result = void 0;
        try {
          const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this.#flushFlag;
          result = this.#handle._processChunk(chunk, flushFlag);
          passthroughBufferConcat(false);
        } catch (err) {
          passthroughBufferConcat(false);
          this.#onError(new ZlibError(err));
        } finally {
          if (this.#handle) {
            ;
            this.#handle._handle = nativeHandle;
            nativeHandle.close = originalNativeClose;
            this.#handle.close = originalClose;
            this.#handle.removeAllListeners("error");
          }
        }
        if (this.#handle)
          this.#handle.on("error", (er) => this.#onError(new ZlibError(er)));
        let writeReturn;
        if (result) {
          if (Array.isArray(result) && result.length > 0) {
            const r = result[0];
            writeReturn = this[_superWrite](buffer_1.Buffer.from(r));
            for (let i = 1; i < result.length; i++) {
              writeReturn = this[_superWrite](result[i]);
            }
          } else {
            writeReturn = this[_superWrite](buffer_1.Buffer.from(result));
          }
        }
        if (cb)
          cb();
        return writeReturn;
      }
    };
    var Zlib = class extends ZlibBase {
      #level;
      #strategy;
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants_js_1.constants.Z_NO_FLUSH;
        opts.finishFlush = opts.finishFlush || constants_js_1.constants.Z_FINISH;
        opts.fullFlushFlag = constants_js_1.constants.Z_FULL_FLUSH;
        super(opts, mode);
        this.#level = opts.level;
        this.#strategy = opts.strategy;
      }
      params(level, strategy) {
        if (this.sawError)
          return;
        if (!this.handle)
          throw new Error("cannot switch params when binding is closed");
        if (!this.handle.params)
          throw new Error("not supported in this implementation");
        if (this.#level !== level || this.#strategy !== strategy) {
          this.flush(constants_js_1.constants.Z_SYNC_FLUSH);
          (0, assert_1.default)(this.handle, "zlib binding closed");
          const origFlush = this.handle.flush;
          this.handle.flush = (flushFlag, cb) => {
            if (typeof flushFlag === "function") {
              cb = flushFlag;
              flushFlag = this.flushFlag;
            }
            this.flush(flushFlag);
            cb?.();
          };
          try {
            ;
            this.handle.params(level, strategy);
          } finally {
            this.handle.flush = origFlush;
          }
          if (this.handle) {
            this.#level = level;
            this.#strategy = strategy;
          }
        }
      }
    };
    exports2.Zlib = Zlib;
    var Deflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Deflate");
      }
    };
    exports2.Deflate = Deflate;
    var Inflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Inflate");
      }
    };
    exports2.Inflate = Inflate;
    var Gzip = class extends Zlib {
      #portable;
      constructor(opts) {
        super(opts, "Gzip");
        this.#portable = opts && !!opts.portable;
      }
      [_superWrite](data) {
        if (!this.#portable)
          return super[_superWrite](data);
        this.#portable = false;
        data[9] = 255;
        return super[_superWrite](data);
      }
    };
    exports2.Gzip = Gzip;
    var Gunzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gunzip");
      }
    };
    exports2.Gunzip = Gunzip;
    var DeflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "DeflateRaw");
      }
    };
    exports2.DeflateRaw = DeflateRaw;
    var InflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "InflateRaw");
      }
    };
    exports2.InflateRaw = InflateRaw;
    var Unzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Unzip");
      }
    };
    exports2.Unzip = Unzip;
    var Brotli = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants_js_1.constants.BROTLI_OPERATION_PROCESS;
        opts.finishFlush = opts.finishFlush || constants_js_1.constants.BROTLI_OPERATION_FINISH;
        opts.fullFlushFlag = constants_js_1.constants.BROTLI_OPERATION_FLUSH;
        super(opts, mode);
      }
    };
    exports2.Brotli = Brotli;
    var BrotliCompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliCompress");
      }
    };
    exports2.BrotliCompress = BrotliCompress;
    var BrotliDecompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliDecompress");
      }
    };
    exports2.BrotliDecompress = BrotliDecompress;
  }
});

// node_modules/minipass-sized/node_modules/minipass/index.js
var require_minipass6 = __commonJS({
  "node_modules/minipass-sized/node_modules/minipass/index.js"(exports2, module2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    module2.exports = class Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = [this.buffer.join("")];
          else
            this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer[0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this.pipes.find((p2) => p2.dest === dest);
        if (p) {
          this.pipes.splice(this.pipes.indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          const ret2 = super.emit("error", data);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this.pipes) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this.pipes) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this.pipes) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || // readable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/minipass-sized/index.js
var require_minipass_sized = __commonJS({
  "node_modules/minipass-sized/index.js"(exports2, module2) {
    var Minipass = require_minipass6();
    var SizeError = class extends Error {
      constructor(found, expect) {
        super(`Bad data size: expected ${expect} bytes, but got ${found}`);
        this.expect = expect;
        this.found = found;
        this.code = "EBADSIZE";
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "SizeError";
      }
    };
    var MinipassSized = class extends Minipass {
      constructor(options = {}) {
        super(options);
        if (options.objectMode)
          throw new TypeError(`${this.constructor.name} streams only work with string and buffer data`);
        this.found = 0;
        this.expect = options.size;
        if (typeof this.expect !== "number" || this.expect > Number.MAX_SAFE_INTEGER || isNaN(this.expect) || this.expect < 0 || !isFinite(this.expect) || this.expect !== Math.floor(this.expect))
          throw new Error("invalid expected size: " + this.expect);
      }
      write(chunk, encoding, cb) {
        const buffer = Buffer.isBuffer(chunk) ? chunk : typeof chunk === "string" ? Buffer.from(chunk, typeof encoding === "string" ? encoding : "utf8") : chunk;
        if (!Buffer.isBuffer(buffer)) {
          this.emit("error", new TypeError(`${this.constructor.name} streams only work with string and buffer data`));
          return false;
        }
        this.found += buffer.length;
        if (this.found > this.expect)
          this.emit("error", new SizeError(this.found, this.expect));
        return super.write(chunk, encoding, cb);
      }
      emit(ev, ...data) {
        if (ev === "end") {
          if (this.found !== this.expect)
            this.emit("error", new SizeError(this.found, this.expect));
        }
        return super.emit(ev, ...data);
      }
    };
    MinipassSized.SizeError = SizeError;
    module2.exports = MinipassSized;
  }
});

// node_modules/minipass-fetch/lib/blob.js
var require_blob = __commonJS({
  "node_modules/minipass-fetch/lib/blob.js"(exports2, module2) {
    "use strict";
    var { Minipass } = require_commonjs3();
    var TYPE = Symbol("type");
    var BUFFER = Symbol("buffer");
    var Blob = class _Blob {
      constructor(blobParts, options) {
        this[TYPE] = "";
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            const buffer = element instanceof Buffer ? element : ArrayBuffer.isView(element) ? Buffer.from(element.buffer, element.byteOffset, element.byteLength) : element instanceof ArrayBuffer ? Buffer.from(element) : element instanceof _Blob ? element[BUFFER] : typeof element === "string" ? Buffer.from(element) : Buffer.from(String(element));
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers, size);
        const type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const off = buf.byteOffset;
        const len = buf.byteLength;
        const ab = buf.buffer.slice(off, off + len);
        return Promise.resolve(ab);
      }
      stream() {
        return new Minipass().end(this[BUFFER]);
      }
      slice(start, end, type) {
        const size = this.size;
        const relativeStart = start === void 0 ? 0 : start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        const relativeEnd = end === void 0 ? size : end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(
          relativeStart,
          relativeStart + span
        );
        const blob = new _Blob([], { type });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static get BUFFER() {
        return BUFFER;
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true }
    });
    module2.exports = Blob;
  }
});

// node_modules/minipass-fetch/lib/fetch-error.js
var require_fetch_error = __commonJS({
  "node_modules/minipass-fetch/lib/fetch-error.js"(exports2, module2) {
    "use strict";
    var FetchError = class extends Error {
      constructor(message, type, systemError) {
        super(message);
        this.code = "FETCH_ERROR";
        if (systemError) {
          Object.assign(this, systemError);
        }
        this.errno = this.code;
        this.type = this.code === "EBADSIZE" && this.found > this.expect ? "max-size" : type;
        this.message = message;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "FetchError";
      }
      // don't allow name to be overwritten
      set name(n) {
      }
      get [Symbol.toStringTag]() {
        return "FetchError";
      }
    };
    module2.exports = FetchError;
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports2, module2) {
    "use strict";
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key)) continue;
      if (key === "SlowBuffer" || key === "Buffer") continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer2) {
      if (!Buffer2.hasOwnProperty(key)) continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
      Safer[key] = Buffer2[key];
    }
    safer.Buffer.prototype = Buffer2.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer2(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer2(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module2.exports = safer;
  }
});

// node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS({
  "node_modules/iconv-lite/lib/bom-handling.js"(exports2) {
    "use strict";
    var BOMChar = "\uFEFF";
    exports2.PrependBOM = PrependBOMWrapper;
    function PrependBOMWrapper(encoder, options) {
      this.encoder = encoder;
      this.addBOM = true;
    }
    PrependBOMWrapper.prototype.write = function(str) {
      if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
      }
      return this.encoder.write(str);
    };
    PrependBOMWrapper.prototype.end = function() {
      return this.encoder.end();
    };
    exports2.StripBOM = StripBOMWrapper;
    function StripBOMWrapper(decoder, options) {
      this.decoder = decoder;
      this.pass = false;
      this.options = options || {};
    }
    StripBOMWrapper.prototype.write = function(buf) {
      var res = this.decoder.write(buf);
      if (this.pass || !res)
        return res;
      if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === "function")
          this.options.stripBOM();
      }
      this.pass = true;
      return res;
    };
    StripBOMWrapper.prototype.end = function() {
      return this.decoder.end();
    };
  }
});

// node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS({
  "node_modules/iconv-lite/encodings/internal.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    module2.exports = {
      // Encodings
      utf8: { type: "_internal", bomAware: true },
      cesu8: { type: "_internal", bomAware: true },
      unicode11utf8: "utf8",
      ucs2: { type: "_internal", bomAware: true },
      utf16le: "ucs2",
      binary: { type: "_internal" },
      base64: { type: "_internal" },
      hex: { type: "_internal" },
      // Codec.
      _internal: InternalCodec
    };
    function InternalCodec(codecOptions, iconv) {
      this.enc = codecOptions.encodingName;
      this.bomAware = codecOptions.bomAware;
      if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
      else if (this.enc === "cesu8") {
        this.enc = "utf8";
        this.encoder = InternalEncoderCesu8;
        if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "\u{1F4A9}") {
          this.decoder = InternalDecoderCesu8;
          this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
      }
    }
    InternalCodec.prototype.encoder = InternalEncoder;
    InternalCodec.prototype.decoder = InternalDecoder;
    var StringDecoder = require("string_decoder").StringDecoder;
    if (!StringDecoder.prototype.end)
      StringDecoder.prototype.end = function() {
      };
    function InternalDecoder(options, codec) {
      this.decoder = new StringDecoder(codec.enc);
    }
    InternalDecoder.prototype.write = function(buf) {
      if (!Buffer2.isBuffer(buf)) {
        buf = Buffer2.from(buf);
      }
      return this.decoder.write(buf);
    };
    InternalDecoder.prototype.end = function() {
      return this.decoder.end();
    };
    function InternalEncoder(options, codec) {
      this.enc = codec.enc;
    }
    InternalEncoder.prototype.write = function(str) {
      return Buffer2.from(str, this.enc);
    };
    InternalEncoder.prototype.end = function() {
    };
    function InternalEncoderBase64(options, codec) {
      this.prevStr = "";
    }
    InternalEncoderBase64.prototype.write = function(str) {
      str = this.prevStr + str;
      var completeQuads = str.length - str.length % 4;
      this.prevStr = str.slice(completeQuads);
      str = str.slice(0, completeQuads);
      return Buffer2.from(str, "base64");
    };
    InternalEncoderBase64.prototype.end = function() {
      return Buffer2.from(this.prevStr, "base64");
    };
    function InternalEncoderCesu8(options, codec) {
    }
    InternalEncoderCesu8.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
      for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (charCode < 128)
          buf[bufIdx++] = charCode;
        else if (charCode < 2048) {
          buf[bufIdx++] = 192 + (charCode >>> 6);
          buf[bufIdx++] = 128 + (charCode & 63);
        } else {
          buf[bufIdx++] = 224 + (charCode >>> 12);
          buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
          buf[bufIdx++] = 128 + (charCode & 63);
        }
      }
      return buf.slice(0, bufIdx);
    };
    InternalEncoderCesu8.prototype.end = function() {
    };
    function InternalDecoderCesu8(options, codec) {
      this.acc = 0;
      this.contBytes = 0;
      this.accBytes = 0;
      this.defaultCharUnicode = codec.defaultCharUnicode;
    }
    InternalDecoderCesu8.prototype.write = function(buf) {
      var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
      for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 192) !== 128) {
          if (contBytes > 0) {
            res += this.defaultCharUnicode;
            contBytes = 0;
          }
          if (curByte < 128) {
            res += String.fromCharCode(curByte);
          } else if (curByte < 224) {
            acc = curByte & 31;
            contBytes = 1;
            accBytes = 1;
          } else if (curByte < 240) {
            acc = curByte & 15;
            contBytes = 2;
            accBytes = 1;
          } else {
            res += this.defaultCharUnicode;
          }
        } else {
          if (contBytes > 0) {
            acc = acc << 6 | curByte & 63;
            contBytes--;
            accBytes++;
            if (contBytes === 0) {
              if (accBytes === 2 && acc < 128 && acc > 0)
                res += this.defaultCharUnicode;
              else if (accBytes === 3 && acc < 2048)
                res += this.defaultCharUnicode;
              else
                res += String.fromCharCode(acc);
            }
          } else {
            res += this.defaultCharUnicode;
          }
        }
      }
      this.acc = acc;
      this.contBytes = contBytes;
      this.accBytes = accBytes;
      return res;
    };
    InternalDecoderCesu8.prototype.end = function() {
      var res = 0;
      if (this.contBytes > 0)
        res += this.defaultCharUnicode;
      return res;
    };
  }
});

// node_modules/iconv-lite/encodings/utf32.js
var require_utf32 = __commonJS({
  "node_modules/iconv-lite/encodings/utf32.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2._utf32 = Utf32Codec;
    function Utf32Codec(codecOptions, iconv) {
      this.iconv = iconv;
      this.bomAware = true;
      this.isLE = codecOptions.isLE;
    }
    exports2.utf32le = { type: "_utf32", isLE: true };
    exports2.utf32be = { type: "_utf32", isLE: false };
    exports2.ucs4le = "utf32le";
    exports2.ucs4be = "utf32be";
    Utf32Codec.prototype.encoder = Utf32Encoder;
    Utf32Codec.prototype.decoder = Utf32Decoder;
    function Utf32Encoder(options, codec) {
      this.isLE = codec.isLE;
      this.highSurrogate = 0;
    }
    Utf32Encoder.prototype.write = function(str) {
      var src = Buffer2.from(str, "ucs2");
      var dst = Buffer2.alloc(src.length * 2);
      var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
      var offset = 0;
      for (var i = 0; i < src.length; i += 2) {
        var code = src.readUInt16LE(i);
        var isHighSurrogate = 55296 <= code && code < 56320;
        var isLowSurrogate = 56320 <= code && code < 57344;
        if (this.highSurrogate) {
          if (isHighSurrogate || !isLowSurrogate) {
            write32.call(dst, this.highSurrogate, offset);
            offset += 4;
          } else {
            var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
            write32.call(dst, codepoint, offset);
            offset += 4;
            this.highSurrogate = 0;
            continue;
          }
        }
        if (isHighSurrogate)
          this.highSurrogate = code;
        else {
          write32.call(dst, code, offset);
          offset += 4;
          this.highSurrogate = 0;
        }
      }
      if (offset < dst.length)
        dst = dst.slice(0, offset);
      return dst;
    };
    Utf32Encoder.prototype.end = function() {
      if (!this.highSurrogate)
        return;
      var buf = Buffer2.alloc(4);
      if (this.isLE)
        buf.writeUInt32LE(this.highSurrogate, 0);
      else
        buf.writeUInt32BE(this.highSurrogate, 0);
      this.highSurrogate = 0;
      return buf;
    };
    function Utf32Decoder(options, codec) {
      this.isLE = codec.isLE;
      this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
      this.overflow = [];
    }
    Utf32Decoder.prototype.write = function(src) {
      if (src.length === 0)
        return "";
      var i = 0;
      var codepoint = 0;
      var dst = Buffer2.alloc(src.length + 4);
      var offset = 0;
      var isLE = this.isLE;
      var overflow = this.overflow;
      var badChar = this.badChar;
      if (overflow.length > 0) {
        for (; i < src.length && overflow.length < 4; i++)
          overflow.push(src[i]);
        if (overflow.length === 4) {
          if (isLE) {
            codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
          } else {
            codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
          }
          overflow.length = 0;
          offset = _writeCodepoint(dst, offset, codepoint, badChar);
        }
      }
      for (; i < src.length - 3; i += 4) {
        if (isLE) {
          codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
        } else {
          codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
        }
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
      for (; i < src.length; i++) {
        overflow.push(src[i]);
      }
      return dst.slice(0, offset).toString("ucs2");
    };
    function _writeCodepoint(dst, offset, codepoint, badChar) {
      if (codepoint < 0 || codepoint > 1114111) {
        codepoint = badChar;
      }
      if (codepoint >= 65536) {
        codepoint -= 65536;
        var high = 55296 | codepoint >> 10;
        dst[offset++] = high & 255;
        dst[offset++] = high >> 8;
        var codepoint = 56320 | codepoint & 1023;
      }
      dst[offset++] = codepoint & 255;
      dst[offset++] = codepoint >> 8;
      return offset;
    }
    Utf32Decoder.prototype.end = function() {
      this.overflow.length = 0;
    };
    exports2.utf32 = Utf32AutoCodec;
    exports2.ucs4 = "utf32";
    function Utf32AutoCodec(options, iconv) {
      this.iconv = iconv;
    }
    Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
    Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
    function Utf32AutoEncoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0)
        options.addBOM = true;
      this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
    }
    Utf32AutoEncoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf32AutoEncoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf32AutoDecoder(options, codec) {
      this.decoder = null;
      this.initialBufs = [];
      this.initialBufsLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf32AutoDecoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 32)
          return "";
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.write(buf);
    };
    Utf32AutoDecoder.prototype.end = function() {
      if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        var trail = this.decoder.end();
        if (trail)
          resStr += trail;
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.end();
    };
    function detectEncoding(bufs, defaultEncoding) {
      var b = [];
      var charsProcessed = 0;
      var invalidLE = 0, invalidBE = 0;
      var bmpCharsLE = 0, bmpCharsBE = 0;
      outer_loop:
        for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 4) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                  return "utf-32le";
                }
                if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                  return "utf-32be";
                }
              }
              if (b[0] !== 0 || b[1] > 16) invalidBE++;
              if (b[3] !== 0 || b[2] > 16) invalidLE++;
              if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
              if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
      if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
      if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
      return defaultEncoding || "utf-32le";
    }
  }
});

// node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS({
  "node_modules/iconv-lite/encodings/utf16.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2.utf16be = Utf16BECodec;
    function Utf16BECodec() {
    }
    Utf16BECodec.prototype.encoder = Utf16BEEncoder;
    Utf16BECodec.prototype.decoder = Utf16BEDecoder;
    Utf16BECodec.prototype.bomAware = true;
    function Utf16BEEncoder() {
    }
    Utf16BEEncoder.prototype.write = function(str) {
      var buf = Buffer2.from(str, "ucs2");
      for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i];
        buf[i] = buf[i + 1];
        buf[i + 1] = tmp;
      }
      return buf;
    };
    Utf16BEEncoder.prototype.end = function() {
    };
    function Utf16BEDecoder() {
      this.overflowByte = -1;
    }
    Utf16BEDecoder.prototype.write = function(buf) {
      if (buf.length == 0)
        return "";
      var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
      if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1;
        j = 2;
      }
      for (; i < buf.length - 1; i += 2, j += 2) {
        buf2[j] = buf[i + 1];
        buf2[j + 1] = buf[i];
      }
      this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
      return buf2.slice(0, j).toString("ucs2");
    };
    Utf16BEDecoder.prototype.end = function() {
      this.overflowByte = -1;
    };
    exports2.utf16 = Utf16Codec;
    function Utf16Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf16Codec.prototype.encoder = Utf16Encoder;
    Utf16Codec.prototype.decoder = Utf16Decoder;
    function Utf16Encoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0)
        options.addBOM = true;
      this.encoder = codec.iconv.getEncoder("utf-16le", options);
    }
    Utf16Encoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf16Encoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf16Decoder(options, codec) {
      this.decoder = null;
      this.initialBufs = [];
      this.initialBufsLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf16Decoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 16)
          return "";
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.write(buf);
    };
    Utf16Decoder.prototype.end = function() {
      if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        var trail = this.decoder.end();
        if (trail)
          resStr += trail;
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.end();
    };
    function detectEncoding(bufs, defaultEncoding) {
      var b = [];
      var charsProcessed = 0;
      var asciiCharsLE = 0, asciiCharsBE = 0;
      outer_loop:
        for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 2) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254) return "utf-16le";
                if (b[0] === 254 && b[1] === 255) return "utf-16be";
              }
              if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
              if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
      if (asciiCharsBE > asciiCharsLE) return "utf-16be";
      if (asciiCharsBE < asciiCharsLE) return "utf-16le";
      return defaultEncoding || "utf-16le";
    }
  }
});

// node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS({
  "node_modules/iconv-lite/encodings/utf7.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2.utf7 = Utf7Codec;
    exports2.unicode11utf7 = "utf7";
    function Utf7Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7Codec.prototype.encoder = Utf7Encoder;
    Utf7Codec.prototype.decoder = Utf7Decoder;
    Utf7Codec.prototype.bomAware = true;
    var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
    function Utf7Encoder(options, codec) {
      this.iconv = codec.iconv;
    }
    Utf7Encoder.prototype.write = function(str) {
      return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
      }.bind(this)));
    };
    Utf7Encoder.prototype.end = function() {
    };
    function Utf7Decoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64Regex = /[A-Za-z0-9\/+]/;
    var base64Chars = [];
    for (i = 0; i < 256; i++)
      base64Chars[i] = base64Regex.test(String.fromCharCode(i));
    var i;
    var plusChar = "+".charCodeAt(0);
    var minusChar = "-".charCodeAt(0);
    var andChar = "&".charCodeAt(0);
    Utf7Decoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == plusChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64Chars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "+";
            } else {
              var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7Decoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
    exports2.utf7imap = Utf7IMAPCodec;
    function Utf7IMAPCodec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
    Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
    Utf7IMAPCodec.prototype.bomAware = true;
    function Utf7IMAPEncoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = Buffer2.alloc(6);
      this.base64AccumIdx = 0;
    }
    Utf7IMAPEncoder.prototype.write = function(str) {
      var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
      for (var i2 = 0; i2 < str.length; i2++) {
        var uChar = str.charCodeAt(i2);
        if (32 <= uChar && uChar <= 126) {
          if (inBase64) {
            if (base64AccumIdx > 0) {
              bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
              base64AccumIdx = 0;
            }
            buf[bufIdx++] = minusChar;
            inBase64 = false;
          }
          if (!inBase64) {
            buf[bufIdx++] = uChar;
            if (uChar === andChar)
              buf[bufIdx++] = minusChar;
          }
        } else {
          if (!inBase64) {
            buf[bufIdx++] = andChar;
            inBase64 = true;
          }
          if (inBase64) {
            base64Accum[base64AccumIdx++] = uChar >> 8;
            base64Accum[base64AccumIdx++] = uChar & 255;
            if (base64AccumIdx == base64Accum.length) {
              bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
              base64AccumIdx = 0;
            }
          }
        }
      }
      this.inBase64 = inBase64;
      this.base64AccumIdx = base64AccumIdx;
      return buf.slice(0, bufIdx);
    };
    Utf7IMAPEncoder.prototype.end = function() {
      var buf = Buffer2.alloc(10), bufIdx = 0;
      if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
          bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
          this.base64AccumIdx = 0;
        }
        buf[bufIdx++] = minusChar;
        this.inBase64 = false;
      }
      return buf.slice(0, bufIdx);
    };
    function Utf7IMAPDecoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64IMAPChars = base64Chars.slice();
    base64IMAPChars[",".charCodeAt(0)] = true;
    Utf7IMAPDecoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == andChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64IMAPChars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "&";
            } else {
              var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7IMAPDecoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-codec.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2._sbcs = SBCSCodec;
    function SBCSCodec(codecOptions, iconv) {
      if (!codecOptions)
        throw new Error("SBCS codec is called without the data.");
      if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
        throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
      if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
          asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
      }
      this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
      var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
      for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
      this.encodeBuf = encodeBuf;
    }
    SBCSCodec.prototype.encoder = SBCSEncoder;
    SBCSCodec.prototype.decoder = SBCSDecoder;
    function SBCSEncoder(options, codec) {
      this.encodeBuf = codec.encodeBuf;
    }
    SBCSEncoder.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length);
      for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
      return buf;
    };
    SBCSEncoder.prototype.end = function() {
    };
    function SBCSDecoder(options, codec) {
      this.decodeBuf = codec.decodeBuf;
    }
    SBCSDecoder.prototype.write = function(buf) {
      var decodeBuf = this.decodeBuf;
      var newBuf = Buffer2.alloc(buf.length * 2);
      var idx1 = 0, idx2 = 0;
      for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i] * 2;
        idx2 = i * 2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
      }
      return newBuf.toString("ucs2");
    };
    SBCSDecoder.prototype.end = function() {
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-data.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // Not supported by iconv, not sure why.
      "10029": "maccenteuro",
      "maccenteuro": {
        "type": "_sbcs",
        "chars": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7"
      },
      "808": "cp808",
      "ibm808": "cp808",
      "cp808": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\u20AC\u25A0\xA0"
      },
      "mik": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2514\u2534\u252C\u251C\u2500\u253C\u2563\u2551\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2510\u2591\u2592\u2593\u2502\u2524\u2116\xA7\u2557\u255D\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "cp720": {
        "type": "_sbcs",
        "chars": "\x80\x81\xE9\xE2\x84\xE0\x86\xE7\xEA\xEB\xE8\xEF\xEE\x8D\x8E\x8F\x90\u0651\u0652\xF4\xA4\u0640\xFB\xF9\u0621\u0622\u0623\u0624\xA3\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0636\u0637\u0638\u0639\u063A\u0641\xB5\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u2261\u064B\u064C\u064D\u064E\u064F\u0650\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      // Aliases of generated encodings.
      "ascii8bit": "ascii",
      "usascii": "ascii",
      "ansix34": "ascii",
      "ansix341968": "ascii",
      "ansix341986": "ascii",
      "csascii": "ascii",
      "cp367": "ascii",
      "ibm367": "ascii",
      "isoir6": "ascii",
      "iso646us": "ascii",
      "iso646irv": "ascii",
      "us": "ascii",
      "latin1": "iso88591",
      "latin2": "iso88592",
      "latin3": "iso88593",
      "latin4": "iso88594",
      "latin5": "iso88599",
      "latin6": "iso885910",
      "latin7": "iso885913",
      "latin8": "iso885914",
      "latin9": "iso885915",
      "latin10": "iso885916",
      "csisolatin1": "iso88591",
      "csisolatin2": "iso88592",
      "csisolatin3": "iso88593",
      "csisolatin4": "iso88594",
      "csisolatincyrillic": "iso88595",
      "csisolatinarabic": "iso88596",
      "csisolatingreek": "iso88597",
      "csisolatinhebrew": "iso88598",
      "csisolatin5": "iso88599",
      "csisolatin6": "iso885910",
      "l1": "iso88591",
      "l2": "iso88592",
      "l3": "iso88593",
      "l4": "iso88594",
      "l5": "iso88599",
      "l6": "iso885910",
      "l7": "iso885913",
      "l8": "iso885914",
      "l9": "iso885915",
      "l10": "iso885916",
      "isoir14": "iso646jp",
      "isoir57": "iso646cn",
      "isoir100": "iso88591",
      "isoir101": "iso88592",
      "isoir109": "iso88593",
      "isoir110": "iso88594",
      "isoir144": "iso88595",
      "isoir127": "iso88596",
      "isoir126": "iso88597",
      "isoir138": "iso88598",
      "isoir148": "iso88599",
      "isoir157": "iso885910",
      "isoir166": "tis620",
      "isoir179": "iso885913",
      "isoir199": "iso885914",
      "isoir203": "iso885915",
      "isoir226": "iso885916",
      "cp819": "iso88591",
      "ibm819": "iso88591",
      "cyrillic": "iso88595",
      "arabic": "iso88596",
      "arabic8": "iso88596",
      "ecma114": "iso88596",
      "asmo708": "iso88596",
      "greek": "iso88597",
      "greek8": "iso88597",
      "ecma118": "iso88597",
      "elot928": "iso88597",
      "hebrew": "iso88598",
      "hebrew8": "iso88598",
      "turkish": "iso88599",
      "turkish8": "iso88599",
      "thai": "iso885911",
      "thai8": "iso885911",
      "celtic": "iso885914",
      "celtic8": "iso885914",
      "isoceltic": "iso885914",
      "tis6200": "tis620",
      "tis62025291": "tis620",
      "tis62025330": "tis620",
      "10000": "macroman",
      "10006": "macgreek",
      "10007": "maccyrillic",
      "10079": "maciceland",
      "10081": "macturkish",
      "cspc8codepage437": "cp437",
      "cspc775baltic": "cp775",
      "cspc850multilingual": "cp850",
      "cspcp852": "cp852",
      "cspc862latinhebrew": "cp862",
      "cpgr": "cp869",
      "msee": "cp1250",
      "mscyrl": "cp1251",
      "msansi": "cp1252",
      "msgreek": "cp1253",
      "msturk": "cp1254",
      "mshebr": "cp1255",
      "msarab": "cp1256",
      "winbaltrim": "cp1257",
      "cp20866": "koi8r",
      "20866": "koi8r",
      "ibm878": "koi8r",
      "cskoi8r": "koi8r",
      "cp21866": "koi8u",
      "21866": "koi8u",
      "ibm1168": "koi8u",
      "strk10482002": "rk1048",
      "tcvn5712": "tcvn",
      "tcvn57121": "tcvn",
      "gb198880": "iso646cn",
      "cn": "iso646cn",
      "csiso14jisc6220ro": "iso646jp",
      "jisc62201969ro": "iso646jp",
      "jp": "iso646jp",
      "cshproman8": "hproman8",
      "r8": "hproman8",
      "roman8": "hproman8",
      "xroman8": "hproman8",
      "ibm1051": "hproman8",
      "mac": "macintosh",
      "csmacintosh": "macintosh"
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-data-generated.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "437": "cp437",
      "737": "cp737",
      "775": "cp775",
      "850": "cp850",
      "852": "cp852",
      "855": "cp855",
      "856": "cp856",
      "857": "cp857",
      "858": "cp858",
      "860": "cp860",
      "861": "cp861",
      "862": "cp862",
      "863": "cp863",
      "864": "cp864",
      "865": "cp865",
      "866": "cp866",
      "869": "cp869",
      "874": "windows874",
      "922": "cp922",
      "1046": "cp1046",
      "1124": "cp1124",
      "1125": "cp1125",
      "1129": "cp1129",
      "1133": "cp1133",
      "1161": "cp1161",
      "1162": "cp1162",
      "1163": "cp1163",
      "1250": "windows1250",
      "1251": "windows1251",
      "1252": "windows1252",
      "1253": "windows1253",
      "1254": "windows1254",
      "1255": "windows1255",
      "1256": "windows1256",
      "1257": "windows1257",
      "1258": "windows1258",
      "28591": "iso88591",
      "28592": "iso88592",
      "28593": "iso88593",
      "28594": "iso88594",
      "28595": "iso88595",
      "28596": "iso88596",
      "28597": "iso88597",
      "28598": "iso88598",
      "28599": "iso88599",
      "28600": "iso885910",
      "28601": "iso885911",
      "28603": "iso885913",
      "28604": "iso885914",
      "28605": "iso885915",
      "28606": "iso885916",
      "windows874": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\uFFFD\uFFFD\uFFFD\u2026\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "win874": "windows874",
      "cp874": "windows874",
      "windows1250": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\u0160\u2039\u015A\u0164\u017D\u0179\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0161\u203A\u015B\u0165\u017E\u017A\xA0\u02C7\u02D8\u0141\xA4\u0104\xA6\xA7\xA8\xA9\u015E\xAB\xAC\xAD\xAE\u017B\xB0\xB1\u02DB\u0142\xB4\xB5\xB6\xB7\xB8\u0105\u015F\xBB\u013D\u02DD\u013E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
      },
      "win1250": "windows1250",
      "cp1250": "windows1250",
      "windows1251": {
        "type": "_sbcs",
        "chars": "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u040C\u040B\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u045C\u045B\u045F\xA0\u040E\u045E\u0408\xA4\u0490\xA6\xA7\u0401\xA9\u0404\xAB\xAC\xAD\xAE\u0407\xB0\xB1\u0406\u0456\u0491\xB5\xB6\xB7\u0451\u2116\u0454\xBB\u0458\u0405\u0455\u0457\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "win1251": "windows1251",
      "cp1251": "windows1251",
      "windows1252": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\u017D\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\u017E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "win1252": "windows1252",
      "cp1252": "windows1252",
      "windows1253": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0385\u0386\xA3\xA4\xA5\xA6\xA7\xA8\xA9\uFFFD\xAB\xAC\xAD\xAE\u2015\xB0\xB1\xB2\xB3\u0384\xB5\xB6\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
      },
      "win1253": "windows1253",
      "cp1253": "windows1253",
      "windows1254": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
      },
      "win1254": "windows1254",
      "cp1254": "windows1254",
      "windows1255": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\xA1\xA2\xA3\u20AA\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\xBF\u05B0\u05B1\u05B2\u05B3\u05B4\u05B5\u05B6\u05B7\u05B8\u05B9\u05BA\u05BB\u05BC\u05BD\u05BE\u05BF\u05C0\u05C1\u05C2\u05C3\u05F0\u05F1\u05F2\u05F3\u05F4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
      },
      "win1255": "windows1255",
      "cp1255": "windows1255",
      "windows1256": {
        "type": "_sbcs",
        "chars": "\u20AC\u067E\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0679\u2039\u0152\u0686\u0698\u0688\u06AF\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u06A9\u2122\u0691\u203A\u0153\u200C\u200D\u06BA\xA0\u060C\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\u06BE\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\u061B\xBB\xBC\xBD\xBE\u061F\u06C1\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\xD7\u0637\u0638\u0639\u063A\u0640\u0641\u0642\u0643\xE0\u0644\xE2\u0645\u0646\u0647\u0648\xE7\xE8\xE9\xEA\xEB\u0649\u064A\xEE\xEF\u064B\u064C\u064D\u064E\xF4\u064F\u0650\xF7\u0651\xF9\u0652\xFB\xFC\u200E\u200F\u06D2"
      },
      "win1256": "windows1256",
      "cp1256": "windows1256",
      "windows1257": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\xA8\u02C7\xB8\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\xAF\u02DB\uFFFD\xA0\uFFFD\xA2\xA3\xA4\uFFFD\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u02D9"
      },
      "win1257": "windows1257",
      "cp1257": "windows1257",
      "windows1258": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "win1258": "windows1258",
      "cp1258": "windows1258",
      "iso88591": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "cp28591": "iso88591",
      "iso88592": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u02D8\u0141\xA4\u013D\u015A\xA7\xA8\u0160\u015E\u0164\u0179\xAD\u017D\u017B\xB0\u0105\u02DB\u0142\xB4\u013E\u015B\u02C7\xB8\u0161\u015F\u0165\u017A\u02DD\u017E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
      },
      "cp28592": "iso88592",
      "iso88593": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0126\u02D8\xA3\xA4\uFFFD\u0124\xA7\xA8\u0130\u015E\u011E\u0134\xAD\uFFFD\u017B\xB0\u0127\xB2\xB3\xB4\xB5\u0125\xB7\xB8\u0131\u015F\u011F\u0135\xBD\uFFFD\u017C\xC0\xC1\xC2\uFFFD\xC4\u010A\u0108\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\uFFFD\xD1\xD2\xD3\xD4\u0120\xD6\xD7\u011C\xD9\xDA\xDB\xDC\u016C\u015C\xDF\xE0\xE1\xE2\uFFFD\xE4\u010B\u0109\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\uFFFD\xF1\xF2\xF3\xF4\u0121\xF6\xF7\u011D\xF9\xFA\xFB\xFC\u016D\u015D\u02D9"
      },
      "cp28593": "iso88593",
      "iso88594": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0138\u0156\xA4\u0128\u013B\xA7\xA8\u0160\u0112\u0122\u0166\xAD\u017D\xAF\xB0\u0105\u02DB\u0157\xB4\u0129\u013C\u02C7\xB8\u0161\u0113\u0123\u0167\u014A\u017E\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\u012A\u0110\u0145\u014C\u0136\xD4\xD5\xD6\xD7\xD8\u0172\xDA\xDB\xDC\u0168\u016A\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\u012B\u0111\u0146\u014D\u0137\xF4\xF5\xF6\xF7\xF8\u0173\xFA\xFB\xFC\u0169\u016B\u02D9"
      },
      "cp28594": "iso88594",
      "iso88595": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0403\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0453\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
      },
      "cp28595": "iso88595",
      "iso88596": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\uFFFD\uFFFD\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u060C\xAD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u061B\uFFFD\uFFFD\uFFFD\u061F\uFFFD\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "cp28596": "iso88596",
      "iso88597": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u2018\u2019\xA3\u20AC\u20AF\xA6\xA7\xA8\xA9\u037A\xAB\xAC\xAD\uFFFD\u2015\xB0\xB1\xB2\xB3\u0384\u0385\u0386\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
      },
      "cp28597": "iso88597",
      "iso88598": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2017\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
      },
      "cp28598": "iso88598",
      "iso88599": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
      },
      "cp28599": "iso88599",
      "iso885910": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0112\u0122\u012A\u0128\u0136\xA7\u013B\u0110\u0160\u0166\u017D\xAD\u016A\u014A\xB0\u0105\u0113\u0123\u012B\u0129\u0137\xB7\u013C\u0111\u0161\u0167\u017E\u2015\u016B\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\xCF\xD0\u0145\u014C\xD3\xD4\xD5\xD6\u0168\xD8\u0172\xDA\xDB\xDC\xDD\xDE\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\xEF\xF0\u0146\u014D\xF3\xF4\xF5\xF6\u0169\xF8\u0173\xFA\xFB\xFC\xFD\xFE\u0138"
      },
      "cp28600": "iso885910",
      "iso885911": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "cp28601": "iso885911",
      "iso885913": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u201D\xA2\xA3\xA4\u201E\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\u201C\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u2019"
      },
      "cp28603": "iso885913",
      "iso885914": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u1E02\u1E03\xA3\u010A\u010B\u1E0A\xA7\u1E80\xA9\u1E82\u1E0B\u1EF2\xAD\xAE\u0178\u1E1E\u1E1F\u0120\u0121\u1E40\u1E41\xB6\u1E56\u1E81\u1E57\u1E83\u1E60\u1EF3\u1E84\u1E85\u1E61\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0174\xD1\xD2\xD3\xD4\xD5\xD6\u1E6A\xD8\xD9\xDA\xDB\xDC\xDD\u0176\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0175\xF1\xF2\xF3\xF4\xF5\xF6\u1E6B\xF8\xF9\xFA\xFB\xFC\xFD\u0177\xFF"
      },
      "cp28604": "iso885914",
      "iso885915": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\u0160\xA7\u0161\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u017D\xB5\xB6\xB7\u017E\xB9\xBA\xBB\u0152\u0153\u0178\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "cp28605": "iso885915",
      "iso885916": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0105\u0141\u20AC\u201E\u0160\xA7\u0161\xA9\u0218\xAB\u0179\xAD\u017A\u017B\xB0\xB1\u010C\u0142\u017D\u201D\xB6\xB7\u017E\u010D\u0219\xBB\u0152\u0153\u0178\u017C\xC0\xC1\xC2\u0102\xC4\u0106\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0110\u0143\xD2\xD3\xD4\u0150\xD6\u015A\u0170\xD9\xDA\xDB\xDC\u0118\u021A\xDF\xE0\xE1\xE2\u0103\xE4\u0107\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0111\u0144\xF2\xF3\xF4\u0151\xF6\u015B\u0171\xF9\xFA\xFB\xFC\u0119\u021B\xFF"
      },
      "cp28606": "iso885916",
      "cp437": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm437": "cp437",
      "csibm437": "cp437",
      "cp737": {
        "type": "_sbcs",
        "chars": "\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u03C5\u03C6\u03C7\u03C8\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03C9\u03AC\u03AD\u03AE\u03CA\u03AF\u03CC\u03CD\u03CB\u03CE\u0386\u0388\u0389\u038A\u038C\u038E\u038F\xB1\u2265\u2264\u03AA\u03AB\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm737": "cp737",
      "csibm737": "cp737",
      "cp775": {
        "type": "_sbcs",
        "chars": "\u0106\xFC\xE9\u0101\xE4\u0123\xE5\u0107\u0142\u0113\u0156\u0157\u012B\u0179\xC4\xC5\xC9\xE6\xC6\u014D\xF6\u0122\xA2\u015A\u015B\xD6\xDC\xF8\xA3\xD8\xD7\xA4\u0100\u012A\xF3\u017B\u017C\u017A\u201D\xA6\xA9\xAE\xAC\xBD\xBC\u0141\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0104\u010C\u0118\u0116\u2563\u2551\u2557\u255D\u012E\u0160\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0172\u016A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u017D\u0105\u010D\u0119\u0117\u012F\u0161\u0173\u016B\u017E\u2518\u250C\u2588\u2584\u258C\u2590\u2580\xD3\xDF\u014C\u0143\xF5\xD5\xB5\u0144\u0136\u0137\u013B\u013C\u0146\u0112\u0145\u2019\xAD\xB1\u201C\xBE\xB6\xA7\xF7\u201E\xB0\u2219\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm775": "cp775",
      "csibm775": "cp775",
      "cp850": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u0131\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm850": "cp850",
      "csibm850": "cp850",
      "cp852": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\u016F\u0107\xE7\u0142\xEB\u0150\u0151\xEE\u0179\xC4\u0106\xC9\u0139\u013A\xF4\xF6\u013D\u013E\u015A\u015B\xD6\xDC\u0164\u0165\u0141\xD7\u010D\xE1\xED\xF3\xFA\u0104\u0105\u017D\u017E\u0118\u0119\xAC\u017A\u010C\u015F\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\u011A\u015E\u2563\u2551\u2557\u255D\u017B\u017C\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0102\u0103\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u0111\u0110\u010E\xCB\u010F\u0147\xCD\xCE\u011B\u2518\u250C\u2588\u2584\u0162\u016E\u2580\xD3\xDF\xD4\u0143\u0144\u0148\u0160\u0161\u0154\xDA\u0155\u0170\xFD\xDD\u0163\xB4\xAD\u02DD\u02DB\u02C7\u02D8\xA7\xF7\xB8\xB0\xA8\u02D9\u0171\u0158\u0159\u25A0\xA0"
      },
      "ibm852": "cp852",
      "csibm852": "cp852",
      "cp855": {
        "type": "_sbcs",
        "chars": "\u0452\u0402\u0453\u0403\u0451\u0401\u0454\u0404\u0455\u0405\u0456\u0406\u0457\u0407\u0458\u0408\u0459\u0409\u045A\u040A\u045B\u040B\u045C\u040C\u045E\u040E\u045F\u040F\u044E\u042E\u044A\u042A\u0430\u0410\u0431\u0411\u0446\u0426\u0434\u0414\u0435\u0415\u0444\u0424\u0433\u0413\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0445\u0425\u0438\u0418\u2563\u2551\u2557\u255D\u0439\u0419\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u043A\u041A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u043B\u041B\u043C\u041C\u043D\u041D\u043E\u041E\u043F\u2518\u250C\u2588\u2584\u041F\u044F\u2580\u042F\u0440\u0420\u0441\u0421\u0442\u0422\u0443\u0423\u0436\u0416\u0432\u0412\u044C\u042C\u2116\xAD\u044B\u042B\u0437\u0417\u0448\u0428\u044D\u042D\u0449\u0429\u0447\u0427\xA7\u25A0\xA0"
      },
      "ibm855": "cp855",
      "csibm855": "cp855",
      "cp856": {
        "type": "_sbcs",
        "chars": "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\xA3\uFFFD\xD7\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAE\xAC\xBD\xBC\uFFFD\xAB\xBB\u2591\u2592\u2593\u2502\u2524\uFFFD\uFFFD\uFFFD\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\uFFFD\uFFFD\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2518\u250C\u2588\u2584\xA6\uFFFD\u2580\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xB5\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm856": "cp856",
      "csibm856": "cp856",
      "cp857": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\u0131\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\u0130\xD6\xDC\xF8\xA3\xD8\u015E\u015F\xE1\xED\xF3\xFA\xF1\xD1\u011E\u011F\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xBA\xAA\xCA\xCB\xC8\uFFFD\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\uFFFD\xD7\xDA\xDB\xD9\xEC\xFF\xAF\xB4\xAD\xB1\uFFFD\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm857": "cp857",
      "csibm857": "cp857",
      "cp858": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u20AC\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm858": "cp858",
      "csibm858": "cp858",
      "cp860": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE3\xE0\xC1\xE7\xEA\xCA\xE8\xCD\xD4\xEC\xC3\xC2\xC9\xC0\xC8\xF4\xF5\xF2\xDA\xF9\xCC\xD5\xDC\xA2\xA3\xD9\u20A7\xD3\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xD2\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm860": "cp860",
      "csibm860": "cp860",
      "cp861": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xD0\xF0\xDE\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xFE\xFB\xDD\xFD\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xC1\xCD\xD3\xDA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm861": "cp861",
      "csibm861": "cp861",
      "cp862": {
        "type": "_sbcs",
        "chars": "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm862": "cp862",
      "csibm862": "cp862",
      "cp863": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xC2\xE0\xB6\xE7\xEA\xEB\xE8\xEF\xEE\u2017\xC0\xA7\xC9\xC8\xCA\xF4\xCB\xCF\xFB\xF9\xA4\xD4\xDC\xA2\xA3\xD9\xDB\u0192\xA6\xB4\xF3\xFA\xA8\xB8\xB3\xAF\xCE\u2310\xAC\xBD\xBC\xBE\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm863": "cp863",
      "csibm863": "cp863",
      "cp864": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$\u066A&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xB0\xB7\u2219\u221A\u2592\u2500\u2502\u253C\u2524\u252C\u251C\u2534\u2510\u250C\u2514\u2518\u03B2\u221E\u03C6\xB1\xBD\xBC\u2248\xAB\xBB\uFEF7\uFEF8\uFFFD\uFFFD\uFEFB\uFEFC\uFFFD\xA0\xAD\uFE82\xA3\xA4\uFE84\uFFFD\uFFFD\uFE8E\uFE8F\uFE95\uFE99\u060C\uFE9D\uFEA1\uFEA5\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFED1\u061B\uFEB1\uFEB5\uFEB9\u061F\xA2\uFE80\uFE81\uFE83\uFE85\uFECA\uFE8B\uFE8D\uFE91\uFE93\uFE97\uFE9B\uFE9F\uFEA3\uFEA7\uFEA9\uFEAB\uFEAD\uFEAF\uFEB3\uFEB7\uFEBB\uFEBF\uFEC1\uFEC5\uFECB\uFECF\xA6\xAC\xF7\xD7\uFEC9\u0640\uFED3\uFED7\uFEDB\uFEDF\uFEE3\uFEE7\uFEEB\uFEED\uFEEF\uFEF3\uFEBD\uFECC\uFECE\uFECD\uFEE1\uFE7D\u0651\uFEE5\uFEE9\uFEEC\uFEF0\uFEF2\uFED0\uFED5\uFEF5\uFEF6\uFEDD\uFED9\uFEF1\u25A0\uFFFD"
      },
      "ibm864": "cp864",
      "csibm864": "cp864",
      "cp865": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xA4\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm865": "cp865",
      "csibm865": "cp865",
      "cp866": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\xA4\u25A0\xA0"
      },
      "ibm866": "cp866",
      "csibm866": "cp866",
      "cp869": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0386\uFFFD\xB7\xAC\xA6\u2018\u2019\u0388\u2015\u0389\u038A\u03AA\u038C\uFFFD\uFFFD\u038E\u03AB\xA9\u038F\xB2\xB3\u03AC\xA3\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03CD\u0391\u0392\u0393\u0394\u0395\u0396\u0397\xBD\u0398\u0399\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u039A\u039B\u039C\u039D\u2563\u2551\u2557\u255D\u039E\u039F\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u03A0\u03A1\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u2518\u250C\u2588\u2584\u03B4\u03B5\u2580\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u0384\xAD\xB1\u03C5\u03C6\u03C7\xA7\u03C8\u0385\xB0\xA8\u03C9\u03CB\u03B0\u03CE\u25A0\xA0"
      },
      "ibm869": "cp869",
      "csibm869": "cp869",
      "cp922": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\u203E\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0160\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\u017D\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0161\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\u017E\xFF"
      },
      "ibm922": "cp922",
      "csibm922": "cp922",
      "cp1046": {
        "type": "_sbcs",
        "chars": "\uFE88\xD7\xF7\uF8F6\uF8F5\uF8F4\uF8F7\uFE71\x88\u25A0\u2502\u2500\u2510\u250C\u2514\u2518\uFE79\uFE7B\uFE7D\uFE7F\uFE77\uFE8A\uFEF0\uFEF3\uFEF2\uFECE\uFECF\uFED0\uFEF6\uFEF8\uFEFA\uFEFC\xA0\uF8FA\uF8F9\uF8F8\xA4\uF8FB\uFE8B\uFE91\uFE97\uFE9B\uFE9F\uFEA3\u060C\xAD\uFEA7\uFEB3\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFEB7\u061B\uFEBB\uFEBF\uFECA\u061F\uFECB\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\uFEC7\u0639\u063A\uFECC\uFE82\uFE84\uFE8E\uFED3\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFED7\uFEDB\uFEDF\uF8FC\uFEF5\uFEF7\uFEF9\uFEFB\uFEE3\uFEE7\uFEEC\uFEE9\uFFFD"
      },
      "ibm1046": "cp1046",
      "csibm1046": "cp1046",
      "cp1124": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0490\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0491\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
      },
      "ibm1124": "cp1124",
      "csibm1124": "cp1124",
      "cp1125": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0490\u0491\u0404\u0454\u0406\u0456\u0407\u0457\xB7\u221A\u2116\xA4\u25A0\xA0"
      },
      "ibm1125": "cp1125",
      "csibm1125": "cp1125",
      "cp1129": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "ibm1129": "cp1129",
      "csibm1129": "cp1129",
      "cp1133": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E81\u0E82\u0E84\u0E87\u0E88\u0EAA\u0E8A\u0E8D\u0E94\u0E95\u0E96\u0E97\u0E99\u0E9A\u0E9B\u0E9C\u0E9D\u0E9E\u0E9F\u0EA1\u0EA2\u0EA3\u0EA5\u0EA7\u0EAB\u0EAD\u0EAE\uFFFD\uFFFD\uFFFD\u0EAF\u0EB0\u0EB2\u0EB3\u0EB4\u0EB5\u0EB6\u0EB7\u0EB8\u0EB9\u0EBC\u0EB1\u0EBB\u0EBD\uFFFD\uFFFD\uFFFD\u0EC0\u0EC1\u0EC2\u0EC3\u0EC4\u0EC8\u0EC9\u0ECA\u0ECB\u0ECC\u0ECD\u0EC6\uFFFD\u0EDC\u0EDD\u20AD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0ED0\u0ED1\u0ED2\u0ED3\u0ED4\u0ED5\u0ED6\u0ED7\u0ED8\u0ED9\uFFFD\uFFFD\xA2\xAC\xA6\uFFFD"
      },
      "ibm1133": "cp1133",
      "csibm1133": "cp1133",
      "cp1161": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E48\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\u0E49\u0E4A\u0E4B\u20AC\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\xA2\xAC\xA6\xA0"
      },
      "ibm1161": "cp1161",
      "csibm1161": "cp1161",
      "cp1162": {
        "type": "_sbcs",
        "chars": "\u20AC\x81\x82\x83\x84\u2026\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "ibm1162": "cp1162",
      "csibm1162": "cp1162",
      "cp1163": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "ibm1163": "cp1163",
      "csibm1163": "cp1163",
      "maccroatian": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u2126\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uFFFD\xA9\u2044\xA4\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7"
      },
      "maccyrillic": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\xA2\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u2202\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
      },
      "macgreek": {
        "type": "_sbcs",
        "chars": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\xAD\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\u0387\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\uFFFD"
      },
      "maciceland": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macroman": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macromania": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u015E\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\u0103\u015F\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\u0162\u0163\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macthai": {
        "type": "_sbcs",
        "chars": "\xAB\xBB\u2026\uF88C\uF88F\uF892\uF895\uF898\uF88B\uF88E\uF891\uF894\uF897\u201C\u201D\uF899\uFFFD\u2022\uF884\uF889\uF885\uF886\uF887\uF888\uF88A\uF88D\uF890\uF893\uF896\u2018\u2019\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFEFF\u200B\u2013\u2014\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u2122\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\xAE\xA9\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "macturkish": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\uFFFD\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macukraine": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
      },
      "koi8r": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u2553\u2554\u2555\u2556\u2557\u2558\u2559\u255A\u255B\u255C\u255D\u255E\u255F\u2560\u2561\u0401\u2562\u2563\u2564\u2565\u2566\u2567\u2568\u2569\u256A\u256B\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8u": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u255D\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8ru": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u045E\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u040E\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8t": {
        "type": "_sbcs",
        "chars": "\u049B\u0493\u201A\u0492\u201E\u2026\u2020\u2021\uFFFD\u2030\u04B3\u2039\u04B2\u04B7\u04B6\uFFFD\u049A\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u04EF\u04EE\u0451\xA4\u04E3\xA6\xA7\uFFFD\uFFFD\uFFFD\xAB\xAC\xAD\xAE\uFFFD\xB0\xB1\xB2\u0401\uFFFD\u04E2\xB6\xB7\uFFFD\u2116\uFFFD\xBB\uFFFD\uFFFD\uFFFD\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "armscii8": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\u0587\u0589)(\xBB\xAB\u2014.\u055D,-\u058A\u2026\u055C\u055B\u055E\u0531\u0561\u0532\u0562\u0533\u0563\u0534\u0564\u0535\u0565\u0536\u0566\u0537\u0567\u0538\u0568\u0539\u0569\u053A\u056A\u053B\u056B\u053C\u056C\u053D\u056D\u053E\u056E\u053F\u056F\u0540\u0570\u0541\u0571\u0542\u0572\u0543\u0573\u0544\u0574\u0545\u0575\u0546\u0576\u0547\u0577\u0548\u0578\u0549\u0579\u054A\u057A\u054B\u057B\u054C\u057C\u054D\u057D\u054E\u057E\u054F\u057F\u0550\u0580\u0551\u0581\u0552\u0582\u0553\u0583\u0554\u0584\u0555\u0585\u0556\u0586\u055A\uFFFD"
      },
      "rk1048": {
        "type": "_sbcs",
        "chars": "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u049A\u04BA\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u049B\u04BB\u045F\xA0\u04B0\u04B1\u04D8\xA4\u04E8\xA6\xA7\u0401\xA9\u0492\xAB\xAC\xAD\xAE\u04AE\xB0\xB1\u0406\u0456\u04E9\xB5\xB6\xB7\u0451\u2116\u0493\xBB\u04D9\u04A2\u04A3\u04AF\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "tcvn": {
        "type": "_sbcs",
        "chars": "\0\xDA\u1EE4\u1EEA\u1EEC\u1EEE\x07\b	\n\v\f\r\u1EE8\u1EF0\u1EF2\u1EF6\u1EF8\xDD\u1EF4\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xC0\u1EA2\xC3\xC1\u1EA0\u1EB6\u1EAC\xC8\u1EBA\u1EBC\xC9\u1EB8\u1EC6\xCC\u1EC8\u0128\xCD\u1ECA\xD2\u1ECE\xD5\xD3\u1ECC\u1ED8\u1EDC\u1EDE\u1EE0\u1EDA\u1EE2\xD9\u1EE6\u0168\xA0\u0102\xC2\xCA\xD4\u01A0\u01AF\u0110\u0103\xE2\xEA\xF4\u01A1\u01B0\u0111\u1EB0\u0300\u0309\u0303\u0301\u0323\xE0\u1EA3\xE3\xE1\u1EA1\u1EB2\u1EB1\u1EB3\u1EB5\u1EAF\u1EB4\u1EAE\u1EA6\u1EA8\u1EAA\u1EA4\u1EC0\u1EB7\u1EA7\u1EA9\u1EAB\u1EA5\u1EAD\xE8\u1EC2\u1EBB\u1EBD\xE9\u1EB9\u1EC1\u1EC3\u1EC5\u1EBF\u1EC7\xEC\u1EC9\u1EC4\u1EBE\u1ED2\u0129\xED\u1ECB\xF2\u1ED4\u1ECF\xF5\xF3\u1ECD\u1ED3\u1ED5\u1ED7\u1ED1\u1ED9\u1EDD\u1EDF\u1EE1\u1EDB\u1EE3\xF9\u1ED6\u1EE7\u0169\xFA\u1EE5\u1EEB\u1EED\u1EEF\u1EE9\u1EF1\u1EF3\u1EF7\u1EF9\xFD\u1EF5\u1ED0"
      },
      "georgianacademy": {
        "type": "_sbcs",
        "chars": "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10EF\u10F0\u10F1\u10F2\u10F3\u10F4\u10F5\u10F6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "georgianps": {
        "type": "_sbcs",
        "chars": "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10F1\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10F2\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10F3\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10F4\u10EF\u10F0\u10F5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "pt154": {
        "type": "_sbcs",
        "chars": "\u0496\u0492\u04EE\u0493\u201E\u2026\u04B6\u04AE\u04B2\u04AF\u04A0\u04E2\u04A2\u049A\u04BA\u04B8\u0497\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u04B3\u04B7\u04A1\u04E3\u04A3\u049B\u04BB\u04B9\xA0\u040E\u045E\u0408\u04E8\u0498\u04B0\xA7\u0401\xA9\u04D8\xAB\xAC\u04EF\xAE\u049C\xB0\u04B1\u0406\u0456\u0499\u04E9\xB6\xB7\u0451\u2116\u04D9\xBB\u0458\u04AA\u04AB\u049D\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "viscii": {
        "type": "_sbcs",
        "chars": "\0\u1EB2\u1EB4\u1EAA\x07\b	\n\v\f\r\u1EF6\u1EF8\x1B\u1EF4 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\u1EA0\u1EAE\u1EB0\u1EB6\u1EA4\u1EA6\u1EA8\u1EAC\u1EBC\u1EB8\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EE2\u1EDA\u1EDC\u1EDE\u1ECA\u1ECE\u1ECC\u1EC8\u1EE6\u0168\u1EE4\u1EF2\xD5\u1EAF\u1EB1\u1EB7\u1EA5\u1EA7\u1EA9\u1EAD\u1EBD\u1EB9\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1ED1\u1ED3\u1ED5\u1ED7\u1EE0\u01A0\u1ED9\u1EDD\u1EDF\u1ECB\u1EF0\u1EE8\u1EEA\u1EEC\u01A1\u1EDB\u01AF\xC0\xC1\xC2\xC3\u1EA2\u0102\u1EB3\u1EB5\xC8\xC9\xCA\u1EBA\xCC\xCD\u0128\u1EF3\u0110\u1EE9\xD2\xD3\xD4\u1EA1\u1EF7\u1EEB\u1EED\xD9\xDA\u1EF9\u1EF5\xDD\u1EE1\u01B0\xE0\xE1\xE2\xE3\u1EA3\u0103\u1EEF\u1EAB\xE8\xE9\xEA\u1EBB\xEC\xED\u0129\u1EC9\u0111\u1EF1\xF2\xF3\xF4\xF5\u1ECF\u1ECD\u1EE5\xF9\xFA\u0169\u1EE7\xFD\u1EE3\u1EEE"
      },
      "iso646cn": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#\xA5%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "iso646jp": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\xA5]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "hproman8": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xC0\xC2\xC8\xCA\xCB\xCE\xCF\xB4\u02CB\u02C6\xA8\u02DC\xD9\xDB\u20A4\xAF\xDD\xFD\xB0\xC7\xE7\xD1\xF1\xA1\xBF\xA4\xA3\xA5\xA7\u0192\xA2\xE2\xEA\xF4\xFB\xE1\xE9\xF3\xFA\xE0\xE8\xF2\xF9\xE4\xEB\xF6\xFC\xC5\xEE\xD8\xC6\xE5\xED\xF8\xE6\xC4\xEC\xD6\xDC\xC9\xEF\xDF\xD4\xC1\xC3\xE3\xD0\xF0\xCD\xCC\xD3\xD2\xD5\xF5\u0160\u0161\xDA\u0178\xFF\xDE\xFE\xB7\xB5\xB6\xBE\u2014\xBC\xBD\xAA\xBA\xAB\u25A0\xBB\xB1\uFFFD"
      },
      "macintosh": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "ascii": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "tis620": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      }
    };
  }
});

// node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS({
  "node_modules/iconv-lite/encodings/dbcs-codec.js"(exports2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports2._dbcs = DBCSCodec;
    var UNASSIGNED = -1;
    var GB18030_CODE = -2;
    var SEQ_START = -10;
    var NODE_START = -1e3;
    var UNASSIGNED_NODE = new Array(256);
    var DEF_CHAR = -1;
    for (i = 0; i < 256; i++)
      UNASSIGNED_NODE[i] = UNASSIGNED;
    var i;
    function DBCSCodec(codecOptions, iconv) {
      this.encodingName = codecOptions.encodingName;
      if (!codecOptions)
        throw new Error("DBCS codec is called without the data.");
      if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");
      var mappingTable = codecOptions.table();
      this.decodeTables = [];
      this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
      this.decodeTableSeq = [];
      for (var i2 = 0; i2 < mappingTable.length; i2++)
        this._addDecodeChunk(mappingTable[i2]);
      if (typeof codecOptions.gb18030 === "function") {
        this.gb18030 = codecOptions.gb18030();
        var commonThirdByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));
        var commonFourthByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));
        var firstByteNode = this.decodeTables[0];
        for (var i2 = 129; i2 <= 254; i2++) {
          var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
          for (var j = 48; j <= 57; j++) {
            if (secondByteNode[j] === UNASSIGNED) {
              secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
            } else if (secondByteNode[j] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 2");
            }
            var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
            for (var k = 129; k <= 254; k++) {
              if (thirdByteNode[k] === UNASSIGNED) {
                thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
              } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
                continue;
              } else if (thirdByteNode[k] > NODE_START) {
                throw new Error("gb18030 decode tables conflict at byte 3");
              }
              var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
              for (var l = 48; l <= 57; l++) {
                if (fourthByteNode[l] === UNASSIGNED)
                  fourthByteNode[l] = GB18030_CODE;
              }
            }
          }
        }
      }
      this.defaultCharUnicode = iconv.defaultCharUnicode;
      this.encodeTable = [];
      this.encodeTableSeq = [];
      var skipEncodeChars = {};
      if (codecOptions.encodeSkipVals)
        for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
          var val = codecOptions.encodeSkipVals[i2];
          if (typeof val === "number")
            skipEncodeChars[val] = true;
          else
            for (var j = val.from; j <= val.to; j++)
              skipEncodeChars[j] = true;
        }
      this._fillEncodeTable(0, 0, skipEncodeChars);
      if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
          if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
            this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
      }
      this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
      if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
      if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
    }
    DBCSCodec.prototype.encoder = DBCSEncoder;
    DBCSCodec.prototype.decoder = DBCSDecoder;
    DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
      var bytes = [];
      for (; addr > 0; addr >>>= 8)
        bytes.push(addr & 255);
      if (bytes.length == 0)
        bytes.push(0);
      var node = this.decodeTables[0];
      for (var i2 = bytes.length - 1; i2 > 0; i2--) {
        var val = node[bytes[i2]];
        if (val == UNASSIGNED) {
          node[bytes[i2]] = NODE_START - this.decodeTables.length;
          this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        } else if (val <= NODE_START) {
          node = this.decodeTables[NODE_START - val];
        } else
          throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
      }
      return node;
    };
    DBCSCodec.prototype._addDecodeChunk = function(chunk) {
      var curAddr = parseInt(chunk[0], 16);
      var writeTable = this._getDecodeTrieNode(curAddr);
      curAddr = curAddr & 255;
      for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") {
          for (var l = 0; l < part.length; ) {
            var code = part.charCodeAt(l++);
            if (55296 <= code && code < 56320) {
              var codeTrail = part.charCodeAt(l++);
              if (56320 <= codeTrail && codeTrail < 57344)
                writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
              else
                throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
            } else if (4080 < code && code <= 4095) {
              var len = 4095 - code + 2;
              var seq = [];
              for (var m = 0; m < len; m++)
                seq.push(part.charCodeAt(l++));
              writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
              this.decodeTableSeq.push(seq);
            } else
              writeTable[curAddr++] = code;
          }
        } else if (typeof part === "number") {
          var charCode = writeTable[curAddr - 1] + 1;
          for (var l = 0; l < part; l++)
            writeTable[curAddr++] = charCode++;
        } else
          throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
      }
      if (curAddr > 255)
        throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    };
    DBCSCodec.prototype._getEncodeBucket = function(uCode) {
      var high = uCode >> 8;
      if (this.encodeTable[high] === void 0)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
      return this.encodeTable[high];
    };
    DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
      else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
    };
    DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
      var uCode = seq[0];
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      var node;
      if (bucket[low] <= SEQ_START) {
        node = this.encodeTableSeq[SEQ_START - bucket[low]];
      } else {
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
      }
      for (var j = 1; j < seq.length - 1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === "object")
          node = oldVal;
        else {
          node = node[uCode] = {};
          if (oldVal !== void 0)
            node[DEF_CHAR] = oldVal;
        }
      }
      uCode = seq[seq.length - 1];
      node[uCode] = dbcsCode;
    };
    DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
      var node = this.decodeTables[nodeIdx];
      var hasValues = false;
      var subNodeEmpty = {};
      for (var i2 = 0; i2 < 256; i2++) {
        var uCode = node[i2];
        var mbCode = prefix + i2;
        if (skipEncodeChars[mbCode])
          continue;
        if (uCode >= 0) {
          this._setEncodeChar(uCode, mbCode);
          hasValues = true;
        } else if (uCode <= NODE_START) {
          var subNodeIdx = NODE_START - uCode;
          if (!subNodeEmpty[subNodeIdx]) {
            var newPrefix = mbCode << 8 >>> 0;
            if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
              hasValues = true;
            else
              subNodeEmpty[subNodeIdx] = true;
          }
        } else if (uCode <= SEQ_START) {
          this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
          hasValues = true;
        }
      }
      return hasValues;
    };
    function DBCSEncoder(options, codec) {
      this.leadSurrogate = -1;
      this.seqObj = void 0;
      this.encodeTable = codec.encodeTable;
      this.encodeTableSeq = codec.encodeTableSeq;
      this.defaultCharSingleByte = codec.defCharSB;
      this.gb18030 = codec.gb18030;
    }
    DBCSEncoder.prototype.write = function(str) {
      var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
      while (true) {
        if (nextChar === -1) {
          if (i2 == str.length) break;
          var uCode = str.charCodeAt(i2++);
        } else {
          var uCode = nextChar;
          nextChar = -1;
        }
        if (55296 <= uCode && uCode < 57344) {
          if (uCode < 56320) {
            if (leadSurrogate === -1) {
              leadSurrogate = uCode;
              continue;
            } else {
              leadSurrogate = uCode;
              uCode = UNASSIGNED;
            }
          } else {
            if (leadSurrogate !== -1) {
              uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
              leadSurrogate = -1;
            } else {
              uCode = UNASSIGNED;
            }
          }
        } else if (leadSurrogate !== -1) {
          nextChar = uCode;
          uCode = UNASSIGNED;
          leadSurrogate = -1;
        }
        var dbcsCode = UNASSIGNED;
        if (seqObj !== void 0 && uCode != UNASSIGNED) {
          var resCode = seqObj[uCode];
          if (typeof resCode === "object") {
            seqObj = resCode;
            continue;
          } else if (typeof resCode == "number") {
            dbcsCode = resCode;
          } else if (resCode == void 0) {
            resCode = seqObj[DEF_CHAR];
            if (resCode !== void 0) {
              dbcsCode = resCode;
              nextChar = uCode;
            } else {
            }
          }
          seqObj = void 0;
        } else if (uCode >= 0) {
          var subtable = this.encodeTable[uCode >> 8];
          if (subtable !== void 0)
            dbcsCode = subtable[uCode & 255];
          if (dbcsCode <= SEQ_START) {
            seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
            continue;
          }
          if (dbcsCode == UNASSIGNED && this.gb18030) {
            var idx = findIdx(this.gb18030.uChars, uCode);
            if (idx != -1) {
              var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
              newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
              dbcsCode = dbcsCode % 12600;
              newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
              dbcsCode = dbcsCode % 1260;
              newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
              dbcsCode = dbcsCode % 10;
              newBuf[j++] = 48 + dbcsCode;
              continue;
            }
          }
        }
        if (dbcsCode === UNASSIGNED)
          dbcsCode = this.defaultCharSingleByte;
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else if (dbcsCode < 65536) {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        } else if (dbcsCode < 16777216) {
          newBuf[j++] = dbcsCode >> 16;
          newBuf[j++] = dbcsCode >> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        } else {
          newBuf[j++] = dbcsCode >>> 24;
          newBuf[j++] = dbcsCode >>> 16 & 255;
          newBuf[j++] = dbcsCode >>> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = seqObj;
      this.leadSurrogate = leadSurrogate;
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.end = function() {
      if (this.leadSurrogate === -1 && this.seqObj === void 0)
        return;
      var newBuf = Buffer2.alloc(10), j = 0;
      if (this.seqObj) {
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== void 0) {
          if (dbcsCode < 256) {
            newBuf[j++] = dbcsCode;
          } else {
            newBuf[j++] = dbcsCode >> 8;
            newBuf[j++] = dbcsCode & 255;
          }
        } else {
        }
        this.seqObj = void 0;
      }
      if (this.leadSurrogate !== -1) {
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
      }
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.findIdx = findIdx;
    function DBCSDecoder(options, codec) {
      this.nodeIdx = 0;
      this.prevBytes = [];
      this.decodeTables = codec.decodeTables;
      this.decodeTableSeq = codec.decodeTableSeq;
      this.defaultCharUnicode = codec.defaultCharUnicode;
      this.gb18030 = codec.gb18030;
    }
    DBCSDecoder.prototype.write = function(buf) {
      var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
      for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
        var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
        var uCode = this.decodeTables[nodeIdx][curByte];
        if (uCode >= 0) {
        } else if (uCode === UNASSIGNED) {
          uCode = this.defaultCharUnicode.charCodeAt(0);
          i2 = seqStart;
        } else if (uCode === GB18030_CODE) {
          if (i2 >= 3) {
            var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
          } else {
            var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
          }
          var idx = findIdx(this.gb18030.gbChars, ptr);
          uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        } else if (uCode <= NODE_START) {
          nodeIdx = NODE_START - uCode;
          continue;
        } else if (uCode <= SEQ_START) {
          var seq = this.decodeTableSeq[SEQ_START - uCode];
          for (var k = 0; k < seq.length - 1; k++) {
            uCode = seq[k];
            newBuf[j++] = uCode & 255;
            newBuf[j++] = uCode >> 8;
          }
          uCode = seq[seq.length - 1];
        } else
          throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
        if (uCode >= 65536) {
          uCode -= 65536;
          var uCodeLead = 55296 | uCode >> 10;
          newBuf[j++] = uCodeLead & 255;
          newBuf[j++] = uCodeLead >> 8;
          uCode = 56320 | uCode & 1023;
        }
        newBuf[j++] = uCode & 255;
        newBuf[j++] = uCode >> 8;
        nodeIdx = 0;
        seqStart = i2 + 1;
      }
      this.nodeIdx = nodeIdx;
      this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
      return newBuf.slice(0, j).toString("ucs2");
    };
    DBCSDecoder.prototype.end = function() {
      var ret = "";
      while (this.prevBytes.length > 0) {
        ret += this.defaultCharUnicode;
        var bytesArr = this.prevBytes.slice(1);
        this.prevBytes = [];
        this.nodeIdx = 0;
        if (bytesArr.length > 0)
          ret += this.write(bytesArr);
      }
      this.prevBytes = [];
      this.nodeIdx = 0;
      return ret;
    };
    function findIdx(table, val) {
      if (table[0] > val)
        return -1;
      var l = 0, r = table.length;
      while (l < r - 1) {
        var mid = l + (r - l + 1 >> 1);
        if (table[mid] <= val)
          l = mid;
        else
          r = mid;
      }
      return l;
    }
  }
});

// node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS({
  "node_modules/iconv-lite/encodings/tables/shiftjis.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 128],
      ["a1", "\uFF61", 62],
      ["8140", "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008", 9, "\uFF0B\uFF0D\xB1\xD7"],
      ["8180", "\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"],
      ["81b8", "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"],
      ["81c8", "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"],
      ["81da", "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"],
      ["81f0", "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"],
      ["81fc", "\u25EF"],
      ["824f", "\uFF10", 9],
      ["8260", "\uFF21", 25],
      ["8281", "\uFF41", 25],
      ["829f", "\u3041", 82],
      ["8340", "\u30A1", 62],
      ["8380", "\u30E0", 22],
      ["839f", "\u0391", 16, "\u03A3", 6],
      ["83bf", "\u03B1", 16, "\u03C3", 6],
      ["8440", "\u0410", 5, "\u0401\u0416", 25],
      ["8470", "\u0430", 5, "\u0451\u0436", 7],
      ["8480", "\u043E", 17],
      ["849f", "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"],
      ["8740", "\u2460", 19, "\u2160", 9],
      ["875f", "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"],
      ["877e", "\u337B"],
      ["8780", "\u301D\u301F\u2116\u33CD\u2121\u32A4", 4, "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"],
      ["889f", "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"],
      ["8940", "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186"],
      ["8980", "\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"],
      ["8a40", "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B"],
      ["8a80", "\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"],
      ["8b40", "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551"],
      ["8b80", "\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"],
      ["8c40", "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8"],
      ["8c80", "\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"],
      ["8d40", "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D"],
      ["8d80", "\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"],
      ["8e40", "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62"],
      ["8e80", "\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"],
      ["8f40", "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3"],
      ["8f80", "\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"],
      ["9040", "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8"],
      ["9080", "\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"],
      ["9140", "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB"],
      ["9180", "\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"],
      ["9240", "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4"],
      ["9280", "\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"],
      ["9340", "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC"],
      ["9380", "\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"],
      ["9440", "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885"],
      ["9480", "\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"],
      ["9540", "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577"],
      ["9580", "\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"],
      ["9640", "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6"],
      ["9680", "\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"],
      ["9740", "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32"],
      ["9780", "\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"],
      ["9840", "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"],
      ["989f", "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"],
      ["9940", "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED"],
      ["9980", "\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"],
      ["9a40", "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638"],
      ["9a80", "\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"],
      ["9b40", "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80"],
      ["9b80", "\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"],
      ["9c40", "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060"],
      ["9c80", "\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"],
      ["9d40", "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B"],
      ["9d80", "\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"],
      ["9e40", "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E"],
      ["9e80", "\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"],
      ["9f40", "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF"],
      ["9f80", "\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"],
      ["e040", "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD"],
      ["e080", "\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"],
      ["e140", "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF"],
      ["e180", "\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"],
      ["e240", "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0"],
      ["e280", "\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"],
      ["e340", "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37"],
      ["e380", "\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"],
      ["e440", "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264"],
      ["e480", "\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"],
      ["e540", "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC"],
      ["e580", "\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"],
      ["e640", "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7"],
      ["e680", "\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"],
      ["e740", "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C"],
      ["e780", "\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"],
      ["e840", "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599"],
      ["e880", "\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"],
      ["e940", "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43"],
      ["e980", "\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"],
      ["ea40", "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF"],
      ["ea80", "\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0\u582F\u69C7\u9059\u7464\u51DC\u7199"],
      ["ed40", "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F"],
      ["ed80", "\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"],
      ["ee40", "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559"],
      ["ee80", "\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"],
      ["eeef", "\u2170", 9, "\uFFE2\uFFE4\uFF07\uFF02"],
      ["f040", "\uE000", 62],
      ["f080", "\uE03F", 124],
      ["f140", "\uE0BC", 62],
      ["f180", "\uE0FB", 124],
      ["f240", "\uE178", 62],
      ["f280", "\uE1B7", 124],
      ["f340", "\uE234", 62],
      ["f380", "\uE273", 124],
      ["f440", "\uE2F0", 62],
      ["f480", "\uE32F", 124],
      ["f540", "\uE3AC", 62],
      ["f580", "\uE3EB", 124],
      ["f640", "\uE468", 62],
      ["f680", "\uE4A7", 124],
      ["f740", "\uE524", 62],
      ["f780", "\uE563", 124],
      ["f840", "\uE5E0", 62],
      ["f880", "\uE61F", 124],
      ["f940", "\uE69C"],
      ["fa40", "\u2170", 9, "\u2160", 9, "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u2235\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A"],
      ["fa80", "\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F"],
      ["fb40", "\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19"],
      ["fb80", "\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9"],
      ["fc40", "\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS({
  "node_modules/iconv-lite/encodings/tables/eucjp.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["8ea1", "\uFF61", 62],
      ["a1a1", "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008", 9, "\uFF0B\uFF0D\xB1\xD7\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7"],
      ["a2a1", "\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"],
      ["a2ba", "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"],
      ["a2ca", "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"],
      ["a2dc", "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"],
      ["a2f2", "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"],
      ["a2fe", "\u25EF"],
      ["a3b0", "\uFF10", 9],
      ["a3c1", "\uFF21", 25],
      ["a3e1", "\uFF41", 25],
      ["a4a1", "\u3041", 82],
      ["a5a1", "\u30A1", 85],
      ["a6a1", "\u0391", 16, "\u03A3", 6],
      ["a6c1", "\u03B1", 16, "\u03C3", 6],
      ["a7a1", "\u0410", 5, "\u0401\u0416", 25],
      ["a7d1", "\u0430", 5, "\u0451\u0436", 25],
      ["a8a1", "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"],
      ["ada1", "\u2460", 19, "\u2160", 9],
      ["adc0", "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"],
      ["addf", "\u337B\u301D\u301F\u2116\u33CD\u2121\u32A4", 4, "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"],
      ["b0a1", "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"],
      ["b1a1", "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC"],
      ["b2a1", "\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"],
      ["b3a1", "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431"],
      ["b4a1", "\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"],
      ["b5a1", "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC"],
      ["b6a1", "\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"],
      ["b7a1", "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372"],
      ["b8a1", "\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"],
      ["b9a1", "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC"],
      ["baa1", "\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"],
      ["bba1", "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642"],
      ["bca1", "\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"],
      ["bda1", "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F"],
      ["bea1", "\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"],
      ["bfa1", "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE"],
      ["c0a1", "\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"],
      ["c1a1", "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E"],
      ["c2a1", "\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"],
      ["c3a1", "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5"],
      ["c4a1", "\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"],
      ["c5a1", "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230"],
      ["c6a1", "\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"],
      ["c7a1", "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6"],
      ["c8a1", "\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"],
      ["c9a1", "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D"],
      ["caa1", "\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"],
      ["cba1", "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80"],
      ["cca1", "\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"],
      ["cda1", "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483"],
      ["cea1", "\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"],
      ["cfa1", "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"],
      ["d0a1", "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"],
      ["d1a1", "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8"],
      ["d2a1", "\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"],
      ["d3a1", "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709"],
      ["d4a1", "\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"],
      ["d5a1", "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53"],
      ["d6a1", "\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"],
      ["d7a1", "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A"],
      ["d8a1", "\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"],
      ["d9a1", "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC"],
      ["daa1", "\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"],
      ["dba1", "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD"],
      ["dca1", "\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"],
      ["dda1", "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE"],
      ["dea1", "\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"],
      ["dfa1", "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC"],
      ["e0a1", "\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"],
      ["e1a1", "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670"],
      ["e2a1", "\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"],
      ["e3a1", "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50"],
      ["e4a1", "\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"],
      ["e5a1", "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A"],
      ["e6a1", "\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"],
      ["e7a1", "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9"],
      ["e8a1", "\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"],
      ["e9a1", "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759"],
      ["eaa1", "\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"],
      ["eba1", "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B"],
      ["eca1", "\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"],
      ["eda1", "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8"],
      ["eea1", "\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"],
      ["efa1", "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E"],
      ["f0a1", "\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"],
      ["f1a1", "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7"],
      ["f2a1", "\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"],
      ["f3a1", "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0"],
      ["f4a1", "\u582F\u69C7\u9059\u7464\u51DC\u7199"],
      ["f9a1", "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7"],
      ["faa1", "\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"],
      ["fba1", "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA"],
      ["fca1", "\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"],
      ["fcf1", "\u2170", 9, "\uFFE2\uFFE4\uFF07\uFF02"],
      ["8fa2af", "\u02D8\u02C7\xB8\u02D9\u02DD\xAF\u02DB\u02DA\uFF5E\u0384\u0385"],
      ["8fa2c2", "\xA1\xA6\xBF"],
      ["8fa2eb", "\xBA\xAA\xA9\xAE\u2122\xA4\u2116"],
      ["8fa6e1", "\u0386\u0388\u0389\u038A\u03AA"],
      ["8fa6e7", "\u038C"],
      ["8fa6e9", "\u038E\u03AB"],
      ["8fa6ec", "\u038F"],
      ["8fa6f1", "\u03AC\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03C2\u03CD\u03CB\u03B0\u03CE"],
      ["8fa7c2", "\u0402", 10, "\u040E\u040F"],
      ["8fa7f2", "\u0452", 10, "\u045E\u045F"],
      ["8fa9a1", "\xC6\u0110"],
      ["8fa9a4", "\u0126"],
      ["8fa9a6", "\u0132"],
      ["8fa9a8", "\u0141\u013F"],
      ["8fa9ab", "\u014A\xD8\u0152"],
      ["8fa9af", "\u0166\xDE"],
      ["8fa9c1", "\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0142\u0140\u0149\u014B\xF8\u0153\xDF\u0167\xFE"],
      ["8faaa1", "\xC1\xC0\xC4\xC2\u0102\u01CD\u0100\u0104\xC5\xC3\u0106\u0108\u010C\xC7\u010A\u010E\xC9\xC8\xCB\xCA\u011A\u0116\u0112\u0118"],
      ["8faaba", "\u011C\u011E\u0122\u0120\u0124\xCD\xCC\xCF\xCE\u01CF\u0130\u012A\u012E\u0128\u0134\u0136\u0139\u013D\u013B\u0143\u0147\u0145\xD1\xD3\xD2\xD6\xD4\u01D1\u0150\u014C\xD5\u0154\u0158\u0156\u015A\u015C\u0160\u015E\u0164\u0162\xDA\xD9\xDC\xDB\u016C\u01D3\u0170\u016A\u0172\u016E\u0168\u01D7\u01DB\u01D9\u01D5\u0174\xDD\u0178\u0176\u0179\u017D\u017B"],
      ["8faba1", "\xE1\xE0\xE4\xE2\u0103\u01CE\u0101\u0105\xE5\xE3\u0107\u0109\u010D\xE7\u010B\u010F\xE9\xE8\xEB\xEA\u011B\u0117\u0113\u0119\u01F5\u011D\u011F"],
      ["8fabbd", "\u0121\u0125\xED\xEC\xEF\xEE\u01D0"],
      ["8fabc5", "\u012B\u012F\u0129\u0135\u0137\u013A\u013E\u013C\u0144\u0148\u0146\xF1\xF3\xF2\xF6\xF4\u01D2\u0151\u014D\xF5\u0155\u0159\u0157\u015B\u015D\u0161\u015F\u0165\u0163\xFA\xF9\xFC\xFB\u016D\u01D4\u0171\u016B\u0173\u016F\u0169\u01D8\u01DC\u01DA\u01D6\u0175\xFD\xFF\u0177\u017A\u017E\u017C"],
      ["8fb0a1", "\u4E02\u4E04\u4E05\u4E0C\u4E12\u4E1F\u4E23\u4E24\u4E28\u4E2B\u4E2E\u4E2F\u4E30\u4E35\u4E40\u4E41\u4E44\u4E47\u4E51\u4E5A\u4E5C\u4E63\u4E68\u4E69\u4E74\u4E75\u4E79\u4E7F\u4E8D\u4E96\u4E97\u4E9D\u4EAF\u4EB9\u4EC3\u4ED0\u4EDA\u4EDB\u4EE0\u4EE1\u4EE2\u4EE8\u4EEF\u4EF1\u4EF3\u4EF5\u4EFD\u4EFE\u4EFF\u4F00\u4F02\u4F03\u4F08\u4F0B\u4F0C\u4F12\u4F15\u4F16\u4F17\u4F19\u4F2E\u4F31\u4F60\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E\u4F40\u4F42\u4F48\u4F49\u4F4B\u4F4C\u4F52\u4F54\u4F56\u4F58\u4F5F\u4F63\u4F6A\u4F6C\u4F6E\u4F71\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F7E\u4F81\u4F82\u4F84"],
      ["8fb1a1", "\u4F85\u4F89\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F94\u4F97\u4F99\u4F9A\u4F9E\u4F9F\u4FB2\u4FB7\u4FB9\u4FBB\u4FBC\u4FBD\u4FBE\u4FC0\u4FC1\u4FC5\u4FC6\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FCF\u4FD2\u4FDC\u4FE0\u4FE2\u4FF0\u4FF2\u4FFC\u4FFD\u4FFF\u5000\u5001\u5004\u5007\u500A\u500C\u500E\u5010\u5013\u5017\u5018\u501B\u501C\u501D\u501E\u5022\u5027\u502E\u5030\u5032\u5033\u5035\u5040\u5041\u5042\u5045\u5046\u504A\u504C\u504E\u5051\u5052\u5053\u5057\u5059\u505F\u5060\u5062\u5063\u5066\u5067\u506A\u506D\u5070\u5071\u503B\u5081\u5083\u5084\u5086\u508A\u508E\u508F\u5090"],
      ["8fb2a1", "\u5092\u5093\u5094\u5096\u509B\u509C\u509E", 4, "\u50AA\u50AF\u50B0\u50B9\u50BA\u50BD\u50C0\u50C3\u50C4\u50C7\u50CC\u50CE\u50D0\u50D3\u50D4\u50D8\u50DC\u50DD\u50DF\u50E2\u50E4\u50E6\u50E8\u50E9\u50EF\u50F1\u50F6\u50FA\u50FE\u5103\u5106\u5107\u5108\u510B\u510C\u510D\u510E\u50F2\u5110\u5117\u5119\u511B\u511C\u511D\u511E\u5123\u5127\u5128\u512C\u512D\u512F\u5131\u5133\u5134\u5135\u5138\u5139\u5142\u514A\u514F\u5153\u5155\u5157\u5158\u515F\u5164\u5166\u517E\u5183\u5184\u518B\u518E\u5198\u519D\u51A1\u51A3\u51AD\u51B8\u51BA\u51BC\u51BE\u51BF\u51C2"],
      ["8fb3a1", "\u51C8\u51CF\u51D1\u51D2\u51D3\u51D5\u51D8\u51DE\u51E2\u51E5\u51EE\u51F2\u51F3\u51F4\u51F7\u5201\u5202\u5205\u5212\u5213\u5215\u5216\u5218\u5222\u5228\u5231\u5232\u5235\u523C\u5245\u5249\u5255\u5257\u5258\u525A\u525C\u525F\u5260\u5261\u5266\u526E\u5277\u5278\u5279\u5280\u5282\u5285\u528A\u528C\u5293\u5295\u5296\u5297\u5298\u529A\u529C\u52A4\u52A5\u52A6\u52A7\u52AF\u52B0\u52B6\u52B7\u52B8\u52BA\u52BB\u52BD\u52C0\u52C4\u52C6\u52C8\u52CC\u52CF\u52D1\u52D4\u52D6\u52DB\u52DC\u52E1\u52E5\u52E8\u52E9\u52EA\u52EC\u52F0\u52F1\u52F4\u52F6\u52F7\u5300\u5303\u530A\u530B"],
      ["8fb4a1", "\u530C\u5311\u5313\u5318\u531B\u531C\u531E\u531F\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u5330\u5332\u5335\u533C\u533D\u533E\u5342\u534C\u534B\u5359\u535B\u5361\u5363\u5365\u536C\u536D\u5372\u5379\u537E\u5383\u5387\u5388\u538E\u5393\u5394\u5399\u539D\u53A1\u53A4\u53AA\u53AB\u53AF\u53B2\u53B4\u53B5\u53B7\u53B8\u53BA\u53BD\u53C0\u53C5\u53CF\u53D2\u53D3\u53D5\u53DA\u53DD\u53DE\u53E0\u53E6\u53E7\u53F5\u5402\u5413\u541A\u5421\u5427\u5428\u542A\u542F\u5431\u5434\u5435\u5443\u5444\u5447\u544D\u544F\u545E\u5462\u5464\u5466\u5467\u5469\u546B\u546D\u546E\u5474\u547F"],
      ["8fb5a1", "\u5481\u5483\u5485\u5488\u5489\u548D\u5491\u5495\u5496\u549C\u549F\u54A1\u54A6\u54A7\u54A9\u54AA\u54AD\u54AE\u54B1\u54B7\u54B9\u54BA\u54BB\u54BF\u54C6\u54CA\u54CD\u54CE\u54E0\u54EA\u54EC\u54EF\u54F6\u54FC\u54FE\u54FF\u5500\u5501\u5505\u5508\u5509\u550C\u550D\u550E\u5515\u552A\u552B\u5532\u5535\u5536\u553B\u553C\u553D\u5541\u5547\u5549\u554A\u554D\u5550\u5551\u5558\u555A\u555B\u555E\u5560\u5561\u5564\u5566\u557F\u5581\u5582\u5586\u5588\u558E\u558F\u5591\u5592\u5593\u5594\u5597\u55A3\u55A4\u55AD\u55B2\u55BF\u55C1\u55C3\u55C6\u55C9\u55CB\u55CC\u55CE\u55D1\u55D2"],
      ["8fb6a1", "\u55D3\u55D7\u55D8\u55DB\u55DE\u55E2\u55E9\u55F6\u55FF\u5605\u5608\u560A\u560D", 5, "\u5619\u562C\u5630\u5633\u5635\u5637\u5639\u563B\u563C\u563D\u563F\u5640\u5641\u5643\u5644\u5646\u5649\u564B\u564D\u564F\u5654\u565E\u5660\u5661\u5662\u5663\u5666\u5669\u566D\u566F\u5671\u5672\u5675\u5684\u5685\u5688\u568B\u568C\u5695\u5699\u569A\u569D\u569E\u569F\u56A6\u56A7\u56A8\u56A9\u56AB\u56AC\u56AD\u56B1\u56B3\u56B7\u56BE\u56C5\u56C9\u56CA\u56CB\u56CF\u56D0\u56CC\u56CD\u56D9\u56DC\u56DD\u56DF\u56E1\u56E4", 4, "\u56F1\u56EB\u56ED"],
      ["8fb7a1", "\u56F6\u56F7\u5701\u5702\u5707\u570A\u570C\u5711\u5715\u571A\u571B\u571D\u5720\u5722\u5723\u5724\u5725\u5729\u572A\u572C\u572E\u572F\u5733\u5734\u573D\u573E\u573F\u5745\u5746\u574C\u574D\u5752\u5762\u5765\u5767\u5768\u576B\u576D", 4, "\u5773\u5774\u5775\u5777\u5779\u577A\u577B\u577C\u577E\u5781\u5783\u578C\u5794\u5797\u5799\u579A\u579C\u579D\u579E\u579F\u57A1\u5795\u57A7\u57A8\u57A9\u57AC\u57B8\u57BD\u57C7\u57C8\u57CC\u57CF\u57D5\u57DD\u57DE\u57E4\u57E6\u57E7\u57E9\u57ED\u57F0\u57F5\u57F6\u57F8\u57FD\u57FE\u57FF\u5803\u5804\u5808\u5809\u57E1"],
      ["8fb8a1", "\u580C\u580D\u581B\u581E\u581F\u5820\u5826\u5827\u582D\u5832\u5839\u583F\u5849\u584C\u584D\u584F\u5850\u5855\u585F\u5861\u5864\u5867\u5868\u5878\u587C\u587F\u5880\u5881\u5887\u5888\u5889\u588A\u588C\u588D\u588F\u5890\u5894\u5896\u589D\u58A0\u58A1\u58A2\u58A6\u58A9\u58B1\u58B2\u58C4\u58BC\u58C2\u58C8\u58CD\u58CE\u58D0\u58D2\u58D4\u58D6\u58DA\u58DD\u58E1\u58E2\u58E9\u58F3\u5905\u5906\u590B\u590C\u5912\u5913\u5914\u8641\u591D\u5921\u5923\u5924\u5928\u592F\u5930\u5933\u5935\u5936\u593F\u5943\u5946\u5952\u5953\u5959\u595B\u595D\u595E\u595F\u5961\u5963\u596B\u596D"],
      ["8fb9a1", "\u596F\u5972\u5975\u5976\u5979\u597B\u597C\u598B\u598C\u598E\u5992\u5995\u5997\u599F\u59A4\u59A7\u59AD\u59AE\u59AF\u59B0\u59B3\u59B7\u59BA\u59BC\u59C1\u59C3\u59C4\u59C8\u59CA\u59CD\u59D2\u59DD\u59DE\u59DF\u59E3\u59E4\u59E7\u59EE\u59EF\u59F1\u59F2\u59F4\u59F7\u5A00\u5A04\u5A0C\u5A0D\u5A0E\u5A12\u5A13\u5A1E\u5A23\u5A24\u5A27\u5A28\u5A2A\u5A2D\u5A30\u5A44\u5A45\u5A47\u5A48\u5A4C\u5A50\u5A55\u5A5E\u5A63\u5A65\u5A67\u5A6D\u5A77\u5A7A\u5A7B\u5A7E\u5A8B\u5A90\u5A93\u5A96\u5A99\u5A9C\u5A9E\u5A9F\u5AA0\u5AA2\u5AA7\u5AAC\u5AB1\u5AB2\u5AB3\u5AB5\u5AB8\u5ABA\u5ABB\u5ABF"],
      ["8fbaa1", "\u5AC4\u5AC6\u5AC8\u5ACF\u5ADA\u5ADC\u5AE0\u5AE5\u5AEA\u5AEE\u5AF5\u5AF6\u5AFD\u5B00\u5B01\u5B08\u5B17\u5B34\u5B19\u5B1B\u5B1D\u5B21\u5B25\u5B2D\u5B38\u5B41\u5B4B\u5B4C\u5B52\u5B56\u5B5E\u5B68\u5B6E\u5B6F\u5B7C\u5B7D\u5B7E\u5B7F\u5B81\u5B84\u5B86\u5B8A\u5B8E\u5B90\u5B91\u5B93\u5B94\u5B96\u5BA8\u5BA9\u5BAC\u5BAD\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBC\u5BC0\u5BC1\u5BCD\u5BCF\u5BD6", 4, "\u5BE0\u5BEF\u5BF1\u5BF4\u5BFD\u5C0C\u5C17\u5C1E\u5C1F\u5C23\u5C26\u5C29\u5C2B\u5C2C\u5C2E\u5C30\u5C32\u5C35\u5C36\u5C59\u5C5A\u5C5C\u5C62\u5C63\u5C67\u5C68\u5C69"],
      ["8fbba1", "\u5C6D\u5C70\u5C74\u5C75\u5C7A\u5C7B\u5C7C\u5C7D\u5C87\u5C88\u5C8A\u5C8F\u5C92\u5C9D\u5C9F\u5CA0\u5CA2\u5CA3\u5CA6\u5CAA\u5CB2\u5CB4\u5CB5\u5CBA\u5CC9\u5CCB\u5CD2\u5CDD\u5CD7\u5CEE\u5CF1\u5CF2\u5CF4\u5D01\u5D06\u5D0D\u5D12\u5D2B\u5D23\u5D24\u5D26\u5D27\u5D31\u5D34\u5D39\u5D3D\u5D3F\u5D42\u5D43\u5D46\u5D48\u5D55\u5D51\u5D59\u5D4A\u5D5F\u5D60\u5D61\u5D62\u5D64\u5D6A\u5D6D\u5D70\u5D79\u5D7A\u5D7E\u5D7F\u5D81\u5D83\u5D88\u5D8A\u5D92\u5D93\u5D94\u5D95\u5D99\u5D9B\u5D9F\u5DA0\u5DA7\u5DAB\u5DB0\u5DB4\u5DB8\u5DB9\u5DC3\u5DC7\u5DCB\u5DD0\u5DCE\u5DD8\u5DD9\u5DE0\u5DE4"],
      ["8fbca1", "\u5DE9\u5DF8\u5DF9\u5E00\u5E07\u5E0D\u5E12\u5E14\u5E15\u5E18\u5E1F\u5E20\u5E2E\u5E28\u5E32\u5E35\u5E3E\u5E4B\u5E50\u5E49\u5E51\u5E56\u5E58\u5E5B\u5E5C\u5E5E\u5E68\u5E6A", 4, "\u5E70\u5E80\u5E8B\u5E8E\u5EA2\u5EA4\u5EA5\u5EA8\u5EAA\u5EAC\u5EB1\u5EB3\u5EBD\u5EBE\u5EBF\u5EC6\u5ECC\u5ECB\u5ECE\u5ED1\u5ED2\u5ED4\u5ED5\u5EDC\u5EDE\u5EE5\u5EEB\u5F02\u5F06\u5F07\u5F08\u5F0E\u5F19\u5F1C\u5F1D\u5F21\u5F22\u5F23\u5F24\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F34\u5F36\u5F3B\u5F3D\u5F3F\u5F40\u5F44\u5F45\u5F47\u5F4D\u5F50\u5F54\u5F58\u5F5B\u5F60\u5F63\u5F64\u5F67"],
      ["8fbda1", "\u5F6F\u5F72\u5F74\u5F75\u5F78\u5F7A\u5F7D\u5F7E\u5F89\u5F8D\u5F8F\u5F96\u5F9C\u5F9D\u5FA2\u5FA7\u5FAB\u5FA4\u5FAC\u5FAF\u5FB0\u5FB1\u5FB8\u5FC4\u5FC7\u5FC8\u5FC9\u5FCB\u5FD0", 4, "\u5FDE\u5FE1\u5FE2\u5FE8\u5FE9\u5FEA\u5FEC\u5FED\u5FEE\u5FEF\u5FF2\u5FF3\u5FF6\u5FFA\u5FFC\u6007\u600A\u600D\u6013\u6014\u6017\u6018\u601A\u601F\u6024\u602D\u6033\u6035\u6040\u6047\u6048\u6049\u604C\u6051\u6054\u6056\u6057\u605D\u6061\u6067\u6071\u607E\u607F\u6082\u6086\u6088\u608A\u608E\u6091\u6093\u6095\u6098\u609D\u609E\u60A2\u60A4\u60A5\u60A8\u60B0\u60B1\u60B7"],
      ["8fbea1", "\u60BB\u60BE\u60C2\u60C4\u60C8\u60C9\u60CA\u60CB\u60CE\u60CF\u60D4\u60D5\u60D9\u60DB\u60DD\u60DE\u60E2\u60E5\u60F2\u60F5\u60F8\u60FC\u60FD\u6102\u6107\u610A\u610C\u6110", 4, "\u6116\u6117\u6119\u611C\u611E\u6122\u612A\u612B\u6130\u6131\u6135\u6136\u6137\u6139\u6141\u6145\u6146\u6149\u615E\u6160\u616C\u6172\u6178\u617B\u617C\u617F\u6180\u6181\u6183\u6184\u618B\u618D\u6192\u6193\u6197\u6198\u619C\u619D\u619F\u61A0\u61A5\u61A8\u61AA\u61AD\u61B8\u61B9\u61BC\u61C0\u61C1\u61C2\u61CE\u61CF\u61D5\u61DC\u61DD\u61DE\u61DF\u61E1\u61E2\u61E7\u61E9\u61E5"],
      ["8fbfa1", "\u61EC\u61ED\u61EF\u6201\u6203\u6204\u6207\u6213\u6215\u621C\u6220\u6222\u6223\u6227\u6229\u622B\u6239\u623D\u6242\u6243\u6244\u6246\u624C\u6250\u6251\u6252\u6254\u6256\u625A\u625C\u6264\u626D\u626F\u6273\u627A\u627D\u628D\u628E\u628F\u6290\u62A6\u62A8\u62B3\u62B6\u62B7\u62BA\u62BE\u62BF\u62C4\u62CE\u62D5\u62D6\u62DA\u62EA\u62F2\u62F4\u62FC\u62FD\u6303\u6304\u630A\u630B\u630D\u6310\u6313\u6316\u6318\u6329\u632A\u632D\u6335\u6336\u6339\u633C\u6341\u6342\u6343\u6344\u6346\u634A\u634B\u634E\u6352\u6353\u6354\u6358\u635B\u6365\u6366\u636C\u636D\u6371\u6374\u6375"],
      ["8fc0a1", "\u6378\u637C\u637D\u637F\u6382\u6384\u6387\u638A\u6390\u6394\u6395\u6399\u639A\u639E\u63A4\u63A6\u63AD\u63AE\u63AF\u63BD\u63C1\u63C5\u63C8\u63CE\u63D1\u63D3\u63D4\u63D5\u63DC\u63E0\u63E5\u63EA\u63EC\u63F2\u63F3\u63F5\u63F8\u63F9\u6409\u640A\u6410\u6412\u6414\u6418\u641E\u6420\u6422\u6424\u6425\u6429\u642A\u642F\u6430\u6435\u643D\u643F\u644B\u644F\u6451\u6452\u6453\u6454\u645A\u645B\u645C\u645D\u645F\u6460\u6461\u6463\u646D\u6473\u6474\u647B\u647D\u6485\u6487\u648F\u6490\u6491\u6498\u6499\u649B\u649D\u649F\u64A1\u64A3\u64A6\u64A8\u64AC\u64B3\u64BD\u64BE\u64BF"],
      ["8fc1a1", "\u64C4\u64C9\u64CA\u64CB\u64CC\u64CE\u64D0\u64D1\u64D5\u64D7\u64E4\u64E5\u64E9\u64EA\u64ED\u64F0\u64F5\u64F7\u64FB\u64FF\u6501\u6504\u6508\u6509\u650A\u650F\u6513\u6514\u6516\u6519\u651B\u651E\u651F\u6522\u6526\u6529\u652E\u6531\u653A\u653C\u653D\u6543\u6547\u6549\u6550\u6552\u6554\u655F\u6560\u6567\u656B\u657A\u657D\u6581\u6585\u658A\u6592\u6595\u6598\u659D\u65A0\u65A3\u65A6\u65AE\u65B2\u65B3\u65B4\u65BF\u65C2\u65C8\u65C9\u65CE\u65D0\u65D4\u65D6\u65D8\u65DF\u65F0\u65F2\u65F4\u65F5\u65F9\u65FE\u65FF\u6600\u6604\u6608\u6609\u660D\u6611\u6612\u6615\u6616\u661D"],
      ["8fc2a1", "\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6631\u6633\u6639\u6637\u6640\u6645\u6646\u664A\u664C\u6651\u664E\u6657\u6658\u6659\u665B\u665C\u6660\u6661\u66FB\u666A\u666B\u666C\u667E\u6673\u6675\u667F\u6677\u6678\u6679\u667B\u6680\u667C\u668B\u668C\u668D\u6690\u6692\u6699\u669A\u669B\u669C\u669F\u66A0\u66A4\u66AD\u66B1\u66B2\u66B5\u66BB\u66BF\u66C0\u66C2\u66C3\u66C8\u66CC\u66CE\u66CF\u66D4\u66DB\u66DF\u66E8\u66EB\u66EC\u66EE\u66FA\u6705\u6707\u670E\u6713\u6719\u671C\u6720\u6722\u6733\u673E\u6745\u6747\u6748\u674C\u6754\u6755\u675D"],
      ["8fc3a1", "\u6766\u676C\u676E\u6774\u6776\u677B\u6781\u6784\u678E\u678F\u6791\u6793\u6796\u6798\u6799\u679B\u67B0\u67B1\u67B2\u67B5\u67BB\u67BC\u67BD\u67F9\u67C0\u67C2\u67C3\u67C5\u67C8\u67C9\u67D2\u67D7\u67D9\u67DC\u67E1\u67E6\u67F0\u67F2\u67F6\u67F7\u6852\u6814\u6819\u681D\u681F\u6828\u6827\u682C\u682D\u682F\u6830\u6831\u6833\u683B\u683F\u6844\u6845\u684A\u684C\u6855\u6857\u6858\u685B\u686B\u686E", 4, "\u6875\u6879\u687A\u687B\u687C\u6882\u6884\u6886\u6888\u6896\u6898\u689A\u689C\u68A1\u68A3\u68A5\u68A9\u68AA\u68AE\u68B2\u68BB\u68C5\u68C8\u68CC\u68CF"],
      ["8fc4a1", "\u68D0\u68D1\u68D3\u68D6\u68D9\u68DC\u68DD\u68E5\u68E8\u68EA\u68EB\u68EC\u68ED\u68F0\u68F1\u68F5\u68F6\u68FB\u68FC\u68FD\u6906\u6909\u690A\u6910\u6911\u6913\u6916\u6917\u6931\u6933\u6935\u6938\u693B\u6942\u6945\u6949\u694E\u6957\u695B\u6963\u6964\u6965\u6966\u6968\u6969\u696C\u6970\u6971\u6972\u697A\u697B\u697F\u6980\u698D\u6992\u6996\u6998\u69A1\u69A5\u69A6\u69A8\u69AB\u69AD\u69AF\u69B7\u69B8\u69BA\u69BC\u69C5\u69C8\u69D1\u69D6\u69D7\u69E2\u69E5\u69EE\u69EF\u69F1\u69F3\u69F5\u69FE\u6A00\u6A01\u6A03\u6A0F\u6A11\u6A15\u6A1A\u6A1D\u6A20\u6A24\u6A28\u6A30\u6A32"],
      ["8fc5a1", "\u6A34\u6A37\u6A3B\u6A3E\u6A3F\u6A45\u6A46\u6A49\u6A4A\u6A4E\u6A50\u6A51\u6A52\u6A55\u6A56\u6A5B\u6A64\u6A67\u6A6A\u6A71\u6A73\u6A7E\u6A81\u6A83\u6A86\u6A87\u6A89\u6A8B\u6A91\u6A9B\u6A9D\u6A9E\u6A9F\u6AA5\u6AAB\u6AAF\u6AB0\u6AB1\u6AB4\u6ABD\u6ABE\u6ABF\u6AC6\u6AC9\u6AC8\u6ACC\u6AD0\u6AD4\u6AD5\u6AD6\u6ADC\u6ADD\u6AE4\u6AE7\u6AEC\u6AF0\u6AF1\u6AF2\u6AFC\u6AFD\u6B02\u6B03\u6B06\u6B07\u6B09\u6B0F\u6B10\u6B11\u6B17\u6B1B\u6B1E\u6B24\u6B28\u6B2B\u6B2C\u6B2F\u6B35\u6B36\u6B3B\u6B3F\u6B46\u6B4A\u6B4D\u6B52\u6B56\u6B58\u6B5D\u6B60\u6B67\u6B6B\u6B6E\u6B70\u6B75\u6B7D"],
      ["8fc6a1", "\u6B7E\u6B82\u6B85\u6B97\u6B9B\u6B9F\u6BA0\u6BA2\u6BA3\u6BA8\u6BA9\u6BAC\u6BAD\u6BAE\u6BB0\u6BB8\u6BB9\u6BBD\u6BBE\u6BC3\u6BC4\u6BC9\u6BCC\u6BD6\u6BDA\u6BE1\u6BE3\u6BE6\u6BE7\u6BEE\u6BF1\u6BF7\u6BF9\u6BFF\u6C02\u6C04\u6C05\u6C09\u6C0D\u6C0E\u6C10\u6C12\u6C19\u6C1F\u6C26\u6C27\u6C28\u6C2C\u6C2E\u6C33\u6C35\u6C36\u6C3A\u6C3B\u6C3F\u6C4A\u6C4B\u6C4D\u6C4F\u6C52\u6C54\u6C59\u6C5B\u6C5C\u6C6B\u6C6D\u6C6F\u6C74\u6C76\u6C78\u6C79\u6C7B\u6C85\u6C86\u6C87\u6C89\u6C94\u6C95\u6C97\u6C98\u6C9C\u6C9F\u6CB0\u6CB2\u6CB4\u6CC2\u6CC6\u6CCD\u6CCF\u6CD0\u6CD1\u6CD2\u6CD4\u6CD6"],
      ["8fc7a1", "\u6CDA\u6CDC\u6CE0\u6CE7\u6CE9\u6CEB\u6CEC\u6CEE\u6CF2\u6CF4\u6D04\u6D07\u6D0A\u6D0E\u6D0F\u6D11\u6D13\u6D1A\u6D26\u6D27\u6D28\u6C67\u6D2E\u6D2F\u6D31\u6D39\u6D3C\u6D3F\u6D57\u6D5E\u6D5F\u6D61\u6D65\u6D67\u6D6F\u6D70\u6D7C\u6D82\u6D87\u6D91\u6D92\u6D94\u6D96\u6D97\u6D98\u6DAA\u6DAC\u6DB4\u6DB7\u6DB9\u6DBD\u6DBF\u6DC4\u6DC8\u6DCA\u6DCE\u6DCF\u6DD6\u6DDB\u6DDD\u6DDF\u6DE0\u6DE2\u6DE5\u6DE9\u6DEF\u6DF0\u6DF4\u6DF6\u6DFC\u6E00\u6E04\u6E1E\u6E22\u6E27\u6E32\u6E36\u6E39\u6E3B\u6E3C\u6E44\u6E45\u6E48\u6E49\u6E4B\u6E4F\u6E51\u6E52\u6E53\u6E54\u6E57\u6E5C\u6E5D\u6E5E"],
      ["8fc8a1", "\u6E62\u6E63\u6E68\u6E73\u6E7B\u6E7D\u6E8D\u6E93\u6E99\u6EA0\u6EA7\u6EAD\u6EAE\u6EB1\u6EB3\u6EBB\u6EBF\u6EC0\u6EC1\u6EC3\u6EC7\u6EC8\u6ECA\u6ECD\u6ECE\u6ECF\u6EEB\u6EED\u6EEE\u6EF9\u6EFB\u6EFD\u6F04\u6F08\u6F0A\u6F0C\u6F0D\u6F16\u6F18\u6F1A\u6F1B\u6F26\u6F29\u6F2A\u6F2F\u6F30\u6F33\u6F36\u6F3B\u6F3C\u6F2D\u6F4F\u6F51\u6F52\u6F53\u6F57\u6F59\u6F5A\u6F5D\u6F5E\u6F61\u6F62\u6F68\u6F6C\u6F7D\u6F7E\u6F83\u6F87\u6F88\u6F8B\u6F8C\u6F8D\u6F90\u6F92\u6F93\u6F94\u6F96\u6F9A\u6F9F\u6FA0\u6FA5\u6FA6\u6FA7\u6FA8\u6FAE\u6FAF\u6FB0\u6FB5\u6FB6\u6FBC\u6FC5\u6FC7\u6FC8\u6FCA"],
      ["8fc9a1", "\u6FDA\u6FDE\u6FE8\u6FE9\u6FF0\u6FF5\u6FF9\u6FFC\u6FFD\u7000\u7005\u7006\u7007\u700D\u7017\u7020\u7023\u702F\u7034\u7037\u7039\u703C\u7043\u7044\u7048\u7049\u704A\u704B\u7054\u7055\u705D\u705E\u704E\u7064\u7065\u706C\u706E\u7075\u7076\u707E\u7081\u7085\u7086\u7094", 4, "\u709B\u70A4\u70AB\u70B0\u70B1\u70B4\u70B7\u70CA\u70D1\u70D3\u70D4\u70D5\u70D6\u70D8\u70DC\u70E4\u70FA\u7103", 4, "\u710B\u710C\u710F\u711E\u7120\u712B\u712D\u712F\u7130\u7131\u7138\u7141\u7145\u7146\u7147\u714A\u714B\u7150\u7152\u7157\u715A\u715C\u715E\u7160"],
      ["8fcaa1", "\u7168\u7179\u7180\u7185\u7187\u718C\u7192\u719A\u719B\u71A0\u71A2\u71AF\u71B0\u71B2\u71B3\u71BA\u71BF\u71C0\u71C1\u71C4\u71CB\u71CC\u71D3\u71D6\u71D9\u71DA\u71DC\u71F8\u71FE\u7200\u7207\u7208\u7209\u7213\u7217\u721A\u721D\u721F\u7224\u722B\u722F\u7234\u7238\u7239\u7241\u7242\u7243\u7245\u724E\u724F\u7250\u7253\u7255\u7256\u725A\u725C\u725E\u7260\u7263\u7268\u726B\u726E\u726F\u7271\u7277\u7278\u727B\u727C\u727F\u7284\u7289\u728D\u728E\u7293\u729B\u72A8\u72AD\u72AE\u72B1\u72B4\u72BE\u72C1\u72C7\u72C9\u72CC\u72D5\u72D6\u72D8\u72DF\u72E5\u72F3\u72F4\u72FA\u72FB"],
      ["8fcba1", "\u72FE\u7302\u7304\u7305\u7307\u730B\u730D\u7312\u7313\u7318\u7319\u731E\u7322\u7324\u7327\u7328\u732C\u7331\u7332\u7335\u733A\u733B\u733D\u7343\u734D\u7350\u7352\u7356\u7358\u735D\u735E\u735F\u7360\u7366\u7367\u7369\u736B\u736C\u736E\u736F\u7371\u7377\u7379\u737C\u7380\u7381\u7383\u7385\u7386\u738E\u7390\u7393\u7395\u7397\u7398\u739C\u739E\u739F\u73A0\u73A2\u73A5\u73A6\u73AA\u73AB\u73AD\u73B5\u73B7\u73B9\u73BC\u73BD\u73BF\u73C5\u73C6\u73C9\u73CB\u73CC\u73CF\u73D2\u73D3\u73D6\u73D9\u73DD\u73E1\u73E3\u73E6\u73E7\u73E9\u73F4\u73F5\u73F7\u73F9\u73FA\u73FB\u73FD"],
      ["8fcca1", "\u73FF\u7400\u7401\u7404\u7407\u740A\u7411\u741A\u741B\u7424\u7426\u7428", 9, "\u7439\u7440\u7443\u7444\u7446\u7447\u744B\u744D\u7451\u7452\u7457\u745D\u7462\u7466\u7467\u7468\u746B\u746D\u746E\u7471\u7472\u7480\u7481\u7485\u7486\u7487\u7489\u748F\u7490\u7491\u7492\u7498\u7499\u749A\u749C\u749F\u74A0\u74A1\u74A3\u74A6\u74A8\u74A9\u74AA\u74AB\u74AE\u74AF\u74B1\u74B2\u74B5\u74B9\u74BB\u74BF\u74C8\u74C9\u74CC\u74D0\u74D3\u74D8\u74DA\u74DB\u74DE\u74DF\u74E4\u74E8\u74EA\u74EB\u74EF\u74F4\u74FA\u74FB\u74FC\u74FF\u7506"],
      ["8fcda1", "\u7512\u7516\u7517\u7520\u7521\u7524\u7527\u7529\u752A\u752F\u7536\u7539\u753D\u753E\u753F\u7540\u7543\u7547\u7548\u754E\u7550\u7552\u7557\u755E\u755F\u7561\u756F\u7571\u7579", 5, "\u7581\u7585\u7590\u7592\u7593\u7595\u7599\u759C\u75A2\u75A4\u75B4\u75BA\u75BF\u75C0\u75C1\u75C4\u75C6\u75CC\u75CE\u75CF\u75D7\u75DC\u75DF\u75E0\u75E1\u75E4\u75E7\u75EC\u75EE\u75EF\u75F1\u75F9\u7600\u7602\u7603\u7604\u7607\u7608\u760A\u760C\u760F\u7612\u7613\u7615\u7616\u7619\u761B\u761C\u761D\u761E\u7623\u7625\u7626\u7629\u762D\u7632\u7633\u7635\u7638\u7639"],
      ["8fcea1", "\u763A\u763C\u764A\u7640\u7641\u7643\u7644\u7645\u7649\u764B\u7655\u7659\u765F\u7664\u7665\u766D\u766E\u766F\u7671\u7674\u7681\u7685\u768C\u768D\u7695\u769B\u769C\u769D\u769F\u76A0\u76A2", 6, "\u76AA\u76AD\u76BD\u76C1\u76C5\u76C9\u76CB\u76CC\u76CE\u76D4\u76D9\u76E0\u76E6\u76E8\u76EC\u76F0\u76F1\u76F6\u76F9\u76FC\u7700\u7706\u770A\u770E\u7712\u7714\u7715\u7717\u7719\u771A\u771C\u7722\u7728\u772D\u772E\u772F\u7734\u7735\u7736\u7739\u773D\u773E\u7742\u7745\u7746\u774A\u774D\u774E\u774F\u7752\u7756\u7757\u775C\u775E\u775F\u7760\u7762"],
      ["8fcfa1", "\u7764\u7767\u776A\u776C\u7770\u7772\u7773\u7774\u777A\u777D\u7780\u7784\u778C\u778D\u7794\u7795\u7796\u779A\u779F\u77A2\u77A7\u77AA\u77AE\u77AF\u77B1\u77B5\u77BE\u77C3\u77C9\u77D1\u77D2\u77D5\u77D9\u77DE\u77DF\u77E0\u77E4\u77E6\u77EA\u77EC\u77F0\u77F1\u77F4\u77F8\u77FB\u7805\u7806\u7809\u780D\u780E\u7811\u781D\u7821\u7822\u7823\u782D\u782E\u7830\u7835\u7837\u7843\u7844\u7847\u7848\u784C\u784E\u7852\u785C\u785E\u7860\u7861\u7863\u7864\u7868\u786A\u786E\u787A\u787E\u788A\u788F\u7894\u7898\u78A1\u789D\u789E\u789F\u78A4\u78A8\u78AC\u78AD\u78B0\u78B1\u78B2\u78B3"],
      ["8fd0a1", "\u78BB\u78BD\u78BF\u78C7\u78C8\u78C9\u78CC\u78CE\u78D2\u78D3\u78D5\u78D6\u78E4\u78DB\u78DF\u78E0\u78E1\u78E6\u78EA\u78F2\u78F3\u7900\u78F6\u78F7\u78FA\u78FB\u78FF\u7906\u790C\u7910\u791A\u791C\u791E\u791F\u7920\u7925\u7927\u7929\u792D\u7931\u7934\u7935\u793B\u793D\u793F\u7944\u7945\u7946\u794A\u794B\u794F\u7951\u7954\u7958\u795B\u795C\u7967\u7969\u796B\u7972\u7979\u797B\u797C\u797E\u798B\u798C\u7991\u7993\u7994\u7995\u7996\u7998\u799B\u799C\u79A1\u79A8\u79A9\u79AB\u79AF\u79B1\u79B4\u79B8\u79BB\u79C2\u79C4\u79C7\u79C8\u79CA\u79CF\u79D4\u79D6\u79DA\u79DD\u79DE"],
      ["8fd1a1", "\u79E0\u79E2\u79E5\u79EA\u79EB\u79ED\u79F1\u79F8\u79FC\u7A02\u7A03\u7A07\u7A09\u7A0A\u7A0C\u7A11\u7A15\u7A1B\u7A1E\u7A21\u7A27\u7A2B\u7A2D\u7A2F\u7A30\u7A34\u7A35\u7A38\u7A39\u7A3A\u7A44\u7A45\u7A47\u7A48\u7A4C\u7A55\u7A56\u7A59\u7A5C\u7A5D\u7A5F\u7A60\u7A65\u7A67\u7A6A\u7A6D\u7A75\u7A78\u7A7E\u7A80\u7A82\u7A85\u7A86\u7A8A\u7A8B\u7A90\u7A91\u7A94\u7A9E\u7AA0\u7AA3\u7AAC\u7AB3\u7AB5\u7AB9\u7ABB\u7ABC\u7AC6\u7AC9\u7ACC\u7ACE\u7AD1\u7ADB\u7AE8\u7AE9\u7AEB\u7AEC\u7AF1\u7AF4\u7AFB\u7AFD\u7AFE\u7B07\u7B14\u7B1F\u7B23\u7B27\u7B29\u7B2A\u7B2B\u7B2D\u7B2E\u7B2F\u7B30"],
      ["8fd2a1", "\u7B31\u7B34\u7B3D\u7B3F\u7B40\u7B41\u7B47\u7B4E\u7B55\u7B60\u7B64\u7B66\u7B69\u7B6A\u7B6D\u7B6F\u7B72\u7B73\u7B77\u7B84\u7B89\u7B8E\u7B90\u7B91\u7B96\u7B9B\u7B9E\u7BA0\u7BA5\u7BAC\u7BAF\u7BB0\u7BB2\u7BB5\u7BB6\u7BBA\u7BBB\u7BBC\u7BBD\u7BC2\u7BC5\u7BC8\u7BCA\u7BD4\u7BD6\u7BD7\u7BD9\u7BDA\u7BDB\u7BE8\u7BEA\u7BF2\u7BF4\u7BF5\u7BF8\u7BF9\u7BFA\u7BFC\u7BFE\u7C01\u7C02\u7C03\u7C04\u7C06\u7C09\u7C0B\u7C0C\u7C0E\u7C0F\u7C19\u7C1B\u7C20\u7C25\u7C26\u7C28\u7C2C\u7C31\u7C33\u7C34\u7C36\u7C39\u7C3A\u7C46\u7C4A\u7C55\u7C51\u7C52\u7C53\u7C59", 5],
      ["8fd3a1", "\u7C61\u7C63\u7C67\u7C69\u7C6D\u7C6E\u7C70\u7C72\u7C79\u7C7C\u7C7D\u7C86\u7C87\u7C8F\u7C94\u7C9E\u7CA0\u7CA6\u7CB0\u7CB6\u7CB7\u7CBA\u7CBB\u7CBC\u7CBF\u7CC4\u7CC7\u7CC8\u7CC9\u7CCD\u7CCF\u7CD3\u7CD4\u7CD5\u7CD7\u7CD9\u7CDA\u7CDD\u7CE6\u7CE9\u7CEB\u7CF5\u7D03\u7D07\u7D08\u7D09\u7D0F\u7D11\u7D12\u7D13\u7D16\u7D1D\u7D1E\u7D23\u7D26\u7D2A\u7D2D\u7D31\u7D3C\u7D3D\u7D3E\u7D40\u7D41\u7D47\u7D48\u7D4D\u7D51\u7D53\u7D57\u7D59\u7D5A\u7D5C\u7D5D\u7D65\u7D67\u7D6A\u7D70\u7D78\u7D7A\u7D7B\u7D7F\u7D81\u7D82\u7D83\u7D85\u7D86\u7D88\u7D8B\u7D8C\u7D8D\u7D91\u7D96\u7D97\u7D9D"],
      ["8fd4a1", "\u7D9E\u7DA6\u7DA7\u7DAA\u7DB3\u7DB6\u7DB7\u7DB9\u7DC2", 4, "\u7DCC\u7DCD\u7DCE\u7DD7\u7DD9\u7E00\u7DE2\u7DE5\u7DE6\u7DEA\u7DEB\u7DED\u7DF1\u7DF5\u7DF6\u7DF9\u7DFA\u7E08\u7E10\u7E11\u7E15\u7E17\u7E1C\u7E1D\u7E20\u7E27\u7E28\u7E2C\u7E2D\u7E2F\u7E33\u7E36\u7E3F\u7E44\u7E45\u7E47\u7E4E\u7E50\u7E52\u7E58\u7E5F\u7E61\u7E62\u7E65\u7E6B\u7E6E\u7E6F\u7E73\u7E78\u7E7E\u7E81\u7E86\u7E87\u7E8A\u7E8D\u7E91\u7E95\u7E98\u7E9A\u7E9D\u7E9E\u7F3C\u7F3B\u7F3D\u7F3E\u7F3F\u7F43\u7F44\u7F47\u7F4F\u7F52\u7F53\u7F5B\u7F5C\u7F5D\u7F61\u7F63\u7F64\u7F65\u7F66\u7F6D"],
      ["8fd5a1", "\u7F71\u7F7D\u7F7E\u7F7F\u7F80\u7F8B\u7F8D\u7F8F\u7F90\u7F91\u7F96\u7F97\u7F9C\u7FA1\u7FA2\u7FA6\u7FAA\u7FAD\u7FB4\u7FBC\u7FBF\u7FC0\u7FC3\u7FC8\u7FCE\u7FCF\u7FDB\u7FDF\u7FE3\u7FE5\u7FE8\u7FEC\u7FEE\u7FEF\u7FF2\u7FFA\u7FFD\u7FFE\u7FFF\u8007\u8008\u800A\u800D\u800E\u800F\u8011\u8013\u8014\u8016\u801D\u801E\u801F\u8020\u8024\u8026\u802C\u802E\u8030\u8034\u8035\u8037\u8039\u803A\u803C\u803E\u8040\u8044\u8060\u8064\u8066\u806D\u8071\u8075\u8081\u8088\u808E\u809C\u809E\u80A6\u80A7\u80AB\u80B8\u80B9\u80C8\u80CD\u80CF\u80D2\u80D4\u80D5\u80D7\u80D8\u80E0\u80ED\u80EE"],
      ["8fd6a1", "\u80F0\u80F2\u80F3\u80F6\u80F9\u80FA\u80FE\u8103\u810B\u8116\u8117\u8118\u811C\u811E\u8120\u8124\u8127\u812C\u8130\u8135\u813A\u813C\u8145\u8147\u814A\u814C\u8152\u8157\u8160\u8161\u8167\u8168\u8169\u816D\u816F\u8177\u8181\u8190\u8184\u8185\u8186\u818B\u818E\u8196\u8198\u819B\u819E\u81A2\u81AE\u81B2\u81B4\u81BB\u81CB\u81C3\u81C5\u81CA\u81CE\u81CF\u81D5\u81D7\u81DB\u81DD\u81DE\u81E1\u81E4\u81EB\u81EC\u81F0\u81F1\u81F2\u81F5\u81F6\u81F8\u81F9\u81FD\u81FF\u8200\u8203\u820F\u8213\u8214\u8219\u821A\u821D\u8221\u8222\u8228\u8232\u8234\u823A\u8243\u8244\u8245\u8246"],
      ["8fd7a1", "\u824B\u824E\u824F\u8251\u8256\u825C\u8260\u8263\u8267\u826D\u8274\u827B\u827D\u827F\u8280\u8281\u8283\u8284\u8287\u8289\u828A\u828E\u8291\u8294\u8296\u8298\u829A\u829B\u82A0\u82A1\u82A3\u82A4\u82A7\u82A8\u82A9\u82AA\u82AE\u82B0\u82B2\u82B4\u82B7\u82BA\u82BC\u82BE\u82BF\u82C6\u82D0\u82D5\u82DA\u82E0\u82E2\u82E4\u82E8\u82EA\u82ED\u82EF\u82F6\u82F7\u82FD\u82FE\u8300\u8301\u8307\u8308\u830A\u830B\u8354\u831B\u831D\u831E\u831F\u8321\u8322\u832C\u832D\u832E\u8330\u8333\u8337\u833A\u833C\u833D\u8342\u8343\u8344\u8347\u834D\u834E\u8351\u8355\u8356\u8357\u8370\u8378"],
      ["8fd8a1", "\u837D\u837F\u8380\u8382\u8384\u8386\u838D\u8392\u8394\u8395\u8398\u8399\u839B\u839C\u839D\u83A6\u83A7\u83A9\u83AC\u83BE\u83BF\u83C0\u83C7\u83C9\u83CF\u83D0\u83D1\u83D4\u83DD\u8353\u83E8\u83EA\u83F6\u83F8\u83F9\u83FC\u8401\u8406\u840A\u840F\u8411\u8415\u8419\u83AD\u842F\u8439\u8445\u8447\u8448\u844A\u844D\u844F\u8451\u8452\u8456\u8458\u8459\u845A\u845C\u8460\u8464\u8465\u8467\u846A\u8470\u8473\u8474\u8476\u8478\u847C\u847D\u8481\u8485\u8492\u8493\u8495\u849E\u84A6\u84A8\u84A9\u84AA\u84AF\u84B1\u84B4\u84BA\u84BD\u84BE\u84C0\u84C2\u84C7\u84C8\u84CC\u84CF\u84D3"],
      ["8fd9a1", "\u84DC\u84E7\u84EA\u84EF\u84F0\u84F1\u84F2\u84F7\u8532\u84FA\u84FB\u84FD\u8502\u8503\u8507\u850C\u850E\u8510\u851C\u851E\u8522\u8523\u8524\u8525\u8527\u852A\u852B\u852F\u8533\u8534\u8536\u853F\u8546\u854F", 4, "\u8556\u8559\u855C", 6, "\u8564\u856B\u856F\u8579\u857A\u857B\u857D\u857F\u8581\u8585\u8586\u8589\u858B\u858C\u858F\u8593\u8598\u859D\u859F\u85A0\u85A2\u85A5\u85A7\u85B4\u85B6\u85B7\u85B8\u85BC\u85BD\u85BE\u85BF\u85C2\u85C7\u85CA\u85CB\u85CE\u85AD\u85D8\u85DA\u85DF\u85E0\u85E6\u85E8\u85ED\u85F3\u85F6\u85FC"],
      ["8fdaa1", "\u85FF\u8600\u8604\u8605\u860D\u860E\u8610\u8611\u8612\u8618\u8619\u861B\u861E\u8621\u8627\u8629\u8636\u8638\u863A\u863C\u863D\u8640\u8642\u8646\u8652\u8653\u8656\u8657\u8658\u8659\u865D\u8660", 4, "\u8669\u866C\u866F\u8675\u8676\u8677\u867A\u868D\u8691\u8696\u8698\u869A\u869C\u86A1\u86A6\u86A7\u86A8\u86AD\u86B1\u86B3\u86B4\u86B5\u86B7\u86B8\u86B9\u86BF\u86C0\u86C1\u86C3\u86C5\u86D1\u86D2\u86D5\u86D7\u86DA\u86DC\u86E0\u86E3\u86E5\u86E7\u8688\u86FA\u86FC\u86FD\u8704\u8705\u8707\u870B\u870E\u870F\u8710\u8713\u8714\u8719\u871E\u871F\u8721\u8723"],
      ["8fdba1", "\u8728\u872E\u872F\u8731\u8732\u8739\u873A\u873C\u873D\u873E\u8740\u8743\u8745\u874D\u8758\u875D\u8761\u8764\u8765\u876F\u8771\u8772\u877B\u8783", 6, "\u878B\u878C\u8790\u8793\u8795\u8797\u8798\u8799\u879E\u87A0\u87A3\u87A7\u87AC\u87AD\u87AE\u87B1\u87B5\u87BE\u87BF\u87C1\u87C8\u87C9\u87CA\u87CE\u87D5\u87D6\u87D9\u87DA\u87DC\u87DF\u87E2\u87E3\u87E4\u87EA\u87EB\u87ED\u87F1\u87F3\u87F8\u87FA\u87FF\u8801\u8803\u8806\u8809\u880A\u880B\u8810\u8819\u8812\u8813\u8814\u8818\u881A\u881B\u881C\u881E\u881F\u8828\u882D\u882E\u8830\u8832\u8835"],
      ["8fdca1", "\u883A\u883C\u8841\u8843\u8845\u8848\u8849\u884A\u884B\u884E\u8851\u8855\u8856\u8858\u885A\u885C\u885F\u8860\u8864\u8869\u8871\u8879\u887B\u8880\u8898\u889A\u889B\u889C\u889F\u88A0\u88A8\u88AA\u88BA\u88BD\u88BE\u88C0\u88CA", 4, "\u88D1\u88D2\u88D3\u88DB\u88DE\u88E7\u88EF\u88F0\u88F1\u88F5\u88F7\u8901\u8906\u890D\u890E\u890F\u8915\u8916\u8918\u8919\u891A\u891C\u8920\u8926\u8927\u8928\u8930\u8931\u8932\u8935\u8939\u893A\u893E\u8940\u8942\u8945\u8946\u8949\u894F\u8952\u8957\u895A\u895B\u895C\u8961\u8962\u8963\u896B\u896E\u8970\u8973\u8975\u897A"],
      ["8fdda1", "\u897B\u897C\u897D\u8989\u898D\u8990\u8994\u8995\u899B\u899C\u899F\u89A0\u89A5\u89B0\u89B4\u89B5\u89B6\u89B7\u89BC\u89D4", 4, "\u89E5\u89E9\u89EB\u89ED\u89F1\u89F3\u89F6\u89F9\u89FD\u89FF\u8A04\u8A05\u8A07\u8A0F\u8A11\u8A12\u8A14\u8A15\u8A1E\u8A20\u8A22\u8A24\u8A26\u8A2B\u8A2C\u8A2F\u8A35\u8A37\u8A3D\u8A3E\u8A40\u8A43\u8A45\u8A47\u8A49\u8A4D\u8A4E\u8A53\u8A56\u8A57\u8A58\u8A5C\u8A5D\u8A61\u8A65\u8A67\u8A75\u8A76\u8A77\u8A79\u8A7A\u8A7B\u8A7E\u8A7F\u8A80\u8A83\u8A86\u8A8B\u8A8F\u8A90\u8A92\u8A96\u8A97\u8A99\u8A9F\u8AA7\u8AA9\u8AAE\u8AAF\u8AB3"],
      ["8fdea1", "\u8AB6\u8AB7\u8ABB\u8ABE\u8AC3\u8AC6\u8AC8\u8AC9\u8ACA\u8AD1\u8AD3\u8AD4\u8AD5\u8AD7\u8ADD\u8ADF\u8AEC\u8AF0\u8AF4\u8AF5\u8AF6\u8AFC\u8AFF\u8B05\u8B06\u8B0B\u8B11\u8B1C\u8B1E\u8B1F\u8B0A\u8B2D\u8B30\u8B37\u8B3C\u8B42", 4, "\u8B48\u8B52\u8B53\u8B54\u8B59\u8B4D\u8B5E\u8B63\u8B6D\u8B76\u8B78\u8B79\u8B7C\u8B7E\u8B81\u8B84\u8B85\u8B8B\u8B8D\u8B8F\u8B94\u8B95\u8B9C\u8B9E\u8B9F\u8C38\u8C39\u8C3D\u8C3E\u8C45\u8C47\u8C49\u8C4B\u8C4F\u8C51\u8C53\u8C54\u8C57\u8C58\u8C5B\u8C5D\u8C59\u8C63\u8C64\u8C66\u8C68\u8C69\u8C6D\u8C73\u8C75\u8C76\u8C7B\u8C7E\u8C86"],
      ["8fdfa1", "\u8C87\u8C8B\u8C90\u8C92\u8C93\u8C99\u8C9B\u8C9C\u8CA4\u8CB9\u8CBA\u8CC5\u8CC6\u8CC9\u8CCB\u8CCF\u8CD6\u8CD5\u8CD9\u8CDD\u8CE1\u8CE8\u8CEC\u8CEF\u8CF0\u8CF2\u8CF5\u8CF7\u8CF8\u8CFE\u8CFF\u8D01\u8D03\u8D09\u8D12\u8D17\u8D1B\u8D65\u8D69\u8D6C\u8D6E\u8D7F\u8D82\u8D84\u8D88\u8D8D\u8D90\u8D91\u8D95\u8D9E\u8D9F\u8DA0\u8DA6\u8DAB\u8DAC\u8DAF\u8DB2\u8DB5\u8DB7\u8DB9\u8DBB\u8DC0\u8DC5\u8DC6\u8DC7\u8DC8\u8DCA\u8DCE\u8DD1\u8DD4\u8DD5\u8DD7\u8DD9\u8DE4\u8DE5\u8DE7\u8DEC\u8DF0\u8DBC\u8DF1\u8DF2\u8DF4\u8DFD\u8E01\u8E04\u8E05\u8E06\u8E0B\u8E11\u8E14\u8E16\u8E20\u8E21\u8E22"],
      ["8fe0a1", "\u8E23\u8E26\u8E27\u8E31\u8E33\u8E36\u8E37\u8E38\u8E39\u8E3D\u8E40\u8E41\u8E4B\u8E4D\u8E4E\u8E4F\u8E54\u8E5B\u8E5C\u8E5D\u8E5E\u8E61\u8E62\u8E69\u8E6C\u8E6D\u8E6F\u8E70\u8E71\u8E79\u8E7A\u8E7B\u8E82\u8E83\u8E89\u8E90\u8E92\u8E95\u8E9A\u8E9B\u8E9D\u8E9E\u8EA2\u8EA7\u8EA9\u8EAD\u8EAE\u8EB3\u8EB5\u8EBA\u8EBB\u8EC0\u8EC1\u8EC3\u8EC4\u8EC7\u8ECF\u8ED1\u8ED4\u8EDC\u8EE8\u8EEE\u8EF0\u8EF1\u8EF7\u8EF9\u8EFA\u8EED\u8F00\u8F02\u8F07\u8F08\u8F0F\u8F10\u8F16\u8F17\u8F18\u8F1E\u8F20\u8F21\u8F23\u8F25\u8F27\u8F28\u8F2C\u8F2D\u8F2E\u8F34\u8F35\u8F36\u8F37\u8F3A\u8F40\u8F41"],
      ["8fe1a1", "\u8F43\u8F47\u8F4F\u8F51", 4, "\u8F58\u8F5D\u8F5E\u8F65\u8F9D\u8FA0\u8FA1\u8FA4\u8FA5\u8FA6\u8FB5\u8FB6\u8FB8\u8FBE\u8FC0\u8FC1\u8FC6\u8FCA\u8FCB\u8FCD\u8FD0\u8FD2\u8FD3\u8FD5\u8FE0\u8FE3\u8FE4\u8FE8\u8FEE\u8FF1\u8FF5\u8FF6\u8FFB\u8FFE\u9002\u9004\u9008\u900C\u9018\u901B\u9028\u9029\u902F\u902A\u902C\u902D\u9033\u9034\u9037\u903F\u9043\u9044\u904C\u905B\u905D\u9062\u9066\u9067\u906C\u9070\u9074\u9079\u9085\u9088\u908B\u908C\u908E\u9090\u9095\u9097\u9098\u9099\u909B\u90A0\u90A1\u90A2\u90A5\u90B0\u90B2\u90B3\u90B4\u90B6\u90BD\u90CC\u90BE\u90C3"],
      ["8fe2a1", "\u90C4\u90C5\u90C7\u90C8\u90D5\u90D7\u90D8\u90D9\u90DC\u90DD\u90DF\u90E5\u90D2\u90F6\u90EB\u90EF\u90F0\u90F4\u90FE\u90FF\u9100\u9104\u9105\u9106\u9108\u910D\u9110\u9114\u9116\u9117\u9118\u911A\u911C\u911E\u9120\u9125\u9122\u9123\u9127\u9129\u912E\u912F\u9131\u9134\u9136\u9137\u9139\u913A\u913C\u913D\u9143\u9147\u9148\u914F\u9153\u9157\u9159\u915A\u915B\u9161\u9164\u9167\u916D\u9174\u9179\u917A\u917B\u9181\u9183\u9185\u9186\u918A\u918E\u9191\u9193\u9194\u9195\u9198\u919E\u91A1\u91A6\u91A8\u91AC\u91AD\u91AE\u91B0\u91B1\u91B2\u91B3\u91B6\u91BB\u91BC\u91BD\u91BF"],
      ["8fe3a1", "\u91C2\u91C3\u91C5\u91D3\u91D4\u91D7\u91D9\u91DA\u91DE\u91E4\u91E5\u91E9\u91EA\u91EC", 5, "\u91F7\u91F9\u91FB\u91FD\u9200\u9201\u9204\u9205\u9206\u9207\u9209\u920A\u920C\u9210\u9212\u9213\u9216\u9218\u921C\u921D\u9223\u9224\u9225\u9226\u9228\u922E\u922F\u9230\u9233\u9235\u9236\u9238\u9239\u923A\u923C\u923E\u9240\u9242\u9243\u9246\u9247\u924A\u924D\u924E\u924F\u9251\u9258\u9259\u925C\u925D\u9260\u9261\u9265\u9267\u9268\u9269\u926E\u926F\u9270\u9275", 4, "\u927B\u927C\u927D\u927F\u9288\u9289\u928A\u928D\u928E\u9292\u9297"],
      ["8fe4a1", "\u9299\u929F\u92A0\u92A4\u92A5\u92A7\u92A8\u92AB\u92AF\u92B2\u92B6\u92B8\u92BA\u92BB\u92BC\u92BD\u92BF", 4, "\u92C5\u92C6\u92C7\u92C8\u92CB\u92CC\u92CD\u92CE\u92D0\u92D3\u92D5\u92D7\u92D8\u92D9\u92DC\u92DD\u92DF\u92E0\u92E1\u92E3\u92E5\u92E7\u92E8\u92EC\u92EE\u92F0\u92F9\u92FB\u92FF\u9300\u9302\u9308\u930D\u9311\u9314\u9315\u931C\u931D\u931E\u931F\u9321\u9324\u9325\u9327\u9329\u932A\u9333\u9334\u9336\u9337\u9347\u9348\u9349\u9350\u9351\u9352\u9355\u9357\u9358\u935A\u935E\u9364\u9365\u9367\u9369\u936A\u936D\u936F\u9370\u9371\u9373\u9374\u9376"],
      ["8fe5a1", "\u937A\u937D\u937F\u9380\u9381\u9382\u9388\u938A\u938B\u938D\u938F\u9392\u9395\u9398\u939B\u939E\u93A1\u93A3\u93A4\u93A6\u93A8\u93AB\u93B4\u93B5\u93B6\u93BA\u93A9\u93C1\u93C4\u93C5\u93C6\u93C7\u93C9", 4, "\u93D3\u93D9\u93DC\u93DE\u93DF\u93E2\u93E6\u93E7\u93F9\u93F7\u93F8\u93FA\u93FB\u93FD\u9401\u9402\u9404\u9408\u9409\u940D\u940E\u940F\u9415\u9416\u9417\u941F\u942E\u942F\u9431\u9432\u9433\u9434\u943B\u943F\u943D\u9443\u9445\u9448\u944A\u944C\u9455\u9459\u945C\u945F\u9461\u9463\u9468\u946B\u946D\u946E\u946F\u9471\u9472\u9484\u9483\u9578\u9579"],
      ["8fe6a1", "\u957E\u9584\u9588\u958C\u958D\u958E\u959D\u959E\u959F\u95A1\u95A6\u95A9\u95AB\u95AC\u95B4\u95B6\u95BA\u95BD\u95BF\u95C6\u95C8\u95C9\u95CB\u95D0\u95D1\u95D2\u95D3\u95D9\u95DA\u95DD\u95DE\u95DF\u95E0\u95E4\u95E6\u961D\u961E\u9622\u9624\u9625\u9626\u962C\u9631\u9633\u9637\u9638\u9639\u963A\u963C\u963D\u9641\u9652\u9654\u9656\u9657\u9658\u9661\u966E\u9674\u967B\u967C\u967E\u967F\u9681\u9682\u9683\u9684\u9689\u9691\u9696\u969A\u969D\u969F\u96A4\u96A5\u96A6\u96A9\u96AE\u96AF\u96B3\u96BA\u96CA\u96D2\u5DB2\u96D8\u96DA\u96DD\u96DE\u96DF\u96E9\u96EF\u96F1\u96FA\u9702"],
      ["8fe7a1", "\u9703\u9705\u9709\u971A\u971B\u971D\u9721\u9722\u9723\u9728\u9731\u9733\u9741\u9743\u974A\u974E\u974F\u9755\u9757\u9758\u975A\u975B\u9763\u9767\u976A\u976E\u9773\u9776\u9777\u9778\u977B\u977D\u977F\u9780\u9789\u9795\u9796\u9797\u9799\u979A\u979E\u979F\u97A2\u97AC\u97AE\u97B1\u97B2\u97B5\u97B6\u97B8\u97B9\u97BA\u97BC\u97BE\u97BF\u97C1\u97C4\u97C5\u97C7\u97C9\u97CA\u97CC\u97CD\u97CE\u97D0\u97D1\u97D4\u97D7\u97D8\u97D9\u97DD\u97DE\u97E0\u97DB\u97E1\u97E4\u97EF\u97F1\u97F4\u97F7\u97F8\u97FA\u9807\u980A\u9819\u980D\u980E\u9814\u9816\u981C\u981E\u9820\u9823\u9826"],
      ["8fe8a1", "\u982B\u982E\u982F\u9830\u9832\u9833\u9835\u9825\u983E\u9844\u9847\u984A\u9851\u9852\u9853\u9856\u9857\u9859\u985A\u9862\u9863\u9865\u9866\u986A\u986C\u98AB\u98AD\u98AE\u98B0\u98B4\u98B7\u98B8\u98BA\u98BB\u98BF\u98C2\u98C5\u98C8\u98CC\u98E1\u98E3\u98E5\u98E6\u98E7\u98EA\u98F3\u98F6\u9902\u9907\u9908\u9911\u9915\u9916\u9917\u991A\u991B\u991C\u991F\u9922\u9926\u9927\u992B\u9931", 4, "\u9939\u993A\u993B\u993C\u9940\u9941\u9946\u9947\u9948\u994D\u994E\u9954\u9958\u9959\u995B\u995C\u995E\u995F\u9960\u999B\u999D\u999F\u99A6\u99B0\u99B1\u99B2\u99B5"],
      ["8fe9a1", "\u99B9\u99BA\u99BD\u99BF\u99C3\u99C9\u99D3\u99D4\u99D9\u99DA\u99DC\u99DE\u99E7\u99EA\u99EB\u99EC\u99F0\u99F4\u99F5\u99F9\u99FD\u99FE\u9A02\u9A03\u9A04\u9A0B\u9A0C\u9A10\u9A11\u9A16\u9A1E\u9A20\u9A22\u9A23\u9A24\u9A27\u9A2D\u9A2E\u9A33\u9A35\u9A36\u9A38\u9A47\u9A41\u9A44\u9A4A\u9A4B\u9A4C\u9A4E\u9A51\u9A54\u9A56\u9A5D\u9AAA\u9AAC\u9AAE\u9AAF\u9AB2\u9AB4\u9AB5\u9AB6\u9AB9\u9ABB\u9ABE\u9ABF\u9AC1\u9AC3\u9AC6\u9AC8\u9ACE\u9AD0\u9AD2\u9AD5\u9AD6\u9AD7\u9ADB\u9ADC\u9AE0\u9AE4\u9AE5\u9AE7\u9AE9\u9AEC\u9AF2\u9AF3\u9AF5\u9AF9\u9AFA\u9AFD\u9AFF", 4],
      ["8feaa1", "\u9B04\u9B05\u9B08\u9B09\u9B0B\u9B0C\u9B0D\u9B0E\u9B10\u9B12\u9B16\u9B19\u9B1B\u9B1C\u9B20\u9B26\u9B2B\u9B2D\u9B33\u9B34\u9B35\u9B37\u9B39\u9B3A\u9B3D\u9B48\u9B4B\u9B4C\u9B55\u9B56\u9B57\u9B5B\u9B5E\u9B61\u9B63\u9B65\u9B66\u9B68\u9B6A", 4, "\u9B73\u9B75\u9B77\u9B78\u9B79\u9B7F\u9B80\u9B84\u9B85\u9B86\u9B87\u9B89\u9B8A\u9B8B\u9B8D\u9B8F\u9B90\u9B94\u9B9A\u9B9D\u9B9E\u9BA6\u9BA7\u9BA9\u9BAC\u9BB0\u9BB1\u9BB2\u9BB7\u9BB8\u9BBB\u9BBC\u9BBE\u9BBF\u9BC1\u9BC7\u9BC8\u9BCE\u9BD0\u9BD7\u9BD8\u9BDD\u9BDF\u9BE5\u9BE7\u9BEA\u9BEB\u9BEF\u9BF3\u9BF7\u9BF8"],
      ["8feba1", "\u9BF9\u9BFA\u9BFD\u9BFF\u9C00\u9C02\u9C0B\u9C0F\u9C11\u9C16\u9C18\u9C19\u9C1A\u9C1C\u9C1E\u9C22\u9C23\u9C26", 4, "\u9C31\u9C35\u9C36\u9C37\u9C3D\u9C41\u9C43\u9C44\u9C45\u9C49\u9C4A\u9C4E\u9C4F\u9C50\u9C53\u9C54\u9C56\u9C58\u9C5B\u9C5D\u9C5E\u9C5F\u9C63\u9C69\u9C6A\u9C5C\u9C6B\u9C68\u9C6E\u9C70\u9C72\u9C75\u9C77\u9C7B\u9CE6\u9CF2\u9CF7\u9CF9\u9D0B\u9D02\u9D11\u9D17\u9D18\u9D1C\u9D1D\u9D1E\u9D2F\u9D30\u9D32\u9D33\u9D34\u9D3A\u9D3C\u9D45\u9D3D\u9D42\u9D43\u9D47\u9D4A\u9D53\u9D54\u9D5F\u9D63\u9D62\u9D65\u9D69\u9D6A\u9D6B\u9D70\u9D76\u9D77\u9D7B"],
      ["8feca1", "\u9D7C\u9D7E\u9D83\u9D84\u9D86\u9D8A\u9D8D\u9D8E\u9D92\u9D93\u9D95\u9D96\u9D97\u9D98\u9DA1\u9DAA\u9DAC\u9DAE\u9DB1\u9DB5\u9DB9\u9DBC\u9DBF\u9DC3\u9DC7\u9DC9\u9DCA\u9DD4\u9DD5\u9DD6\u9DD7\u9DDA\u9DDE\u9DDF\u9DE0\u9DE5\u9DE7\u9DE9\u9DEB\u9DEE\u9DF0\u9DF3\u9DF4\u9DFE\u9E0A\u9E02\u9E07\u9E0E\u9E10\u9E11\u9E12\u9E15\u9E16\u9E19\u9E1C\u9E1D\u9E7A\u9E7B\u9E7C\u9E80\u9E82\u9E83\u9E84\u9E85\u9E87\u9E8E\u9E8F\u9E96\u9E98\u9E9B\u9E9E\u9EA4\u9EA8\u9EAC\u9EAE\u9EAF\u9EB0\u9EB3\u9EB4\u9EB5\u9EC6\u9EC8\u9ECB\u9ED5\u9EDF\u9EE4\u9EE7\u9EEC\u9EED\u9EEE\u9EF0\u9EF1\u9EF2\u9EF5"],
      ["8feda1", "\u9EF8\u9EFF\u9F02\u9F03\u9F09\u9F0F\u9F10\u9F11\u9F12\u9F14\u9F16\u9F17\u9F19\u9F1A\u9F1B\u9F1F\u9F22\u9F26\u9F2A\u9F2B\u9F2F\u9F31\u9F32\u9F34\u9F37\u9F39\u9F3A\u9F3C\u9F3D\u9F3F\u9F41\u9F43", 4, "\u9F53\u9F55\u9F56\u9F57\u9F58\u9F5A\u9F5D\u9F5E\u9F68\u9F69\u9F6D", 4, "\u9F73\u9F75\u9F7A\u9F7D\u9F8F\u9F90\u9F91\u9F92\u9F94\u9F96\u9F97\u9F9E\u9FA1\u9FA2\u9FA3\u9FA5"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp936.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127, "\u20AC"],
      ["8140", "\u4E02\u4E04\u4E05\u4E06\u4E0F\u4E12\u4E17\u4E1F\u4E20\u4E21\u4E23\u4E26\u4E29\u4E2E\u4E2F\u4E31\u4E33\u4E35\u4E37\u4E3C\u4E40\u4E41\u4E42\u4E44\u4E46\u4E4A\u4E51\u4E55\u4E57\u4E5A\u4E5B\u4E62\u4E63\u4E64\u4E65\u4E67\u4E68\u4E6A", 5, "\u4E72\u4E74", 9, "\u4E7F", 6, "\u4E87\u4E8A"],
      ["8180", "\u4E90\u4E96\u4E97\u4E99\u4E9C\u4E9D\u4E9E\u4EA3\u4EAA\u4EAF\u4EB0\u4EB1\u4EB4\u4EB6\u4EB7\u4EB8\u4EB9\u4EBC\u4EBD\u4EBE\u4EC8\u4ECC\u4ECF\u4ED0\u4ED2\u4EDA\u4EDB\u4EDC\u4EE0\u4EE2\u4EE6\u4EE7\u4EE9\u4EED\u4EEE\u4EEF\u4EF1\u4EF4\u4EF8\u4EF9\u4EFA\u4EFC\u4EFE\u4F00\u4F02", 6, "\u4F0B\u4F0C\u4F12", 4, "\u4F1C\u4F1D\u4F21\u4F23\u4F28\u4F29\u4F2C\u4F2D\u4F2E\u4F31\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E", 4, "\u4F44\u4F45\u4F47", 5, "\u4F52\u4F54\u4F56\u4F61\u4F62\u4F66\u4F68\u4F6A\u4F6B\u4F6D\u4F6E\u4F71\u4F72\u4F75\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F80\u4F81\u4F82\u4F85\u4F86\u4F87\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F95\u4F96\u4F98\u4F99\u4F9A\u4F9C\u4F9E\u4F9F\u4FA1\u4FA2"],
      ["8240", "\u4FA4\u4FAB\u4FAD\u4FB0", 4, "\u4FB6", 8, "\u4FC0\u4FC1\u4FC2\u4FC6\u4FC7\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FD2", 4, "\u4FD9\u4FDB\u4FE0\u4FE2\u4FE4\u4FE5\u4FE7\u4FEB\u4FEC\u4FF0\u4FF2\u4FF4\u4FF5\u4FF6\u4FF7\u4FF9\u4FFB\u4FFC\u4FFD\u4FFF", 11],
      ["8280", "\u500B\u500E\u5010\u5011\u5013\u5015\u5016\u5017\u501B\u501D\u501E\u5020\u5022\u5023\u5024\u5027\u502B\u502F", 10, "\u503B\u503D\u503F\u5040\u5041\u5042\u5044\u5045\u5046\u5049\u504A\u504B\u504D\u5050", 4, "\u5056\u5057\u5058\u5059\u505B\u505D", 7, "\u5066", 5, "\u506D", 8, "\u5078\u5079\u507A\u507C\u507D\u5081\u5082\u5083\u5084\u5086\u5087\u5089\u508A\u508B\u508C\u508E", 20, "\u50A4\u50A6\u50AA\u50AB\u50AD", 4, "\u50B3", 6, "\u50BC"],
      ["8340", "\u50BD", 17, "\u50D0", 5, "\u50D7\u50D8\u50D9\u50DB", 10, "\u50E8\u50E9\u50EA\u50EB\u50EF\u50F0\u50F1\u50F2\u50F4\u50F6", 4, "\u50FC", 9, "\u5108"],
      ["8380", "\u5109\u510A\u510C", 5, "\u5113", 13, "\u5122", 28, "\u5142\u5147\u514A\u514C\u514E\u514F\u5150\u5152\u5153\u5157\u5158\u5159\u515B\u515D", 4, "\u5163\u5164\u5166\u5167\u5169\u516A\u516F\u5172\u517A\u517E\u517F\u5183\u5184\u5186\u5187\u518A\u518B\u518E\u518F\u5190\u5191\u5193\u5194\u5198\u519A\u519D\u519E\u519F\u51A1\u51A3\u51A6", 4, "\u51AD\u51AE\u51B4\u51B8\u51B9\u51BA\u51BE\u51BF\u51C1\u51C2\u51C3\u51C5\u51C8\u51CA\u51CD\u51CE\u51D0\u51D2", 5],
      ["8440", "\u51D8\u51D9\u51DA\u51DC\u51DE\u51DF\u51E2\u51E3\u51E5", 5, "\u51EC\u51EE\u51F1\u51F2\u51F4\u51F7\u51FE\u5204\u5205\u5209\u520B\u520C\u520F\u5210\u5213\u5214\u5215\u521C\u521E\u521F\u5221\u5222\u5223\u5225\u5226\u5227\u522A\u522C\u522F\u5231\u5232\u5234\u5235\u523C\u523E\u5244", 5, "\u524B\u524E\u524F\u5252\u5253\u5255\u5257\u5258"],
      ["8480", "\u5259\u525A\u525B\u525D\u525F\u5260\u5262\u5263\u5264\u5266\u5268\u526B\u526C\u526D\u526E\u5270\u5271\u5273", 9, "\u527E\u5280\u5283", 4, "\u5289", 6, "\u5291\u5292\u5294", 6, "\u529C\u52A4\u52A5\u52A6\u52A7\u52AE\u52AF\u52B0\u52B4", 9, "\u52C0\u52C1\u52C2\u52C4\u52C5\u52C6\u52C8\u52CA\u52CC\u52CD\u52CE\u52CF\u52D1\u52D3\u52D4\u52D5\u52D7\u52D9", 5, "\u52E0\u52E1\u52E2\u52E3\u52E5", 10, "\u52F1", 7, "\u52FB\u52FC\u52FD\u5301\u5302\u5303\u5304\u5307\u5309\u530A\u530B\u530C\u530E"],
      ["8540", "\u5311\u5312\u5313\u5314\u5318\u531B\u531C\u531E\u531F\u5322\u5324\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u532F", 9, "\u533C\u533D\u5340\u5342\u5344\u5346\u534B\u534C\u534D\u5350\u5354\u5358\u5359\u535B\u535D\u5365\u5368\u536A\u536C\u536D\u5372\u5376\u5379\u537B\u537C\u537D\u537E\u5380\u5381\u5383\u5387\u5388\u538A\u538E\u538F"],
      ["8580", "\u5390", 4, "\u5396\u5397\u5399\u539B\u539C\u539E\u53A0\u53A1\u53A4\u53A7\u53AA\u53AB\u53AC\u53AD\u53AF", 6, "\u53B7\u53B8\u53B9\u53BA\u53BC\u53BD\u53BE\u53C0\u53C3", 4, "\u53CE\u53CF\u53D0\u53D2\u53D3\u53D5\u53DA\u53DC\u53DD\u53DE\u53E1\u53E2\u53E7\u53F4\u53FA\u53FE\u53FF\u5400\u5402\u5405\u5407\u540B\u5414\u5418\u5419\u541A\u541C\u5422\u5424\u5425\u542A\u5430\u5433\u5436\u5437\u543A\u543D\u543F\u5441\u5442\u5444\u5445\u5447\u5449\u544C\u544D\u544E\u544F\u5451\u545A\u545D", 4, "\u5463\u5465\u5467\u5469", 7, "\u5474\u5479\u547A\u547E\u547F\u5481\u5483\u5485\u5487\u5488\u5489\u548A\u548D\u5491\u5493\u5497\u5498\u549C\u549E\u549F\u54A0\u54A1"],
      ["8640", "\u54A2\u54A5\u54AE\u54B0\u54B2\u54B5\u54B6\u54B7\u54B9\u54BA\u54BC\u54BE\u54C3\u54C5\u54CA\u54CB\u54D6\u54D8\u54DB\u54E0", 4, "\u54EB\u54EC\u54EF\u54F0\u54F1\u54F4", 5, "\u54FB\u54FE\u5500\u5502\u5503\u5504\u5505\u5508\u550A", 4, "\u5512\u5513\u5515", 5, "\u551C\u551D\u551E\u551F\u5521\u5525\u5526"],
      ["8680", "\u5528\u5529\u552B\u552D\u5532\u5534\u5535\u5536\u5538\u5539\u553A\u553B\u553D\u5540\u5542\u5545\u5547\u5548\u554B", 4, "\u5551\u5552\u5553\u5554\u5557", 4, "\u555D\u555E\u555F\u5560\u5562\u5563\u5568\u5569\u556B\u556F", 5, "\u5579\u557A\u557D\u557F\u5585\u5586\u558C\u558D\u558E\u5590\u5592\u5593\u5595\u5596\u5597\u559A\u559B\u559E\u55A0", 6, "\u55A8", 8, "\u55B2\u55B4\u55B6\u55B8\u55BA\u55BC\u55BF", 4, "\u55C6\u55C7\u55C8\u55CA\u55CB\u55CE\u55CF\u55D0\u55D5\u55D7", 4, "\u55DE\u55E0\u55E2\u55E7\u55E9\u55ED\u55EE\u55F0\u55F1\u55F4\u55F6\u55F8", 4, "\u55FF\u5602\u5603\u5604\u5605"],
      ["8740", "\u5606\u5607\u560A\u560B\u560D\u5610", 7, "\u5619\u561A\u561C\u561D\u5620\u5621\u5622\u5625\u5626\u5628\u5629\u562A\u562B\u562E\u562F\u5630\u5633\u5635\u5637\u5638\u563A\u563C\u563D\u563E\u5640", 11, "\u564F", 4, "\u5655\u5656\u565A\u565B\u565D", 4],
      ["8780", "\u5663\u5665\u5666\u5667\u566D\u566E\u566F\u5670\u5672\u5673\u5674\u5675\u5677\u5678\u5679\u567A\u567D", 7, "\u5687", 6, "\u5690\u5691\u5692\u5694", 14, "\u56A4", 10, "\u56B0", 6, "\u56B8\u56B9\u56BA\u56BB\u56BD", 12, "\u56CB", 8, "\u56D5\u56D6\u56D8\u56D9\u56DC\u56E3\u56E5", 5, "\u56EC\u56EE\u56EF\u56F2\u56F3\u56F6\u56F7\u56F8\u56FB\u56FC\u5700\u5701\u5702\u5705\u5707\u570B", 6],
      ["8840", "\u5712", 9, "\u571D\u571E\u5720\u5721\u5722\u5724\u5725\u5726\u5727\u572B\u5731\u5732\u5734", 4, "\u573C\u573D\u573F\u5741\u5743\u5744\u5745\u5746\u5748\u5749\u574B\u5752", 4, "\u5758\u5759\u5762\u5763\u5765\u5767\u576C\u576E\u5770\u5771\u5772\u5774\u5775\u5778\u5779\u577A\u577D\u577E\u577F\u5780"],
      ["8880", "\u5781\u5787\u5788\u5789\u578A\u578D", 4, "\u5794", 6, "\u579C\u579D\u579E\u579F\u57A5\u57A8\u57AA\u57AC\u57AF\u57B0\u57B1\u57B3\u57B5\u57B6\u57B7\u57B9", 8, "\u57C4", 6, "\u57CC\u57CD\u57D0\u57D1\u57D3\u57D6\u57D7\u57DB\u57DC\u57DE\u57E1\u57E2\u57E3\u57E5", 7, "\u57EE\u57F0\u57F1\u57F2\u57F3\u57F5\u57F6\u57F7\u57FB\u57FC\u57FE\u57FF\u5801\u5803\u5804\u5805\u5808\u5809\u580A\u580C\u580E\u580F\u5810\u5812\u5813\u5814\u5816\u5817\u5818\u581A\u581B\u581C\u581D\u581F\u5822\u5823\u5825", 4, "\u582B", 4, "\u5831\u5832\u5833\u5834\u5836", 7],
      ["8940", "\u583E", 5, "\u5845", 6, "\u584E\u584F\u5850\u5852\u5853\u5855\u5856\u5857\u5859", 4, "\u585F", 5, "\u5866", 4, "\u586D", 16, "\u587F\u5882\u5884\u5886\u5887\u5888\u588A\u588B\u588C"],
      ["8980", "\u588D", 4, "\u5894", 4, "\u589B\u589C\u589D\u58A0", 7, "\u58AA", 17, "\u58BD\u58BE\u58BF\u58C0\u58C2\u58C3\u58C4\u58C6", 10, "\u58D2\u58D3\u58D4\u58D6", 13, "\u58E5", 5, "\u58ED\u58EF\u58F1\u58F2\u58F4\u58F5\u58F7\u58F8\u58FA", 7, "\u5903\u5905\u5906\u5908", 4, "\u590E\u5910\u5911\u5912\u5913\u5917\u5918\u591B\u591D\u591E\u5920\u5921\u5922\u5923\u5926\u5928\u592C\u5930\u5932\u5933\u5935\u5936\u593B"],
      ["8a40", "\u593D\u593E\u593F\u5940\u5943\u5945\u5946\u594A\u594C\u594D\u5950\u5952\u5953\u5959\u595B", 4, "\u5961\u5963\u5964\u5966", 12, "\u5975\u5977\u597A\u597B\u597C\u597E\u597F\u5980\u5985\u5989\u598B\u598C\u598E\u598F\u5990\u5991\u5994\u5995\u5998\u599A\u599B\u599C\u599D\u599F\u59A0\u59A1\u59A2\u59A6"],
      ["8a80", "\u59A7\u59AC\u59AD\u59B0\u59B1\u59B3", 5, "\u59BA\u59BC\u59BD\u59BF", 6, "\u59C7\u59C8\u59C9\u59CC\u59CD\u59CE\u59CF\u59D5\u59D6\u59D9\u59DB\u59DE", 4, "\u59E4\u59E6\u59E7\u59E9\u59EA\u59EB\u59ED", 11, "\u59FA\u59FC\u59FD\u59FE\u5A00\u5A02\u5A0A\u5A0B\u5A0D\u5A0E\u5A0F\u5A10\u5A12\u5A14\u5A15\u5A16\u5A17\u5A19\u5A1A\u5A1B\u5A1D\u5A1E\u5A21\u5A22\u5A24\u5A26\u5A27\u5A28\u5A2A", 6, "\u5A33\u5A35\u5A37", 4, "\u5A3D\u5A3E\u5A3F\u5A41", 4, "\u5A47\u5A48\u5A4B", 9, "\u5A56\u5A57\u5A58\u5A59\u5A5B", 5],
      ["8b40", "\u5A61\u5A63\u5A64\u5A65\u5A66\u5A68\u5A69\u5A6B", 8, "\u5A78\u5A79\u5A7B\u5A7C\u5A7D\u5A7E\u5A80", 17, "\u5A93", 6, "\u5A9C", 13, "\u5AAB\u5AAC"],
      ["8b80", "\u5AAD", 4, "\u5AB4\u5AB6\u5AB7\u5AB9", 4, "\u5ABF\u5AC0\u5AC3", 5, "\u5ACA\u5ACB\u5ACD", 4, "\u5AD3\u5AD5\u5AD7\u5AD9\u5ADA\u5ADB\u5ADD\u5ADE\u5ADF\u5AE2\u5AE4\u5AE5\u5AE7\u5AE8\u5AEA\u5AEC", 4, "\u5AF2", 22, "\u5B0A", 11, "\u5B18", 25, "\u5B33\u5B35\u5B36\u5B38", 7, "\u5B41", 6],
      ["8c40", "\u5B48", 7, "\u5B52\u5B56\u5B5E\u5B60\u5B61\u5B67\u5B68\u5B6B\u5B6D\u5B6E\u5B6F\u5B72\u5B74\u5B76\u5B77\u5B78\u5B79\u5B7B\u5B7C\u5B7E\u5B7F\u5B82\u5B86\u5B8A\u5B8D\u5B8E\u5B90\u5B91\u5B92\u5B94\u5B96\u5B9F\u5BA7\u5BA8\u5BA9\u5BAC\u5BAD\u5BAE\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBB\u5BBC\u5BC0\u5BC1\u5BC3\u5BC8\u5BC9\u5BCA\u5BCB\u5BCD\u5BCE\u5BCF"],
      ["8c80", "\u5BD1\u5BD4", 8, "\u5BE0\u5BE2\u5BE3\u5BE6\u5BE7\u5BE9", 4, "\u5BEF\u5BF1", 6, "\u5BFD\u5BFE\u5C00\u5C02\u5C03\u5C05\u5C07\u5C08\u5C0B\u5C0C\u5C0D\u5C0E\u5C10\u5C12\u5C13\u5C17\u5C19\u5C1B\u5C1E\u5C1F\u5C20\u5C21\u5C23\u5C26\u5C28\u5C29\u5C2A\u5C2B\u5C2D\u5C2E\u5C2F\u5C30\u5C32\u5C33\u5C35\u5C36\u5C37\u5C43\u5C44\u5C46\u5C47\u5C4C\u5C4D\u5C52\u5C53\u5C54\u5C56\u5C57\u5C58\u5C5A\u5C5B\u5C5C\u5C5D\u5C5F\u5C62\u5C64\u5C67", 6, "\u5C70\u5C72", 6, "\u5C7B\u5C7C\u5C7D\u5C7E\u5C80\u5C83", 4, "\u5C89\u5C8A\u5C8B\u5C8E\u5C8F\u5C92\u5C93\u5C95\u5C9D", 4, "\u5CA4", 4],
      ["8d40", "\u5CAA\u5CAE\u5CAF\u5CB0\u5CB2\u5CB4\u5CB6\u5CB9\u5CBA\u5CBB\u5CBC\u5CBE\u5CC0\u5CC2\u5CC3\u5CC5", 5, "\u5CCC", 5, "\u5CD3", 5, "\u5CDA", 6, "\u5CE2\u5CE3\u5CE7\u5CE9\u5CEB\u5CEC\u5CEE\u5CEF\u5CF1", 9, "\u5CFC", 4],
      ["8d80", "\u5D01\u5D04\u5D05\u5D08", 5, "\u5D0F", 4, "\u5D15\u5D17\u5D18\u5D19\u5D1A\u5D1C\u5D1D\u5D1F", 4, "\u5D25\u5D28\u5D2A\u5D2B\u5D2C\u5D2F", 4, "\u5D35", 7, "\u5D3F", 7, "\u5D48\u5D49\u5D4D", 10, "\u5D59\u5D5A\u5D5C\u5D5E", 10, "\u5D6A\u5D6D\u5D6E\u5D70\u5D71\u5D72\u5D73\u5D75", 12, "\u5D83", 21, "\u5D9A\u5D9B\u5D9C\u5D9E\u5D9F\u5DA0"],
      ["8e40", "\u5DA1", 21, "\u5DB8", 12, "\u5DC6", 6, "\u5DCE", 12, "\u5DDC\u5DDF\u5DE0\u5DE3\u5DE4\u5DEA\u5DEC\u5DED"],
      ["8e80", "\u5DF0\u5DF5\u5DF6\u5DF8", 4, "\u5DFF\u5E00\u5E04\u5E07\u5E09\u5E0A\u5E0B\u5E0D\u5E0E\u5E12\u5E13\u5E17\u5E1E", 7, "\u5E28", 4, "\u5E2F\u5E30\u5E32", 4, "\u5E39\u5E3A\u5E3E\u5E3F\u5E40\u5E41\u5E43\u5E46", 5, "\u5E4D", 6, "\u5E56", 4, "\u5E5C\u5E5D\u5E5F\u5E60\u5E63", 14, "\u5E75\u5E77\u5E79\u5E7E\u5E81\u5E82\u5E83\u5E85\u5E88\u5E89\u5E8C\u5E8D\u5E8E\u5E92\u5E98\u5E9B\u5E9D\u5EA1\u5EA2\u5EA3\u5EA4\u5EA8", 4, "\u5EAE", 4, "\u5EB4\u5EBA\u5EBB\u5EBC\u5EBD\u5EBF", 6],
      ["8f40", "\u5EC6\u5EC7\u5EC8\u5ECB", 5, "\u5ED4\u5ED5\u5ED7\u5ED8\u5ED9\u5EDA\u5EDC", 11, "\u5EE9\u5EEB", 8, "\u5EF5\u5EF8\u5EF9\u5EFB\u5EFC\u5EFD\u5F05\u5F06\u5F07\u5F09\u5F0C\u5F0D\u5F0E\u5F10\u5F12\u5F14\u5F16\u5F19\u5F1A\u5F1C\u5F1D\u5F1E\u5F21\u5F22\u5F23\u5F24"],
      ["8f80", "\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F32", 6, "\u5F3B\u5F3D\u5F3E\u5F3F\u5F41", 14, "\u5F51\u5F54\u5F59\u5F5A\u5F5B\u5F5C\u5F5E\u5F5F\u5F60\u5F63\u5F65\u5F67\u5F68\u5F6B\u5F6E\u5F6F\u5F72\u5F74\u5F75\u5F76\u5F78\u5F7A\u5F7D\u5F7E\u5F7F\u5F83\u5F86\u5F8D\u5F8E\u5F8F\u5F91\u5F93\u5F94\u5F96\u5F9A\u5F9B\u5F9D\u5F9E\u5F9F\u5FA0\u5FA2", 5, "\u5FA9\u5FAB\u5FAC\u5FAF", 5, "\u5FB6\u5FB8\u5FB9\u5FBA\u5FBB\u5FBE", 4, "\u5FC7\u5FC8\u5FCA\u5FCB\u5FCE\u5FD3\u5FD4\u5FD5\u5FDA\u5FDB\u5FDC\u5FDE\u5FDF\u5FE2\u5FE3\u5FE5\u5FE6\u5FE8\u5FE9\u5FEC\u5FEF\u5FF0\u5FF2\u5FF3\u5FF4\u5FF6\u5FF7\u5FF9\u5FFA\u5FFC\u6007"],
      ["9040", "\u6008\u6009\u600B\u600C\u6010\u6011\u6013\u6017\u6018\u601A\u601E\u601F\u6022\u6023\u6024\u602C\u602D\u602E\u6030", 4, "\u6036", 4, "\u603D\u603E\u6040\u6044", 6, "\u604C\u604E\u604F\u6051\u6053\u6054\u6056\u6057\u6058\u605B\u605C\u605E\u605F\u6060\u6061\u6065\u6066\u606E\u6071\u6072\u6074\u6075\u6077\u607E\u6080"],
      ["9080", "\u6081\u6082\u6085\u6086\u6087\u6088\u608A\u608B\u608E\u608F\u6090\u6091\u6093\u6095\u6097\u6098\u6099\u609C\u609E\u60A1\u60A2\u60A4\u60A5\u60A7\u60A9\u60AA\u60AE\u60B0\u60B3\u60B5\u60B6\u60B7\u60B9\u60BA\u60BD", 7, "\u60C7\u60C8\u60C9\u60CC", 4, "\u60D2\u60D3\u60D4\u60D6\u60D7\u60D9\u60DB\u60DE\u60E1", 4, "\u60EA\u60F1\u60F2\u60F5\u60F7\u60F8\u60FB", 4, "\u6102\u6103\u6104\u6105\u6107\u610A\u610B\u610C\u6110", 4, "\u6116\u6117\u6118\u6119\u611B\u611C\u611D\u611E\u6121\u6122\u6125\u6128\u6129\u612A\u612C", 18, "\u6140", 6],
      ["9140", "\u6147\u6149\u614B\u614D\u614F\u6150\u6152\u6153\u6154\u6156", 6, "\u615E\u615F\u6160\u6161\u6163\u6164\u6165\u6166\u6169", 6, "\u6171\u6172\u6173\u6174\u6176\u6178", 18, "\u618C\u618D\u618F", 4, "\u6195"],
      ["9180", "\u6196", 6, "\u619E", 8, "\u61AA\u61AB\u61AD", 9, "\u61B8", 5, "\u61BF\u61C0\u61C1\u61C3", 4, "\u61C9\u61CC", 4, "\u61D3\u61D5", 16, "\u61E7", 13, "\u61F6", 8, "\u6200", 5, "\u6207\u6209\u6213\u6214\u6219\u621C\u621D\u621E\u6220\u6223\u6226\u6227\u6228\u6229\u622B\u622D\u622F\u6230\u6231\u6232\u6235\u6236\u6238", 4, "\u6242\u6244\u6245\u6246\u624A"],
      ["9240", "\u624F\u6250\u6255\u6256\u6257\u6259\u625A\u625C", 6, "\u6264\u6265\u6268\u6271\u6272\u6274\u6275\u6277\u6278\u627A\u627B\u627D\u6281\u6282\u6283\u6285\u6286\u6287\u6288\u628B", 5, "\u6294\u6299\u629C\u629D\u629E\u62A3\u62A6\u62A7\u62A9\u62AA\u62AD\u62AE\u62AF\u62B0\u62B2\u62B3\u62B4\u62B6\u62B7\u62B8\u62BA\u62BE\u62C0\u62C1"],
      ["9280", "\u62C3\u62CB\u62CF\u62D1\u62D5\u62DD\u62DE\u62E0\u62E1\u62E4\u62EA\u62EB\u62F0\u62F2\u62F5\u62F8\u62F9\u62FA\u62FB\u6300\u6303\u6304\u6305\u6306\u630A\u630B\u630C\u630D\u630F\u6310\u6312\u6313\u6314\u6315\u6317\u6318\u6319\u631C\u6326\u6327\u6329\u632C\u632D\u632E\u6330\u6331\u6333", 5, "\u633B\u633C\u633E\u633F\u6340\u6341\u6344\u6347\u6348\u634A\u6351\u6352\u6353\u6354\u6356", 7, "\u6360\u6364\u6365\u6366\u6368\u636A\u636B\u636C\u636F\u6370\u6372\u6373\u6374\u6375\u6378\u6379\u637C\u637D\u637E\u637F\u6381\u6383\u6384\u6385\u6386\u638B\u638D\u6391\u6393\u6394\u6395\u6397\u6399", 6, "\u63A1\u63A4\u63A6\u63AB\u63AF\u63B1\u63B2\u63B5\u63B6\u63B9\u63BB\u63BD\u63BF\u63C0"],
      ["9340", "\u63C1\u63C2\u63C3\u63C5\u63C7\u63C8\u63CA\u63CB\u63CC\u63D1\u63D3\u63D4\u63D5\u63D7", 6, "\u63DF\u63E2\u63E4", 4, "\u63EB\u63EC\u63EE\u63EF\u63F0\u63F1\u63F3\u63F5\u63F7\u63F9\u63FA\u63FB\u63FC\u63FE\u6403\u6404\u6406", 4, "\u640D\u640E\u6411\u6412\u6415", 5, "\u641D\u641F\u6422\u6423\u6424"],
      ["9380", "\u6425\u6427\u6428\u6429\u642B\u642E", 5, "\u6435", 4, "\u643B\u643C\u643E\u6440\u6442\u6443\u6449\u644B", 6, "\u6453\u6455\u6456\u6457\u6459", 4, "\u645F", 7, "\u6468\u646A\u646B\u646C\u646E", 9, "\u647B", 6, "\u6483\u6486\u6488", 8, "\u6493\u6494\u6497\u6498\u649A\u649B\u649C\u649D\u649F", 4, "\u64A5\u64A6\u64A7\u64A8\u64AA\u64AB\u64AF\u64B1\u64B2\u64B3\u64B4\u64B6\u64B9\u64BB\u64BD\u64BE\u64BF\u64C1\u64C3\u64C4\u64C6", 6, "\u64CF\u64D1\u64D3\u64D4\u64D5\u64D6\u64D9\u64DA"],
      ["9440", "\u64DB\u64DC\u64DD\u64DF\u64E0\u64E1\u64E3\u64E5\u64E7", 24, "\u6501", 7, "\u650A", 7, "\u6513", 4, "\u6519", 8],
      ["9480", "\u6522\u6523\u6524\u6526", 4, "\u652C\u652D\u6530\u6531\u6532\u6533\u6537\u653A\u653C\u653D\u6540", 4, "\u6546\u6547\u654A\u654B\u654D\u654E\u6550\u6552\u6553\u6554\u6557\u6558\u655A\u655C\u655F\u6560\u6561\u6564\u6565\u6567\u6568\u6569\u656A\u656D\u656E\u656F\u6571\u6573\u6575\u6576\u6578", 14, "\u6588\u6589\u658A\u658D\u658E\u658F\u6592\u6594\u6595\u6596\u6598\u659A\u659D\u659E\u65A0\u65A2\u65A3\u65A6\u65A8\u65AA\u65AC\u65AE\u65B1", 7, "\u65BA\u65BB\u65BE\u65BF\u65C0\u65C2\u65C7\u65C8\u65C9\u65CA\u65CD\u65D0\u65D1\u65D3\u65D4\u65D5\u65D8", 7, "\u65E1\u65E3\u65E4\u65EA\u65EB"],
      ["9540", "\u65F2\u65F3\u65F4\u65F5\u65F8\u65F9\u65FB", 4, "\u6601\u6604\u6605\u6607\u6608\u6609\u660B\u660D\u6610\u6611\u6612\u6616\u6617\u6618\u661A\u661B\u661C\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6632\u6633\u6637", 4, "\u663D\u663F\u6640\u6642\u6644", 6, "\u664D\u664E\u6650\u6651\u6658"],
      ["9580", "\u6659\u665B\u665C\u665D\u665E\u6660\u6662\u6663\u6665\u6667\u6669", 4, "\u6671\u6672\u6673\u6675\u6678\u6679\u667B\u667C\u667D\u667F\u6680\u6681\u6683\u6685\u6686\u6688\u6689\u668A\u668B\u668D\u668E\u668F\u6690\u6692\u6693\u6694\u6695\u6698", 4, "\u669E", 8, "\u66A9", 4, "\u66AF", 4, "\u66B5\u66B6\u66B7\u66B8\u66BA\u66BB\u66BC\u66BD\u66BF", 25, "\u66DA\u66DE", 7, "\u66E7\u66E8\u66EA", 5, "\u66F1\u66F5\u66F6\u66F8\u66FA\u66FB\u66FD\u6701\u6702\u6703"],
      ["9640", "\u6704\u6705\u6706\u6707\u670C\u670E\u670F\u6711\u6712\u6713\u6716\u6718\u6719\u671A\u671C\u671E\u6720", 5, "\u6727\u6729\u672E\u6730\u6732\u6733\u6736\u6737\u6738\u6739\u673B\u673C\u673E\u673F\u6741\u6744\u6745\u6747\u674A\u674B\u674D\u6752\u6754\u6755\u6757", 4, "\u675D\u6762\u6763\u6764\u6766\u6767\u676B\u676C\u676E\u6771\u6774\u6776"],
      ["9680", "\u6778\u6779\u677A\u677B\u677D\u6780\u6782\u6783\u6785\u6786\u6788\u678A\u678C\u678D\u678E\u678F\u6791\u6792\u6793\u6794\u6796\u6799\u679B\u679F\u67A0\u67A1\u67A4\u67A6\u67A9\u67AC\u67AE\u67B1\u67B2\u67B4\u67B9", 7, "\u67C2\u67C5", 9, "\u67D5\u67D6\u67D7\u67DB\u67DF\u67E1\u67E3\u67E4\u67E6\u67E7\u67E8\u67EA\u67EB\u67ED\u67EE\u67F2\u67F5", 7, "\u67FE\u6801\u6802\u6803\u6804\u6806\u680D\u6810\u6812\u6814\u6815\u6818", 4, "\u681E\u681F\u6820\u6822", 6, "\u682B", 6, "\u6834\u6835\u6836\u683A\u683B\u683F\u6847\u684B\u684D\u684F\u6852\u6856", 5],
      ["9740", "\u685C\u685D\u685E\u685F\u686A\u686C", 7, "\u6875\u6878", 8, "\u6882\u6884\u6887", 7, "\u6890\u6891\u6892\u6894\u6895\u6896\u6898", 9, "\u68A3\u68A4\u68A5\u68A9\u68AA\u68AB\u68AC\u68AE\u68B1\u68B2\u68B4\u68B6\u68B7\u68B8"],
      ["9780", "\u68B9", 6, "\u68C1\u68C3", 5, "\u68CA\u68CC\u68CE\u68CF\u68D0\u68D1\u68D3\u68D4\u68D6\u68D7\u68D9\u68DB", 4, "\u68E1\u68E2\u68E4", 9, "\u68EF\u68F2\u68F3\u68F4\u68F6\u68F7\u68F8\u68FB\u68FD\u68FE\u68FF\u6900\u6902\u6903\u6904\u6906", 4, "\u690C\u690F\u6911\u6913", 11, "\u6921\u6922\u6923\u6925", 7, "\u692E\u692F\u6931\u6932\u6933\u6935\u6936\u6937\u6938\u693A\u693B\u693C\u693E\u6940\u6941\u6943", 16, "\u6955\u6956\u6958\u6959\u695B\u695C\u695F"],
      ["9840", "\u6961\u6962\u6964\u6965\u6967\u6968\u6969\u696A\u696C\u696D\u696F\u6970\u6972", 4, "\u697A\u697B\u697D\u697E\u697F\u6981\u6983\u6985\u698A\u698B\u698C\u698E", 5, "\u6996\u6997\u6999\u699A\u699D", 9, "\u69A9\u69AA\u69AC\u69AE\u69AF\u69B0\u69B2\u69B3\u69B5\u69B6\u69B8\u69B9\u69BA\u69BC\u69BD"],
      ["9880", "\u69BE\u69BF\u69C0\u69C2", 7, "\u69CB\u69CD\u69CF\u69D1\u69D2\u69D3\u69D5", 5, "\u69DC\u69DD\u69DE\u69E1", 11, "\u69EE\u69EF\u69F0\u69F1\u69F3", 9, "\u69FE\u6A00", 9, "\u6A0B", 11, "\u6A19", 5, "\u6A20\u6A22", 5, "\u6A29\u6A2B\u6A2C\u6A2D\u6A2E\u6A30\u6A32\u6A33\u6A34\u6A36", 6, "\u6A3F", 4, "\u6A45\u6A46\u6A48", 7, "\u6A51", 6, "\u6A5A"],
      ["9940", "\u6A5C", 4, "\u6A62\u6A63\u6A64\u6A66", 10, "\u6A72", 6, "\u6A7A\u6A7B\u6A7D\u6A7E\u6A7F\u6A81\u6A82\u6A83\u6A85", 8, "\u6A8F\u6A92", 4, "\u6A98", 7, "\u6AA1", 5],
      ["9980", "\u6AA7\u6AA8\u6AAA\u6AAD", 114, "\u6B25\u6B26\u6B28", 6],
      ["9a40", "\u6B2F\u6B30\u6B31\u6B33\u6B34\u6B35\u6B36\u6B38\u6B3B\u6B3C\u6B3D\u6B3F\u6B40\u6B41\u6B42\u6B44\u6B45\u6B48\u6B4A\u6B4B\u6B4D", 11, "\u6B5A", 7, "\u6B68\u6B69\u6B6B", 13, "\u6B7A\u6B7D\u6B7E\u6B7F\u6B80\u6B85\u6B88"],
      ["9a80", "\u6B8C\u6B8E\u6B8F\u6B90\u6B91\u6B94\u6B95\u6B97\u6B98\u6B99\u6B9C", 4, "\u6BA2", 7, "\u6BAB", 7, "\u6BB6\u6BB8", 6, "\u6BC0\u6BC3\u6BC4\u6BC6", 4, "\u6BCC\u6BCE\u6BD0\u6BD1\u6BD8\u6BDA\u6BDC", 4, "\u6BE2", 7, "\u6BEC\u6BED\u6BEE\u6BF0\u6BF1\u6BF2\u6BF4\u6BF6\u6BF7\u6BF8\u6BFA\u6BFB\u6BFC\u6BFE", 6, "\u6C08", 4, "\u6C0E\u6C12\u6C17\u6C1C\u6C1D\u6C1E\u6C20\u6C23\u6C25\u6C2B\u6C2C\u6C2D\u6C31\u6C33\u6C36\u6C37\u6C39\u6C3A\u6C3B\u6C3C\u6C3E\u6C3F\u6C43\u6C44\u6C45\u6C48\u6C4B", 4, "\u6C51\u6C52\u6C53\u6C56\u6C58"],
      ["9b40", "\u6C59\u6C5A\u6C62\u6C63\u6C65\u6C66\u6C67\u6C6B", 4, "\u6C71\u6C73\u6C75\u6C77\u6C78\u6C7A\u6C7B\u6C7C\u6C7F\u6C80\u6C84\u6C87\u6C8A\u6C8B\u6C8D\u6C8E\u6C91\u6C92\u6C95\u6C96\u6C97\u6C98\u6C9A\u6C9C\u6C9D\u6C9E\u6CA0\u6CA2\u6CA8\u6CAC\u6CAF\u6CB0\u6CB4\u6CB5\u6CB6\u6CB7\u6CBA\u6CC0\u6CC1\u6CC2\u6CC3\u6CC6\u6CC7\u6CC8\u6CCB\u6CCD\u6CCE\u6CCF\u6CD1\u6CD2\u6CD8"],
      ["9b80", "\u6CD9\u6CDA\u6CDC\u6CDD\u6CDF\u6CE4\u6CE6\u6CE7\u6CE9\u6CEC\u6CED\u6CF2\u6CF4\u6CF9\u6CFF\u6D00\u6D02\u6D03\u6D05\u6D06\u6D08\u6D09\u6D0A\u6D0D\u6D0F\u6D10\u6D11\u6D13\u6D14\u6D15\u6D16\u6D18\u6D1C\u6D1D\u6D1F", 5, "\u6D26\u6D28\u6D29\u6D2C\u6D2D\u6D2F\u6D30\u6D34\u6D36\u6D37\u6D38\u6D3A\u6D3F\u6D40\u6D42\u6D44\u6D49\u6D4C\u6D50\u6D55\u6D56\u6D57\u6D58\u6D5B\u6D5D\u6D5F\u6D61\u6D62\u6D64\u6D65\u6D67\u6D68\u6D6B\u6D6C\u6D6D\u6D70\u6D71\u6D72\u6D73\u6D75\u6D76\u6D79\u6D7A\u6D7B\u6D7D", 4, "\u6D83\u6D84\u6D86\u6D87\u6D8A\u6D8B\u6D8D\u6D8F\u6D90\u6D92\u6D96", 4, "\u6D9C\u6DA2\u6DA5\u6DAC\u6DAD\u6DB0\u6DB1\u6DB3\u6DB4\u6DB6\u6DB7\u6DB9", 5, "\u6DC1\u6DC2\u6DC3\u6DC8\u6DC9\u6DCA"],
      ["9c40", "\u6DCD\u6DCE\u6DCF\u6DD0\u6DD2\u6DD3\u6DD4\u6DD5\u6DD7\u6DDA\u6DDB\u6DDC\u6DDF\u6DE2\u6DE3\u6DE5\u6DE7\u6DE8\u6DE9\u6DEA\u6DED\u6DEF\u6DF0\u6DF2\u6DF4\u6DF5\u6DF6\u6DF8\u6DFA\u6DFD", 7, "\u6E06\u6E07\u6E08\u6E09\u6E0B\u6E0F\u6E12\u6E13\u6E15\u6E18\u6E19\u6E1B\u6E1C\u6E1E\u6E1F\u6E22\u6E26\u6E27\u6E28\u6E2A\u6E2C\u6E2E\u6E30\u6E31\u6E33\u6E35"],
      ["9c80", "\u6E36\u6E37\u6E39\u6E3B", 7, "\u6E45", 7, "\u6E4F\u6E50\u6E51\u6E52\u6E55\u6E57\u6E59\u6E5A\u6E5C\u6E5D\u6E5E\u6E60", 10, "\u6E6C\u6E6D\u6E6F", 14, "\u6E80\u6E81\u6E82\u6E84\u6E87\u6E88\u6E8A", 4, "\u6E91", 6, "\u6E99\u6E9A\u6E9B\u6E9D\u6E9E\u6EA0\u6EA1\u6EA3\u6EA4\u6EA6\u6EA8\u6EA9\u6EAB\u6EAC\u6EAD\u6EAE\u6EB0\u6EB3\u6EB5\u6EB8\u6EB9\u6EBC\u6EBE\u6EBF\u6EC0\u6EC3\u6EC4\u6EC5\u6EC6\u6EC8\u6EC9\u6ECA\u6ECC\u6ECD\u6ECE\u6ED0\u6ED2\u6ED6\u6ED8\u6ED9\u6EDB\u6EDC\u6EDD\u6EE3\u6EE7\u6EEA", 5],
      ["9d40", "\u6EF0\u6EF1\u6EF2\u6EF3\u6EF5\u6EF6\u6EF7\u6EF8\u6EFA", 7, "\u6F03\u6F04\u6F05\u6F07\u6F08\u6F0A", 4, "\u6F10\u6F11\u6F12\u6F16", 9, "\u6F21\u6F22\u6F23\u6F25\u6F26\u6F27\u6F28\u6F2C\u6F2E\u6F30\u6F32\u6F34\u6F35\u6F37", 6, "\u6F3F\u6F40\u6F41\u6F42"],
      ["9d80", "\u6F43\u6F44\u6F45\u6F48\u6F49\u6F4A\u6F4C\u6F4E", 9, "\u6F59\u6F5A\u6F5B\u6F5D\u6F5F\u6F60\u6F61\u6F63\u6F64\u6F65\u6F67", 5, "\u6F6F\u6F70\u6F71\u6F73\u6F75\u6F76\u6F77\u6F79\u6F7B\u6F7D", 6, "\u6F85\u6F86\u6F87\u6F8A\u6F8B\u6F8F", 12, "\u6F9D\u6F9E\u6F9F\u6FA0\u6FA2", 4, "\u6FA8", 10, "\u6FB4\u6FB5\u6FB7\u6FB8\u6FBA", 5, "\u6FC1\u6FC3", 5, "\u6FCA", 6, "\u6FD3", 10, "\u6FDF\u6FE2\u6FE3\u6FE4\u6FE5"],
      ["9e40", "\u6FE6", 7, "\u6FF0", 32, "\u7012", 7, "\u701C", 6, "\u7024", 6],
      ["9e80", "\u702B", 9, "\u7036\u7037\u7038\u703A", 17, "\u704D\u704E\u7050", 13, "\u705F", 11, "\u706E\u7071\u7072\u7073\u7074\u7077\u7079\u707A\u707B\u707D\u7081\u7082\u7083\u7084\u7086\u7087\u7088\u708B\u708C\u708D\u708F\u7090\u7091\u7093\u7097\u7098\u709A\u709B\u709E", 12, "\u70B0\u70B2\u70B4\u70B5\u70B6\u70BA\u70BE\u70BF\u70C4\u70C5\u70C6\u70C7\u70C9\u70CB", 12, "\u70DA"],
      ["9f40", "\u70DC\u70DD\u70DE\u70E0\u70E1\u70E2\u70E3\u70E5\u70EA\u70EE\u70F0", 6, "\u70F8\u70FA\u70FB\u70FC\u70FE", 10, "\u710B", 4, "\u7111\u7112\u7114\u7117\u711B", 10, "\u7127", 7, "\u7132\u7133\u7134"],
      ["9f80", "\u7135\u7137", 13, "\u7146\u7147\u7148\u7149\u714B\u714D\u714F", 12, "\u715D\u715F", 4, "\u7165\u7169", 4, "\u716F\u7170\u7171\u7174\u7175\u7176\u7177\u7179\u717B\u717C\u717E", 5, "\u7185", 4, "\u718B\u718C\u718D\u718E\u7190\u7191\u7192\u7193\u7195\u7196\u7197\u719A", 4, "\u71A1", 6, "\u71A9\u71AA\u71AB\u71AD", 5, "\u71B4\u71B6\u71B7\u71B8\u71BA", 8, "\u71C4", 9, "\u71CF", 4],
      ["a040", "\u71D6", 9, "\u71E1\u71E2\u71E3\u71E4\u71E6\u71E8", 5, "\u71EF", 9, "\u71FA", 11, "\u7207", 19],
      ["a080", "\u721B\u721C\u721E", 9, "\u7229\u722B\u722D\u722E\u722F\u7232\u7233\u7234\u723A\u723C\u723E\u7240", 6, "\u7249\u724A\u724B\u724E\u724F\u7250\u7251\u7253\u7254\u7255\u7257\u7258\u725A\u725C\u725E\u7260\u7263\u7264\u7265\u7268\u726A\u726B\u726C\u726D\u7270\u7271\u7273\u7274\u7276\u7277\u7278\u727B\u727C\u727D\u7282\u7283\u7285", 4, "\u728C\u728E\u7290\u7291\u7293", 11, "\u72A0", 11, "\u72AE\u72B1\u72B2\u72B3\u72B5\u72BA", 6, "\u72C5\u72C6\u72C7\u72C9\u72CA\u72CB\u72CC\u72CF\u72D1\u72D3\u72D4\u72D5\u72D6\u72D8\u72DA\u72DB"],
      ["a1a1", "\u3000\u3001\u3002\xB7\u02C9\u02C7\xA8\u3003\u3005\u2014\uFF5E\u2016\u2026\u2018\u2019\u201C\u201D\u3014\u3015\u3008", 7, "\u3016\u3017\u3010\u3011\xB1\xD7\xF7\u2236\u2227\u2228\u2211\u220F\u222A\u2229\u2208\u2237\u221A\u22A5\u2225\u2220\u2312\u2299\u222B\u222E\u2261\u224C\u2248\u223D\u221D\u2260\u226E\u226F\u2264\u2265\u221E\u2235\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFF04\xA4\uFFE0\uFFE1\u2030\xA7\u2116\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u203B\u2192\u2190\u2191\u2193\u3013"],
      ["a2a1", "\u2170", 9],
      ["a2b1", "\u2488", 19, "\u2474", 19, "\u2460", 9],
      ["a2e5", "\u3220", 9],
      ["a2f1", "\u2160", 11],
      ["a3a1", "\uFF01\uFF02\uFF03\uFFE5\uFF05", 88, "\uFFE3"],
      ["a4a1", "\u3041", 82],
      ["a5a1", "\u30A1", 85],
      ["a6a1", "\u0391", 16, "\u03A3", 6],
      ["a6c1", "\u03B1", 16, "\u03C3", 6],
      ["a6e0", "\uFE35\uFE36\uFE39\uFE3A\uFE3F\uFE40\uFE3D\uFE3E\uFE41\uFE42\uFE43\uFE44"],
      ["a6ee", "\uFE3B\uFE3C\uFE37\uFE38\uFE31"],
      ["a6f4", "\uFE33\uFE34"],
      ["a7a1", "\u0410", 5, "\u0401\u0416", 25],
      ["a7d1", "\u0430", 5, "\u0451\u0436", 25],
      ["a840", "\u02CA\u02CB\u02D9\u2013\u2015\u2025\u2035\u2105\u2109\u2196\u2197\u2198\u2199\u2215\u221F\u2223\u2252\u2266\u2267\u22BF\u2550", 35, "\u2581", 6],
      ["a880", "\u2588", 7, "\u2593\u2594\u2595\u25BC\u25BD\u25E2\u25E3\u25E4\u25E5\u2609\u2295\u3012\u301D\u301E"],
      ["a8a1", "\u0101\xE1\u01CE\xE0\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA\u01DC\xFC\xEA\u0251"],
      ["a8bd", "\u0144\u0148"],
      ["a8c0", "\u0261"],
      ["a8c5", "\u3105", 36],
      ["a940", "\u3021", 8, "\u32A3\u338E\u338F\u339C\u339D\u339E\u33A1\u33C4\u33CE\u33D1\u33D2\u33D5\uFE30\uFFE2\uFFE4"],
      ["a959", "\u2121\u3231"],
      ["a95c", "\u2010"],
      ["a960", "\u30FC\u309B\u309C\u30FD\u30FE\u3006\u309D\u309E\uFE49", 9, "\uFE54\uFE55\uFE56\uFE57\uFE59", 8],
      ["a980", "\uFE62", 4, "\uFE68\uFE69\uFE6A\uFE6B"],
      ["a996", "\u3007"],
      ["a9a4", "\u2500", 75],
      ["aa40", "\u72DC\u72DD\u72DF\u72E2", 5, "\u72EA\u72EB\u72F5\u72F6\u72F9\u72FD\u72FE\u72FF\u7300\u7302\u7304", 5, "\u730B\u730C\u730D\u730F\u7310\u7311\u7312\u7314\u7318\u7319\u731A\u731F\u7320\u7323\u7324\u7326\u7327\u7328\u732D\u732F\u7330\u7332\u7333\u7335\u7336\u733A\u733B\u733C\u733D\u7340", 8],
      ["aa80", "\u7349\u734A\u734B\u734C\u734E\u734F\u7351\u7353\u7354\u7355\u7356\u7358", 7, "\u7361", 10, "\u736E\u7370\u7371"],
      ["ab40", "\u7372", 11, "\u737F", 4, "\u7385\u7386\u7388\u738A\u738C\u738D\u738F\u7390\u7392\u7393\u7394\u7395\u7397\u7398\u7399\u739A\u739C\u739D\u739E\u73A0\u73A1\u73A3", 5, "\u73AA\u73AC\u73AD\u73B1\u73B4\u73B5\u73B6\u73B8\u73B9\u73BC\u73BD\u73BE\u73BF\u73C1\u73C3", 4],
      ["ab80", "\u73CB\u73CC\u73CE\u73D2", 6, "\u73DA\u73DB\u73DC\u73DD\u73DF\u73E1\u73E2\u73E3\u73E4\u73E6\u73E8\u73EA\u73EB\u73EC\u73EE\u73EF\u73F0\u73F1\u73F3", 4],
      ["ac40", "\u73F8", 10, "\u7404\u7407\u7408\u740B\u740C\u740D\u740E\u7411", 8, "\u741C", 5, "\u7423\u7424\u7427\u7429\u742B\u742D\u742F\u7431\u7432\u7437", 4, "\u743D\u743E\u743F\u7440\u7442", 11],
      ["ac80", "\u744E", 6, "\u7456\u7458\u745D\u7460", 12, "\u746E\u746F\u7471", 4, "\u7478\u7479\u747A"],
      ["ad40", "\u747B\u747C\u747D\u747F\u7482\u7484\u7485\u7486\u7488\u7489\u748A\u748C\u748D\u748F\u7491", 10, "\u749D\u749F", 7, "\u74AA", 15, "\u74BB", 12],
      ["ad80", "\u74C8", 9, "\u74D3", 8, "\u74DD\u74DF\u74E1\u74E5\u74E7", 6, "\u74F0\u74F1\u74F2"],
      ["ae40", "\u74F3\u74F5\u74F8", 6, "\u7500\u7501\u7502\u7503\u7505", 7, "\u750E\u7510\u7512\u7514\u7515\u7516\u7517\u751B\u751D\u751E\u7520", 4, "\u7526\u7527\u752A\u752E\u7534\u7536\u7539\u753C\u753D\u753F\u7541\u7542\u7543\u7544\u7546\u7547\u7549\u754A\u754D\u7550\u7551\u7552\u7553\u7555\u7556\u7557\u7558"],
      ["ae80", "\u755D", 7, "\u7567\u7568\u7569\u756B", 6, "\u7573\u7575\u7576\u7577\u757A", 4, "\u7580\u7581\u7582\u7584\u7585\u7587"],
      ["af40", "\u7588\u7589\u758A\u758C\u758D\u758E\u7590\u7593\u7595\u7598\u759B\u759C\u759E\u75A2\u75A6", 4, "\u75AD\u75B6\u75B7\u75BA\u75BB\u75BF\u75C0\u75C1\u75C6\u75CB\u75CC\u75CE\u75CF\u75D0\u75D1\u75D3\u75D7\u75D9\u75DA\u75DC\u75DD\u75DF\u75E0\u75E1\u75E5\u75E9\u75EC\u75ED\u75EE\u75EF\u75F2\u75F3\u75F5\u75F6\u75F7\u75F8\u75FA\u75FB\u75FD\u75FE\u7602\u7604\u7606\u7607"],
      ["af80", "\u7608\u7609\u760B\u760D\u760E\u760F\u7611\u7612\u7613\u7614\u7616\u761A\u761C\u761D\u761E\u7621\u7623\u7627\u7628\u762C\u762E\u762F\u7631\u7632\u7636\u7637\u7639\u763A\u763B\u763D\u7641\u7642\u7644"],
      ["b040", "\u7645", 6, "\u764E", 5, "\u7655\u7657", 4, "\u765D\u765F\u7660\u7661\u7662\u7664", 6, "\u766C\u766D\u766E\u7670", 7, "\u7679\u767A\u767C\u767F\u7680\u7681\u7683\u7685\u7689\u768A\u768C\u768D\u768F\u7690\u7692\u7694\u7695\u7697\u7698\u769A\u769B"],
      ["b080", "\u769C", 7, "\u76A5", 8, "\u76AF\u76B0\u76B3\u76B5", 9, "\u76C0\u76C1\u76C3\u554A\u963F\u57C3\u6328\u54CE\u5509\u54C0\u7691\u764C\u853C\u77EE\u827E\u788D\u7231\u9698\u978D\u6C28\u5B89\u4FFA\u6309\u6697\u5CB8\u80FA\u6848\u80AE\u6602\u76CE\u51F9\u6556\u71AC\u7FF1\u8884\u50B2\u5965\u61CA\u6FB3\u82AD\u634C\u6252\u53ED\u5427\u7B06\u516B\u75A4\u5DF4\u62D4\u8DCB\u9776\u628A\u8019\u575D\u9738\u7F62\u7238\u767D\u67CF\u767E\u6446\u4F70\u8D25\u62DC\u7A17\u6591\u73ED\u642C\u6273\u822C\u9881\u677F\u7248\u626E\u62CC\u4F34\u74E3\u534A\u529E\u7ECA\u90A6\u5E2E\u6886\u699C\u8180\u7ED1\u68D2\u78C5\u868C\u9551\u508D\u8C24\u82DE\u80DE\u5305\u8912\u5265"],
      ["b140", "\u76C4\u76C7\u76C9\u76CB\u76CC\u76D3\u76D5\u76D9\u76DA\u76DC\u76DD\u76DE\u76E0", 4, "\u76E6", 7, "\u76F0\u76F3\u76F5\u76F6\u76F7\u76FA\u76FB\u76FD\u76FF\u7700\u7702\u7703\u7705\u7706\u770A\u770C\u770E", 10, "\u771B\u771C\u771D\u771E\u7721\u7723\u7724\u7725\u7727\u772A\u772B"],
      ["b180", "\u772C\u772E\u7730", 4, "\u7739\u773B\u773D\u773E\u773F\u7742\u7744\u7745\u7746\u7748", 7, "\u7752", 7, "\u775C\u8584\u96F9\u4FDD\u5821\u9971\u5B9D\u62B1\u62A5\u66B4\u8C79\u9C8D\u7206\u676F\u7891\u60B2\u5351\u5317\u8F88\u80CC\u8D1D\u94A1\u500D\u72C8\u5907\u60EB\u7119\u88AB\u5954\u82EF\u672C\u7B28\u5D29\u7EF7\u752D\u6CF5\u8E66\u8FF8\u903C\u9F3B\u6BD4\u9119\u7B14\u5F7C\u78A7\u84D6\u853D\u6BD5\u6BD9\u6BD6\u5E01\u5E87\u75F9\u95ED\u655D\u5F0A\u5FC5\u8F9F\u58C1\u81C2\u907F\u965B\u97AD\u8FB9\u7F16\u8D2C\u6241\u4FBF\u53D8\u535E\u8FA8\u8FA9\u8FAB\u904D\u6807\u5F6A\u8198\u8868\u9CD6\u618B\u522B\u762A\u5F6C\u658C\u6FD2\u6EE8\u5BBE\u6448\u5175\u51B0\u67C4\u4E19\u79C9\u997C\u70B3"],
      ["b240", "\u775D\u775E\u775F\u7760\u7764\u7767\u7769\u776A\u776D", 11, "\u777A\u777B\u777C\u7781\u7782\u7783\u7786", 5, "\u778F\u7790\u7793", 11, "\u77A1\u77A3\u77A4\u77A6\u77A8\u77AB\u77AD\u77AE\u77AF\u77B1\u77B2\u77B4\u77B6", 4],
      ["b280", "\u77BC\u77BE\u77C0", 12, "\u77CE", 8, "\u77D8\u77D9\u77DA\u77DD", 4, "\u77E4\u75C5\u5E76\u73BB\u83E0\u64AD\u62E8\u94B5\u6CE2\u535A\u52C3\u640F\u94C2\u7B94\u4F2F\u5E1B\u8236\u8116\u818A\u6E24\u6CCA\u9A73\u6355\u535C\u54FA\u8865\u57E0\u4E0D\u5E03\u6B65\u7C3F\u90E8\u6016\u64E6\u731C\u88C1\u6750\u624D\u8D22\u776C\u8E29\u91C7\u5F69\u83DC\u8521\u9910\u53C2\u8695\u6B8B\u60ED\u60E8\u707F\u82CD\u8231\u4ED3\u6CA7\u85CF\u64CD\u7CD9\u69FD\u66F9\u8349\u5395\u7B56\u4FA7\u518C\u6D4B\u5C42\u8E6D\u63D2\u53C9\u832C\u8336\u67E5\u78B4\u643D\u5BDF\u5C94\u5DEE\u8BE7\u62C6\u67F4\u8C7A\u6400\u63BA\u8749\u998B\u8C17\u7F20\u94F2\u4EA7\u9610\u98A4\u660C\u7316"],
      ["b340", "\u77E6\u77E8\u77EA\u77EF\u77F0\u77F1\u77F2\u77F4\u77F5\u77F7\u77F9\u77FA\u77FB\u77FC\u7803", 5, "\u780A\u780B\u780E\u780F\u7810\u7813\u7815\u7819\u781B\u781E\u7820\u7821\u7822\u7824\u7828\u782A\u782B\u782E\u782F\u7831\u7832\u7833\u7835\u7836\u783D\u783F\u7841\u7842\u7843\u7844\u7846\u7848\u7849\u784A\u784B\u784D\u784F\u7851\u7853\u7854\u7858\u7859\u785A"],
      ["b380", "\u785B\u785C\u785E", 11, "\u786F", 7, "\u7878\u7879\u787A\u787B\u787D", 6, "\u573A\u5C1D\u5E38\u957F\u507F\u80A0\u5382\u655E\u7545\u5531\u5021\u8D85\u6284\u949E\u671D\u5632\u6F6E\u5DE2\u5435\u7092\u8F66\u626F\u64A4\u63A3\u5F7B\u6F88\u90F4\u81E3\u8FB0\u5C18\u6668\u5FF1\u6C89\u9648\u8D81\u886C\u6491\u79F0\u57CE\u6A59\u6210\u5448\u4E58\u7A0B\u60E9\u6F84\u8BDA\u627F\u901E\u9A8B\u79E4\u5403\u75F4\u6301\u5319\u6C60\u8FDF\u5F1B\u9A70\u803B\u9F7F\u4F88\u5C3A\u8D64\u7FC5\u65A5\u70BD\u5145\u51B2\u866B\u5D07\u5BA0\u62BD\u916C\u7574\u8E0C\u7A20\u6101\u7B79\u4EC7\u7EF8\u7785\u4E11\u81ED\u521D\u51FA\u6A71\u53A8\u8E87\u9504\u96CF\u6EC1\u9664\u695A"],
      ["b440", "\u7884\u7885\u7886\u7888\u788A\u788B\u788F\u7890\u7892\u7894\u7895\u7896\u7899\u789D\u789E\u78A0\u78A2\u78A4\u78A6\u78A8", 7, "\u78B5\u78B6\u78B7\u78B8\u78BA\u78BB\u78BC\u78BD\u78BF\u78C0\u78C2\u78C3\u78C4\u78C6\u78C7\u78C8\u78CC\u78CD\u78CE\u78CF\u78D1\u78D2\u78D3\u78D6\u78D7\u78D8\u78DA", 9],
      ["b480", "\u78E4\u78E5\u78E6\u78E7\u78E9\u78EA\u78EB\u78ED", 4, "\u78F3\u78F5\u78F6\u78F8\u78F9\u78FB", 5, "\u7902\u7903\u7904\u7906", 6, "\u7840\u50A8\u77D7\u6410\u89E6\u5904\u63E3\u5DDD\u7A7F\u693D\u4F20\u8239\u5598\u4E32\u75AE\u7A97\u5E62\u5E8A\u95EF\u521B\u5439\u708A\u6376\u9524\u5782\u6625\u693F\u9187\u5507\u6DF3\u7EAF\u8822\u6233\u7EF0\u75B5\u8328\u78C1\u96CC\u8F9E\u6148\u74F7\u8BCD\u6B64\u523A\u8D50\u6B21\u806A\u8471\u56F1\u5306\u4ECE\u4E1B\u51D1\u7C97\u918B\u7C07\u4FC3\u8E7F\u7BE1\u7A9C\u6467\u5D14\u50AC\u8106\u7601\u7CB9\u6DEC\u7FE0\u6751\u5B58\u5BF8\u78CB\u64AE\u6413\u63AA\u632B\u9519\u642D\u8FBE\u7B54\u7629\u6253\u5927\u5446\u6B79\u50A3\u6234\u5E26\u6B86\u4EE3\u8D37\u888B\u5F85\u902E"],
      ["b540", "\u790D", 5, "\u7914", 9, "\u791F", 4, "\u7925", 14, "\u7935", 4, "\u793D\u793F\u7942\u7943\u7944\u7945\u7947\u794A", 8, "\u7954\u7955\u7958\u7959\u7961\u7963"],
      ["b580", "\u7964\u7966\u7969\u796A\u796B\u796C\u796E\u7970", 6, "\u7979\u797B", 4, "\u7982\u7983\u7986\u7987\u7988\u7989\u798B\u798C\u798D\u798E\u7990\u7991\u7992\u6020\u803D\u62C5\u4E39\u5355\u90F8\u63B8\u80C6\u65E6\u6C2E\u4F46\u60EE\u6DE1\u8BDE\u5F39\u86CB\u5F53\u6321\u515A\u8361\u6863\u5200\u6363\u8E48\u5012\u5C9B\u7977\u5BFC\u5230\u7A3B\u60BC\u9053\u76D7\u5FB7\u5F97\u7684\u8E6C\u706F\u767B\u7B49\u77AA\u51F3\u9093\u5824\u4F4E\u6EF4\u8FEA\u654C\u7B1B\u72C4\u6DA4\u7FDF\u5AE1\u62B5\u5E95\u5730\u8482\u7B2C\u5E1D\u5F1F\u9012\u7F14\u98A0\u6382\u6EC7\u7898\u70B9\u5178\u975B\u57AB\u7535\u4F43\u7538\u5E97\u60E6\u5960\u6DC0\u6BBF\u7889\u53FC\u96D5\u51CB\u5201\u6389\u540A\u9493\u8C03\u8DCC\u7239\u789F\u8776\u8FED\u8C0D\u53E0"],
      ["b640", "\u7993", 6, "\u799B", 11, "\u79A8", 10, "\u79B4", 4, "\u79BC\u79BF\u79C2\u79C4\u79C5\u79C7\u79C8\u79CA\u79CC\u79CE\u79CF\u79D0\u79D3\u79D4\u79D6\u79D7\u79D9", 5, "\u79E0\u79E1\u79E2\u79E5\u79E8\u79EA"],
      ["b680", "\u79EC\u79EE\u79F1", 6, "\u79F9\u79FA\u79FC\u79FE\u79FF\u7A01\u7A04\u7A05\u7A07\u7A08\u7A09\u7A0A\u7A0C\u7A0F", 4, "\u7A15\u7A16\u7A18\u7A19\u7A1B\u7A1C\u4E01\u76EF\u53EE\u9489\u9876\u9F0E\u952D\u5B9A\u8BA2\u4E22\u4E1C\u51AC\u8463\u61C2\u52A8\u680B\u4F97\u606B\u51BB\u6D1E\u515C\u6296\u6597\u9661\u8C46\u9017\u75D8\u90FD\u7763\u6BD2\u728A\u72EC\u8BFB\u5835\u7779\u8D4C\u675C\u9540\u809A\u5EA6\u6E21\u5992\u7AEF\u77ED\u953B\u6BB5\u65AD\u7F0E\u5806\u5151\u961F\u5BF9\u58A9\u5428\u8E72\u6566\u987F\u56E4\u949D\u76FE\u9041\u6387\u54C6\u591A\u593A\u579B\u8EB2\u6735\u8DFA\u8235\u5241\u60F0\u5815\u86FE\u5CE8\u9E45\u4FC4\u989D\u8BB9\u5A25\u6076\u5384\u627C\u904F\u9102\u997F\u6069\u800C\u513F\u8033\u5C14\u9975\u6D31\u4E8C"],
      ["b740", "\u7A1D\u7A1F\u7A21\u7A22\u7A24", 14, "\u7A34\u7A35\u7A36\u7A38\u7A3A\u7A3E\u7A40", 5, "\u7A47", 9, "\u7A52", 4, "\u7A58", 16],
      ["b780", "\u7A69", 6, "\u7A71\u7A72\u7A73\u7A75\u7A7B\u7A7C\u7A7D\u7A7E\u7A82\u7A85\u7A87\u7A89\u7A8A\u7A8B\u7A8C\u7A8E\u7A8F\u7A90\u7A93\u7A94\u7A99\u7A9A\u7A9B\u7A9E\u7AA1\u7AA2\u8D30\u53D1\u7F5A\u7B4F\u4F10\u4E4F\u9600\u6CD5\u73D0\u85E9\u5E06\u756A\u7FFB\u6A0A\u77FE\u9492\u7E41\u51E1\u70E6\u53CD\u8FD4\u8303\u8D29\u72AF\u996D\u6CDB\u574A\u82B3\u65B9\u80AA\u623F\u9632\u59A8\u4EFF\u8BBF\u7EBA\u653E\u83F2\u975E\u5561\u98DE\u80A5\u532A\u8BFD\u5420\u80BA\u5E9F\u6CB8\u8D39\u82AC\u915A\u5429\u6C1B\u5206\u7EB7\u575F\u711A\u6C7E\u7C89\u594B\u4EFD\u5FFF\u6124\u7CAA\u4E30\u5C01\u67AB\u8702\u5CF0\u950B\u98CE\u75AF\u70FD\u9022\u51AF\u7F1D\u8BBD\u5949\u51E4\u4F5B\u5426\u592B\u6577\u80A4\u5B75\u6276\u62C2\u8F90\u5E45\u6C1F\u7B26\u4F0F\u4FD8\u670D"],
      ["b840", "\u7AA3\u7AA4\u7AA7\u7AA9\u7AAA\u7AAB\u7AAE", 4, "\u7AB4", 10, "\u7AC0", 10, "\u7ACC", 9, "\u7AD7\u7AD8\u7ADA\u7ADB\u7ADC\u7ADD\u7AE1\u7AE2\u7AE4\u7AE7", 5, "\u7AEE\u7AF0\u7AF1\u7AF2\u7AF3"],
      ["b880", "\u7AF4", 4, "\u7AFB\u7AFC\u7AFE\u7B00\u7B01\u7B02\u7B05\u7B07\u7B09\u7B0C\u7B0D\u7B0E\u7B10\u7B12\u7B13\u7B16\u7B17\u7B18\u7B1A\u7B1C\u7B1D\u7B1F\u7B21\u7B22\u7B23\u7B27\u7B29\u7B2D\u6D6E\u6DAA\u798F\u88B1\u5F17\u752B\u629A\u8F85\u4FEF\u91DC\u65A7\u812F\u8151\u5E9C\u8150\u8D74\u526F\u8986\u8D4B\u590D\u5085\u4ED8\u961C\u7236\u8179\u8D1F\u5BCC\u8BA3\u9644\u5987\u7F1A\u5490\u5676\u560E\u8BE5\u6539\u6982\u9499\u76D6\u6E89\u5E72\u7518\u6746\u67D1\u7AFF\u809D\u8D76\u611F\u79C6\u6562\u8D63\u5188\u521A\u94A2\u7F38\u809B\u7EB2\u5C97\u6E2F\u6760\u7BD9\u768B\u9AD8\u818F\u7F94\u7CD5\u641E\u9550\u7A3F\u544A\u54E5\u6B4C\u6401\u6208\u9E3D\u80F3\u7599\u5272\u9769\u845B\u683C\u86E4\u9601\u9694\u94EC\u4E2A\u5404\u7ED9\u6839\u8DDF\u8015\u66F4\u5E9A\u7FB9"],
      ["b940", "\u7B2F\u7B30\u7B32\u7B34\u7B35\u7B36\u7B37\u7B39\u7B3B\u7B3D\u7B3F", 5, "\u7B46\u7B48\u7B4A\u7B4D\u7B4E\u7B53\u7B55\u7B57\u7B59\u7B5C\u7B5E\u7B5F\u7B61\u7B63", 10, "\u7B6F\u7B70\u7B73\u7B74\u7B76\u7B78\u7B7A\u7B7C\u7B7D\u7B7F\u7B81\u7B82\u7B83\u7B84\u7B86", 6, "\u7B8E\u7B8F"],
      ["b980", "\u7B91\u7B92\u7B93\u7B96\u7B98\u7B99\u7B9A\u7B9B\u7B9E\u7B9F\u7BA0\u7BA3\u7BA4\u7BA5\u7BAE\u7BAF\u7BB0\u7BB2\u7BB3\u7BB5\u7BB6\u7BB7\u7BB9", 7, "\u7BC2\u7BC3\u7BC4\u57C2\u803F\u6897\u5DE5\u653B\u529F\u606D\u9F9A\u4F9B\u8EAC\u516C\u5BAB\u5F13\u5DE9\u6C5E\u62F1\u8D21\u5171\u94A9\u52FE\u6C9F\u82DF\u72D7\u57A2\u6784\u8D2D\u591F\u8F9C\u83C7\u5495\u7B8D\u4F30\u6CBD\u5B64\u59D1\u9F13\u53E4\u86CA\u9AA8\u8C37\u80A1\u6545\u987E\u56FA\u96C7\u522E\u74DC\u5250\u5BE1\u6302\u8902\u4E56\u62D0\u602A\u68FA\u5173\u5B98\u51A0\u89C2\u7BA1\u9986\u7F50\u60EF\u704C\u8D2F\u5149\u5E7F\u901B\u7470\u89C4\u572D\u7845\u5F52\u9F9F\u95FA\u8F68\u9B3C\u8BE1\u7678\u6842\u67DC\u8DEA\u8D35\u523D\u8F8A\u6EDA\u68CD\u9505\u90ED\u56FD\u679C\u88F9\u8FC7\u54C8"],
      ["ba40", "\u7BC5\u7BC8\u7BC9\u7BCA\u7BCB\u7BCD\u7BCE\u7BCF\u7BD0\u7BD2\u7BD4", 4, "\u7BDB\u7BDC\u7BDE\u7BDF\u7BE0\u7BE2\u7BE3\u7BE4\u7BE7\u7BE8\u7BE9\u7BEB\u7BEC\u7BED\u7BEF\u7BF0\u7BF2", 4, "\u7BF8\u7BF9\u7BFA\u7BFB\u7BFD\u7BFF", 7, "\u7C08\u7C09\u7C0A\u7C0D\u7C0E\u7C10", 5, "\u7C17\u7C18\u7C19"],
      ["ba80", "\u7C1A", 4, "\u7C20", 5, "\u7C28\u7C29\u7C2B", 12, "\u7C39", 5, "\u7C42\u9AB8\u5B69\u6D77\u6C26\u4EA5\u5BB3\u9A87\u9163\u61A8\u90AF\u97E9\u542B\u6DB5\u5BD2\u51FD\u558A\u7F55\u7FF0\u64BC\u634D\u65F1\u61BE\u608D\u710A\u6C57\u6C49\u592F\u676D\u822A\u58D5\u568E\u8C6A\u6BEB\u90DD\u597D\u8017\u53F7\u6D69\u5475\u559D\u8377\u83CF\u6838\u79BE\u548C\u4F55\u5408\u76D2\u8C89\u9602\u6CB3\u6DB8\u8D6B\u8910\u9E64\u8D3A\u563F\u9ED1\u75D5\u5F88\u72E0\u6068\u54FC\u4EA8\u6A2A\u8861\u6052\u8F70\u54C4\u70D8\u8679\u9E3F\u6D2A\u5B8F\u5F18\u7EA2\u5589\u4FAF\u7334\u543C\u539A\u5019\u540E\u547C\u4E4E\u5FFD\u745A\u58F6\u846B\u80E1\u8774\u72D0\u7CCA\u6E56"],
      ["bb40", "\u7C43", 9, "\u7C4E", 36, "\u7C75", 5, "\u7C7E", 9],
      ["bb80", "\u7C88\u7C8A", 6, "\u7C93\u7C94\u7C96\u7C99\u7C9A\u7C9B\u7CA0\u7CA1\u7CA3\u7CA6\u7CA7\u7CA8\u7CA9\u7CAB\u7CAC\u7CAD\u7CAF\u7CB0\u7CB4", 4, "\u7CBA\u7CBB\u5F27\u864E\u552C\u62A4\u4E92\u6CAA\u6237\u82B1\u54D7\u534E\u733E\u6ED1\u753B\u5212\u5316\u8BDD\u69D0\u5F8A\u6000\u6DEE\u574F\u6B22\u73AF\u6853\u8FD8\u7F13\u6362\u60A3\u5524\u75EA\u8C62\u7115\u6DA3\u5BA6\u5E7B\u8352\u614C\u9EC4\u78FA\u8757\u7C27\u7687\u51F0\u60F6\u714C\u6643\u5E4C\u604D\u8C0E\u7070\u6325\u8F89\u5FBD\u6062\u86D4\u56DE\u6BC1\u6094\u6167\u5349\u60E0\u6666\u8D3F\u79FD\u4F1A\u70E9\u6C47\u8BB3\u8BF2\u7ED8\u8364\u660F\u5A5A\u9B42\u6D51\u6DF7\u8C41\u6D3B\u4F19\u706B\u83B7\u6216\u60D1\u970D\u8D27\u7978\u51FB\u573E\u57FA\u673A\u7578\u7A3D\u79EF\u7B95"],
      ["bc40", "\u7CBF\u7CC0\u7CC2\u7CC3\u7CC4\u7CC6\u7CC9\u7CCB\u7CCE", 6, "\u7CD8\u7CDA\u7CDB\u7CDD\u7CDE\u7CE1", 6, "\u7CE9", 5, "\u7CF0", 7, "\u7CF9\u7CFA\u7CFC", 13, "\u7D0B", 5],
      ["bc80", "\u7D11", 14, "\u7D21\u7D23\u7D24\u7D25\u7D26\u7D28\u7D29\u7D2A\u7D2C\u7D2D\u7D2E\u7D30", 6, "\u808C\u9965\u8FF9\u6FC0\u8BA5\u9E21\u59EC\u7EE9\u7F09\u5409\u6781\u68D8\u8F91\u7C4D\u96C6\u53CA\u6025\u75BE\u6C72\u5373\u5AC9\u7EA7\u6324\u51E0\u810A\u5DF1\u84DF\u6280\u5180\u5B63\u4F0E\u796D\u5242\u60B8\u6D4E\u5BC4\u5BC2\u8BA1\u8BB0\u65E2\u5FCC\u9645\u5993\u7EE7\u7EAA\u5609\u67B7\u5939\u4F73\u5BB6\u52A0\u835A\u988A\u8D3E\u7532\u94BE\u5047\u7A3C\u4EF7\u67B6\u9A7E\u5AC1\u6B7C\u76D1\u575A\u5C16\u7B3A\u95F4\u714E\u517C\u80A9\u8270\u5978\u7F04\u8327\u68C0\u67EC\u78B1\u7877\u62E3\u6361\u7B80\u4FED\u526A\u51CF\u8350\u69DB\u9274\u8DF5\u8D31\u89C1\u952E\u7BAD\u4EF6"],
      ["bd40", "\u7D37", 54, "\u7D6F", 7],
      ["bd80", "\u7D78", 32, "\u5065\u8230\u5251\u996F\u6E10\u6E85\u6DA7\u5EFA\u50F5\u59DC\u5C06\u6D46\u6C5F\u7586\u848B\u6868\u5956\u8BB2\u5320\u9171\u964D\u8549\u6912\u7901\u7126\u80F6\u4EA4\u90CA\u6D47\u9A84\u5A07\u56BC\u6405\u94F0\u77EB\u4FA5\u811A\u72E1\u89D2\u997A\u7F34\u7EDE\u527F\u6559\u9175\u8F7F\u8F83\u53EB\u7A96\u63ED\u63A5\u7686\u79F8\u8857\u9636\u622A\u52AB\u8282\u6854\u6770\u6377\u776B\u7AED\u6D01\u7ED3\u89E3\u59D0\u6212\u85C9\u82A5\u754C\u501F\u4ECB\u75A5\u8BEB\u5C4A\u5DFE\u7B4B\u65A4\u91D1\u4ECA\u6D25\u895F\u7D27\u9526\u4EC5\u8C28\u8FDB\u9773\u664B\u7981\u8FD1\u70EC\u6D78"],
      ["be40", "\u7D99", 12, "\u7DA7", 6, "\u7DAF", 42],
      ["be80", "\u7DDA", 32, "\u5C3D\u52B2\u8346\u5162\u830E\u775B\u6676\u9CB8\u4EAC\u60CA\u7CBE\u7CB3\u7ECF\u4E95\u8B66\u666F\u9888\u9759\u5883\u656C\u955C\u5F84\u75C9\u9756\u7ADF\u7ADE\u51C0\u70AF\u7A98\u63EA\u7A76\u7EA0\u7396\u97ED\u4E45\u7078\u4E5D\u9152\u53A9\u6551\u65E7\u81FC\u8205\u548E\u5C31\u759A\u97A0\u62D8\u72D9\u75BD\u5C45\u9A79\u83CA\u5C40\u5480\u77E9\u4E3E\u6CAE\u805A\u62D2\u636E\u5DE8\u5177\u8DDD\u8E1E\u952F\u4FF1\u53E5\u60E7\u70AC\u5267\u6350\u9E43\u5A1F\u5026\u7737\u5377\u7EE2\u6485\u652B\u6289\u6398\u5014\u7235\u89C9\u51B3\u8BC0\u7EDD\u5747\u83CC\u94A7\u519B\u541B\u5CFB"],
      ["bf40", "\u7DFB", 62],
      ["bf80", "\u7E3A\u7E3C", 4, "\u7E42", 4, "\u7E48", 21, "\u4FCA\u7AE3\u6D5A\u90E1\u9A8F\u5580\u5496\u5361\u54AF\u5F00\u63E9\u6977\u51EF\u6168\u520A\u582A\u52D8\u574E\u780D\u770B\u5EB7\u6177\u7CE0\u625B\u6297\u4EA2\u7095\u8003\u62F7\u70E4\u9760\u5777\u82DB\u67EF\u68F5\u78D5\u9897\u79D1\u58F3\u54B3\u53EF\u6E34\u514B\u523B\u5BA2\u8BFE\u80AF\u5543\u57A6\u6073\u5751\u542D\u7A7A\u6050\u5B54\u63A7\u62A0\u53E3\u6263\u5BC7\u67AF\u54ED\u7A9F\u82E6\u9177\u5E93\u88E4\u5938\u57AE\u630E\u8DE8\u80EF\u5757\u7B77\u4FA9\u5FEB\u5BBD\u6B3E\u5321\u7B50\u72C2\u6846\u77FF\u7736\u65F7\u51B5\u4E8F\u76D4\u5CBF\u7AA5\u8475\u594E\u9B41\u5080"],
      ["c040", "\u7E5E", 35, "\u7E83", 23, "\u7E9C\u7E9D\u7E9E"],
      ["c080", "\u7EAE\u7EB4\u7EBB\u7EBC\u7ED6\u7EE4\u7EEC\u7EF9\u7F0A\u7F10\u7F1E\u7F37\u7F39\u7F3B", 6, "\u7F43\u7F46", 9, "\u7F52\u7F53\u9988\u6127\u6E83\u5764\u6606\u6346\u56F0\u62EC\u6269\u5ED3\u9614\u5783\u62C9\u5587\u8721\u814A\u8FA3\u5566\u83B1\u6765\u8D56\u84DD\u5A6A\u680F\u62E6\u7BEE\u9611\u5170\u6F9C\u8C30\u63FD\u89C8\u61D2\u7F06\u70C2\u6EE5\u7405\u6994\u72FC\u5ECA\u90CE\u6717\u6D6A\u635E\u52B3\u7262\u8001\u4F6C\u59E5\u916A\u70D9\u6D9D\u52D2\u4E50\u96F7\u956D\u857E\u78CA\u7D2F\u5121\u5792\u64C2\u808B\u7C7B\u6CEA\u68F1\u695E\u51B7\u5398\u68A8\u7281\u9ECE\u7BF1\u72F8\u79BB\u6F13\u7406\u674E\u91CC\u9CA4\u793C\u8389\u8354\u540F\u6817\u4E3D\u5389\u52B1\u783E\u5386\u5229\u5088\u4F8B\u4FD0"],
      ["c140", "\u7F56\u7F59\u7F5B\u7F5C\u7F5D\u7F5E\u7F60\u7F63", 4, "\u7F6B\u7F6C\u7F6D\u7F6F\u7F70\u7F73\u7F75\u7F76\u7F77\u7F78\u7F7A\u7F7B\u7F7C\u7F7D\u7F7F\u7F80\u7F82", 7, "\u7F8B\u7F8D\u7F8F", 4, "\u7F95", 4, "\u7F9B\u7F9C\u7FA0\u7FA2\u7FA3\u7FA5\u7FA6\u7FA8", 6, "\u7FB1"],
      ["c180", "\u7FB3", 4, "\u7FBA\u7FBB\u7FBE\u7FC0\u7FC2\u7FC3\u7FC4\u7FC6\u7FC7\u7FC8\u7FC9\u7FCB\u7FCD\u7FCF", 4, "\u7FD6\u7FD7\u7FD9", 5, "\u7FE2\u7FE3\u75E2\u7ACB\u7C92\u6CA5\u96B6\u529B\u7483\u54E9\u4FE9\u8054\u83B2\u8FDE\u9570\u5EC9\u601C\u6D9F\u5E18\u655B\u8138\u94FE\u604B\u70BC\u7EC3\u7CAE\u51C9\u6881\u7CB1\u826F\u4E24\u8F86\u91CF\u667E\u4EAE\u8C05\u64A9\u804A\u50DA\u7597\u71CE\u5BE5\u8FBD\u6F66\u4E86\u6482\u9563\u5ED6\u6599\u5217\u88C2\u70C8\u52A3\u730E\u7433\u6797\u78F7\u9716\u4E34\u90BB\u9CDE\u6DCB\u51DB\u8D41\u541D\u62CE\u73B2\u83F1\u96F6\u9F84\u94C3\u4F36\u7F9A\u51CC\u7075\u9675\u5CAD\u9886\u53E6\u4EE4\u6E9C\u7409\u69B4\u786B\u998F\u7559\u5218\u7624\u6D41\u67F3\u516D\u9F99\u804B\u5499\u7B3C\u7ABF"],
      ["c240", "\u7FE4\u7FE7\u7FE8\u7FEA\u7FEB\u7FEC\u7FED\u7FEF\u7FF2\u7FF4", 6, "\u7FFD\u7FFE\u7FFF\u8002\u8007\u8008\u8009\u800A\u800E\u800F\u8011\u8013\u801A\u801B\u801D\u801E\u801F\u8021\u8023\u8024\u802B", 5, "\u8032\u8034\u8039\u803A\u803C\u803E\u8040\u8041\u8044\u8045\u8047\u8048\u8049\u804E\u804F\u8050\u8051\u8053\u8055\u8056\u8057"],
      ["c280", "\u8059\u805B", 13, "\u806B", 5, "\u8072", 11, "\u9686\u5784\u62E2\u9647\u697C\u5A04\u6402\u7BD3\u6F0F\u964B\u82A6\u5362\u9885\u5E90\u7089\u63B3\u5364\u864F\u9C81\u9E93\u788C\u9732\u8DEF\u8D42\u9E7F\u6F5E\u7984\u5F55\u9646\u622E\u9A74\u5415\u94DD\u4FA3\u65C5\u5C65\u5C61\u7F15\u8651\u6C2F\u5F8B\u7387\u6EE4\u7EFF\u5CE6\u631B\u5B6A\u6EE6\u5375\u4E71\u63A0\u7565\u62A1\u8F6E\u4F26\u4ED1\u6CA6\u7EB6\u8BBA\u841D\u87BA\u7F57\u903B\u9523\u7BA9\u9AA1\u88F8\u843D\u6D1B\u9A86\u7EDC\u5988\u9EBB\u739B\u7801\u8682\u9A6C\u9A82\u561B\u5417\u57CB\u4E70\u9EA6\u5356\u8FC8\u8109\u7792\u9992\u86EE\u6EE1\u8513\u66FC\u6162\u6F2B"],
      ["c340", "\u807E\u8081\u8082\u8085\u8088\u808A\u808D", 5, "\u8094\u8095\u8097\u8099\u809E\u80A3\u80A6\u80A7\u80A8\u80AC\u80B0\u80B3\u80B5\u80B6\u80B8\u80B9\u80BB\u80C5\u80C7", 4, "\u80CF", 6, "\u80D8\u80DF\u80E0\u80E2\u80E3\u80E6\u80EE\u80F5\u80F7\u80F9\u80FB\u80FE\u80FF\u8100\u8101\u8103\u8104\u8105\u8107\u8108\u810B"],
      ["c380", "\u810C\u8115\u8117\u8119\u811B\u811C\u811D\u811F", 12, "\u812D\u812E\u8130\u8133\u8134\u8135\u8137\u8139", 4, "\u813F\u8C29\u8292\u832B\u76F2\u6C13\u5FD9\u83BD\u732B\u8305\u951A\u6BDB\u77DB\u94C6\u536F\u8302\u5192\u5E3D\u8C8C\u8D38\u4E48\u73AB\u679A\u6885\u9176\u9709\u7164\u6CA1\u7709\u5A92\u9541\u6BCF\u7F8E\u6627\u5BD0\u59B9\u5A9A\u95E8\u95F7\u4EEC\u840C\u8499\u6AAC\u76DF\u9530\u731B\u68A6\u5B5F\u772F\u919A\u9761\u7CDC\u8FF7\u8C1C\u5F25\u7C73\u79D8\u89C5\u6CCC\u871C\u5BC6\u5E42\u68C9\u7720\u7EF5\u5195\u514D\u52C9\u5A29\u7F05\u9762\u82D7\u63CF\u7784\u85D0\u79D2\u6E3A\u5E99\u5999\u8511\u706D\u6C11\u62BF\u76BF\u654F\u60AF\u95FD\u660E\u879F\u9E23\u94ED\u540D\u547D\u8C2C\u6478"],
      ["c440", "\u8140", 5, "\u8147\u8149\u814D\u814E\u814F\u8152\u8156\u8157\u8158\u815B", 4, "\u8161\u8162\u8163\u8164\u8166\u8168\u816A\u816B\u816C\u816F\u8172\u8173\u8175\u8176\u8177\u8178\u8181\u8183", 4, "\u8189\u818B\u818C\u818D\u818E\u8190\u8192", 5, "\u8199\u819A\u819E", 4, "\u81A4\u81A5"],
      ["c480", "\u81A7\u81A9\u81AB", 7, "\u81B4", 5, "\u81BC\u81BD\u81BE\u81BF\u81C4\u81C5\u81C7\u81C8\u81C9\u81CB\u81CD", 6, "\u6479\u8611\u6A21\u819C\u78E8\u6469\u9B54\u62B9\u672B\u83AB\u58A8\u9ED8\u6CAB\u6F20\u5BDE\u964C\u8C0B\u725F\u67D0\u62C7\u7261\u4EA9\u59C6\u6BCD\u5893\u66AE\u5E55\u52DF\u6155\u6728\u76EE\u7766\u7267\u7A46\u62FF\u54EA\u5450\u94A0\u90A3\u5A1C\u7EB3\u6C16\u4E43\u5976\u8010\u5948\u5357\u7537\u96BE\u56CA\u6320\u8111\u607C\u95F9\u6DD6\u5462\u9981\u5185\u5AE9\u80FD\u59AE\u9713\u502A\u6CE5\u5C3C\u62DF\u4F60\u533F\u817B\u9006\u6EBA\u852B\u62C8\u5E74\u78BE\u64B5\u637B\u5FF5\u5A18\u917F\u9E1F\u5C3F\u634F\u8042\u5B7D\u556E\u954A\u954D\u6D85\u60A8\u67E0\u72DE\u51DD\u5B81"],
      ["c540", "\u81D4", 14, "\u81E4\u81E5\u81E6\u81E8\u81E9\u81EB\u81EE", 4, "\u81F5", 5, "\u81FD\u81FF\u8203\u8207", 4, "\u820E\u820F\u8211\u8213\u8215", 5, "\u821D\u8220\u8224\u8225\u8226\u8227\u8229\u822E\u8232\u823A\u823C\u823D\u823F"],
      ["c580", "\u8240\u8241\u8242\u8243\u8245\u8246\u8248\u824A\u824C\u824D\u824E\u8250", 7, "\u8259\u825B\u825C\u825D\u825E\u8260", 7, "\u8269\u62E7\u6CDE\u725B\u626D\u94AE\u7EBD\u8113\u6D53\u519C\u5F04\u5974\u52AA\u6012\u5973\u6696\u8650\u759F\u632A\u61E6\u7CEF\u8BFA\u54E6\u6B27\u9E25\u6BB4\u85D5\u5455\u5076\u6CA4\u556A\u8DB4\u722C\u5E15\u6015\u7436\u62CD\u6392\u724C\u5F98\u6E43\u6D3E\u6500\u6F58\u76D8\u78D0\u76FC\u7554\u5224\u53DB\u4E53\u5E9E\u65C1\u802A\u80D6\u629B\u5486\u5228\u70AE\u888D\u8DD1\u6CE1\u5478\u80DA\u57F9\u88F4\u8D54\u966A\u914D\u4F69\u6C9B\u55B7\u76C6\u7830\u62A8\u70F9\u6F8E\u5F6D\u84EC\u68DA\u787C\u7BF7\u81A8\u670B\u9E4F\u6367\u78B0\u576F\u7812\u9739\u6279\u62AB\u5288\u7435\u6BD7"],
      ["c640", "\u826A\u826B\u826C\u826D\u8271\u8275\u8276\u8277\u8278\u827B\u827C\u8280\u8281\u8283\u8285\u8286\u8287\u8289\u828C\u8290\u8293\u8294\u8295\u8296\u829A\u829B\u829E\u82A0\u82A2\u82A3\u82A7\u82B2\u82B5\u82B6\u82BA\u82BB\u82BC\u82BF\u82C0\u82C2\u82C3\u82C5\u82C6\u82C9\u82D0\u82D6\u82D9\u82DA\u82DD\u82E2\u82E7\u82E8\u82E9\u82EA\u82EC\u82ED\u82EE\u82F0\u82F2\u82F3\u82F5\u82F6\u82F8"],
      ["c680", "\u82FA\u82FC", 4, "\u830A\u830B\u830D\u8310\u8312\u8313\u8316\u8318\u8319\u831D", 9, "\u8329\u832A\u832E\u8330\u8332\u8337\u833B\u833D\u5564\u813E\u75B2\u76AE\u5339\u75DE\u50FB\u5C41\u8B6C\u7BC7\u504F\u7247\u9A97\u98D8\u6F02\u74E2\u7968\u6487\u77A5\u62FC\u9891\u8D2B\u54C1\u8058\u4E52\u576A\u82F9\u840D\u5E73\u51ED\u74F6\u8BC4\u5C4F\u5761\u6CFC\u9887\u5A46\u7834\u9B44\u8FEB\u7C95\u5256\u6251\u94FA\u4EC6\u8386\u8461\u83E9\u84B2\u57D4\u6734\u5703\u666E\u6D66\u8C31\u66DD\u7011\u671F\u6B3A\u6816\u621A\u59BB\u4E03\u51C4\u6F06\u67D2\u6C8F\u5176\u68CB\u5947\u6B67\u7566\u5D0E\u8110\u9F50\u65D7\u7948\u7941\u9A91\u8D77\u5C82\u4E5E\u4F01\u542F\u5951\u780C\u5668\u6C14\u8FC4\u5F03\u6C7D\u6CE3\u8BAB\u6390"],
      ["c740", "\u833E\u833F\u8341\u8342\u8344\u8345\u8348\u834A", 4, "\u8353\u8355", 4, "\u835D\u8362\u8370", 6, "\u8379\u837A\u837E", 6, "\u8387\u8388\u838A\u838B\u838C\u838D\u838F\u8390\u8391\u8394\u8395\u8396\u8397\u8399\u839A\u839D\u839F\u83A1", 6, "\u83AC\u83AD\u83AE"],
      ["c780", "\u83AF\u83B5\u83BB\u83BE\u83BF\u83C2\u83C3\u83C4\u83C6\u83C8\u83C9\u83CB\u83CD\u83CE\u83D0\u83D1\u83D2\u83D3\u83D5\u83D7\u83D9\u83DA\u83DB\u83DE\u83E2\u83E3\u83E4\u83E6\u83E7\u83E8\u83EB\u83EC\u83ED\u6070\u6D3D\u7275\u6266\u948E\u94C5\u5343\u8FC1\u7B7E\u4EDF\u8C26\u4E7E\u9ED4\u94B1\u94B3\u524D\u6F5C\u9063\u6D45\u8C34\u5811\u5D4C\u6B20\u6B49\u67AA\u545B\u8154\u7F8C\u5899\u8537\u5F3A\u62A2\u6A47\u9539\u6572\u6084\u6865\u77A7\u4E54\u4FA8\u5DE7\u9798\u64AC\u7FD8\u5CED\u4FCF\u7A8D\u5207\u8304\u4E14\u602F\u7A83\u94A6\u4FB5\u4EB2\u79E6\u7434\u52E4\u82B9\u64D2\u79BD\u5BDD\u6C81\u9752\u8F7B\u6C22\u503E\u537F\u6E05\u64CE\u6674\u6C30\u60C5\u9877\u8BF7\u5E86\u743C\u7A77\u79CB\u4E18\u90B1\u7403\u6C42\u56DA\u914B\u6CC5\u8D8B\u533A\u86C6\u66F2\u8EAF\u5C48\u9A71\u6E20"],
      ["c840", "\u83EE\u83EF\u83F3", 4, "\u83FA\u83FB\u83FC\u83FE\u83FF\u8400\u8402\u8405\u8407\u8408\u8409\u840A\u8410\u8412", 5, "\u8419\u841A\u841B\u841E", 5, "\u8429", 7, "\u8432", 5, "\u8439\u843A\u843B\u843E", 7, "\u8447\u8448\u8449"],
      ["c880", "\u844A", 6, "\u8452", 4, "\u8458\u845D\u845E\u845F\u8460\u8462\u8464", 4, "\u846A\u846E\u846F\u8470\u8472\u8474\u8477\u8479\u847B\u847C\u53D6\u5A36\u9F8B\u8DA3\u53BB\u5708\u98A7\u6743\u919B\u6CC9\u5168\u75CA\u62F3\u72AC\u5238\u529D\u7F3A\u7094\u7638\u5374\u9E4A\u69B7\u786E\u96C0\u88D9\u7FA4\u7136\u71C3\u5189\u67D3\u74E4\u58E4\u6518\u56B7\u8BA9\u9976\u6270\u7ED5\u60F9\u70ED\u58EC\u4EC1\u4EBA\u5FCD\u97E7\u4EFB\u8BA4\u5203\u598A\u7EAB\u6254\u4ECD\u65E5\u620E\u8338\u84C9\u8363\u878D\u7194\u6EB6\u5BB9\u7ED2\u5197\u63C9\u67D4\u8089\u8339\u8815\u5112\u5B7A\u5982\u8FB1\u4E73\u6C5D\u5165\u8925\u8F6F\u962E\u854A\u745E\u9510\u95F0\u6DA6\u82E5\u5F31\u6492\u6D12\u8428\u816E\u9CC3\u585E\u8D5B\u4E09\u53C1"],
      ["c940", "\u847D", 4, "\u8483\u8484\u8485\u8486\u848A\u848D\u848F", 7, "\u8498\u849A\u849B\u849D\u849E\u849F\u84A0\u84A2", 12, "\u84B0\u84B1\u84B3\u84B5\u84B6\u84B7\u84BB\u84BC\u84BE\u84C0\u84C2\u84C3\u84C5\u84C6\u84C7\u84C8\u84CB\u84CC\u84CE\u84CF\u84D2\u84D4\u84D5\u84D7"],
      ["c980", "\u84D8", 4, "\u84DE\u84E1\u84E2\u84E4\u84E7", 4, "\u84ED\u84EE\u84EF\u84F1", 10, "\u84FD\u84FE\u8500\u8501\u8502\u4F1E\u6563\u6851\u55D3\u4E27\u6414\u9A9A\u626B\u5AC2\u745F\u8272\u6DA9\u68EE\u50E7\u838E\u7802\u6740\u5239\u6C99\u7EB1\u50BB\u5565\u715E\u7B5B\u6652\u73CA\u82EB\u6749\u5C71\u5220\u717D\u886B\u95EA\u9655\u64C5\u8D61\u81B3\u5584\u6C55\u6247\u7F2E\u5892\u4F24\u5546\u8D4F\u664C\u4E0A\u5C1A\u88F3\u68A2\u634E\u7A0D\u70E7\u828D\u52FA\u97F6\u5C11\u54E8\u90B5\u7ECD\u5962\u8D4A\u86C7\u820C\u820D\u8D66\u6444\u5C04\u6151\u6D89\u793E\u8BBE\u7837\u7533\u547B\u4F38\u8EAB\u6DF1\u5A20\u7EC5\u795E\u6C88\u5BA1\u5A76\u751A\u80BE\u614E\u6E17\u58F0\u751F\u7525\u7272\u5347\u7EF3"],
      ["ca40", "\u8503", 8, "\u850D\u850E\u850F\u8510\u8512\u8514\u8515\u8516\u8518\u8519\u851B\u851C\u851D\u851E\u8520\u8522", 8, "\u852D", 9, "\u853E", 4, "\u8544\u8545\u8546\u8547\u854B", 10],
      ["ca80", "\u8557\u8558\u855A\u855B\u855C\u855D\u855F", 4, "\u8565\u8566\u8567\u8569", 8, "\u8573\u8575\u8576\u8577\u8578\u857C\u857D\u857F\u8580\u8581\u7701\u76DB\u5269\u80DC\u5723\u5E08\u5931\u72EE\u65BD\u6E7F\u8BD7\u5C38\u8671\u5341\u77F3\u62FE\u65F6\u4EC0\u98DF\u8680\u5B9E\u8BC6\u53F2\u77E2\u4F7F\u5C4E\u9A76\u59CB\u5F0F\u793A\u58EB\u4E16\u67FF\u4E8B\u62ED\u8A93\u901D\u52BF\u662F\u55DC\u566C\u9002\u4ED5\u4F8D\u91CA\u9970\u6C0F\u5E02\u6043\u5BA4\u89C6\u8BD5\u6536\u624B\u9996\u5B88\u5BFF\u6388\u552E\u53D7\u7626\u517D\u852C\u67A2\u68B3\u6B8A\u6292\u8F93\u53D4\u8212\u6DD1\u758F\u4E66\u8D4E\u5B70\u719F\u85AF\u6691\u66D9\u7F72\u8700\u9ECD\u9F20\u5C5E\u672F\u8FF0\u6811\u675F\u620D\u7AD6\u5885\u5EB6\u6570\u6F31"],
      ["cb40", "\u8582\u8583\u8586\u8588", 6, "\u8590", 10, "\u859D", 6, "\u85A5\u85A6\u85A7\u85A9\u85AB\u85AC\u85AD\u85B1", 5, "\u85B8\u85BA", 6, "\u85C2", 6, "\u85CA", 4, "\u85D1\u85D2"],
      ["cb80", "\u85D4\u85D6", 5, "\u85DD", 6, "\u85E5\u85E6\u85E7\u85E8\u85EA", 14, "\u6055\u5237\u800D\u6454\u8870\u7529\u5E05\u6813\u62F4\u971C\u53CC\u723D\u8C01\u6C34\u7761\u7A0E\u542E\u77AC\u987A\u821C\u8BF4\u7855\u6714\u70C1\u65AF\u6495\u5636\u601D\u79C1\u53F8\u4E1D\u6B7B\u8086\u5BFA\u55E3\u56DB\u4F3A\u4F3C\u9972\u5DF3\u677E\u8038\u6002\u9882\u9001\u5B8B\u8BBC\u8BF5\u641C\u8258\u64DE\u55FD\u82CF\u9165\u4FD7\u7D20\u901F\u7C9F\u50F3\u5851\u6EAF\u5BBF\u8BC9\u8083\u9178\u849C\u7B97\u867D\u968B\u968F\u7EE5\u9AD3\u788E\u5C81\u7A57\u9042\u96A7\u795F\u5B59\u635F\u7B0B\u84D1\u68AD\u5506\u7F29\u7410\u7D22\u9501\u6240\u584C\u4ED6\u5B83\u5979\u5854"],
      ["cc40", "\u85F9\u85FA\u85FC\u85FD\u85FE\u8600", 4, "\u8606", 10, "\u8612\u8613\u8614\u8615\u8617", 15, "\u8628\u862A", 13, "\u8639\u863A\u863B\u863D\u863E\u863F\u8640"],
      ["cc80", "\u8641", 11, "\u8652\u8653\u8655", 4, "\u865B\u865C\u865D\u865F\u8660\u8661\u8663", 7, "\u736D\u631E\u8E4B\u8E0F\u80CE\u82D4\u62AC\u53F0\u6CF0\u915E\u592A\u6001\u6C70\u574D\u644A\u8D2A\u762B\u6EE9\u575B\u6A80\u75F0\u6F6D\u8C2D\u8C08\u5766\u6BEF\u8892\u78B3\u63A2\u53F9\u70AD\u6C64\u5858\u642A\u5802\u68E0\u819B\u5510\u7CD6\u5018\u8EBA\u6DCC\u8D9F\u70EB\u638F\u6D9B\u6ED4\u7EE6\u8404\u6843\u9003\u6DD8\u9676\u8BA8\u5957\u7279\u85E4\u817E\u75BC\u8A8A\u68AF\u5254\u8E22\u9511\u63D0\u9898\u8E44\u557C\u4F53\u66FF\u568F\u60D5\u6D95\u5243\u5C49\u5929\u6DFB\u586B\u7530\u751C\u606C\u8214\u8146\u6311\u6761\u8FE2\u773A\u8DF3\u8D34\u94C1\u5E16\u5385\u542C\u70C3"],
      ["cd40", "\u866D\u866F\u8670\u8672", 6, "\u8683", 6, "\u868E", 4, "\u8694\u8696", 5, "\u869E", 4, "\u86A5\u86A6\u86AB\u86AD\u86AE\u86B2\u86B3\u86B7\u86B8\u86B9\u86BB", 4, "\u86C1\u86C2\u86C3\u86C5\u86C8\u86CC\u86CD\u86D2\u86D3\u86D5\u86D6\u86D7\u86DA\u86DC"],
      ["cd80", "\u86DD\u86E0\u86E1\u86E2\u86E3\u86E5\u86E6\u86E7\u86E8\u86EA\u86EB\u86EC\u86EF\u86F5\u86F6\u86F7\u86FA\u86FB\u86FC\u86FD\u86FF\u8701\u8704\u8705\u8706\u870B\u870C\u870E\u870F\u8710\u8711\u8714\u8716\u6C40\u5EF7\u505C\u4EAD\u5EAD\u633A\u8247\u901A\u6850\u916E\u77B3\u540C\u94DC\u5F64\u7AE5\u6876\u6345\u7B52\u7EDF\u75DB\u5077\u6295\u5934\u900F\u51F8\u79C3\u7A81\u56FE\u5F92\u9014\u6D82\u5C60\u571F\u5410\u5154\u6E4D\u56E2\u63A8\u9893\u817F\u8715\u892A\u9000\u541E\u5C6F\u81C0\u62D6\u6258\u8131\u9E35\u9640\u9A6E\u9A7C\u692D\u59A5\u62D3\u553E\u6316\u54C7\u86D9\u6D3C\u5A03\u74E6\u889C\u6B6A\u5916\u8C4C\u5F2F\u6E7E\u73A9\u987D\u4E38\u70F7\u5B8C\u7897\u633D\u665A\u7696\u60CB\u5B9B\u5A49\u4E07\u8155\u6C6A\u738B\u4EA1\u6789\u7F51\u5F80\u65FA\u671B\u5FD8\u5984\u5A01"],
      ["ce40", "\u8719\u871B\u871D\u871F\u8720\u8724\u8726\u8727\u8728\u872A\u872B\u872C\u872D\u872F\u8730\u8732\u8733\u8735\u8736\u8738\u8739\u873A\u873C\u873D\u8740", 6, "\u874A\u874B\u874D\u874F\u8750\u8751\u8752\u8754\u8755\u8756\u8758\u875A", 5, "\u8761\u8762\u8766", 7, "\u876F\u8771\u8772\u8773\u8775"],
      ["ce80", "\u8777\u8778\u8779\u877A\u877F\u8780\u8781\u8784\u8786\u8787\u8789\u878A\u878C\u878E", 4, "\u8794\u8795\u8796\u8798", 6, "\u87A0", 4, "\u5DCD\u5FAE\u5371\u97E6\u8FDD\u6845\u56F4\u552F\u60DF\u4E3A\u6F4D\u7EF4\u82C7\u840E\u59D4\u4F1F\u4F2A\u5C3E\u7EAC\u672A\u851A\u5473\u754F\u80C3\u5582\u9B4F\u4F4D\u6E2D\u8C13\u5C09\u6170\u536B\u761F\u6E29\u868A\u6587\u95FB\u7EB9\u543B\u7A33\u7D0A\u95EE\u55E1\u7FC1\u74EE\u631D\u8717\u6DA1\u7A9D\u6211\u65A1\u5367\u63E1\u6C83\u5DEB\u545C\u94A8\u4E4C\u6C61\u8BEC\u5C4B\u65E0\u829C\u68A7\u543E\u5434\u6BCB\u6B66\u4E94\u6342\u5348\u821E\u4F0D\u4FAE\u575E\u620A\u96FE\u6664\u7269\u52FF\u52A1\u609F\u8BEF\u6614\u7199\u6790\u897F\u7852\u77FD\u6670\u563B\u5438\u9521\u727A"],
      ["cf40", "\u87A5\u87A6\u87A7\u87A9\u87AA\u87AE\u87B0\u87B1\u87B2\u87B4\u87B6\u87B7\u87B8\u87B9\u87BB\u87BC\u87BE\u87BF\u87C1", 4, "\u87C7\u87C8\u87C9\u87CC", 4, "\u87D4", 6, "\u87DC\u87DD\u87DE\u87DF\u87E1\u87E2\u87E3\u87E4\u87E6\u87E7\u87E8\u87E9\u87EB\u87EC\u87ED\u87EF", 9],
      ["cf80", "\u87FA\u87FB\u87FC\u87FD\u87FF\u8800\u8801\u8802\u8804", 5, "\u880B", 7, "\u8814\u8817\u8818\u8819\u881A\u881C", 4, "\u8823\u7A00\u606F\u5E0C\u6089\u819D\u5915\u60DC\u7184\u70EF\u6EAA\u6C50\u7280\u6A84\u88AD\u5E2D\u4E60\u5AB3\u559C\u94E3\u6D17\u7CFB\u9699\u620F\u7EC6\u778E\u867E\u5323\u971E\u8F96\u6687\u5CE1\u4FA0\u72ED\u4E0B\u53A6\u590F\u5413\u6380\u9528\u5148\u4ED9\u9C9C\u7EA4\u54B8\u8D24\u8854\u8237\u95F2\u6D8E\u5F26\u5ACC\u663E\u9669\u73B0\u732E\u53BF\u817A\u9985\u7FA1\u5BAA\u9677\u9650\u7EBF\u76F8\u53A2\u9576\u9999\u7BB1\u8944\u6E58\u4E61\u7FD4\u7965\u8BE6\u60F3\u54CD\u4EAB\u9879\u5DF7\u6A61\u50CF\u5411\u8C61\u8427\u785D\u9704\u524A\u54EE\u56A3\u9500\u6D88\u5BB5\u6DC6\u6653"],
      ["d040", "\u8824", 13, "\u8833", 5, "\u883A\u883B\u883D\u883E\u883F\u8841\u8842\u8843\u8846", 5, "\u884E", 5, "\u8855\u8856\u8858\u885A", 6, "\u8866\u8867\u886A\u886D\u886F\u8871\u8873\u8874\u8875\u8876\u8878\u8879\u887A"],
      ["d080", "\u887B\u887C\u8880\u8883\u8886\u8887\u8889\u888A\u888C\u888E\u888F\u8890\u8891\u8893\u8894\u8895\u8897", 4, "\u889D", 4, "\u88A3\u88A5", 5, "\u5C0F\u5B5D\u6821\u8096\u5578\u7B11\u6548\u6954\u4E9B\u6B47\u874E\u978B\u534F\u631F\u643A\u90AA\u659C\u80C1\u8C10\u5199\u68B0\u5378\u87F9\u61C8\u6CC4\u6CFB\u8C22\u5C51\u85AA\u82AF\u950C\u6B23\u8F9B\u65B0\u5FFB\u5FC3\u4FE1\u8845\u661F\u8165\u7329\u60FA\u5174\u5211\u578B\u5F62\u90A2\u884C\u9192\u5E78\u674F\u6027\u59D3\u5144\u51F6\u80F8\u5308\u6C79\u96C4\u718A\u4F11\u4FEE\u7F9E\u673D\u55C5\u9508\u79C0\u8896\u7EE3\u589F\u620C\u9700\u865A\u5618\u987B\u5F90\u8BB8\u84C4\u9157\u53D9\u65ED\u5E8F\u755C\u6064\u7D6E\u5A7F\u7EEA\u7EED\u8F69\u55A7\u5BA3\u60AC\u65CB\u7384"],
      ["d140", "\u88AC\u88AE\u88AF\u88B0\u88B2", 4, "\u88B8\u88B9\u88BA\u88BB\u88BD\u88BE\u88BF\u88C0\u88C3\u88C4\u88C7\u88C8\u88CA\u88CB\u88CC\u88CD\u88CF\u88D0\u88D1\u88D3\u88D6\u88D7\u88DA", 4, "\u88E0\u88E1\u88E6\u88E7\u88E9", 6, "\u88F2\u88F5\u88F6\u88F7\u88FA\u88FB\u88FD\u88FF\u8900\u8901\u8903", 5],
      ["d180", "\u8909\u890B", 4, "\u8911\u8914", 4, "\u891C", 4, "\u8922\u8923\u8924\u8926\u8927\u8928\u8929\u892C\u892D\u892E\u892F\u8931\u8932\u8933\u8935\u8937\u9009\u7663\u7729\u7EDA\u9774\u859B\u5B66\u7A74\u96EA\u8840\u52CB\u718F\u5FAA\u65EC\u8BE2\u5BFB\u9A6F\u5DE1\u6B89\u6C5B\u8BAD\u8BAF\u900A\u8FC5\u538B\u62BC\u9E26\u9E2D\u5440\u4E2B\u82BD\u7259\u869C\u5D16\u8859\u6DAF\u96C5\u54D1\u4E9A\u8BB6\u7109\u54BD\u9609\u70DF\u6DF9\u76D0\u4E25\u7814\u8712\u5CA9\u5EF6\u8A00\u989C\u960E\u708E\u6CBF\u5944\u63A9\u773C\u884D\u6F14\u8273\u5830\u71D5\u538C\u781A\u96C1\u5501\u5F66\u7130\u5BB4\u8C1A\u9A8C\u6B83\u592E\u9E2F\u79E7\u6768\u626C\u4F6F\u75A1\u7F8A\u6D0B\u9633\u6C27\u4EF0\u75D2\u517B\u6837\u6F3E\u9080\u8170\u5996\u7476"],
      ["d240", "\u8938", 8, "\u8942\u8943\u8945", 24, "\u8960", 5, "\u8967", 19, "\u897C"],
      ["d280", "\u897D\u897E\u8980\u8982\u8984\u8985\u8987", 26, "\u6447\u5C27\u9065\u7A91\u8C23\u59DA\u54AC\u8200\u836F\u8981\u8000\u6930\u564E\u8036\u7237\u91CE\u51B6\u4E5F\u9875\u6396\u4E1A\u53F6\u66F3\u814B\u591C\u6DB2\u4E00\u58F9\u533B\u63D6\u94F1\u4F9D\u4F0A\u8863\u9890\u5937\u9057\u79FB\u4EEA\u80F0\u7591\u6C82\u5B9C\u59E8\u5F5D\u6905\u8681\u501A\u5DF2\u4E59\u77E3\u4EE5\u827A\u6291\u6613\u9091\u5C79\u4EBF\u5F79\u81C6\u9038\u8084\u75AB\u4EA6\u88D4\u610F\u6BC5\u5FC6\u4E49\u76CA\u6EA2\u8BE3\u8BAE\u8C0A\u8BD1\u5F02\u7FFC\u7FCC\u7ECE\u8335\u836B\u56E0\u6BB7\u97F3\u9634\u59FB\u541F\u94F6\u6DEB\u5BC5\u996E\u5C39\u5F15\u9690"],
      ["d340", "\u89A2", 30, "\u89C3\u89CD\u89D3\u89D4\u89D5\u89D7\u89D8\u89D9\u89DB\u89DD\u89DF\u89E0\u89E1\u89E2\u89E4\u89E7\u89E8\u89E9\u89EA\u89EC\u89ED\u89EE\u89F0\u89F1\u89F2\u89F4", 6],
      ["d380", "\u89FB", 4, "\u8A01", 5, "\u8A08", 21, "\u5370\u82F1\u6A31\u5A74\u9E70\u5E94\u7F28\u83B9\u8424\u8425\u8367\u8747\u8FCE\u8D62\u76C8\u5F71\u9896\u786C\u6620\u54DF\u62E5\u4F63\u81C3\u75C8\u5EB8\u96CD\u8E0A\u86F9\u548F\u6CF3\u6D8C\u6C38\u607F\u52C7\u7528\u5E7D\u4F18\u60A0\u5FE7\u5C24\u7531\u90AE\u94C0\u72B9\u6CB9\u6E38\u9149\u6709\u53CB\u53F3\u4F51\u91C9\u8BF1\u53C8\u5E7C\u8FC2\u6DE4\u4E8E\u76C2\u6986\u865E\u611A\u8206\u4F59\u4FDE\u903E\u9C7C\u6109\u6E1D\u6E14\u9685\u4E88\u5A31\u96E8\u4E0E\u5C7F\u79B9\u5B87\u8BED\u7FBD\u7389\u57DF\u828B\u90C1\u5401\u9047\u55BB\u5CEA\u5FA1\u6108\u6B32\u72F1\u80B2\u8A89"],
      ["d440", "\u8A1E", 31, "\u8A3F", 8, "\u8A49", 21],
      ["d480", "\u8A5F", 25, "\u8A7A", 6, "\u6D74\u5BD3\u88D5\u9884\u8C6B\u9A6D\u9E33\u6E0A\u51A4\u5143\u57A3\u8881\u539F\u63F4\u8F95\u56ED\u5458\u5706\u733F\u6E90\u7F18\u8FDC\u82D1\u613F\u6028\u9662\u66F0\u7EA6\u8D8A\u8DC3\u94A5\u5CB3\u7CA4\u6708\u60A6\u9605\u8018\u4E91\u90E7\u5300\u9668\u5141\u8FD0\u8574\u915D\u6655\u97F5\u5B55\u531D\u7838\u6742\u683D\u54C9\u707E\u5BB0\u8F7D\u518D\u5728\u54B1\u6512\u6682\u8D5E\u8D43\u810F\u846C\u906D\u7CDF\u51FF\u85FB\u67A3\u65E9\u6FA1\u86A4\u8E81\u566A\u9020\u7682\u7076\u71E5\u8D23\u62E9\u5219\u6CFD\u8D3C\u600E\u589E\u618E\u66FE\u8D60\u624E\u55B3\u6E23\u672D\u8F67"],
      ["d540", "\u8A81", 7, "\u8A8B", 7, "\u8A94", 46],
      ["d580", "\u8AC3", 32, "\u94E1\u95F8\u7728\u6805\u69A8\u548B\u4E4D\u70B8\u8BC8\u6458\u658B\u5B85\u7A84\u503A\u5BE8\u77BB\u6BE1\u8A79\u7C98\u6CBE\u76CF\u65A9\u8F97\u5D2D\u5C55\u8638\u6808\u5360\u6218\u7AD9\u6E5B\u7EFD\u6A1F\u7AE0\u5F70\u6F33\u5F20\u638C\u6DA8\u6756\u4E08\u5E10\u8D26\u4ED7\u80C0\u7634\u969C\u62DB\u662D\u627E\u6CBC\u8D75\u7167\u7F69\u5146\u8087\u53EC\u906E\u6298\u54F2\u86F0\u8F99\u8005\u9517\u8517\u8FD9\u6D59\u73CD\u659F\u771F\u7504\u7827\u81FB\u8D1E\u9488\u4FA6\u6795\u75B9\u8BCA\u9707\u632F\u9547\u9635\u84B8\u6323\u7741\u5F81\u72F0\u4E89\u6014\u6574\u62EF\u6B63\u653F"],
      ["d640", "\u8AE4", 34, "\u8B08", 27],
      ["d680", "\u8B24\u8B25\u8B27", 30, "\u5E27\u75C7\u90D1\u8BC1\u829D\u679D\u652F\u5431\u8718\u77E5\u80A2\u8102\u6C41\u4E4B\u7EC7\u804C\u76F4\u690D\u6B96\u6267\u503C\u4F84\u5740\u6307\u6B62\u8DBE\u53EA\u65E8\u7EB8\u5FD7\u631A\u63B7\u81F3\u81F4\u7F6E\u5E1C\u5CD9\u5236\u667A\u79E9\u7A1A\u8D28\u7099\u75D4\u6EDE\u6CBB\u7A92\u4E2D\u76C5\u5FE0\u949F\u8877\u7EC8\u79CD\u80BF\u91CD\u4EF2\u4F17\u821F\u5468\u5DDE\u6D32\u8BCC\u7CA5\u8F74\u8098\u5E1A\u5492\u76B1\u5B99\u663C\u9AA4\u73E0\u682A\u86DB\u6731\u732A\u8BF8\u8BDB\u9010\u7AF9\u70DB\u716E\u62C4\u77A9\u5631\u4E3B\u8457\u67F1\u52A9\u86C0\u8D2E\u94F8\u7B51"],
      ["d740", "\u8B46", 31, "\u8B67", 4, "\u8B6D", 25],
      ["d780", "\u8B87", 24, "\u8BAC\u8BB1\u8BBB\u8BC7\u8BD0\u8BEA\u8C09\u8C1E\u4F4F\u6CE8\u795D\u9A7B\u6293\u722A\u62FD\u4E13\u7816\u8F6C\u64B0\u8D5A\u7BC6\u6869\u5E84\u88C5\u5986\u649E\u58EE\u72B6\u690E\u9525\u8FFD\u8D58\u5760\u7F00\u8C06\u51C6\u6349\u62D9\u5353\u684C\u7422\u8301\u914C\u5544\u7740\u707C\u6D4A\u5179\u54A8\u8D44\u59FF\u6ECB\u6DC4\u5B5C\u7D2B\u4ED4\u7C7D\u6ED3\u5B50\u81EA\u6E0D\u5B57\u9B03\u68D5\u8E2A\u5B97\u7EFC\u603B\u7EB5\u90B9\u8D70\u594F\u63CD\u79DF\u8DB3\u5352\u65CF\u7956\u8BC5\u963B\u7EC4\u94BB\u7E82\u5634\u9189\u6700\u7F6A\u5C0A\u9075\u6628\u5DE6\u4F50\u67DE\u505A\u4F5C\u5750\u5EA7"],
      ["d840", "\u8C38", 8, "\u8C42\u8C43\u8C44\u8C45\u8C48\u8C4A\u8C4B\u8C4D", 7, "\u8C56\u8C57\u8C58\u8C59\u8C5B", 5, "\u8C63", 6, "\u8C6C", 6, "\u8C74\u8C75\u8C76\u8C77\u8C7B", 6, "\u8C83\u8C84\u8C86\u8C87"],
      ["d880", "\u8C88\u8C8B\u8C8D", 6, "\u8C95\u8C96\u8C97\u8C99", 20, "\u4E8D\u4E0C\u5140\u4E10\u5EFF\u5345\u4E15\u4E98\u4E1E\u9B32\u5B6C\u5669\u4E28\u79BA\u4E3F\u5315\u4E47\u592D\u723B\u536E\u6C10\u56DF\u80E4\u9997\u6BD3\u777E\u9F17\u4E36\u4E9F\u9F10\u4E5C\u4E69\u4E93\u8288\u5B5B\u556C\u560F\u4EC4\u538D\u539D\u53A3\u53A5\u53AE\u9765\u8D5D\u531A\u53F5\u5326\u532E\u533E\u8D5C\u5366\u5363\u5202\u5208\u520E\u522D\u5233\u523F\u5240\u524C\u525E\u5261\u525C\u84AF\u527D\u5282\u5281\u5290\u5293\u5182\u7F54\u4EBB\u4EC3\u4EC9\u4EC2\u4EE8\u4EE1\u4EEB\u4EDE\u4F1B\u4EF3\u4F22\u4F64\u4EF5\u4F25\u4F27\u4F09\u4F2B\u4F5E\u4F67\u6538\u4F5A\u4F5D"],
      ["d940", "\u8CAE", 62],
      ["d980", "\u8CED", 32, "\u4F5F\u4F57\u4F32\u4F3D\u4F76\u4F74\u4F91\u4F89\u4F83\u4F8F\u4F7E\u4F7B\u4FAA\u4F7C\u4FAC\u4F94\u4FE6\u4FE8\u4FEA\u4FC5\u4FDA\u4FE3\u4FDC\u4FD1\u4FDF\u4FF8\u5029\u504C\u4FF3\u502C\u500F\u502E\u502D\u4FFE\u501C\u500C\u5025\u5028\u507E\u5043\u5055\u5048\u504E\u506C\u507B\u50A5\u50A7\u50A9\u50BA\u50D6\u5106\u50ED\u50EC\u50E6\u50EE\u5107\u510B\u4EDD\u6C3D\u4F58\u4F65\u4FCE\u9FA0\u6C46\u7C74\u516E\u5DFD\u9EC9\u9998\u5181\u5914\u52F9\u530D\u8A07\u5310\u51EB\u5919\u5155\u4EA0\u5156\u4EB3\u886E\u88A4\u4EB5\u8114\u88D2\u7980\u5B34\u8803\u7FB8\u51AB\u51B1\u51BD\u51BC"],
      ["da40", "\u8D0E", 14, "\u8D20\u8D51\u8D52\u8D57\u8D5F\u8D65\u8D68\u8D69\u8D6A\u8D6C\u8D6E\u8D6F\u8D71\u8D72\u8D78", 8, "\u8D82\u8D83\u8D86\u8D87\u8D88\u8D89\u8D8C", 4, "\u8D92\u8D93\u8D95", 9, "\u8DA0\u8DA1"],
      ["da80", "\u8DA2\u8DA4", 12, "\u8DB2\u8DB6\u8DB7\u8DB9\u8DBB\u8DBD\u8DC0\u8DC1\u8DC2\u8DC5\u8DC7\u8DC8\u8DC9\u8DCA\u8DCD\u8DD0\u8DD2\u8DD3\u8DD4\u51C7\u5196\u51A2\u51A5\u8BA0\u8BA6\u8BA7\u8BAA\u8BB4\u8BB5\u8BB7\u8BC2\u8BC3\u8BCB\u8BCF\u8BCE\u8BD2\u8BD3\u8BD4\u8BD6\u8BD8\u8BD9\u8BDC\u8BDF\u8BE0\u8BE4\u8BE8\u8BE9\u8BEE\u8BF0\u8BF3\u8BF6\u8BF9\u8BFC\u8BFF\u8C00\u8C02\u8C04\u8C07\u8C0C\u8C0F\u8C11\u8C12\u8C14\u8C15\u8C16\u8C19\u8C1B\u8C18\u8C1D\u8C1F\u8C20\u8C21\u8C25\u8C27\u8C2A\u8C2B\u8C2E\u8C2F\u8C32\u8C33\u8C35\u8C36\u5369\u537A\u961D\u9622\u9621\u9631\u962A\u963D\u963C\u9642\u9649\u9654\u965F\u9667\u966C\u9672\u9674\u9688\u968D\u9697\u96B0\u9097\u909B\u909D\u9099\u90AC\u90A1\u90B4\u90B3\u90B6\u90BA"],
      ["db40", "\u8DD5\u8DD8\u8DD9\u8DDC\u8DE0\u8DE1\u8DE2\u8DE5\u8DE6\u8DE7\u8DE9\u8DED\u8DEE\u8DF0\u8DF1\u8DF2\u8DF4\u8DF6\u8DFC\u8DFE", 6, "\u8E06\u8E07\u8E08\u8E0B\u8E0D\u8E0E\u8E10\u8E11\u8E12\u8E13\u8E15", 7, "\u8E20\u8E21\u8E24", 4, "\u8E2B\u8E2D\u8E30\u8E32\u8E33\u8E34\u8E36\u8E37\u8E38\u8E3B\u8E3C\u8E3E"],
      ["db80", "\u8E3F\u8E43\u8E45\u8E46\u8E4C", 4, "\u8E53", 5, "\u8E5A", 11, "\u8E67\u8E68\u8E6A\u8E6B\u8E6E\u8E71\u90B8\u90B0\u90CF\u90C5\u90BE\u90D0\u90C4\u90C7\u90D3\u90E6\u90E2\u90DC\u90D7\u90DB\u90EB\u90EF\u90FE\u9104\u9122\u911E\u9123\u9131\u912F\u9139\u9143\u9146\u520D\u5942\u52A2\u52AC\u52AD\u52BE\u54FF\u52D0\u52D6\u52F0\u53DF\u71EE\u77CD\u5EF4\u51F5\u51FC\u9B2F\u53B6\u5F01\u755A\u5DEF\u574C\u57A9\u57A1\u587E\u58BC\u58C5\u58D1\u5729\u572C\u572A\u5733\u5739\u572E\u572F\u575C\u573B\u5742\u5769\u5785\u576B\u5786\u577C\u577B\u5768\u576D\u5776\u5773\u57AD\u57A4\u578C\u57B2\u57CF\u57A7\u57B4\u5793\u57A0\u57D5\u57D8\u57DA\u57D9\u57D2\u57B8\u57F4\u57EF\u57F8\u57E4\u57DD"],
      ["dc40", "\u8E73\u8E75\u8E77", 4, "\u8E7D\u8E7E\u8E80\u8E82\u8E83\u8E84\u8E86\u8E88", 6, "\u8E91\u8E92\u8E93\u8E95", 6, "\u8E9D\u8E9F", 11, "\u8EAD\u8EAE\u8EB0\u8EB1\u8EB3", 6, "\u8EBB", 7],
      ["dc80", "\u8EC3", 10, "\u8ECF", 21, "\u580B\u580D\u57FD\u57ED\u5800\u581E\u5819\u5844\u5820\u5865\u586C\u5881\u5889\u589A\u5880\u99A8\u9F19\u61FF\u8279\u827D\u827F\u828F\u828A\u82A8\u8284\u828E\u8291\u8297\u8299\u82AB\u82B8\u82BE\u82B0\u82C8\u82CA\u82E3\u8298\u82B7\u82AE\u82CB\u82CC\u82C1\u82A9\u82B4\u82A1\u82AA\u829F\u82C4\u82CE\u82A4\u82E1\u8309\u82F7\u82E4\u830F\u8307\u82DC\u82F4\u82D2\u82D8\u830C\u82FB\u82D3\u8311\u831A\u8306\u8314\u8315\u82E0\u82D5\u831C\u8351\u835B\u835C\u8308\u8392\u833C\u8334\u8331\u839B\u835E\u832F\u834F\u8347\u8343\u835F\u8340\u8317\u8360\u832D\u833A\u8333\u8366\u8365"],
      ["dd40", "\u8EE5", 62],
      ["dd80", "\u8F24", 32, "\u8368\u831B\u8369\u836C\u836A\u836D\u836E\u83B0\u8378\u83B3\u83B4\u83A0\u83AA\u8393\u839C\u8385\u837C\u83B6\u83A9\u837D\u83B8\u837B\u8398\u839E\u83A8\u83BA\u83BC\u83C1\u8401\u83E5\u83D8\u5807\u8418\u840B\u83DD\u83FD\u83D6\u841C\u8438\u8411\u8406\u83D4\u83DF\u840F\u8403\u83F8\u83F9\u83EA\u83C5\u83C0\u8426\u83F0\u83E1\u845C\u8451\u845A\u8459\u8473\u8487\u8488\u847A\u8489\u8478\u843C\u8446\u8469\u8476\u848C\u848E\u8431\u846D\u84C1\u84CD\u84D0\u84E6\u84BD\u84D3\u84CA\u84BF\u84BA\u84E0\u84A1\u84B9\u84B4\u8497\u84E5\u84E3\u850C\u750D\u8538\u84F0\u8539\u851F\u853A"],
      ["de40", "\u8F45", 32, "\u8F6A\u8F80\u8F8C\u8F92\u8F9D\u8FA0\u8FA1\u8FA2\u8FA4\u8FA5\u8FA6\u8FA7\u8FAA\u8FAC\u8FAD\u8FAE\u8FAF\u8FB2\u8FB3\u8FB4\u8FB5\u8FB7\u8FB8\u8FBA\u8FBB\u8FBC\u8FBF\u8FC0\u8FC3\u8FC6"],
      ["de80", "\u8FC9", 4, "\u8FCF\u8FD2\u8FD6\u8FD7\u8FDA\u8FE0\u8FE1\u8FE3\u8FE7\u8FEC\u8FEF\u8FF1\u8FF2\u8FF4\u8FF5\u8FF6\u8FFA\u8FFB\u8FFC\u8FFE\u8FFF\u9007\u9008\u900C\u900E\u9013\u9015\u9018\u8556\u853B\u84FF\u84FC\u8559\u8548\u8568\u8564\u855E\u857A\u77A2\u8543\u8572\u857B\u85A4\u85A8\u8587\u858F\u8579\u85AE\u859C\u8585\u85B9\u85B7\u85B0\u85D3\u85C1\u85DC\u85FF\u8627\u8605\u8629\u8616\u863C\u5EFE\u5F08\u593C\u5941\u8037\u5955\u595A\u5958\u530F\u5C22\u5C25\u5C2C\u5C34\u624C\u626A\u629F\u62BB\u62CA\u62DA\u62D7\u62EE\u6322\u62F6\u6339\u634B\u6343\u63AD\u63F6\u6371\u637A\u638E\u63B4\u636D\u63AC\u638A\u6369\u63AE\u63BC\u63F2\u63F8\u63E0\u63FF\u63C4\u63DE\u63CE\u6452\u63C6\u63BE\u6445\u6441\u640B\u641B\u6420\u640C\u6426\u6421\u645E\u6484\u646D\u6496"],
      ["df40", "\u9019\u901C\u9023\u9024\u9025\u9027", 5, "\u9030", 4, "\u9037\u9039\u903A\u903D\u903F\u9040\u9043\u9045\u9046\u9048", 4, "\u904E\u9054\u9055\u9056\u9059\u905A\u905C", 5, "\u9064\u9066\u9067\u9069\u906A\u906B\u906C\u906F", 4, "\u9076", 6, "\u907E\u9081"],
      ["df80", "\u9084\u9085\u9086\u9087\u9089\u908A\u908C", 4, "\u9092\u9094\u9096\u9098\u909A\u909C\u909E\u909F\u90A0\u90A4\u90A5\u90A7\u90A8\u90A9\u90AB\u90AD\u90B2\u90B7\u90BC\u90BD\u90BF\u90C0\u647A\u64B7\u64B8\u6499\u64BA\u64C0\u64D0\u64D7\u64E4\u64E2\u6509\u6525\u652E\u5F0B\u5FD2\u7519\u5F11\u535F\u53F1\u53FD\u53E9\u53E8\u53FB\u5412\u5416\u5406\u544B\u5452\u5453\u5454\u5456\u5443\u5421\u5457\u5459\u5423\u5432\u5482\u5494\u5477\u5471\u5464\u549A\u549B\u5484\u5476\u5466\u549D\u54D0\u54AD\u54C2\u54B4\u54D2\u54A7\u54A6\u54D3\u54D4\u5472\u54A3\u54D5\u54BB\u54BF\u54CC\u54D9\u54DA\u54DC\u54A9\u54AA\u54A4\u54DD\u54CF\u54DE\u551B\u54E7\u5520\u54FD\u5514\u54F3\u5522\u5523\u550F\u5511\u5527\u552A\u5567\u558F\u55B5\u5549\u556D\u5541\u5555\u553F\u5550\u553C"],
      ["e040", "\u90C2\u90C3\u90C6\u90C8\u90C9\u90CB\u90CC\u90CD\u90D2\u90D4\u90D5\u90D6\u90D8\u90D9\u90DA\u90DE\u90DF\u90E0\u90E3\u90E4\u90E5\u90E9\u90EA\u90EC\u90EE\u90F0\u90F1\u90F2\u90F3\u90F5\u90F6\u90F7\u90F9\u90FA\u90FB\u90FC\u90FF\u9100\u9101\u9103\u9105", 19, "\u911A\u911B\u911C"],
      ["e080", "\u911D\u911F\u9120\u9121\u9124", 10, "\u9130\u9132", 6, "\u913A", 8, "\u9144\u5537\u5556\u5575\u5576\u5577\u5533\u5530\u555C\u558B\u55D2\u5583\u55B1\u55B9\u5588\u5581\u559F\u557E\u55D6\u5591\u557B\u55DF\u55BD\u55BE\u5594\u5599\u55EA\u55F7\u55C9\u561F\u55D1\u55EB\u55EC\u55D4\u55E6\u55DD\u55C4\u55EF\u55E5\u55F2\u55F3\u55CC\u55CD\u55E8\u55F5\u55E4\u8F94\u561E\u5608\u560C\u5601\u5624\u5623\u55FE\u5600\u5627\u562D\u5658\u5639\u5657\u562C\u564D\u5662\u5659\u565C\u564C\u5654\u5686\u5664\u5671\u566B\u567B\u567C\u5685\u5693\u56AF\u56D4\u56D7\u56DD\u56E1\u56F5\u56EB\u56F9\u56FF\u5704\u570A\u5709\u571C\u5E0F\u5E19\u5E14\u5E11\u5E31\u5E3B\u5E3C"],
      ["e140", "\u9145\u9147\u9148\u9151\u9153\u9154\u9155\u9156\u9158\u9159\u915B\u915C\u915F\u9160\u9166\u9167\u9168\u916B\u916D\u9173\u917A\u917B\u917C\u9180", 4, "\u9186\u9188\u918A\u918E\u918F\u9193", 6, "\u919C", 5, "\u91A4", 5, "\u91AB\u91AC\u91B0\u91B1\u91B2\u91B3\u91B6\u91B7\u91B8\u91B9\u91BB"],
      ["e180", "\u91BC", 10, "\u91C8\u91CB\u91D0\u91D2", 9, "\u91DD", 8, "\u5E37\u5E44\u5E54\u5E5B\u5E5E\u5E61\u5C8C\u5C7A\u5C8D\u5C90\u5C96\u5C88\u5C98\u5C99\u5C91\u5C9A\u5C9C\u5CB5\u5CA2\u5CBD\u5CAC\u5CAB\u5CB1\u5CA3\u5CC1\u5CB7\u5CC4\u5CD2\u5CE4\u5CCB\u5CE5\u5D02\u5D03\u5D27\u5D26\u5D2E\u5D24\u5D1E\u5D06\u5D1B\u5D58\u5D3E\u5D34\u5D3D\u5D6C\u5D5B\u5D6F\u5D5D\u5D6B\u5D4B\u5D4A\u5D69\u5D74\u5D82\u5D99\u5D9D\u8C73\u5DB7\u5DC5\u5F73\u5F77\u5F82\u5F87\u5F89\u5F8C\u5F95\u5F99\u5F9C\u5FA8\u5FAD\u5FB5\u5FBC\u8862\u5F61\u72AD\u72B0\u72B4\u72B7\u72B8\u72C3\u72C1\u72CE\u72CD\u72D2\u72E8\u72EF\u72E9\u72F2\u72F4\u72F7\u7301\u72F3\u7303\u72FA"],
      ["e240", "\u91E6", 62],
      ["e280", "\u9225", 32, "\u72FB\u7317\u7313\u7321\u730A\u731E\u731D\u7315\u7322\u7339\u7325\u732C\u7338\u7331\u7350\u734D\u7357\u7360\u736C\u736F\u737E\u821B\u5925\u98E7\u5924\u5902\u9963\u9967", 5, "\u9974\u9977\u997D\u9980\u9984\u9987\u998A\u998D\u9990\u9991\u9993\u9994\u9995\u5E80\u5E91\u5E8B\u5E96\u5EA5\u5EA0\u5EB9\u5EB5\u5EBE\u5EB3\u8D53\u5ED2\u5ED1\u5EDB\u5EE8\u5EEA\u81BA\u5FC4\u5FC9\u5FD6\u5FCF\u6003\u5FEE\u6004\u5FE1\u5FE4\u5FFE\u6005\u6006\u5FEA\u5FED\u5FF8\u6019\u6035\u6026\u601B\u600F\u600D\u6029\u602B\u600A\u603F\u6021\u6078\u6079\u607B\u607A\u6042"],
      ["e340", "\u9246", 45, "\u9275", 16],
      ["e380", "\u9286", 7, "\u928F", 24, "\u606A\u607D\u6096\u609A\u60AD\u609D\u6083\u6092\u608C\u609B\u60EC\u60BB\u60B1\u60DD\u60D8\u60C6\u60DA\u60B4\u6120\u6126\u6115\u6123\u60F4\u6100\u610E\u612B\u614A\u6175\u61AC\u6194\u61A7\u61B7\u61D4\u61F5\u5FDD\u96B3\u95E9\u95EB\u95F1\u95F3\u95F5\u95F6\u95FC\u95FE\u9603\u9604\u9606\u9608\u960A\u960B\u960C\u960D\u960F\u9612\u9615\u9616\u9617\u9619\u961A\u4E2C\u723F\u6215\u6C35\u6C54\u6C5C\u6C4A\u6CA3\u6C85\u6C90\u6C94\u6C8C\u6C68\u6C69\u6C74\u6C76\u6C86\u6CA9\u6CD0\u6CD4\u6CAD\u6CF7\u6CF8\u6CF1\u6CD7\u6CB2\u6CE0\u6CD6\u6CFA\u6CEB\u6CEE\u6CB1\u6CD3\u6CEF\u6CFE"],
      ["e440", "\u92A8", 5, "\u92AF", 24, "\u92C9", 31],
      ["e480", "\u92E9", 32, "\u6D39\u6D27\u6D0C\u6D43\u6D48\u6D07\u6D04\u6D19\u6D0E\u6D2B\u6D4D\u6D2E\u6D35\u6D1A\u6D4F\u6D52\u6D54\u6D33\u6D91\u6D6F\u6D9E\u6DA0\u6D5E\u6D93\u6D94\u6D5C\u6D60\u6D7C\u6D63\u6E1A\u6DC7\u6DC5\u6DDE\u6E0E\u6DBF\u6DE0\u6E11\u6DE6\u6DDD\u6DD9\u6E16\u6DAB\u6E0C\u6DAE\u6E2B\u6E6E\u6E4E\u6E6B\u6EB2\u6E5F\u6E86\u6E53\u6E54\u6E32\u6E25\u6E44\u6EDF\u6EB1\u6E98\u6EE0\u6F2D\u6EE2\u6EA5\u6EA7\u6EBD\u6EBB\u6EB7\u6ED7\u6EB4\u6ECF\u6E8F\u6EC2\u6E9F\u6F62\u6F46\u6F47\u6F24\u6F15\u6EF9\u6F2F\u6F36\u6F4B\u6F74\u6F2A\u6F09\u6F29\u6F89\u6F8D\u6F8C\u6F78\u6F72\u6F7C\u6F7A\u6FD1"],
      ["e540", "\u930A", 51, "\u933F", 10],
      ["e580", "\u934A", 31, "\u936B\u6FC9\u6FA7\u6FB9\u6FB6\u6FC2\u6FE1\u6FEE\u6FDE\u6FE0\u6FEF\u701A\u7023\u701B\u7039\u7035\u704F\u705E\u5B80\u5B84\u5B95\u5B93\u5BA5\u5BB8\u752F\u9A9E\u6434\u5BE4\u5BEE\u8930\u5BF0\u8E47\u8B07\u8FB6\u8FD3\u8FD5\u8FE5\u8FEE\u8FE4\u8FE9\u8FE6\u8FF3\u8FE8\u9005\u9004\u900B\u9026\u9011\u900D\u9016\u9021\u9035\u9036\u902D\u902F\u9044\u9051\u9052\u9050\u9068\u9058\u9062\u905B\u66B9\u9074\u907D\u9082\u9088\u9083\u908B\u5F50\u5F57\u5F56\u5F58\u5C3B\u54AB\u5C50\u5C59\u5B71\u5C63\u5C66\u7FBC\u5F2A\u5F29\u5F2D\u8274\u5F3C\u9B3B\u5C6E\u5981\u5983\u598D\u59A9\u59AA\u59A3"],
      ["e640", "\u936C", 34, "\u9390", 27],
      ["e680", "\u93AC", 29, "\u93CB\u93CC\u93CD\u5997\u59CA\u59AB\u599E\u59A4\u59D2\u59B2\u59AF\u59D7\u59BE\u5A05\u5A06\u59DD\u5A08\u59E3\u59D8\u59F9\u5A0C\u5A09\u5A32\u5A34\u5A11\u5A23\u5A13\u5A40\u5A67\u5A4A\u5A55\u5A3C\u5A62\u5A75\u80EC\u5AAA\u5A9B\u5A77\u5A7A\u5ABE\u5AEB\u5AB2\u5AD2\u5AD4\u5AB8\u5AE0\u5AE3\u5AF1\u5AD6\u5AE6\u5AD8\u5ADC\u5B09\u5B17\u5B16\u5B32\u5B37\u5B40\u5C15\u5C1C\u5B5A\u5B65\u5B73\u5B51\u5B53\u5B62\u9A75\u9A77\u9A78\u9A7A\u9A7F\u9A7D\u9A80\u9A81\u9A85\u9A88\u9A8A\u9A90\u9A92\u9A93\u9A96\u9A98\u9A9B\u9A9C\u9A9D\u9A9F\u9AA0\u9AA2\u9AA3\u9AA5\u9AA7\u7E9F\u7EA1\u7EA3\u7EA5\u7EA8\u7EA9"],
      ["e740", "\u93CE", 7, "\u93D7", 54],
      ["e780", "\u940E", 32, "\u7EAD\u7EB0\u7EBE\u7EC0\u7EC1\u7EC2\u7EC9\u7ECB\u7ECC\u7ED0\u7ED4\u7ED7\u7EDB\u7EE0\u7EE1\u7EE8\u7EEB\u7EEE\u7EEF\u7EF1\u7EF2\u7F0D\u7EF6\u7EFA\u7EFB\u7EFE\u7F01\u7F02\u7F03\u7F07\u7F08\u7F0B\u7F0C\u7F0F\u7F11\u7F12\u7F17\u7F19\u7F1C\u7F1B\u7F1F\u7F21", 6, "\u7F2A\u7F2B\u7F2C\u7F2D\u7F2F", 4, "\u7F35\u5E7A\u757F\u5DDB\u753E\u9095\u738E\u7391\u73AE\u73A2\u739F\u73CF\u73C2\u73D1\u73B7\u73B3\u73C0\u73C9\u73C8\u73E5\u73D9\u987C\u740A\u73E9\u73E7\u73DE\u73BA\u73F2\u740F\u742A\u745B\u7426\u7425\u7428\u7430\u742E\u742C"],
      ["e840", "\u942F", 14, "\u943F", 43, "\u946C\u946D\u946E\u946F"],
      ["e880", "\u9470", 20, "\u9491\u9496\u9498\u94C7\u94CF\u94D3\u94D4\u94DA\u94E6\u94FB\u951C\u9520\u741B\u741A\u7441\u745C\u7457\u7455\u7459\u7477\u746D\u747E\u749C\u748E\u7480\u7481\u7487\u748B\u749E\u74A8\u74A9\u7490\u74A7\u74D2\u74BA\u97EA\u97EB\u97EC\u674C\u6753\u675E\u6748\u6769\u67A5\u6787\u676A\u6773\u6798\u67A7\u6775\u67A8\u679E\u67AD\u678B\u6777\u677C\u67F0\u6809\u67D8\u680A\u67E9\u67B0\u680C\u67D9\u67B5\u67DA\u67B3\u67DD\u6800\u67C3\u67B8\u67E2\u680E\u67C1\u67FD\u6832\u6833\u6860\u6861\u684E\u6862\u6844\u6864\u6883\u681D\u6855\u6866\u6841\u6867\u6840\u683E\u684A\u6849\u6829\u68B5\u688F\u6874\u6877\u6893\u686B\u68C2\u696E\u68FC\u691F\u6920\u68F9"],
      ["e940", "\u9527\u9533\u953D\u9543\u9548\u954B\u9555\u955A\u9560\u956E\u9574\u9575\u9577", 7, "\u9580", 42],
      ["e980", "\u95AB", 32, "\u6924\u68F0\u690B\u6901\u6957\u68E3\u6910\u6971\u6939\u6960\u6942\u695D\u6984\u696B\u6980\u6998\u6978\u6934\u69CC\u6987\u6988\u69CE\u6989\u6966\u6963\u6979\u699B\u69A7\u69BB\u69AB\u69AD\u69D4\u69B1\u69C1\u69CA\u69DF\u6995\u69E0\u698D\u69FF\u6A2F\u69ED\u6A17\u6A18\u6A65\u69F2\u6A44\u6A3E\u6AA0\u6A50\u6A5B\u6A35\u6A8E\u6A79\u6A3D\u6A28\u6A58\u6A7C\u6A91\u6A90\u6AA9\u6A97\u6AAB\u7337\u7352\u6B81\u6B82\u6B87\u6B84\u6B92\u6B93\u6B8D\u6B9A\u6B9B\u6BA1\u6BAA\u8F6B\u8F6D\u8F71\u8F72\u8F73\u8F75\u8F76\u8F78\u8F77\u8F79\u8F7A\u8F7C\u8F7E\u8F81\u8F82\u8F84\u8F87\u8F8B"],
      ["ea40", "\u95CC", 27, "\u95EC\u95FF\u9607\u9613\u9618\u961B\u961E\u9620\u9623", 6, "\u962B\u962C\u962D\u962F\u9630\u9637\u9638\u9639\u963A\u963E\u9641\u9643\u964A\u964E\u964F\u9651\u9652\u9653\u9656\u9657"],
      ["ea80", "\u9658\u9659\u965A\u965C\u965D\u965E\u9660\u9663\u9665\u9666\u966B\u966D", 4, "\u9673\u9678", 12, "\u9687\u9689\u968A\u8F8D\u8F8E\u8F8F\u8F98\u8F9A\u8ECE\u620B\u6217\u621B\u621F\u6222\u6221\u6225\u6224\u622C\u81E7\u74EF\u74F4\u74FF\u750F\u7511\u7513\u6534\u65EE\u65EF\u65F0\u660A\u6619\u6772\u6603\u6615\u6600\u7085\u66F7\u661D\u6634\u6631\u6636\u6635\u8006\u665F\u6654\u6641\u664F\u6656\u6661\u6657\u6677\u6684\u668C\u66A7\u669D\u66BE\u66DB\u66DC\u66E6\u66E9\u8D32\u8D33\u8D36\u8D3B\u8D3D\u8D40\u8D45\u8D46\u8D48\u8D49\u8D47\u8D4D\u8D55\u8D59\u89C7\u89CA\u89CB\u89CC\u89CE\u89CF\u89D0\u89D1\u726E\u729F\u725D\u7266\u726F\u727E\u727F\u7284\u728B\u728D\u728F\u7292\u6308\u6332\u63B0"],
      ["eb40", "\u968C\u968E\u9691\u9692\u9693\u9695\u9696\u969A\u969B\u969D", 9, "\u96A8", 7, "\u96B1\u96B2\u96B4\u96B5\u96B7\u96B8\u96BA\u96BB\u96BF\u96C2\u96C3\u96C8\u96CA\u96CB\u96D0\u96D1\u96D3\u96D4\u96D6", 9, "\u96E1", 6, "\u96EB"],
      ["eb80", "\u96EC\u96ED\u96EE\u96F0\u96F1\u96F2\u96F4\u96F5\u96F8\u96FA\u96FB\u96FC\u96FD\u96FF\u9702\u9703\u9705\u970A\u970B\u970C\u9710\u9711\u9712\u9714\u9715\u9717", 4, "\u971D\u971F\u9720\u643F\u64D8\u8004\u6BEA\u6BF3\u6BFD\u6BF5\u6BF9\u6C05\u6C07\u6C06\u6C0D\u6C15\u6C18\u6C19\u6C1A\u6C21\u6C29\u6C24\u6C2A\u6C32\u6535\u6555\u656B\u724D\u7252\u7256\u7230\u8662\u5216\u809F\u809C\u8093\u80BC\u670A\u80BD\u80B1\u80AB\u80AD\u80B4\u80B7\u80E7\u80E8\u80E9\u80EA\u80DB\u80C2\u80C4\u80D9\u80CD\u80D7\u6710\u80DD\u80EB\u80F1\u80F4\u80ED\u810D\u810E\u80F2\u80FC\u6715\u8112\u8C5A\u8136\u811E\u812C\u8118\u8132\u8148\u814C\u8153\u8174\u8159\u815A\u8171\u8160\u8169\u817C\u817D\u816D\u8167\u584D\u5AB5\u8188\u8182\u8191\u6ED5\u81A3\u81AA\u81CC\u6726\u81CA\u81BB"],
      ["ec40", "\u9721", 8, "\u972B\u972C\u972E\u972F\u9731\u9733", 4, "\u973A\u973B\u973C\u973D\u973F", 18, "\u9754\u9755\u9757\u9758\u975A\u975C\u975D\u975F\u9763\u9764\u9766\u9767\u9768\u976A", 7],
      ["ec80", "\u9772\u9775\u9777", 4, "\u977D", 7, "\u9786", 4, "\u978C\u978E\u978F\u9790\u9793\u9795\u9796\u9797\u9799", 4, "\u81C1\u81A6\u6B24\u6B37\u6B39\u6B43\u6B46\u6B59\u98D1\u98D2\u98D3\u98D5\u98D9\u98DA\u6BB3\u5F40\u6BC2\u89F3\u6590\u9F51\u6593\u65BC\u65C6\u65C4\u65C3\u65CC\u65CE\u65D2\u65D6\u7080\u709C\u7096\u709D\u70BB\u70C0\u70B7\u70AB\u70B1\u70E8\u70CA\u7110\u7113\u7116\u712F\u7131\u7173\u715C\u7168\u7145\u7172\u714A\u7178\u717A\u7198\u71B3\u71B5\u71A8\u71A0\u71E0\u71D4\u71E7\u71F9\u721D\u7228\u706C\u7118\u7166\u71B9\u623E\u623D\u6243\u6248\u6249\u793B\u7940\u7946\u7949\u795B\u795C\u7953\u795A\u7962\u7957\u7960\u796F\u7967\u797A\u7985\u798A\u799A\u79A7\u79B3\u5FD1\u5FD0"],
      ["ed40", "\u979E\u979F\u97A1\u97A2\u97A4", 6, "\u97AC\u97AE\u97B0\u97B1\u97B3\u97B5", 46],
      ["ed80", "\u97E4\u97E5\u97E8\u97EE", 4, "\u97F4\u97F7", 23, "\u603C\u605D\u605A\u6067\u6041\u6059\u6063\u60AB\u6106\u610D\u615D\u61A9\u619D\u61CB\u61D1\u6206\u8080\u807F\u6C93\u6CF6\u6DFC\u77F6\u77F8\u7800\u7809\u7817\u7818\u7811\u65AB\u782D\u781C\u781D\u7839\u783A\u783B\u781F\u783C\u7825\u782C\u7823\u7829\u784E\u786D\u7856\u7857\u7826\u7850\u7847\u784C\u786A\u789B\u7893\u789A\u7887\u789C\u78A1\u78A3\u78B2\u78B9\u78A5\u78D4\u78D9\u78C9\u78EC\u78F2\u7905\u78F4\u7913\u7924\u791E\u7934\u9F9B\u9EF9\u9EFB\u9EFC\u76F1\u7704\u770D\u76F9\u7707\u7708\u771A\u7722\u7719\u772D\u7726\u7735\u7738\u7750\u7751\u7747\u7743\u775A\u7768"],
      ["ee40", "\u980F", 62],
      ["ee80", "\u984E", 32, "\u7762\u7765\u777F\u778D\u777D\u7780\u778C\u7791\u779F\u77A0\u77B0\u77B5\u77BD\u753A\u7540\u754E\u754B\u7548\u755B\u7572\u7579\u7583\u7F58\u7F61\u7F5F\u8A48\u7F68\u7F74\u7F71\u7F79\u7F81\u7F7E\u76CD\u76E5\u8832\u9485\u9486\u9487\u948B\u948A\u948C\u948D\u948F\u9490\u9494\u9497\u9495\u949A\u949B\u949C\u94A3\u94A4\u94AB\u94AA\u94AD\u94AC\u94AF\u94B0\u94B2\u94B4\u94B6", 4, "\u94BC\u94BD\u94BF\u94C4\u94C8", 6, "\u94D0\u94D1\u94D2\u94D5\u94D6\u94D7\u94D9\u94D8\u94DB\u94DE\u94DF\u94E0\u94E2\u94E4\u94E5\u94E7\u94E8\u94EA"],
      ["ef40", "\u986F", 5, "\u988B\u988E\u9892\u9895\u9899\u98A3\u98A8", 37, "\u98CF\u98D0\u98D4\u98D6\u98D7\u98DB\u98DC\u98DD\u98E0", 4],
      ["ef80", "\u98E5\u98E6\u98E9", 30, "\u94E9\u94EB\u94EE\u94EF\u94F3\u94F4\u94F5\u94F7\u94F9\u94FC\u94FD\u94FF\u9503\u9502\u9506\u9507\u9509\u950A\u950D\u950E\u950F\u9512", 4, "\u9518\u951B\u951D\u951E\u951F\u9522\u952A\u952B\u9529\u952C\u9531\u9532\u9534\u9536\u9537\u9538\u953C\u953E\u953F\u9542\u9535\u9544\u9545\u9546\u9549\u954C\u954E\u954F\u9552\u9553\u9554\u9556\u9557\u9558\u9559\u955B\u955E\u955F\u955D\u9561\u9562\u9564", 8, "\u956F\u9571\u9572\u9573\u953A\u77E7\u77EC\u96C9\u79D5\u79ED\u79E3\u79EB\u7A06\u5D47\u7A03\u7A02\u7A1E\u7A14"],
      ["f040", "\u9908", 4, "\u990E\u990F\u9911", 28, "\u992F", 26],
      ["f080", "\u994A", 9, "\u9956", 12, "\u9964\u9966\u9973\u9978\u9979\u997B\u997E\u9982\u9983\u9989\u7A39\u7A37\u7A51\u9ECF\u99A5\u7A70\u7688\u768E\u7693\u7699\u76A4\u74DE\u74E0\u752C\u9E20\u9E22\u9E28", 4, "\u9E32\u9E31\u9E36\u9E38\u9E37\u9E39\u9E3A\u9E3E\u9E41\u9E42\u9E44\u9E46\u9E47\u9E48\u9E49\u9E4B\u9E4C\u9E4E\u9E51\u9E55\u9E57\u9E5A\u9E5B\u9E5C\u9E5E\u9E63\u9E66", 6, "\u9E71\u9E6D\u9E73\u7592\u7594\u7596\u75A0\u759D\u75AC\u75A3\u75B3\u75B4\u75B8\u75C4\u75B1\u75B0\u75C3\u75C2\u75D6\u75CD\u75E3\u75E8\u75E6\u75E4\u75EB\u75E7\u7603\u75F1\u75FC\u75FF\u7610\u7600\u7605\u760C\u7617\u760A\u7625\u7618\u7615\u7619"],
      ["f140", "\u998C\u998E\u999A", 10, "\u99A6\u99A7\u99A9", 47],
      ["f180", "\u99D9", 32, "\u761B\u763C\u7622\u7620\u7640\u762D\u7630\u763F\u7635\u7643\u763E\u7633\u764D\u765E\u7654\u765C\u7656\u766B\u766F\u7FCA\u7AE6\u7A78\u7A79\u7A80\u7A86\u7A88\u7A95\u7AA6\u7AA0\u7AAC\u7AA8\u7AAD\u7AB3\u8864\u8869\u8872\u887D\u887F\u8882\u88A2\u88C6\u88B7\u88BC\u88C9\u88E2\u88CE\u88E3\u88E5\u88F1\u891A\u88FC\u88E8\u88FE\u88F0\u8921\u8919\u8913\u891B\u890A\u8934\u892B\u8936\u8941\u8966\u897B\u758B\u80E5\u76B2\u76B4\u77DC\u8012\u8014\u8016\u801C\u8020\u8022\u8025\u8026\u8027\u8029\u8028\u8031\u800B\u8035\u8043\u8046\u804D\u8052\u8069\u8071\u8983\u9878\u9880\u9883"],
      ["f240", "\u99FA", 62],
      ["f280", "\u9A39", 32, "\u9889\u988C\u988D\u988F\u9894\u989A\u989B\u989E\u989F\u98A1\u98A2\u98A5\u98A6\u864D\u8654\u866C\u866E\u867F\u867A\u867C\u867B\u86A8\u868D\u868B\u86AC\u869D\u86A7\u86A3\u86AA\u8693\u86A9\u86B6\u86C4\u86B5\u86CE\u86B0\u86BA\u86B1\u86AF\u86C9\u86CF\u86B4\u86E9\u86F1\u86F2\u86ED\u86F3\u86D0\u8713\u86DE\u86F4\u86DF\u86D8\u86D1\u8703\u8707\u86F8\u8708\u870A\u870D\u8709\u8723\u873B\u871E\u8725\u872E\u871A\u873E\u8748\u8734\u8731\u8729\u8737\u873F\u8782\u8722\u877D\u877E\u877B\u8760\u8770\u874C\u876E\u878B\u8753\u8763\u877C\u8764\u8759\u8765\u8793\u87AF\u87A8\u87D2"],
      ["f340", "\u9A5A", 17, "\u9A72\u9A83\u9A89\u9A8D\u9A8E\u9A94\u9A95\u9A99\u9AA6\u9AA9", 6, "\u9AB2\u9AB3\u9AB4\u9AB5\u9AB9\u9ABB\u9ABD\u9ABE\u9ABF\u9AC3\u9AC4\u9AC6", 4, "\u9ACD\u9ACE\u9ACF\u9AD0\u9AD2\u9AD4\u9AD5\u9AD6\u9AD7\u9AD9\u9ADA\u9ADB\u9ADC"],
      ["f380", "\u9ADD\u9ADE\u9AE0\u9AE2\u9AE3\u9AE4\u9AE5\u9AE7\u9AE8\u9AE9\u9AEA\u9AEC\u9AEE\u9AF0", 8, "\u9AFA\u9AFC", 6, "\u9B04\u9B05\u9B06\u87C6\u8788\u8785\u87AD\u8797\u8783\u87AB\u87E5\u87AC\u87B5\u87B3\u87CB\u87D3\u87BD\u87D1\u87C0\u87CA\u87DB\u87EA\u87E0\u87EE\u8816\u8813\u87FE\u880A\u881B\u8821\u8839\u883C\u7F36\u7F42\u7F44\u7F45\u8210\u7AFA\u7AFD\u7B08\u7B03\u7B04\u7B15\u7B0A\u7B2B\u7B0F\u7B47\u7B38\u7B2A\u7B19\u7B2E\u7B31\u7B20\u7B25\u7B24\u7B33\u7B3E\u7B1E\u7B58\u7B5A\u7B45\u7B75\u7B4C\u7B5D\u7B60\u7B6E\u7B7B\u7B62\u7B72\u7B71\u7B90\u7BA6\u7BA7\u7BB8\u7BAC\u7B9D\u7BA8\u7B85\u7BAA\u7B9C\u7BA2\u7BAB\u7BB4\u7BD1\u7BC1\u7BCC\u7BDD\u7BDA\u7BE5\u7BE6\u7BEA\u7C0C\u7BFE\u7BFC\u7C0F\u7C16\u7C0B"],
      ["f440", "\u9B07\u9B09", 5, "\u9B10\u9B11\u9B12\u9B14", 10, "\u9B20\u9B21\u9B22\u9B24", 10, "\u9B30\u9B31\u9B33", 7, "\u9B3D\u9B3E\u9B3F\u9B40\u9B46\u9B4A\u9B4B\u9B4C\u9B4E\u9B50\u9B52\u9B53\u9B55", 5],
      ["f480", "\u9B5B", 32, "\u7C1F\u7C2A\u7C26\u7C38\u7C41\u7C40\u81FE\u8201\u8202\u8204\u81EC\u8844\u8221\u8222\u8223\u822D\u822F\u8228\u822B\u8238\u823B\u8233\u8234\u823E\u8244\u8249\u824B\u824F\u825A\u825F\u8268\u887E\u8885\u8888\u88D8\u88DF\u895E\u7F9D\u7F9F\u7FA7\u7FAF\u7FB0\u7FB2\u7C7C\u6549\u7C91\u7C9D\u7C9C\u7C9E\u7CA2\u7CB2\u7CBC\u7CBD\u7CC1\u7CC7\u7CCC\u7CCD\u7CC8\u7CC5\u7CD7\u7CE8\u826E\u66A8\u7FBF\u7FCE\u7FD5\u7FE5\u7FE1\u7FE6\u7FE9\u7FEE\u7FF3\u7CF8\u7D77\u7DA6\u7DAE\u7E47\u7E9B\u9EB8\u9EB4\u8D73\u8D84\u8D94\u8D91\u8DB1\u8D67\u8D6D\u8C47\u8C49\u914A\u9150\u914E\u914F\u9164"],
      ["f540", "\u9B7C", 62],
      ["f580", "\u9BBB", 32, "\u9162\u9161\u9170\u9169\u916F\u917D\u917E\u9172\u9174\u9179\u918C\u9185\u9190\u918D\u9191\u91A2\u91A3\u91AA\u91AD\u91AE\u91AF\u91B5\u91B4\u91BA\u8C55\u9E7E\u8DB8\u8DEB\u8E05\u8E59\u8E69\u8DB5\u8DBF\u8DBC\u8DBA\u8DC4\u8DD6\u8DD7\u8DDA\u8DDE\u8DCE\u8DCF\u8DDB\u8DC6\u8DEC\u8DF7\u8DF8\u8DE3\u8DF9\u8DFB\u8DE4\u8E09\u8DFD\u8E14\u8E1D\u8E1F\u8E2C\u8E2E\u8E23\u8E2F\u8E3A\u8E40\u8E39\u8E35\u8E3D\u8E31\u8E49\u8E41\u8E42\u8E51\u8E52\u8E4A\u8E70\u8E76\u8E7C\u8E6F\u8E74\u8E85\u8E8F\u8E94\u8E90\u8E9C\u8E9E\u8C78\u8C82\u8C8A\u8C85\u8C98\u8C94\u659B\u89D6\u89DE\u89DA\u89DC"],
      ["f640", "\u9BDC", 62],
      ["f680", "\u9C1B", 32, "\u89E5\u89EB\u89EF\u8A3E\u8B26\u9753\u96E9\u96F3\u96EF\u9706\u9701\u9708\u970F\u970E\u972A\u972D\u9730\u973E\u9F80\u9F83\u9F85", 5, "\u9F8C\u9EFE\u9F0B\u9F0D\u96B9\u96BC\u96BD\u96CE\u96D2\u77BF\u96E0\u928E\u92AE\u92C8\u933E\u936A\u93CA\u938F\u943E\u946B\u9C7F\u9C82\u9C85\u9C86\u9C87\u9C88\u7A23\u9C8B\u9C8E\u9C90\u9C91\u9C92\u9C94\u9C95\u9C9A\u9C9B\u9C9E", 5, "\u9CA5", 4, "\u9CAB\u9CAD\u9CAE\u9CB0", 7, "\u9CBA\u9CBB\u9CBC\u9CBD\u9CC4\u9CC5\u9CC6\u9CC7\u9CCA\u9CCB"],
      ["f740", "\u9C3C", 62],
      ["f780", "\u9C7B\u9C7D\u9C7E\u9C80\u9C83\u9C84\u9C89\u9C8A\u9C8C\u9C8F\u9C93\u9C96\u9C97\u9C98\u9C99\u9C9D\u9CAA\u9CAC\u9CAF\u9CB9\u9CBE", 4, "\u9CC8\u9CC9\u9CD1\u9CD2\u9CDA\u9CDB\u9CE0\u9CE1\u9CCC", 4, "\u9CD3\u9CD4\u9CD5\u9CD7\u9CD8\u9CD9\u9CDC\u9CDD\u9CDF\u9CE2\u977C\u9785\u9791\u9792\u9794\u97AF\u97AB\u97A3\u97B2\u97B4\u9AB1\u9AB0\u9AB7\u9E58\u9AB6\u9ABA\u9ABC\u9AC1\u9AC0\u9AC5\u9AC2\u9ACB\u9ACC\u9AD1\u9B45\u9B43\u9B47\u9B49\u9B48\u9B4D\u9B51\u98E8\u990D\u992E\u9955\u9954\u9ADF\u9AE1\u9AE6\u9AEF\u9AEB\u9AFB\u9AED\u9AF9\u9B08\u9B0F\u9B13\u9B1F\u9B23\u9EBD\u9EBE\u7E3B\u9E82\u9E87\u9E88\u9E8B\u9E92\u93D6\u9E9D\u9E9F\u9EDB\u9EDC\u9EDD\u9EE0\u9EDF\u9EE2\u9EE9\u9EE7\u9EE5\u9EEA\u9EEF\u9F22\u9F2C\u9F2F\u9F39\u9F37\u9F3D\u9F3E\u9F44"],
      ["f840", "\u9CE3", 62],
      ["f880", "\u9D22", 32],
      ["f940", "\u9D43", 62],
      ["f980", "\u9D82", 32],
      ["fa40", "\u9DA3", 62],
      ["fa80", "\u9DE2", 32],
      ["fb40", "\u9E03", 27, "\u9E24\u9E27\u9E2E\u9E30\u9E34\u9E3B\u9E3C\u9E40\u9E4D\u9E50\u9E52\u9E53\u9E54\u9E56\u9E59\u9E5D\u9E5F\u9E60\u9E61\u9E62\u9E65\u9E6E\u9E6F\u9E72\u9E74", 9, "\u9E80"],
      ["fb80", "\u9E81\u9E83\u9E84\u9E85\u9E86\u9E89\u9E8A\u9E8C", 5, "\u9E94", 8, "\u9E9E\u9EA0", 5, "\u9EA7\u9EA8\u9EA9\u9EAA"],
      ["fc40", "\u9EAB", 8, "\u9EB5\u9EB6\u9EB7\u9EB9\u9EBA\u9EBC\u9EBF", 4, "\u9EC5\u9EC6\u9EC7\u9EC8\u9ECA\u9ECB\u9ECC\u9ED0\u9ED2\u9ED3\u9ED5\u9ED6\u9ED7\u9ED9\u9EDA\u9EDE\u9EE1\u9EE3\u9EE4\u9EE6\u9EE8\u9EEB\u9EEC\u9EED\u9EEE\u9EF0", 8, "\u9EFA\u9EFD\u9EFF", 6],
      ["fc80", "\u9F06", 4, "\u9F0C\u9F0F\u9F11\u9F12\u9F14\u9F15\u9F16\u9F18\u9F1A", 5, "\u9F21\u9F23", 8, "\u9F2D\u9F2E\u9F30\u9F31"],
      ["fd40", "\u9F32", 4, "\u9F38\u9F3A\u9F3C\u9F3F", 4, "\u9F45", 10, "\u9F52", 38],
      ["fd80", "\u9F79", 5, "\u9F81\u9F82\u9F8D", 11, "\u9F9C\u9F9D\u9F9E\u9FA1", 4, "\uF92C\uF979\uF995\uF9E7\uF9F1"],
      ["fe40", "\uFA0C\uFA0D\uFA0E\uFA0F\uFA11\uFA13\uFA14\uFA18\uFA1F\uFA20\uFA21\uFA23\uFA24\uFA27\uFA28\uFA29"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS({
  "node_modules/iconv-lite/encodings/tables/gbk-added.json"(exports2, module2) {
    module2.exports = [
      ["a140", "\uE4C6", 62],
      ["a180", "\uE505", 32],
      ["a240", "\uE526", 62],
      ["a280", "\uE565", 32],
      ["a2ab", "\uE766", 5],
      ["a2e3", "\u20AC\uE76D"],
      ["a2ef", "\uE76E\uE76F"],
      ["a2fd", "\uE770\uE771"],
      ["a340", "\uE586", 62],
      ["a380", "\uE5C5", 31, "\u3000"],
      ["a440", "\uE5E6", 62],
      ["a480", "\uE625", 32],
      ["a4f4", "\uE772", 10],
      ["a540", "\uE646", 62],
      ["a580", "\uE685", 32],
      ["a5f7", "\uE77D", 7],
      ["a640", "\uE6A6", 62],
      ["a680", "\uE6E5", 32],
      ["a6b9", "\uE785", 7],
      ["a6d9", "\uE78D", 6],
      ["a6ec", "\uE794\uE795"],
      ["a6f3", "\uE796"],
      ["a6f6", "\uE797", 8],
      ["a740", "\uE706", 62],
      ["a780", "\uE745", 32],
      ["a7c2", "\uE7A0", 14],
      ["a7f2", "\uE7AF", 12],
      ["a896", "\uE7BC", 10],
      ["a8bc", "\u1E3F"],
      ["a8bf", "\u01F9"],
      ["a8c1", "\uE7C9\uE7CA\uE7CB\uE7CC"],
      ["a8ea", "\uE7CD", 20],
      ["a958", "\uE7E2"],
      ["a95b", "\uE7E3"],
      ["a95d", "\uE7E4\uE7E5\uE7E6"],
      ["a989", "\u303E\u2FF0", 11],
      ["a997", "\uE7F4", 12],
      ["a9f0", "\uE801", 14],
      ["aaa1", "\uE000", 93],
      ["aba1", "\uE05E", 93],
      ["aca1", "\uE0BC", 93],
      ["ada1", "\uE11A", 93],
      ["aea1", "\uE178", 93],
      ["afa1", "\uE1D6", 93],
      ["d7fa", "\uE810", 4],
      ["f8a1", "\uE234", 93],
      ["f9a1", "\uE292", 93],
      ["faa1", "\uE2F0", 93],
      ["fba1", "\uE34E", 93],
      ["fca1", "\uE3AC", 93],
      ["fda1", "\uE40A", 93],
      ["fe50", "\u2E81\uE816\uE817\uE818\u2E84\u3473\u3447\u2E88\u2E8B\uE81E\u359E\u361A\u360E\u2E8C\u2E97\u396E\u3918\uE826\u39CF\u39DF\u3A73\u39D0\uE82B\uE82C\u3B4E\u3C6E\u3CE0\u2EA7\uE831\uE832\u2EAA\u4056\u415F\u2EAE\u4337\u2EB3\u2EB6\u2EB7\uE83B\u43B1\u43AC\u2EBB\u43DD\u44D6\u4661\u464C\uE843"],
      ["fe80", "\u4723\u4729\u477C\u478D\u2ECA\u4947\u497A\u497D\u4982\u4983\u4985\u4986\u499F\u499B\u49B7\u49B6\uE854\uE855\u4CA3\u4C9F\u4CA0\u4CA1\u4C77\u4CA2\u4D13", 6, "\u4DAE\uE864\uE468", 93],
      ["8135f437", "\uE7C7"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS({
  "node_modules/iconv-lite/encodings/tables/gb18030-ranges.json"(exports2, module2) {
    module2.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3] };
  }
});

// node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp949.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["8141", "\uAC02\uAC03\uAC05\uAC06\uAC0B", 4, "\uAC18\uAC1E\uAC1F\uAC21\uAC22\uAC23\uAC25", 6, "\uAC2E\uAC32\uAC33\uAC34"],
      ["8161", "\uAC35\uAC36\uAC37\uAC3A\uAC3B\uAC3D\uAC3E\uAC3F\uAC41", 9, "\uAC4C\uAC4E", 5, "\uAC55"],
      ["8181", "\uAC56\uAC57\uAC59\uAC5A\uAC5B\uAC5D", 18, "\uAC72\uAC73\uAC75\uAC76\uAC79\uAC7B", 4, "\uAC82\uAC87\uAC88\uAC8D\uAC8E\uAC8F\uAC91\uAC92\uAC93\uAC95", 6, "\uAC9E\uACA2", 5, "\uACAB\uACAD\uACAE\uACB1", 6, "\uACBA\uACBE\uACBF\uACC0\uACC2\uACC3\uACC5\uACC6\uACC7\uACC9\uACCA\uACCB\uACCD", 7, "\uACD6\uACD8", 7, "\uACE2\uACE3\uACE5\uACE6\uACE9\uACEB\uACED\uACEE\uACF2\uACF4\uACF7", 4, "\uACFE\uACFF\uAD01\uAD02\uAD03\uAD05\uAD07", 4, "\uAD0E\uAD10\uAD12\uAD13"],
      ["8241", "\uAD14\uAD15\uAD16\uAD17\uAD19\uAD1A\uAD1B\uAD1D\uAD1E\uAD1F\uAD21", 7, "\uAD2A\uAD2B\uAD2E", 5],
      ["8261", "\uAD36\uAD37\uAD39\uAD3A\uAD3B\uAD3D", 6, "\uAD46\uAD48\uAD4A", 5, "\uAD51\uAD52\uAD53\uAD55\uAD56\uAD57"],
      ["8281", "\uAD59", 7, "\uAD62\uAD64", 7, "\uAD6E\uAD6F\uAD71\uAD72\uAD77\uAD78\uAD79\uAD7A\uAD7E\uAD80\uAD83", 4, "\uAD8A\uAD8B\uAD8D\uAD8E\uAD8F\uAD91", 10, "\uAD9E", 5, "\uADA5", 17, "\uADB8", 7, "\uADC2\uADC3\uADC5\uADC6\uADC7\uADC9", 6, "\uADD2\uADD4", 7, "\uADDD\uADDE\uADDF\uADE1\uADE2\uADE3\uADE5", 18],
      ["8341", "\uADFA\uADFB\uADFD\uADFE\uAE02", 5, "\uAE0A\uAE0C\uAE0E", 5, "\uAE15", 7],
      ["8361", "\uAE1D", 18, "\uAE32\uAE33\uAE35\uAE36\uAE39\uAE3B\uAE3C"],
      ["8381", "\uAE3D\uAE3E\uAE3F\uAE42\uAE44\uAE47\uAE48\uAE49\uAE4B\uAE4F\uAE51\uAE52\uAE53\uAE55\uAE57", 4, "\uAE5E\uAE62\uAE63\uAE64\uAE66\uAE67\uAE6A\uAE6B\uAE6D\uAE6E\uAE6F\uAE71", 6, "\uAE7A\uAE7E", 5, "\uAE86", 5, "\uAE8D", 46, "\uAEBF\uAEC1\uAEC2\uAEC3\uAEC5", 6, "\uAECE\uAED2", 5, "\uAEDA\uAEDB\uAEDD", 8],
      ["8441", "\uAEE6\uAEE7\uAEE9\uAEEA\uAEEC\uAEEE", 5, "\uAEF5\uAEF6\uAEF7\uAEF9\uAEFA\uAEFB\uAEFD", 8],
      ["8461", "\uAF06\uAF09\uAF0A\uAF0B\uAF0C\uAF0E\uAF0F\uAF11", 18],
      ["8481", "\uAF24", 7, "\uAF2E\uAF2F\uAF31\uAF33\uAF35", 6, "\uAF3E\uAF40\uAF44\uAF45\uAF46\uAF47\uAF4A", 5, "\uAF51", 10, "\uAF5E", 5, "\uAF66", 18, "\uAF7A", 5, "\uAF81\uAF82\uAF83\uAF85\uAF86\uAF87\uAF89", 6, "\uAF92\uAF93\uAF94\uAF96", 5, "\uAF9D", 26, "\uAFBA\uAFBB\uAFBD\uAFBE"],
      ["8541", "\uAFBF\uAFC1", 5, "\uAFCA\uAFCC\uAFCF", 4, "\uAFD5", 6, "\uAFDD", 4],
      ["8561", "\uAFE2", 5, "\uAFEA", 5, "\uAFF2\uAFF3\uAFF5\uAFF6\uAFF7\uAFF9", 6, "\uB002\uB003"],
      ["8581", "\uB005", 6, "\uB00D\uB00E\uB00F\uB011\uB012\uB013\uB015", 6, "\uB01E", 9, "\uB029", 26, "\uB046\uB047\uB049\uB04B\uB04D\uB04F\uB050\uB051\uB052\uB056\uB058\uB05A\uB05B\uB05C\uB05E", 29, "\uB07E\uB07F\uB081\uB082\uB083\uB085", 6, "\uB08E\uB090\uB092", 5, "\uB09B\uB09D\uB09E\uB0A3\uB0A4"],
      ["8641", "\uB0A5\uB0A6\uB0A7\uB0AA\uB0B0\uB0B2\uB0B6\uB0B7\uB0B9\uB0BA\uB0BB\uB0BD", 6, "\uB0C6\uB0CA", 5, "\uB0D2"],
      ["8661", "\uB0D3\uB0D5\uB0D6\uB0D7\uB0D9", 6, "\uB0E1\uB0E2\uB0E3\uB0E4\uB0E6", 10],
      ["8681", "\uB0F1", 22, "\uB10A\uB10D\uB10E\uB10F\uB111\uB114\uB115\uB116\uB117\uB11A\uB11E", 4, "\uB126\uB127\uB129\uB12A\uB12B\uB12D", 6, "\uB136\uB13A", 5, "\uB142\uB143\uB145\uB146\uB147\uB149", 6, "\uB152\uB153\uB156\uB157\uB159\uB15A\uB15B\uB15D\uB15E\uB15F\uB161", 22, "\uB17A\uB17B\uB17D\uB17E\uB17F\uB181\uB183", 4, "\uB18A\uB18C\uB18E\uB18F\uB190\uB191\uB195\uB196\uB197\uB199\uB19A\uB19B\uB19D"],
      ["8741", "\uB19E", 9, "\uB1A9", 15],
      ["8761", "\uB1B9", 18, "\uB1CD\uB1CE\uB1CF\uB1D1\uB1D2\uB1D3\uB1D5"],
      ["8781", "\uB1D6", 5, "\uB1DE\uB1E0", 7, "\uB1EA\uB1EB\uB1ED\uB1EE\uB1EF\uB1F1", 7, "\uB1FA\uB1FC\uB1FE", 5, "\uB206\uB207\uB209\uB20A\uB20D", 6, "\uB216\uB218\uB21A", 5, "\uB221", 18, "\uB235", 6, "\uB23D", 26, "\uB259\uB25A\uB25B\uB25D\uB25E\uB25F\uB261", 6, "\uB26A", 4],
      ["8841", "\uB26F", 4, "\uB276", 5, "\uB27D", 6, "\uB286\uB287\uB288\uB28A", 4],
      ["8861", "\uB28F\uB292\uB293\uB295\uB296\uB297\uB29B", 4, "\uB2A2\uB2A4\uB2A7\uB2A8\uB2A9\uB2AB\uB2AD\uB2AE\uB2AF\uB2B1\uB2B2\uB2B3\uB2B5\uB2B6\uB2B7"],
      ["8881", "\uB2B8", 15, "\uB2CA\uB2CB\uB2CD\uB2CE\uB2CF\uB2D1\uB2D3", 4, "\uB2DA\uB2DC\uB2DE\uB2DF\uB2E0\uB2E1\uB2E3\uB2E7\uB2E9\uB2EA\uB2F0\uB2F1\uB2F2\uB2F6\uB2FC\uB2FD\uB2FE\uB302\uB303\uB305\uB306\uB307\uB309", 6, "\uB312\uB316", 5, "\uB31D", 54, "\uB357\uB359\uB35A\uB35D\uB360\uB361\uB362\uB363"],
      ["8941", "\uB366\uB368\uB36A\uB36C\uB36D\uB36F\uB372\uB373\uB375\uB376\uB377\uB379", 6, "\uB382\uB386", 5, "\uB38D"],
      ["8961", "\uB38E\uB38F\uB391\uB392\uB393\uB395", 10, "\uB3A2", 5, "\uB3A9\uB3AA\uB3AB\uB3AD"],
      ["8981", "\uB3AE", 21, "\uB3C6\uB3C7\uB3C9\uB3CA\uB3CD\uB3CF\uB3D1\uB3D2\uB3D3\uB3D6\uB3D8\uB3DA\uB3DC\uB3DE\uB3DF\uB3E1\uB3E2\uB3E3\uB3E5\uB3E6\uB3E7\uB3E9", 18, "\uB3FD", 18, "\uB411", 6, "\uB419\uB41A\uB41B\uB41D\uB41E\uB41F\uB421", 6, "\uB42A\uB42C", 7, "\uB435", 15],
      ["8a41", "\uB445", 10, "\uB452\uB453\uB455\uB456\uB457\uB459", 6, "\uB462\uB464\uB466"],
      ["8a61", "\uB467", 4, "\uB46D", 18, "\uB481\uB482"],
      ["8a81", "\uB483", 4, "\uB489", 19, "\uB49E", 5, "\uB4A5\uB4A6\uB4A7\uB4A9\uB4AA\uB4AB\uB4AD", 7, "\uB4B6\uB4B8\uB4BA", 5, "\uB4C1\uB4C2\uB4C3\uB4C5\uB4C6\uB4C7\uB4C9", 6, "\uB4D1\uB4D2\uB4D3\uB4D4\uB4D6", 5, "\uB4DE\uB4DF\uB4E1\uB4E2\uB4E5\uB4E7", 4, "\uB4EE\uB4F0\uB4F2", 5, "\uB4F9", 26, "\uB516\uB517\uB519\uB51A\uB51D"],
      ["8b41", "\uB51E", 5, "\uB526\uB52B", 4, "\uB532\uB533\uB535\uB536\uB537\uB539", 6, "\uB542\uB546"],
      ["8b61", "\uB547\uB548\uB549\uB54A\uB54E\uB54F\uB551\uB552\uB553\uB555", 6, "\uB55E\uB562", 8],
      ["8b81", "\uB56B", 52, "\uB5A2\uB5A3\uB5A5\uB5A6\uB5A7\uB5A9\uB5AC\uB5AD\uB5AE\uB5AF\uB5B2\uB5B6", 4, "\uB5BE\uB5BF\uB5C1\uB5C2\uB5C3\uB5C5", 6, "\uB5CE\uB5D2", 5, "\uB5D9", 18, "\uB5ED", 18],
      ["8c41", "\uB600", 15, "\uB612\uB613\uB615\uB616\uB617\uB619", 4],
      ["8c61", "\uB61E", 6, "\uB626", 5, "\uB62D", 6, "\uB635", 5],
      ["8c81", "\uB63B", 12, "\uB649", 26, "\uB665\uB666\uB667\uB669", 50, "\uB69E\uB69F\uB6A1\uB6A2\uB6A3\uB6A5", 5, "\uB6AD\uB6AE\uB6AF\uB6B0\uB6B2", 16],
      ["8d41", "\uB6C3", 16, "\uB6D5", 8],
      ["8d61", "\uB6DE", 17, "\uB6F1\uB6F2\uB6F3\uB6F5\uB6F6\uB6F7\uB6F9\uB6FA"],
      ["8d81", "\uB6FB", 4, "\uB702\uB703\uB704\uB706", 33, "\uB72A\uB72B\uB72D\uB72E\uB731", 6, "\uB73A\uB73C", 7, "\uB745\uB746\uB747\uB749\uB74A\uB74B\uB74D", 6, "\uB756", 9, "\uB761\uB762\uB763\uB765\uB766\uB767\uB769", 6, "\uB772\uB774\uB776", 5, "\uB77E\uB77F\uB781\uB782\uB783\uB785", 6, "\uB78E\uB793\uB794\uB795\uB79A\uB79B\uB79D\uB79E"],
      ["8e41", "\uB79F\uB7A1", 6, "\uB7AA\uB7AE", 5, "\uB7B6\uB7B7\uB7B9", 8],
      ["8e61", "\uB7C2", 4, "\uB7C8\uB7CA", 19],
      ["8e81", "\uB7DE", 13, "\uB7EE\uB7EF\uB7F1\uB7F2\uB7F3\uB7F5", 6, "\uB7FE\uB802", 4, "\uB80A\uB80B\uB80D\uB80E\uB80F\uB811", 6, "\uB81A\uB81C\uB81E", 5, "\uB826\uB827\uB829\uB82A\uB82B\uB82D", 6, "\uB836\uB83A", 5, "\uB841\uB842\uB843\uB845", 11, "\uB852\uB854", 7, "\uB85E\uB85F\uB861\uB862\uB863\uB865", 6, "\uB86E\uB870\uB872", 5, "\uB879\uB87A\uB87B\uB87D", 7],
      ["8f41", "\uB885", 7, "\uB88E", 17],
      ["8f61", "\uB8A0", 7, "\uB8A9", 6, "\uB8B1\uB8B2\uB8B3\uB8B5\uB8B6\uB8B7\uB8B9", 4],
      ["8f81", "\uB8BE\uB8BF\uB8C2\uB8C4\uB8C6", 5, "\uB8CD\uB8CE\uB8CF\uB8D1\uB8D2\uB8D3\uB8D5", 7, "\uB8DE\uB8E0\uB8E2", 5, "\uB8EA\uB8EB\uB8ED\uB8EE\uB8EF\uB8F1", 6, "\uB8FA\uB8FC\uB8FE", 5, "\uB905", 18, "\uB919", 6, "\uB921", 26, "\uB93E\uB93F\uB941\uB942\uB943\uB945", 6, "\uB94D\uB94E\uB950\uB952", 5],
      ["9041", "\uB95A\uB95B\uB95D\uB95E\uB95F\uB961", 6, "\uB96A\uB96C\uB96E", 5, "\uB976\uB977\uB979\uB97A\uB97B\uB97D"],
      ["9061", "\uB97E", 5, "\uB986\uB988\uB98B\uB98C\uB98F", 15],
      ["9081", "\uB99F", 12, "\uB9AE\uB9AF\uB9B1\uB9B2\uB9B3\uB9B5", 6, "\uB9BE\uB9C0\uB9C2", 5, "\uB9CA\uB9CB\uB9CD\uB9D3", 4, "\uB9DA\uB9DC\uB9DF\uB9E0\uB9E2\uB9E6\uB9E7\uB9E9\uB9EA\uB9EB\uB9ED", 6, "\uB9F6\uB9FB", 4, "\uBA02", 5, "\uBA09", 11, "\uBA16", 33, "\uBA3A\uBA3B\uBA3D\uBA3E\uBA3F\uBA41\uBA43\uBA44\uBA45\uBA46"],
      ["9141", "\uBA47\uBA4A\uBA4C\uBA4F\uBA50\uBA51\uBA52\uBA56\uBA57\uBA59\uBA5A\uBA5B\uBA5D", 6, "\uBA66\uBA6A", 5],
      ["9161", "\uBA72\uBA73\uBA75\uBA76\uBA77\uBA79", 9, "\uBA86\uBA88\uBA89\uBA8A\uBA8B\uBA8D", 5],
      ["9181", "\uBA93", 20, "\uBAAA\uBAAD\uBAAE\uBAAF\uBAB1\uBAB3", 4, "\uBABA\uBABC\uBABE", 5, "\uBAC5\uBAC6\uBAC7\uBAC9", 14, "\uBADA", 33, "\uBAFD\uBAFE\uBAFF\uBB01\uBB02\uBB03\uBB05", 7, "\uBB0E\uBB10\uBB12", 5, "\uBB19\uBB1A\uBB1B\uBB1D\uBB1E\uBB1F\uBB21", 6],
      ["9241", "\uBB28\uBB2A\uBB2C", 7, "\uBB37\uBB39\uBB3A\uBB3F", 4, "\uBB46\uBB48\uBB4A\uBB4B\uBB4C\uBB4E\uBB51\uBB52"],
      ["9261", "\uBB53\uBB55\uBB56\uBB57\uBB59", 7, "\uBB62\uBB64", 7, "\uBB6D", 4],
      ["9281", "\uBB72", 21, "\uBB89\uBB8A\uBB8B\uBB8D\uBB8E\uBB8F\uBB91", 18, "\uBBA5\uBBA6\uBBA7\uBBA9\uBBAA\uBBAB\uBBAD", 6, "\uBBB5\uBBB6\uBBB8", 7, "\uBBC1\uBBC2\uBBC3\uBBC5\uBBC6\uBBC7\uBBC9", 6, "\uBBD1\uBBD2\uBBD4", 35, "\uBBFA\uBBFB\uBBFD\uBBFE\uBC01"],
      ["9341", "\uBC03", 4, "\uBC0A\uBC0E\uBC10\uBC12\uBC13\uBC19\uBC1A\uBC20\uBC21\uBC22\uBC23\uBC26\uBC28\uBC2A\uBC2B\uBC2C\uBC2E\uBC2F\uBC32\uBC33\uBC35"],
      ["9361", "\uBC36\uBC37\uBC39", 6, "\uBC42\uBC46\uBC47\uBC48\uBC4A\uBC4B\uBC4E\uBC4F\uBC51", 8],
      ["9381", "\uBC5A\uBC5B\uBC5C\uBC5E", 37, "\uBC86\uBC87\uBC89\uBC8A\uBC8D\uBC8F", 4, "\uBC96\uBC98\uBC9B", 4, "\uBCA2\uBCA3\uBCA5\uBCA6\uBCA9", 6, "\uBCB2\uBCB6", 5, "\uBCBE\uBCBF\uBCC1\uBCC2\uBCC3\uBCC5", 7, "\uBCCE\uBCD2\uBCD3\uBCD4\uBCD6\uBCD7\uBCD9\uBCDA\uBCDB\uBCDD", 22, "\uBCF7\uBCF9\uBCFA\uBCFB\uBCFD"],
      ["9441", "\uBCFE", 5, "\uBD06\uBD08\uBD0A", 5, "\uBD11\uBD12\uBD13\uBD15", 8],
      ["9461", "\uBD1E", 5, "\uBD25", 6, "\uBD2D", 12],
      ["9481", "\uBD3A", 5, "\uBD41", 6, "\uBD4A\uBD4B\uBD4D\uBD4E\uBD4F\uBD51", 6, "\uBD5A", 9, "\uBD65\uBD66\uBD67\uBD69", 22, "\uBD82\uBD83\uBD85\uBD86\uBD8B", 4, "\uBD92\uBD94\uBD96\uBD97\uBD98\uBD9B\uBD9D", 6, "\uBDA5", 10, "\uBDB1", 6, "\uBDB9", 24],
      ["9541", "\uBDD2\uBDD3\uBDD6\uBDD7\uBDD9\uBDDA\uBDDB\uBDDD", 11, "\uBDEA", 5, "\uBDF1"],
      ["9561", "\uBDF2\uBDF3\uBDF5\uBDF6\uBDF7\uBDF9", 6, "\uBE01\uBE02\uBE04\uBE06", 5, "\uBE0E\uBE0F\uBE11\uBE12\uBE13"],
      ["9581", "\uBE15", 6, "\uBE1E\uBE20", 35, "\uBE46\uBE47\uBE49\uBE4A\uBE4B\uBE4D\uBE4F", 4, "\uBE56\uBE58\uBE5C\uBE5D\uBE5E\uBE5F\uBE62\uBE63\uBE65\uBE66\uBE67\uBE69\uBE6B", 4, "\uBE72\uBE76", 4, "\uBE7E\uBE7F\uBE81\uBE82\uBE83\uBE85", 6, "\uBE8E\uBE92", 5, "\uBE9A", 13, "\uBEA9", 14],
      ["9641", "\uBEB8", 23, "\uBED2\uBED3"],
      ["9661", "\uBED5\uBED6\uBED9", 6, "\uBEE1\uBEE2\uBEE6", 5, "\uBEED", 8],
      ["9681", "\uBEF6", 10, "\uBF02", 5, "\uBF0A", 13, "\uBF1A\uBF1E", 33, "\uBF42\uBF43\uBF45\uBF46\uBF47\uBF49", 6, "\uBF52\uBF53\uBF54\uBF56", 44],
      ["9741", "\uBF83", 16, "\uBF95", 8],
      ["9761", "\uBF9E", 17, "\uBFB1", 7],
      ["9781", "\uBFB9", 11, "\uBFC6", 5, "\uBFCE\uBFCF\uBFD1\uBFD2\uBFD3\uBFD5", 6, "\uBFDD\uBFDE\uBFE0\uBFE2", 89, "\uC03D\uC03E\uC03F"],
      ["9841", "\uC040", 16, "\uC052", 5, "\uC059\uC05A\uC05B"],
      ["9861", "\uC05D\uC05E\uC05F\uC061", 6, "\uC06A", 15],
      ["9881", "\uC07A", 21, "\uC092\uC093\uC095\uC096\uC097\uC099", 6, "\uC0A2\uC0A4\uC0A6", 5, "\uC0AE\uC0B1\uC0B2\uC0B7", 4, "\uC0BE\uC0C2\uC0C3\uC0C4\uC0C6\uC0C7\uC0CA\uC0CB\uC0CD\uC0CE\uC0CF\uC0D1", 6, "\uC0DA\uC0DE", 5, "\uC0E6\uC0E7\uC0E9\uC0EA\uC0EB\uC0ED", 6, "\uC0F6\uC0F8\uC0FA", 5, "\uC101\uC102\uC103\uC105\uC106\uC107\uC109", 6, "\uC111\uC112\uC113\uC114\uC116", 5, "\uC121\uC122\uC125\uC128\uC129\uC12A\uC12B\uC12E"],
      ["9941", "\uC132\uC133\uC134\uC135\uC137\uC13A\uC13B\uC13D\uC13E\uC13F\uC141", 6, "\uC14A\uC14E", 5, "\uC156\uC157"],
      ["9961", "\uC159\uC15A\uC15B\uC15D", 6, "\uC166\uC16A", 5, "\uC171\uC172\uC173\uC175\uC176\uC177\uC179\uC17A\uC17B"],
      ["9981", "\uC17C", 8, "\uC186", 5, "\uC18F\uC191\uC192\uC193\uC195\uC197", 4, "\uC19E\uC1A0\uC1A2\uC1A3\uC1A4\uC1A6\uC1A7\uC1AA\uC1AB\uC1AD\uC1AE\uC1AF\uC1B1", 11, "\uC1BE", 5, "\uC1C5\uC1C6\uC1C7\uC1C9\uC1CA\uC1CB\uC1CD", 6, "\uC1D5\uC1D6\uC1D9", 6, "\uC1E1\uC1E2\uC1E3\uC1E5\uC1E6\uC1E7\uC1E9", 6, "\uC1F2\uC1F4", 7, "\uC1FE\uC1FF\uC201\uC202\uC203\uC205", 6, "\uC20E\uC210\uC212", 5, "\uC21A\uC21B\uC21D\uC21E\uC221\uC222\uC223"],
      ["9a41", "\uC224\uC225\uC226\uC227\uC22A\uC22C\uC22E\uC230\uC233\uC235", 16],
      ["9a61", "\uC246\uC247\uC249", 6, "\uC252\uC253\uC255\uC256\uC257\uC259", 6, "\uC261\uC262\uC263\uC264\uC266"],
      ["9a81", "\uC267", 4, "\uC26E\uC26F\uC271\uC272\uC273\uC275", 6, "\uC27E\uC280\uC282", 5, "\uC28A", 5, "\uC291", 6, "\uC299\uC29A\uC29C\uC29E", 5, "\uC2A6\uC2A7\uC2A9\uC2AA\uC2AB\uC2AE", 5, "\uC2B6\uC2B8\uC2BA", 33, "\uC2DE\uC2DF\uC2E1\uC2E2\uC2E5", 5, "\uC2EE\uC2F0\uC2F2\uC2F3\uC2F4\uC2F5\uC2F7\uC2FA\uC2FD\uC2FE\uC2FF\uC301", 6, "\uC30A\uC30B\uC30E\uC30F"],
      ["9b41", "\uC310\uC311\uC312\uC316\uC317\uC319\uC31A\uC31B\uC31D", 6, "\uC326\uC327\uC32A", 8],
      ["9b61", "\uC333", 17, "\uC346", 7],
      ["9b81", "\uC34E", 25, "\uC36A\uC36B\uC36D\uC36E\uC36F\uC371\uC373", 4, "\uC37A\uC37B\uC37E", 5, "\uC385\uC386\uC387\uC389\uC38A\uC38B\uC38D", 50, "\uC3C1", 22, "\uC3DA"],
      ["9c41", "\uC3DB\uC3DD\uC3DE\uC3E1\uC3E3", 4, "\uC3EA\uC3EB\uC3EC\uC3EE", 5, "\uC3F6\uC3F7\uC3F9", 5],
      ["9c61", "\uC3FF", 8, "\uC409", 6, "\uC411", 9],
      ["9c81", "\uC41B", 8, "\uC425", 6, "\uC42D\uC42E\uC42F\uC431\uC432\uC433\uC435", 6, "\uC43E", 9, "\uC449", 26, "\uC466\uC467\uC469\uC46A\uC46B\uC46D", 6, "\uC476\uC477\uC478\uC47A", 5, "\uC481", 18, "\uC495", 6, "\uC49D", 12],
      ["9d41", "\uC4AA", 13, "\uC4B9\uC4BA\uC4BB\uC4BD", 8],
      ["9d61", "\uC4C6", 25],
      ["9d81", "\uC4E0", 8, "\uC4EA", 5, "\uC4F2\uC4F3\uC4F5\uC4F6\uC4F7\uC4F9\uC4FB\uC4FC\uC4FD\uC4FE\uC502", 9, "\uC50D\uC50E\uC50F\uC511\uC512\uC513\uC515", 6, "\uC51D", 10, "\uC52A\uC52B\uC52D\uC52E\uC52F\uC531", 6, "\uC53A\uC53C\uC53E", 5, "\uC546\uC547\uC54B\uC54F\uC550\uC551\uC552\uC556\uC55A\uC55B\uC55C\uC55F\uC562\uC563\uC565\uC566\uC567\uC569", 6, "\uC572\uC576", 5, "\uC57E\uC57F\uC581\uC582\uC583\uC585\uC586\uC588\uC589\uC58A\uC58B\uC58E\uC590\uC592\uC593\uC594"],
      ["9e41", "\uC596\uC599\uC59A\uC59B\uC59D\uC59E\uC59F\uC5A1", 7, "\uC5AA", 9, "\uC5B6"],
      ["9e61", "\uC5B7\uC5BA\uC5BF", 4, "\uC5CB\uC5CD\uC5CF\uC5D2\uC5D3\uC5D5\uC5D6\uC5D7\uC5D9", 6, "\uC5E2\uC5E4\uC5E6\uC5E7"],
      ["9e81", "\uC5E8\uC5E9\uC5EA\uC5EB\uC5EF\uC5F1\uC5F2\uC5F3\uC5F5\uC5F8\uC5F9\uC5FA\uC5FB\uC602\uC603\uC604\uC609\uC60A\uC60B\uC60D\uC60E\uC60F\uC611", 6, "\uC61A\uC61D", 6, "\uC626\uC627\uC629\uC62A\uC62B\uC62F\uC631\uC632\uC636\uC638\uC63A\uC63C\uC63D\uC63E\uC63F\uC642\uC643\uC645\uC646\uC647\uC649", 6, "\uC652\uC656", 5, "\uC65E\uC65F\uC661", 10, "\uC66D\uC66E\uC670\uC672", 5, "\uC67A\uC67B\uC67D\uC67E\uC67F\uC681", 6, "\uC68A\uC68C\uC68E", 5, "\uC696\uC697\uC699\uC69A\uC69B\uC69D", 6, "\uC6A6"],
      ["9f41", "\uC6A8\uC6AA", 5, "\uC6B2\uC6B3\uC6B5\uC6B6\uC6B7\uC6BB", 4, "\uC6C2\uC6C4\uC6C6", 5, "\uC6CE"],
      ["9f61", "\uC6CF\uC6D1\uC6D2\uC6D3\uC6D5", 6, "\uC6DE\uC6DF\uC6E2", 5, "\uC6EA\uC6EB\uC6ED\uC6EE\uC6EF\uC6F1\uC6F2"],
      ["9f81", "\uC6F3", 4, "\uC6FA\uC6FB\uC6FC\uC6FE", 5, "\uC706\uC707\uC709\uC70A\uC70B\uC70D", 6, "\uC716\uC718\uC71A", 5, "\uC722\uC723\uC725\uC726\uC727\uC729", 6, "\uC732\uC734\uC736\uC738\uC739\uC73A\uC73B\uC73E\uC73F\uC741\uC742\uC743\uC745", 4, "\uC74B\uC74E\uC750\uC759\uC75A\uC75B\uC75D\uC75E\uC75F\uC761", 6, "\uC769\uC76A\uC76C", 7, "\uC776\uC777\uC779\uC77A\uC77B\uC77F\uC780\uC781\uC782\uC786\uC78B\uC78C\uC78D\uC78F\uC792\uC793\uC795\uC799\uC79B", 4, "\uC7A2\uC7A7", 4, "\uC7AE\uC7AF\uC7B1\uC7B2\uC7B3\uC7B5\uC7B6\uC7B7"],
      ["a041", "\uC7B8\uC7B9\uC7BA\uC7BB\uC7BE\uC7C2", 5, "\uC7CA\uC7CB\uC7CD\uC7CF\uC7D1", 6, "\uC7D9\uC7DA\uC7DB\uC7DC"],
      ["a061", "\uC7DE", 5, "\uC7E5\uC7E6\uC7E7\uC7E9\uC7EA\uC7EB\uC7ED", 13],
      ["a081", "\uC7FB", 4, "\uC802\uC803\uC805\uC806\uC807\uC809\uC80B", 4, "\uC812\uC814\uC817", 4, "\uC81E\uC81F\uC821\uC822\uC823\uC825", 6, "\uC82E\uC830\uC832", 5, "\uC839\uC83A\uC83B\uC83D\uC83E\uC83F\uC841", 6, "\uC84A\uC84B\uC84E", 5, "\uC855", 26, "\uC872\uC873\uC875\uC876\uC877\uC879\uC87B", 4, "\uC882\uC884\uC888\uC889\uC88A\uC88E", 5, "\uC895", 7, "\uC89E\uC8A0\uC8A2\uC8A3\uC8A4"],
      ["a141", "\uC8A5\uC8A6\uC8A7\uC8A9", 18, "\uC8BE\uC8BF\uC8C0\uC8C1"],
      ["a161", "\uC8C2\uC8C3\uC8C5\uC8C6\uC8C7\uC8C9\uC8CA\uC8CB\uC8CD", 6, "\uC8D6\uC8D8\uC8DA", 5, "\uC8E2\uC8E3\uC8E5"],
      ["a181", "\uC8E6", 14, "\uC8F6", 5, "\uC8FE\uC8FF\uC901\uC902\uC903\uC907", 4, "\uC90E\u3000\u3001\u3002\xB7\u2025\u2026\xA8\u3003\xAD\u2015\u2225\uFF3C\u223C\u2018\u2019\u201C\u201D\u3014\u3015\u3008", 9, "\xB1\xD7\xF7\u2260\u2264\u2265\u221E\u2234\xB0\u2032\u2033\u2103\u212B\uFFE0\uFFE1\uFFE5\u2642\u2640\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\xA7\u203B\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u2192\u2190\u2191\u2193\u2194\u3013\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229\u2227\u2228\uFFE2"],
      ["a241", "\uC910\uC912", 5, "\uC919", 18],
      ["a261", "\uC92D", 6, "\uC935", 18],
      ["a281", "\uC948", 7, "\uC952\uC953\uC955\uC956\uC957\uC959", 6, "\uC962\uC964", 7, "\uC96D\uC96E\uC96F\u21D2\u21D4\u2200\u2203\xB4\uFF5E\u02C7\u02D8\u02DD\u02DA\u02D9\xB8\u02DB\xA1\xBF\u02D0\u222E\u2211\u220F\xA4\u2109\u2030\u25C1\u25C0\u25B7\u25B6\u2664\u2660\u2661\u2665\u2667\u2663\u2299\u25C8\u25A3\u25D0\u25D1\u2592\u25A4\u25A5\u25A8\u25A7\u25A6\u25A9\u2668\u260F\u260E\u261C\u261E\xB6\u2020\u2021\u2195\u2197\u2199\u2196\u2198\u266D\u2669\u266A\u266C\u327F\u321C\u2116\u33C7\u2122\u33C2\u33D8\u2121\u20AC\xAE"],
      ["a341", "\uC971\uC972\uC973\uC975", 6, "\uC97D", 10, "\uC98A\uC98B\uC98D\uC98E\uC98F"],
      ["a361", "\uC991", 6, "\uC99A\uC99C\uC99E", 16],
      ["a381", "\uC9AF", 16, "\uC9C2\uC9C3\uC9C5\uC9C6\uC9C9\uC9CB", 4, "\uC9D2\uC9D4\uC9D7\uC9D8\uC9DB\uFF01", 58, "\uFFE6\uFF3D", 32, "\uFFE3"],
      ["a441", "\uC9DE\uC9DF\uC9E1\uC9E3\uC9E5\uC9E6\uC9E8\uC9E9\uC9EA\uC9EB\uC9EE\uC9F2", 5, "\uC9FA\uC9FB\uC9FD\uC9FE\uC9FF\uCA01\uCA02\uCA03\uCA04"],
      ["a461", "\uCA05\uCA06\uCA07\uCA0A\uCA0E", 5, "\uCA15\uCA16\uCA17\uCA19", 12],
      ["a481", "\uCA26\uCA27\uCA28\uCA2A", 28, "\u3131", 93],
      ["a541", "\uCA47", 4, "\uCA4E\uCA4F\uCA51\uCA52\uCA53\uCA55", 6, "\uCA5E\uCA62", 5, "\uCA69\uCA6A"],
      ["a561", "\uCA6B", 17, "\uCA7E", 5, "\uCA85\uCA86"],
      ["a581", "\uCA87", 16, "\uCA99", 14, "\u2170", 9],
      ["a5b0", "\u2160", 9],
      ["a5c1", "\u0391", 16, "\u03A3", 6],
      ["a5e1", "\u03B1", 16, "\u03C3", 6],
      ["a641", "\uCAA8", 19, "\uCABE\uCABF\uCAC1\uCAC2\uCAC3\uCAC5"],
      ["a661", "\uCAC6", 5, "\uCACE\uCAD0\uCAD2\uCAD4\uCAD5\uCAD6\uCAD7\uCADA", 5, "\uCAE1", 6],
      ["a681", "\uCAE8\uCAE9\uCAEA\uCAEB\uCAED", 6, "\uCAF5", 18, "\uCB09\uCB0A\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542\u2512\u2511\u251A\u2519\u2516\u2515\u250E\u250D\u251E\u251F\u2521\u2522\u2526\u2527\u2529\u252A\u252D\u252E\u2531\u2532\u2535\u2536\u2539\u253A\u253D\u253E\u2540\u2541\u2543", 7],
      ["a741", "\uCB0B", 4, "\uCB11\uCB12\uCB13\uCB15\uCB16\uCB17\uCB19", 6, "\uCB22", 7],
      ["a761", "\uCB2A", 22, "\uCB42\uCB43\uCB44"],
      ["a781", "\uCB45\uCB46\uCB47\uCB4A\uCB4B\uCB4D\uCB4E\uCB4F\uCB51", 6, "\uCB5A\uCB5B\uCB5C\uCB5E", 5, "\uCB65", 7, "\u3395\u3396\u3397\u2113\u3398\u33C4\u33A3\u33A4\u33A5\u33A6\u3399", 9, "\u33CA\u338D\u338E\u338F\u33CF\u3388\u3389\u33C8\u33A7\u33A8\u33B0", 9, "\u3380", 4, "\u33BA", 5, "\u3390", 4, "\u2126\u33C0\u33C1\u338A\u338B\u338C\u33D6\u33C5\u33AD\u33AE\u33AF\u33DB\u33A9\u33AA\u33AB\u33AC\u33DD\u33D0\u33D3\u33C3\u33C9\u33DC\u33C6"],
      ["a841", "\uCB6D", 10, "\uCB7A", 14],
      ["a861", "\uCB89", 18, "\uCB9D", 6],
      ["a881", "\uCBA4", 19, "\uCBB9", 11, "\xC6\xD0\xAA\u0126"],
      ["a8a6", "\u0132"],
      ["a8a8", "\u013F\u0141\xD8\u0152\xBA\xDE\u0166\u014A"],
      ["a8b1", "\u3260", 27, "\u24D0", 25, "\u2460", 14, "\xBD\u2153\u2154\xBC\xBE\u215B\u215C\u215D\u215E"],
      ["a941", "\uCBC5", 14, "\uCBD5", 10],
      ["a961", "\uCBE0\uCBE1\uCBE2\uCBE3\uCBE5\uCBE6\uCBE8\uCBEA", 18],
      ["a981", "\uCBFD", 14, "\uCC0E\uCC0F\uCC11\uCC12\uCC13\uCC15", 6, "\uCC1E\uCC1F\uCC20\uCC23\uCC24\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0140\u0142\xF8\u0153\xDF\xFE\u0167\u014B\u0149\u3200", 27, "\u249C", 25, "\u2474", 14, "\xB9\xB2\xB3\u2074\u207F\u2081\u2082\u2083\u2084"],
      ["aa41", "\uCC25\uCC26\uCC2A\uCC2B\uCC2D\uCC2F\uCC31", 6, "\uCC3A\uCC3F", 4, "\uCC46\uCC47\uCC49\uCC4A\uCC4B\uCC4D\uCC4E"],
      ["aa61", "\uCC4F", 4, "\uCC56\uCC5A", 5, "\uCC61\uCC62\uCC63\uCC65\uCC67\uCC69", 6, "\uCC71\uCC72"],
      ["aa81", "\uCC73\uCC74\uCC76", 29, "\u3041", 82],
      ["ab41", "\uCC94\uCC95\uCC96\uCC97\uCC9A\uCC9B\uCC9D\uCC9E\uCC9F\uCCA1", 6, "\uCCAA\uCCAE", 5, "\uCCB6\uCCB7\uCCB9"],
      ["ab61", "\uCCBA\uCCBB\uCCBD", 6, "\uCCC6\uCCC8\uCCCA", 5, "\uCCD1\uCCD2\uCCD3\uCCD5", 5],
      ["ab81", "\uCCDB", 8, "\uCCE5", 6, "\uCCED\uCCEE\uCCEF\uCCF1", 12, "\u30A1", 85],
      ["ac41", "\uCCFE\uCCFF\uCD00\uCD02", 5, "\uCD0A\uCD0B\uCD0D\uCD0E\uCD0F\uCD11", 6, "\uCD1A\uCD1C\uCD1E\uCD1F\uCD20"],
      ["ac61", "\uCD21\uCD22\uCD23\uCD25\uCD26\uCD27\uCD29\uCD2A\uCD2B\uCD2D", 11, "\uCD3A", 4],
      ["ac81", "\uCD3F", 28, "\uCD5D\uCD5E\uCD5F\u0410", 5, "\u0401\u0416", 25],
      ["acd1", "\u0430", 5, "\u0451\u0436", 25],
      ["ad41", "\uCD61\uCD62\uCD63\uCD65", 6, "\uCD6E\uCD70\uCD72", 5, "\uCD79", 7],
      ["ad61", "\uCD81", 6, "\uCD89", 10, "\uCD96\uCD97\uCD99\uCD9A\uCD9B\uCD9D\uCD9E\uCD9F"],
      ["ad81", "\uCDA0\uCDA1\uCDA2\uCDA3\uCDA6\uCDA8\uCDAA", 5, "\uCDB1", 18, "\uCDC5"],
      ["ae41", "\uCDC6", 5, "\uCDCD\uCDCE\uCDCF\uCDD1", 16],
      ["ae61", "\uCDE2", 5, "\uCDE9\uCDEA\uCDEB\uCDED\uCDEE\uCDEF\uCDF1", 6, "\uCDFA\uCDFC\uCDFE", 4],
      ["ae81", "\uCE03\uCE05\uCE06\uCE07\uCE09\uCE0A\uCE0B\uCE0D", 6, "\uCE15\uCE16\uCE17\uCE18\uCE1A", 5, "\uCE22\uCE23\uCE25\uCE26\uCE27\uCE29\uCE2A\uCE2B"],
      ["af41", "\uCE2C\uCE2D\uCE2E\uCE2F\uCE32\uCE34\uCE36", 19],
      ["af61", "\uCE4A", 13, "\uCE5A\uCE5B\uCE5D\uCE5E\uCE62", 5, "\uCE6A\uCE6C"],
      ["af81", "\uCE6E", 5, "\uCE76\uCE77\uCE79\uCE7A\uCE7B\uCE7D", 6, "\uCE86\uCE88\uCE8A", 5, "\uCE92\uCE93\uCE95\uCE96\uCE97\uCE99"],
      ["b041", "\uCE9A", 5, "\uCEA2\uCEA6", 5, "\uCEAE", 12],
      ["b061", "\uCEBB", 5, "\uCEC2", 19],
      ["b081", "\uCED6", 13, "\uCEE6\uCEE7\uCEE9\uCEEA\uCEED", 6, "\uCEF6\uCEFA", 5, "\uAC00\uAC01\uAC04\uAC07\uAC08\uAC09\uAC0A\uAC10", 7, "\uAC19", 4, "\uAC20\uAC24\uAC2C\uAC2D\uAC2F\uAC30\uAC31\uAC38\uAC39\uAC3C\uAC40\uAC4B\uAC4D\uAC54\uAC58\uAC5C\uAC70\uAC71\uAC74\uAC77\uAC78\uAC7A\uAC80\uAC81\uAC83\uAC84\uAC85\uAC86\uAC89\uAC8A\uAC8B\uAC8C\uAC90\uAC94\uAC9C\uAC9D\uAC9F\uACA0\uACA1\uACA8\uACA9\uACAA\uACAC\uACAF\uACB0\uACB8\uACB9\uACBB\uACBC\uACBD\uACC1\uACC4\uACC8\uACCC\uACD5\uACD7\uACE0\uACE1\uACE4\uACE7\uACE8\uACEA\uACEC\uACEF\uACF0\uACF1\uACF3\uACF5\uACF6\uACFC\uACFD\uAD00\uAD04\uAD06"],
      ["b141", "\uCF02\uCF03\uCF05\uCF06\uCF07\uCF09", 6, "\uCF12\uCF14\uCF16", 5, "\uCF1D\uCF1E\uCF1F\uCF21\uCF22\uCF23"],
      ["b161", "\uCF25", 6, "\uCF2E\uCF32", 5, "\uCF39", 11],
      ["b181", "\uCF45", 14, "\uCF56\uCF57\uCF59\uCF5A\uCF5B\uCF5D", 6, "\uCF66\uCF68\uCF6A\uCF6B\uCF6C\uAD0C\uAD0D\uAD0F\uAD11\uAD18\uAD1C\uAD20\uAD29\uAD2C\uAD2D\uAD34\uAD35\uAD38\uAD3C\uAD44\uAD45\uAD47\uAD49\uAD50\uAD54\uAD58\uAD61\uAD63\uAD6C\uAD6D\uAD70\uAD73\uAD74\uAD75\uAD76\uAD7B\uAD7C\uAD7D\uAD7F\uAD81\uAD82\uAD88\uAD89\uAD8C\uAD90\uAD9C\uAD9D\uADA4\uADB7\uADC0\uADC1\uADC4\uADC8\uADD0\uADD1\uADD3\uADDC\uADE0\uADE4\uADF8\uADF9\uADFC\uADFF\uAE00\uAE01\uAE08\uAE09\uAE0B\uAE0D\uAE14\uAE30\uAE31\uAE34\uAE37\uAE38\uAE3A\uAE40\uAE41\uAE43\uAE45\uAE46\uAE4A\uAE4C\uAE4D\uAE4E\uAE50\uAE54\uAE56\uAE5C\uAE5D\uAE5F\uAE60\uAE61\uAE65\uAE68\uAE69\uAE6C\uAE70\uAE78"],
      ["b241", "\uCF6D\uCF6E\uCF6F\uCF72\uCF73\uCF75\uCF76\uCF77\uCF79", 6, "\uCF81\uCF82\uCF83\uCF84\uCF86", 5, "\uCF8D"],
      ["b261", "\uCF8E", 18, "\uCFA2", 5, "\uCFA9"],
      ["b281", "\uCFAA", 5, "\uCFB1", 18, "\uCFC5", 6, "\uAE79\uAE7B\uAE7C\uAE7D\uAE84\uAE85\uAE8C\uAEBC\uAEBD\uAEBE\uAEC0\uAEC4\uAECC\uAECD\uAECF\uAED0\uAED1\uAED8\uAED9\uAEDC\uAEE8\uAEEB\uAEED\uAEF4\uAEF8\uAEFC\uAF07\uAF08\uAF0D\uAF10\uAF2C\uAF2D\uAF30\uAF32\uAF34\uAF3C\uAF3D\uAF3F\uAF41\uAF42\uAF43\uAF48\uAF49\uAF50\uAF5C\uAF5D\uAF64\uAF65\uAF79\uAF80\uAF84\uAF88\uAF90\uAF91\uAF95\uAF9C\uAFB8\uAFB9\uAFBC\uAFC0\uAFC7\uAFC8\uAFC9\uAFCB\uAFCD\uAFCE\uAFD4\uAFDC\uAFE8\uAFE9\uAFF0\uAFF1\uAFF4\uAFF8\uB000\uB001\uB004\uB00C\uB010\uB014\uB01C\uB01D\uB028\uB044\uB045\uB048\uB04A\uB04C\uB04E\uB053\uB054\uB055\uB057\uB059"],
      ["b341", "\uCFCC", 19, "\uCFE2\uCFE3\uCFE5\uCFE6\uCFE7\uCFE9"],
      ["b361", "\uCFEA", 5, "\uCFF2\uCFF4\uCFF6", 5, "\uCFFD\uCFFE\uCFFF\uD001\uD002\uD003\uD005", 5],
      ["b381", "\uD00B", 5, "\uD012", 5, "\uD019", 19, "\uB05D\uB07C\uB07D\uB080\uB084\uB08C\uB08D\uB08F\uB091\uB098\uB099\uB09A\uB09C\uB09F\uB0A0\uB0A1\uB0A2\uB0A8\uB0A9\uB0AB", 4, "\uB0B1\uB0B3\uB0B4\uB0B5\uB0B8\uB0BC\uB0C4\uB0C5\uB0C7\uB0C8\uB0C9\uB0D0\uB0D1\uB0D4\uB0D8\uB0E0\uB0E5\uB108\uB109\uB10B\uB10C\uB110\uB112\uB113\uB118\uB119\uB11B\uB11C\uB11D\uB123\uB124\uB125\uB128\uB12C\uB134\uB135\uB137\uB138\uB139\uB140\uB141\uB144\uB148\uB150\uB151\uB154\uB155\uB158\uB15C\uB160\uB178\uB179\uB17C\uB180\uB182\uB188\uB189\uB18B\uB18D\uB192\uB193\uB194\uB198\uB19C\uB1A8\uB1CC\uB1D0\uB1D4\uB1DC\uB1DD"],
      ["b441", "\uD02E", 5, "\uD036\uD037\uD039\uD03A\uD03B\uD03D", 6, "\uD046\uD048\uD04A", 5],
      ["b461", "\uD051\uD052\uD053\uD055\uD056\uD057\uD059", 6, "\uD061", 10, "\uD06E\uD06F"],
      ["b481", "\uD071\uD072\uD073\uD075", 6, "\uD07E\uD07F\uD080\uD082", 18, "\uB1DF\uB1E8\uB1E9\uB1EC\uB1F0\uB1F9\uB1FB\uB1FD\uB204\uB205\uB208\uB20B\uB20C\uB214\uB215\uB217\uB219\uB220\uB234\uB23C\uB258\uB25C\uB260\uB268\uB269\uB274\uB275\uB27C\uB284\uB285\uB289\uB290\uB291\uB294\uB298\uB299\uB29A\uB2A0\uB2A1\uB2A3\uB2A5\uB2A6\uB2AA\uB2AC\uB2B0\uB2B4\uB2C8\uB2C9\uB2CC\uB2D0\uB2D2\uB2D8\uB2D9\uB2DB\uB2DD\uB2E2\uB2E4\uB2E5\uB2E6\uB2E8\uB2EB", 4, "\uB2F3\uB2F4\uB2F5\uB2F7", 4, "\uB2FF\uB300\uB301\uB304\uB308\uB310\uB311\uB313\uB314\uB315\uB31C\uB354\uB355\uB356\uB358\uB35B\uB35C\uB35E\uB35F\uB364\uB365"],
      ["b541", "\uD095", 14, "\uD0A6\uD0A7\uD0A9\uD0AA\uD0AB\uD0AD", 5],
      ["b561", "\uD0B3\uD0B6\uD0B8\uD0BA", 5, "\uD0C2\uD0C3\uD0C5\uD0C6\uD0C7\uD0CA", 5, "\uD0D2\uD0D6", 4],
      ["b581", "\uD0DB\uD0DE\uD0DF\uD0E1\uD0E2\uD0E3\uD0E5", 6, "\uD0EE\uD0F2", 5, "\uD0F9", 11, "\uB367\uB369\uB36B\uB36E\uB370\uB371\uB374\uB378\uB380\uB381\uB383\uB384\uB385\uB38C\uB390\uB394\uB3A0\uB3A1\uB3A8\uB3AC\uB3C4\uB3C5\uB3C8\uB3CB\uB3CC\uB3CE\uB3D0\uB3D4\uB3D5\uB3D7\uB3D9\uB3DB\uB3DD\uB3E0\uB3E4\uB3E8\uB3FC\uB410\uB418\uB41C\uB420\uB428\uB429\uB42B\uB434\uB450\uB451\uB454\uB458\uB460\uB461\uB463\uB465\uB46C\uB480\uB488\uB49D\uB4A4\uB4A8\uB4AC\uB4B5\uB4B7\uB4B9\uB4C0\uB4C4\uB4C8\uB4D0\uB4D5\uB4DC\uB4DD\uB4E0\uB4E3\uB4E4\uB4E6\uB4EC\uB4ED\uB4EF\uB4F1\uB4F8\uB514\uB515\uB518\uB51B\uB51C\uB524\uB525\uB527\uB528\uB529\uB52A\uB530\uB531\uB534\uB538"],
      ["b641", "\uD105", 7, "\uD10E", 17],
      ["b661", "\uD120", 15, "\uD132\uD133\uD135\uD136\uD137\uD139\uD13B\uD13C\uD13D\uD13E"],
      ["b681", "\uD13F\uD142\uD146", 5, "\uD14E\uD14F\uD151\uD152\uD153\uD155", 6, "\uD15E\uD160\uD162", 5, "\uD169\uD16A\uD16B\uD16D\uB540\uB541\uB543\uB544\uB545\uB54B\uB54C\uB54D\uB550\uB554\uB55C\uB55D\uB55F\uB560\uB561\uB5A0\uB5A1\uB5A4\uB5A8\uB5AA\uB5AB\uB5B0\uB5B1\uB5B3\uB5B4\uB5B5\uB5BB\uB5BC\uB5BD\uB5C0\uB5C4\uB5CC\uB5CD\uB5CF\uB5D0\uB5D1\uB5D8\uB5EC\uB610\uB611\uB614\uB618\uB625\uB62C\uB634\uB648\uB664\uB668\uB69C\uB69D\uB6A0\uB6A4\uB6AB\uB6AC\uB6B1\uB6D4\uB6F0\uB6F4\uB6F8\uB700\uB701\uB705\uB728\uB729\uB72C\uB72F\uB730\uB738\uB739\uB73B\uB744\uB748\uB74C\uB754\uB755\uB760\uB764\uB768\uB770\uB771\uB773\uB775\uB77C\uB77D\uB780\uB784\uB78C\uB78D\uB78F\uB790\uB791\uB792\uB796\uB797"],
      ["b741", "\uD16E", 13, "\uD17D", 6, "\uD185\uD186\uD187\uD189\uD18A"],
      ["b761", "\uD18B", 20, "\uD1A2\uD1A3\uD1A5\uD1A6\uD1A7"],
      ["b781", "\uD1A9", 6, "\uD1B2\uD1B4\uD1B6\uD1B7\uD1B8\uD1B9\uD1BB\uD1BD\uD1BE\uD1BF\uD1C1", 14, "\uB798\uB799\uB79C\uB7A0\uB7A8\uB7A9\uB7AB\uB7AC\uB7AD\uB7B4\uB7B5\uB7B8\uB7C7\uB7C9\uB7EC\uB7ED\uB7F0\uB7F4\uB7FC\uB7FD\uB7FF\uB800\uB801\uB807\uB808\uB809\uB80C\uB810\uB818\uB819\uB81B\uB81D\uB824\uB825\uB828\uB82C\uB834\uB835\uB837\uB838\uB839\uB840\uB844\uB851\uB853\uB85C\uB85D\uB860\uB864\uB86C\uB86D\uB86F\uB871\uB878\uB87C\uB88D\uB8A8\uB8B0\uB8B4\uB8B8\uB8C0\uB8C1\uB8C3\uB8C5\uB8CC\uB8D0\uB8D4\uB8DD\uB8DF\uB8E1\uB8E8\uB8E9\uB8EC\uB8F0\uB8F8\uB8F9\uB8FB\uB8FD\uB904\uB918\uB920\uB93C\uB93D\uB940\uB944\uB94C\uB94F\uB951\uB958\uB959\uB95C\uB960\uB968\uB969"],
      ["b841", "\uD1D0", 7, "\uD1D9", 17],
      ["b861", "\uD1EB", 8, "\uD1F5\uD1F6\uD1F7\uD1F9", 13],
      ["b881", "\uD208\uD20A", 5, "\uD211", 24, "\uB96B\uB96D\uB974\uB975\uB978\uB97C\uB984\uB985\uB987\uB989\uB98A\uB98D\uB98E\uB9AC\uB9AD\uB9B0\uB9B4\uB9BC\uB9BD\uB9BF\uB9C1\uB9C8\uB9C9\uB9CC\uB9CE", 4, "\uB9D8\uB9D9\uB9DB\uB9DD\uB9DE\uB9E1\uB9E3\uB9E4\uB9E5\uB9E8\uB9EC\uB9F4\uB9F5\uB9F7\uB9F8\uB9F9\uB9FA\uBA00\uBA01\uBA08\uBA15\uBA38\uBA39\uBA3C\uBA40\uBA42\uBA48\uBA49\uBA4B\uBA4D\uBA4E\uBA53\uBA54\uBA55\uBA58\uBA5C\uBA64\uBA65\uBA67\uBA68\uBA69\uBA70\uBA71\uBA74\uBA78\uBA83\uBA84\uBA85\uBA87\uBA8C\uBAA8\uBAA9\uBAAB\uBAAC\uBAB0\uBAB2\uBAB8\uBAB9\uBABB\uBABD\uBAC4\uBAC8\uBAD8\uBAD9\uBAFC"],
      ["b941", "\uD22A\uD22B\uD22E\uD22F\uD231\uD232\uD233\uD235", 6, "\uD23E\uD240\uD242", 5, "\uD249\uD24A\uD24B\uD24C"],
      ["b961", "\uD24D", 14, "\uD25D", 6, "\uD265\uD266\uD267\uD268"],
      ["b981", "\uD269", 22, "\uD282\uD283\uD285\uD286\uD287\uD289\uD28A\uD28B\uD28C\uBB00\uBB04\uBB0D\uBB0F\uBB11\uBB18\uBB1C\uBB20\uBB29\uBB2B\uBB34\uBB35\uBB36\uBB38\uBB3B\uBB3C\uBB3D\uBB3E\uBB44\uBB45\uBB47\uBB49\uBB4D\uBB4F\uBB50\uBB54\uBB58\uBB61\uBB63\uBB6C\uBB88\uBB8C\uBB90\uBBA4\uBBA8\uBBAC\uBBB4\uBBB7\uBBC0\uBBC4\uBBC8\uBBD0\uBBD3\uBBF8\uBBF9\uBBFC\uBBFF\uBC00\uBC02\uBC08\uBC09\uBC0B\uBC0C\uBC0D\uBC0F\uBC11\uBC14", 4, "\uBC1B", 4, "\uBC24\uBC25\uBC27\uBC29\uBC2D\uBC30\uBC31\uBC34\uBC38\uBC40\uBC41\uBC43\uBC44\uBC45\uBC49\uBC4C\uBC4D\uBC50\uBC5D\uBC84\uBC85\uBC88\uBC8B\uBC8C\uBC8E\uBC94\uBC95\uBC97"],
      ["ba41", "\uD28D\uD28E\uD28F\uD292\uD293\uD294\uD296", 5, "\uD29D\uD29E\uD29F\uD2A1\uD2A2\uD2A3\uD2A5", 6, "\uD2AD"],
      ["ba61", "\uD2AE\uD2AF\uD2B0\uD2B2", 5, "\uD2BA\uD2BB\uD2BD\uD2BE\uD2C1\uD2C3", 4, "\uD2CA\uD2CC", 5],
      ["ba81", "\uD2D2\uD2D3\uD2D5\uD2D6\uD2D7\uD2D9\uD2DA\uD2DB\uD2DD", 6, "\uD2E6", 9, "\uD2F2\uD2F3\uD2F5\uD2F6\uD2F7\uD2F9\uD2FA\uBC99\uBC9A\uBCA0\uBCA1\uBCA4\uBCA7\uBCA8\uBCB0\uBCB1\uBCB3\uBCB4\uBCB5\uBCBC\uBCBD\uBCC0\uBCC4\uBCCD\uBCCF\uBCD0\uBCD1\uBCD5\uBCD8\uBCDC\uBCF4\uBCF5\uBCF6\uBCF8\uBCFC\uBD04\uBD05\uBD07\uBD09\uBD10\uBD14\uBD24\uBD2C\uBD40\uBD48\uBD49\uBD4C\uBD50\uBD58\uBD59\uBD64\uBD68\uBD80\uBD81\uBD84\uBD87\uBD88\uBD89\uBD8A\uBD90\uBD91\uBD93\uBD95\uBD99\uBD9A\uBD9C\uBDA4\uBDB0\uBDB8\uBDD4\uBDD5\uBDD8\uBDDC\uBDE9\uBDF0\uBDF4\uBDF8\uBE00\uBE03\uBE05\uBE0C\uBE0D\uBE10\uBE14\uBE1C\uBE1D\uBE1F\uBE44\uBE45\uBE48\uBE4C\uBE4E\uBE54\uBE55\uBE57\uBE59\uBE5A\uBE5B\uBE60\uBE61\uBE64"],
      ["bb41", "\uD2FB", 4, "\uD302\uD304\uD306", 5, "\uD30F\uD311\uD312\uD313\uD315\uD317", 4, "\uD31E\uD322\uD323"],
      ["bb61", "\uD324\uD326\uD327\uD32A\uD32B\uD32D\uD32E\uD32F\uD331", 6, "\uD33A\uD33E", 5, "\uD346\uD347\uD348\uD349"],
      ["bb81", "\uD34A", 31, "\uBE68\uBE6A\uBE70\uBE71\uBE73\uBE74\uBE75\uBE7B\uBE7C\uBE7D\uBE80\uBE84\uBE8C\uBE8D\uBE8F\uBE90\uBE91\uBE98\uBE99\uBEA8\uBED0\uBED1\uBED4\uBED7\uBED8\uBEE0\uBEE3\uBEE4\uBEE5\uBEEC\uBF01\uBF08\uBF09\uBF18\uBF19\uBF1B\uBF1C\uBF1D\uBF40\uBF41\uBF44\uBF48\uBF50\uBF51\uBF55\uBF94\uBFB0\uBFC5\uBFCC\uBFCD\uBFD0\uBFD4\uBFDC\uBFDF\uBFE1\uC03C\uC051\uC058\uC05C\uC060\uC068\uC069\uC090\uC091\uC094\uC098\uC0A0\uC0A1\uC0A3\uC0A5\uC0AC\uC0AD\uC0AF\uC0B0\uC0B3\uC0B4\uC0B5\uC0B6\uC0BC\uC0BD\uC0BF\uC0C0\uC0C1\uC0C5\uC0C8\uC0C9\uC0CC\uC0D0\uC0D8\uC0D9\uC0DB\uC0DC\uC0DD\uC0E4"],
      ["bc41", "\uD36A", 17, "\uD37E\uD37F\uD381\uD382\uD383\uD385\uD386\uD387"],
      ["bc61", "\uD388\uD389\uD38A\uD38B\uD38E\uD392", 5, "\uD39A\uD39B\uD39D\uD39E\uD39F\uD3A1", 6, "\uD3AA\uD3AC\uD3AE"],
      ["bc81", "\uD3AF", 4, "\uD3B5\uD3B6\uD3B7\uD3B9\uD3BA\uD3BB\uD3BD", 6, "\uD3C6\uD3C7\uD3CA", 5, "\uD3D1", 5, "\uC0E5\uC0E8\uC0EC\uC0F4\uC0F5\uC0F7\uC0F9\uC100\uC104\uC108\uC110\uC115\uC11C", 4, "\uC123\uC124\uC126\uC127\uC12C\uC12D\uC12F\uC130\uC131\uC136\uC138\uC139\uC13C\uC140\uC148\uC149\uC14B\uC14C\uC14D\uC154\uC155\uC158\uC15C\uC164\uC165\uC167\uC168\uC169\uC170\uC174\uC178\uC185\uC18C\uC18D\uC18E\uC190\uC194\uC196\uC19C\uC19D\uC19F\uC1A1\uC1A5\uC1A8\uC1A9\uC1AC\uC1B0\uC1BD\uC1C4\uC1C8\uC1CC\uC1D4\uC1D7\uC1D8\uC1E0\uC1E4\uC1E8\uC1F0\uC1F1\uC1F3\uC1FC\uC1FD\uC200\uC204\uC20C\uC20D\uC20F\uC211\uC218\uC219\uC21C\uC21F\uC220\uC228\uC229\uC22B\uC22D"],
      ["bd41", "\uD3D7\uD3D9", 7, "\uD3E2\uD3E4", 7, "\uD3EE\uD3EF\uD3F1\uD3F2\uD3F3\uD3F5\uD3F6\uD3F7"],
      ["bd61", "\uD3F8\uD3F9\uD3FA\uD3FB\uD3FE\uD400\uD402", 5, "\uD409", 13],
      ["bd81", "\uD417", 5, "\uD41E", 25, "\uC22F\uC231\uC232\uC234\uC248\uC250\uC251\uC254\uC258\uC260\uC265\uC26C\uC26D\uC270\uC274\uC27C\uC27D\uC27F\uC281\uC288\uC289\uC290\uC298\uC29B\uC29D\uC2A4\uC2A5\uC2A8\uC2AC\uC2AD\uC2B4\uC2B5\uC2B7\uC2B9\uC2DC\uC2DD\uC2E0\uC2E3\uC2E4\uC2EB\uC2EC\uC2ED\uC2EF\uC2F1\uC2F6\uC2F8\uC2F9\uC2FB\uC2FC\uC300\uC308\uC309\uC30C\uC30D\uC313\uC314\uC315\uC318\uC31C\uC324\uC325\uC328\uC329\uC345\uC368\uC369\uC36C\uC370\uC372\uC378\uC379\uC37C\uC37D\uC384\uC388\uC38C\uC3C0\uC3D8\uC3D9\uC3DC\uC3DF\uC3E0\uC3E2\uC3E8\uC3E9\uC3ED\uC3F4\uC3F5\uC3F8\uC408\uC410\uC424\uC42C\uC430"],
      ["be41", "\uD438", 7, "\uD441\uD442\uD443\uD445", 14],
      ["be61", "\uD454", 7, "\uD45D\uD45E\uD45F\uD461\uD462\uD463\uD465", 7, "\uD46E\uD470\uD471\uD472"],
      ["be81", "\uD473", 4, "\uD47A\uD47B\uD47D\uD47E\uD481\uD483", 4, "\uD48A\uD48C\uD48E", 5, "\uD495", 8, "\uC434\uC43C\uC43D\uC448\uC464\uC465\uC468\uC46C\uC474\uC475\uC479\uC480\uC494\uC49C\uC4B8\uC4BC\uC4E9\uC4F0\uC4F1\uC4F4\uC4F8\uC4FA\uC4FF\uC500\uC501\uC50C\uC510\uC514\uC51C\uC528\uC529\uC52C\uC530\uC538\uC539\uC53B\uC53D\uC544\uC545\uC548\uC549\uC54A\uC54C\uC54D\uC54E\uC553\uC554\uC555\uC557\uC558\uC559\uC55D\uC55E\uC560\uC561\uC564\uC568\uC570\uC571\uC573\uC574\uC575\uC57C\uC57D\uC580\uC584\uC587\uC58C\uC58D\uC58F\uC591\uC595\uC597\uC598\uC59C\uC5A0\uC5A9\uC5B4\uC5B5\uC5B8\uC5B9\uC5BB\uC5BC\uC5BD\uC5BE\uC5C4", 6, "\uC5CC\uC5CE"],
      ["bf41", "\uD49E", 10, "\uD4AA", 14],
      ["bf61", "\uD4B9", 18, "\uD4CD\uD4CE\uD4CF\uD4D1\uD4D2\uD4D3\uD4D5"],
      ["bf81", "\uD4D6", 5, "\uD4DD\uD4DE\uD4E0", 7, "\uD4E9\uD4EA\uD4EB\uD4ED\uD4EE\uD4EF\uD4F1", 6, "\uD4F9\uD4FA\uD4FC\uC5D0\uC5D1\uC5D4\uC5D8\uC5E0\uC5E1\uC5E3\uC5E5\uC5EC\uC5ED\uC5EE\uC5F0\uC5F4\uC5F6\uC5F7\uC5FC", 5, "\uC605\uC606\uC607\uC608\uC60C\uC610\uC618\uC619\uC61B\uC61C\uC624\uC625\uC628\uC62C\uC62D\uC62E\uC630\uC633\uC634\uC635\uC637\uC639\uC63B\uC640\uC641\uC644\uC648\uC650\uC651\uC653\uC654\uC655\uC65C\uC65D\uC660\uC66C\uC66F\uC671\uC678\uC679\uC67C\uC680\uC688\uC689\uC68B\uC68D\uC694\uC695\uC698\uC69C\uC6A4\uC6A5\uC6A7\uC6A9\uC6B0\uC6B1\uC6B4\uC6B8\uC6B9\uC6BA\uC6C0\uC6C1\uC6C3\uC6C5\uC6CC\uC6CD\uC6D0\uC6D4\uC6DC\uC6DD\uC6E0\uC6E1\uC6E8"],
      ["c041", "\uD4FE", 5, "\uD505\uD506\uD507\uD509\uD50A\uD50B\uD50D", 6, "\uD516\uD518", 5],
      ["c061", "\uD51E", 25],
      ["c081", "\uD538\uD539\uD53A\uD53B\uD53E\uD53F\uD541\uD542\uD543\uD545", 6, "\uD54E\uD550\uD552", 5, "\uD55A\uD55B\uD55D\uD55E\uD55F\uD561\uD562\uD563\uC6E9\uC6EC\uC6F0\uC6F8\uC6F9\uC6FD\uC704\uC705\uC708\uC70C\uC714\uC715\uC717\uC719\uC720\uC721\uC724\uC728\uC730\uC731\uC733\uC735\uC737\uC73C\uC73D\uC740\uC744\uC74A\uC74C\uC74D\uC74F\uC751", 7, "\uC75C\uC760\uC768\uC76B\uC774\uC775\uC778\uC77C\uC77D\uC77E\uC783\uC784\uC785\uC787\uC788\uC789\uC78A\uC78E\uC790\uC791\uC794\uC796\uC797\uC798\uC79A\uC7A0\uC7A1\uC7A3\uC7A4\uC7A5\uC7A6\uC7AC\uC7AD\uC7B0\uC7B4\uC7BC\uC7BD\uC7BF\uC7C0\uC7C1\uC7C8\uC7C9\uC7CC\uC7CE\uC7D0\uC7D8\uC7DD\uC7E4\uC7E8\uC7EC\uC800\uC801\uC804\uC808\uC80A"],
      ["c141", "\uD564\uD566\uD567\uD56A\uD56C\uD56E", 5, "\uD576\uD577\uD579\uD57A\uD57B\uD57D", 6, "\uD586\uD58A\uD58B"],
      ["c161", "\uD58C\uD58D\uD58E\uD58F\uD591", 19, "\uD5A6\uD5A7"],
      ["c181", "\uD5A8", 31, "\uC810\uC811\uC813\uC815\uC816\uC81C\uC81D\uC820\uC824\uC82C\uC82D\uC82F\uC831\uC838\uC83C\uC840\uC848\uC849\uC84C\uC84D\uC854\uC870\uC871\uC874\uC878\uC87A\uC880\uC881\uC883\uC885\uC886\uC887\uC88B\uC88C\uC88D\uC894\uC89D\uC89F\uC8A1\uC8A8\uC8BC\uC8BD\uC8C4\uC8C8\uC8CC\uC8D4\uC8D5\uC8D7\uC8D9\uC8E0\uC8E1\uC8E4\uC8F5\uC8FC\uC8FD\uC900\uC904\uC905\uC906\uC90C\uC90D\uC90F\uC911\uC918\uC92C\uC934\uC950\uC951\uC954\uC958\uC960\uC961\uC963\uC96C\uC970\uC974\uC97C\uC988\uC989\uC98C\uC990\uC998\uC999\uC99B\uC99D\uC9C0\uC9C1\uC9C4\uC9C7\uC9C8\uC9CA\uC9D0\uC9D1\uC9D3"],
      ["c241", "\uD5CA\uD5CB\uD5CD\uD5CE\uD5CF\uD5D1\uD5D3", 4, "\uD5DA\uD5DC\uD5DE", 5, "\uD5E6\uD5E7\uD5E9\uD5EA\uD5EB\uD5ED\uD5EE"],
      ["c261", "\uD5EF", 4, "\uD5F6\uD5F8\uD5FA", 5, "\uD602\uD603\uD605\uD606\uD607\uD609", 6, "\uD612"],
      ["c281", "\uD616", 5, "\uD61D\uD61E\uD61F\uD621\uD622\uD623\uD625", 7, "\uD62E", 9, "\uD63A\uD63B\uC9D5\uC9D6\uC9D9\uC9DA\uC9DC\uC9DD\uC9E0\uC9E2\uC9E4\uC9E7\uC9EC\uC9ED\uC9EF\uC9F0\uC9F1\uC9F8\uC9F9\uC9FC\uCA00\uCA08\uCA09\uCA0B\uCA0C\uCA0D\uCA14\uCA18\uCA29\uCA4C\uCA4D\uCA50\uCA54\uCA5C\uCA5D\uCA5F\uCA60\uCA61\uCA68\uCA7D\uCA84\uCA98\uCABC\uCABD\uCAC0\uCAC4\uCACC\uCACD\uCACF\uCAD1\uCAD3\uCAD8\uCAD9\uCAE0\uCAEC\uCAF4\uCB08\uCB10\uCB14\uCB18\uCB20\uCB21\uCB41\uCB48\uCB49\uCB4C\uCB50\uCB58\uCB59\uCB5D\uCB64\uCB78\uCB79\uCB9C\uCBB8\uCBD4\uCBE4\uCBE7\uCBE9\uCC0C\uCC0D\uCC10\uCC14\uCC1C\uCC1D\uCC21\uCC22\uCC27\uCC28\uCC29\uCC2C\uCC2E\uCC30\uCC38\uCC39\uCC3B"],
      ["c341", "\uD63D\uD63E\uD63F\uD641\uD642\uD643\uD644\uD646\uD647\uD64A\uD64C\uD64E\uD64F\uD650\uD652\uD653\uD656\uD657\uD659\uD65A\uD65B\uD65D", 4],
      ["c361", "\uD662", 4, "\uD668\uD66A", 5, "\uD672\uD673\uD675", 11],
      ["c381", "\uD681\uD682\uD684\uD686", 5, "\uD68E\uD68F\uD691\uD692\uD693\uD695", 7, "\uD69E\uD6A0\uD6A2", 5, "\uD6A9\uD6AA\uCC3C\uCC3D\uCC3E\uCC44\uCC45\uCC48\uCC4C\uCC54\uCC55\uCC57\uCC58\uCC59\uCC60\uCC64\uCC66\uCC68\uCC70\uCC75\uCC98\uCC99\uCC9C\uCCA0\uCCA8\uCCA9\uCCAB\uCCAC\uCCAD\uCCB4\uCCB5\uCCB8\uCCBC\uCCC4\uCCC5\uCCC7\uCCC9\uCCD0\uCCD4\uCCE4\uCCEC\uCCF0\uCD01\uCD08\uCD09\uCD0C\uCD10\uCD18\uCD19\uCD1B\uCD1D\uCD24\uCD28\uCD2C\uCD39\uCD5C\uCD60\uCD64\uCD6C\uCD6D\uCD6F\uCD71\uCD78\uCD88\uCD94\uCD95\uCD98\uCD9C\uCDA4\uCDA5\uCDA7\uCDA9\uCDB0\uCDC4\uCDCC\uCDD0\uCDE8\uCDEC\uCDF0\uCDF8\uCDF9\uCDFB\uCDFD\uCE04\uCE08\uCE0C\uCE14\uCE19\uCE20\uCE21\uCE24\uCE28\uCE30\uCE31\uCE33\uCE35"],
      ["c441", "\uD6AB\uD6AD\uD6AE\uD6AF\uD6B1", 7, "\uD6BA\uD6BC", 7, "\uD6C6\uD6C7\uD6C9\uD6CA\uD6CB"],
      ["c461", "\uD6CD\uD6CE\uD6CF\uD6D0\uD6D2\uD6D3\uD6D5\uD6D6\uD6D8\uD6DA", 5, "\uD6E1\uD6E2\uD6E3\uD6E5\uD6E6\uD6E7\uD6E9", 4],
      ["c481", "\uD6EE\uD6EF\uD6F1\uD6F2\uD6F3\uD6F4\uD6F6", 5, "\uD6FE\uD6FF\uD701\uD702\uD703\uD705", 11, "\uD712\uD713\uD714\uCE58\uCE59\uCE5C\uCE5F\uCE60\uCE61\uCE68\uCE69\uCE6B\uCE6D\uCE74\uCE75\uCE78\uCE7C\uCE84\uCE85\uCE87\uCE89\uCE90\uCE91\uCE94\uCE98\uCEA0\uCEA1\uCEA3\uCEA4\uCEA5\uCEAC\uCEAD\uCEC1\uCEE4\uCEE5\uCEE8\uCEEB\uCEEC\uCEF4\uCEF5\uCEF7\uCEF8\uCEF9\uCF00\uCF01\uCF04\uCF08\uCF10\uCF11\uCF13\uCF15\uCF1C\uCF20\uCF24\uCF2C\uCF2D\uCF2F\uCF30\uCF31\uCF38\uCF54\uCF55\uCF58\uCF5C\uCF64\uCF65\uCF67\uCF69\uCF70\uCF71\uCF74\uCF78\uCF80\uCF85\uCF8C\uCFA1\uCFA8\uCFB0\uCFC4\uCFE0\uCFE1\uCFE4\uCFE8\uCFF0\uCFF1\uCFF3\uCFF5\uCFFC\uD000\uD004\uD011\uD018\uD02D\uD034\uD035\uD038\uD03C"],
      ["c541", "\uD715\uD716\uD717\uD71A\uD71B\uD71D\uD71E\uD71F\uD721", 6, "\uD72A\uD72C\uD72E", 5, "\uD736\uD737\uD739"],
      ["c561", "\uD73A\uD73B\uD73D", 6, "\uD745\uD746\uD748\uD74A", 5, "\uD752\uD753\uD755\uD75A", 4],
      ["c581", "\uD75F\uD762\uD764\uD766\uD767\uD768\uD76A\uD76B\uD76D\uD76E\uD76F\uD771\uD772\uD773\uD775", 6, "\uD77E\uD77F\uD780\uD782", 5, "\uD78A\uD78B\uD044\uD045\uD047\uD049\uD050\uD054\uD058\uD060\uD06C\uD06D\uD070\uD074\uD07C\uD07D\uD081\uD0A4\uD0A5\uD0A8\uD0AC\uD0B4\uD0B5\uD0B7\uD0B9\uD0C0\uD0C1\uD0C4\uD0C8\uD0C9\uD0D0\uD0D1\uD0D3\uD0D4\uD0D5\uD0DC\uD0DD\uD0E0\uD0E4\uD0EC\uD0ED\uD0EF\uD0F0\uD0F1\uD0F8\uD10D\uD130\uD131\uD134\uD138\uD13A\uD140\uD141\uD143\uD144\uD145\uD14C\uD14D\uD150\uD154\uD15C\uD15D\uD15F\uD161\uD168\uD16C\uD17C\uD184\uD188\uD1A0\uD1A1\uD1A4\uD1A8\uD1B0\uD1B1\uD1B3\uD1B5\uD1BA\uD1BC\uD1C0\uD1D8\uD1F4\uD1F8\uD207\uD209\uD210\uD22C\uD22D\uD230\uD234\uD23C\uD23D\uD23F\uD241\uD248\uD25C"],
      ["c641", "\uD78D\uD78E\uD78F\uD791", 6, "\uD79A\uD79C\uD79E", 5],
      ["c6a1", "\uD264\uD280\uD281\uD284\uD288\uD290\uD291\uD295\uD29C\uD2A0\uD2A4\uD2AC\uD2B1\uD2B8\uD2B9\uD2BC\uD2BF\uD2C0\uD2C2\uD2C8\uD2C9\uD2CB\uD2D4\uD2D8\uD2DC\uD2E4\uD2E5\uD2F0\uD2F1\uD2F4\uD2F8\uD300\uD301\uD303\uD305\uD30C\uD30D\uD30E\uD310\uD314\uD316\uD31C\uD31D\uD31F\uD320\uD321\uD325\uD328\uD329\uD32C\uD330\uD338\uD339\uD33B\uD33C\uD33D\uD344\uD345\uD37C\uD37D\uD380\uD384\uD38C\uD38D\uD38F\uD390\uD391\uD398\uD399\uD39C\uD3A0\uD3A8\uD3A9\uD3AB\uD3AD\uD3B4\uD3B8\uD3BC\uD3C4\uD3C5\uD3C8\uD3C9\uD3D0\uD3D8\uD3E1\uD3E3\uD3EC\uD3ED\uD3F0\uD3F4\uD3FC\uD3FD\uD3FF\uD401"],
      ["c7a1", "\uD408\uD41D\uD440\uD444\uD45C\uD460\uD464\uD46D\uD46F\uD478\uD479\uD47C\uD47F\uD480\uD482\uD488\uD489\uD48B\uD48D\uD494\uD4A9\uD4CC\uD4D0\uD4D4\uD4DC\uD4DF\uD4E8\uD4EC\uD4F0\uD4F8\uD4FB\uD4FD\uD504\uD508\uD50C\uD514\uD515\uD517\uD53C\uD53D\uD540\uD544\uD54C\uD54D\uD54F\uD551\uD558\uD559\uD55C\uD560\uD565\uD568\uD569\uD56B\uD56D\uD574\uD575\uD578\uD57C\uD584\uD585\uD587\uD588\uD589\uD590\uD5A5\uD5C8\uD5C9\uD5CC\uD5D0\uD5D2\uD5D8\uD5D9\uD5DB\uD5DD\uD5E4\uD5E5\uD5E8\uD5EC\uD5F4\uD5F5\uD5F7\uD5F9\uD600\uD601\uD604\uD608\uD610\uD611\uD613\uD614\uD615\uD61C\uD620"],
      ["c8a1", "\uD624\uD62D\uD638\uD639\uD63C\uD640\uD645\uD648\uD649\uD64B\uD64D\uD651\uD654\uD655\uD658\uD65C\uD667\uD669\uD670\uD671\uD674\uD683\uD685\uD68C\uD68D\uD690\uD694\uD69D\uD69F\uD6A1\uD6A8\uD6AC\uD6B0\uD6B9\uD6BB\uD6C4\uD6C5\uD6C8\uD6CC\uD6D1\uD6D4\uD6D7\uD6D9\uD6E0\uD6E4\uD6E8\uD6F0\uD6F5\uD6FC\uD6FD\uD700\uD704\uD711\uD718\uD719\uD71C\uD720\uD728\uD729\uD72B\uD72D\uD734\uD735\uD738\uD73C\uD744\uD747\uD749\uD750\uD751\uD754\uD756\uD757\uD758\uD759\uD760\uD761\uD763\uD765\uD769\uD76C\uD770\uD774\uD77C\uD77D\uD781\uD788\uD789\uD78C\uD790\uD798\uD799\uD79B\uD79D"],
      ["caa1", "\u4F3D\u4F73\u5047\u50F9\u52A0\u53EF\u5475\u54E5\u5609\u5AC1\u5BB6\u6687\u67B6\u67B7\u67EF\u6B4C\u73C2\u75C2\u7A3C\u82DB\u8304\u8857\u8888\u8A36\u8CC8\u8DCF\u8EFB\u8FE6\u99D5\u523B\u5374\u5404\u606A\u6164\u6BBC\u73CF\u811A\u89BA\u89D2\u95A3\u4F83\u520A\u58BE\u5978\u59E6\u5E72\u5E79\u61C7\u63C0\u6746\u67EC\u687F\u6F97\u764E\u770B\u78F5\u7A08\u7AFF\u7C21\u809D\u826E\u8271\u8AEB\u9593\u4E6B\u559D\u66F7\u6E34\u78A3\u7AED\u845B\u8910\u874E\u97A8\u52D8\u574E\u582A\u5D4C\u611F\u61BE\u6221\u6562\u67D1\u6A44\u6E1B\u7518\u75B3\u76E3\u77B0\u7D3A\u90AF\u9451\u9452\u9F95"],
      ["cba1", "\u5323\u5CAC\u7532\u80DB\u9240\u9598\u525B\u5808\u59DC\u5CA1\u5D17\u5EB7\u5F3A\u5F4A\u6177\u6C5F\u757A\u7586\u7CE0\u7D73\u7DB1\u7F8C\u8154\u8221\u8591\u8941\u8B1B\u92FC\u964D\u9C47\u4ECB\u4EF7\u500B\u51F1\u584F\u6137\u613E\u6168\u6539\u69EA\u6F11\u75A5\u7686\u76D6\u7B87\u82A5\u84CB\uF900\u93A7\u958B\u5580\u5BA2\u5751\uF901\u7CB3\u7FB9\u91B5\u5028\u53BB\u5C45\u5DE8\u62D2\u636E\u64DA\u64E7\u6E20\u70AC\u795B\u8DDD\u8E1E\uF902\u907D\u9245\u92F8\u4E7E\u4EF6\u5065\u5DFE\u5EFA\u6106\u6957\u8171\u8654\u8E47\u9375\u9A2B\u4E5E\u5091\u6770\u6840\u5109\u528D\u5292\u6AA2"],
      ["cca1", "\u77BC\u9210\u9ED4\u52AB\u602F\u8FF2\u5048\u61A9\u63ED\u64CA\u683C\u6A84\u6FC0\u8188\u89A1\u9694\u5805\u727D\u72AC\u7504\u7D79\u7E6D\u80A9\u898B\u8B74\u9063\u9D51\u6289\u6C7A\u6F54\u7D50\u7F3A\u8A23\u517C\u614A\u7B9D\u8B19\u9257\u938C\u4EAC\u4FD3\u501E\u50BE\u5106\u52C1\u52CD\u537F\u5770\u5883\u5E9A\u5F91\u6176\u61AC\u64CE\u656C\u666F\u66BB\u66F4\u6897\u6D87\u7085\u70F1\u749F\u74A5\u74CA\u75D9\u786C\u78EC\u7ADF\u7AF6\u7D45\u7D93\u8015\u803F\u811B\u8396\u8B66\u8F15\u9015\u93E1\u9803\u9838\u9A5A\u9BE8\u4FC2\u5553\u583A\u5951\u5B63\u5C46\u60B8\u6212\u6842\u68B0"],
      ["cda1", "\u68E8\u6EAA\u754C\u7678\u78CE\u7A3D\u7CFB\u7E6B\u7E7C\u8A08\u8AA1\u8C3F\u968E\u9DC4\u53E4\u53E9\u544A\u5471\u56FA\u59D1\u5B64\u5C3B\u5EAB\u62F7\u6537\u6545\u6572\u66A0\u67AF\u69C1\u6CBD\u75FC\u7690\u777E\u7A3F\u7F94\u8003\u80A1\u818F\u82E6\u82FD\u83F0\u85C1\u8831\u88B4\u8AA5\uF903\u8F9C\u932E\u96C7\u9867\u9AD8\u9F13\u54ED\u659B\u66F2\u688F\u7A40\u8C37\u9D60\u56F0\u5764\u5D11\u6606\u68B1\u68CD\u6EFE\u7428\u889E\u9BE4\u6C68\uF904\u9AA8\u4F9B\u516C\u5171\u529F\u5B54\u5DE5\u6050\u606D\u62F1\u63A7\u653B\u73D9\u7A7A\u86A3\u8CA2\u978F\u4E32\u5BE1\u6208\u679C\u74DC"],
      ["cea1", "\u79D1\u83D3\u8A87\u8AB2\u8DE8\u904E\u934B\u9846\u5ED3\u69E8\u85FF\u90ED\uF905\u51A0\u5B98\u5BEC\u6163\u68FA\u6B3E\u704C\u742F\u74D8\u7BA1\u7F50\u83C5\u89C0\u8CAB\u95DC\u9928\u522E\u605D\u62EC\u9002\u4F8A\u5149\u5321\u58D9\u5EE3\u66E0\u6D38\u709A\u72C2\u73D6\u7B50\u80F1\u945B\u5366\u639B\u7F6B\u4E56\u5080\u584A\u58DE\u602A\u6127\u62D0\u69D0\u9B41\u5B8F\u7D18\u80B1\u8F5F\u4EA4\u50D1\u54AC\u55AC\u5B0C\u5DA0\u5DE7\u652A\u654E\u6821\u6A4B\u72E1\u768E\u77EF\u7D5E\u7FF9\u81A0\u854E\u86DF\u8F03\u8F4E\u90CA\u9903\u9A55\u9BAB\u4E18\u4E45\u4E5D\u4EC7\u4FF1\u5177\u52FE"],
      ["cfa1", "\u5340\u53E3\u53E5\u548E\u5614\u5775\u57A2\u5BC7\u5D87\u5ED0\u61FC\u62D8\u6551\u67B8\u67E9\u69CB\u6B50\u6BC6\u6BEC\u6C42\u6E9D\u7078\u72D7\u7396\u7403\u77BF\u77E9\u7A76\u7D7F\u8009\u81FC\u8205\u820A\u82DF\u8862\u8B33\u8CFC\u8EC0\u9011\u90B1\u9264\u92B6\u99D2\u9A45\u9CE9\u9DD7\u9F9C\u570B\u5C40\u83CA\u97A0\u97AB\u9EB4\u541B\u7A98\u7FA4\u88D9\u8ECD\u90E1\u5800\u5C48\u6398\u7A9F\u5BAE\u5F13\u7A79\u7AAE\u828E\u8EAC\u5026\u5238\u52F8\u5377\u5708\u62F3\u6372\u6B0A\u6DC3\u7737\u53A5\u7357\u8568\u8E76\u95D5\u673A\u6AC3\u6F70\u8A6D\u8ECC\u994B\uF906\u6677\u6B78\u8CB4"],
      ["d0a1", "\u9B3C\uF907\u53EB\u572D\u594E\u63C6\u69FB\u73EA\u7845\u7ABA\u7AC5\u7CFE\u8475\u898F\u8D73\u9035\u95A8\u52FB\u5747\u7547\u7B60\u83CC\u921E\uF908\u6A58\u514B\u524B\u5287\u621F\u68D8\u6975\u9699\u50C5\u52A4\u52E4\u61C3\u65A4\u6839\u69FF\u747E\u7B4B\u82B9\u83EB\u89B2\u8B39\u8FD1\u9949\uF909\u4ECA\u5997\u64D2\u6611\u6A8E\u7434\u7981\u79BD\u82A9\u887E\u887F\u895F\uF90A\u9326\u4F0B\u53CA\u6025\u6271\u6C72\u7D1A\u7D66\u4E98\u5162\u77DC\u80AF\u4F01\u4F0E\u5176\u5180\u55DC\u5668\u573B\u57FA\u57FC\u5914\u5947\u5993\u5BC4\u5C90\u5D0E\u5DF1\u5E7E\u5FCC\u6280\u65D7\u65E3"],
      ["d1a1", "\u671E\u671F\u675E\u68CB\u68C4\u6A5F\u6B3A\u6C23\u6C7D\u6C82\u6DC7\u7398\u7426\u742A\u7482\u74A3\u7578\u757F\u7881\u78EF\u7941\u7947\u7948\u797A\u7B95\u7D00\u7DBA\u7F88\u8006\u802D\u808C\u8A18\u8B4F\u8C48\u8D77\u9321\u9324\u98E2\u9951\u9A0E\u9A0F\u9A65\u9E92\u7DCA\u4F76\u5409\u62EE\u6854\u91D1\u55AB\u513A\uF90B\uF90C\u5A1C\u61E6\uF90D\u62CF\u62FF\uF90E", 5, "\u90A3\uF914", 4, "\u8AFE\uF919\uF91A\uF91B\uF91C\u6696\uF91D\u7156\uF91E\uF91F\u96E3\uF920\u634F\u637A\u5357\uF921\u678F\u6960\u6E73\uF922\u7537\uF923\uF924\uF925"],
      ["d2a1", "\u7D0D\uF926\uF927\u8872\u56CA\u5A18\uF928", 4, "\u4E43\uF92D\u5167\u5948\u67F0\u8010\uF92E\u5973\u5E74\u649A\u79CA\u5FF5\u606C\u62C8\u637B\u5BE7\u5BD7\u52AA\uF92F\u5974\u5F29\u6012\uF930\uF931\uF932\u7459\uF933", 5, "\u99D1\uF939", 10, "\u6FC3\uF944\uF945\u81BF\u8FB2\u60F1\uF946\uF947\u8166\uF948\uF949\u5C3F\uF94A", 7, "\u5AE9\u8A25\u677B\u7D10\uF952", 5, "\u80FD\uF958\uF959\u5C3C\u6CE5\u533F\u6EBA\u591A\u8336"],
      ["d3a1", "\u4E39\u4EB6\u4F46\u55AE\u5718\u58C7\u5F56\u65B7\u65E6\u6A80\u6BB5\u6E4D\u77ED\u7AEF\u7C1E\u7DDE\u86CB\u8892\u9132\u935B\u64BB\u6FBE\u737A\u75B8\u9054\u5556\u574D\u61BA\u64D4\u66C7\u6DE1\u6E5B\u6F6D\u6FB9\u75F0\u8043\u81BD\u8541\u8983\u8AC7\u8B5A\u931F\u6C93\u7553\u7B54\u8E0F\u905D\u5510\u5802\u5858\u5E62\u6207\u649E\u68E0\u7576\u7CD6\u87B3\u9EE8\u4EE3\u5788\u576E\u5927\u5C0D\u5CB1\u5E36\u5F85\u6234\u64E1\u73B3\u81FA\u888B\u8CB8\u968A\u9EDB\u5B85\u5FB7\u60B3\u5012\u5200\u5230\u5716\u5835\u5857\u5C0E\u5C60\u5CF6\u5D8B\u5EA6\u5F92\u60BC\u6311\u6389\u6417\u6843"],
      ["d4a1", "\u68F9\u6AC2\u6DD8\u6E21\u6ED4\u6FE4\u71FE\u76DC\u7779\u79B1\u7A3B\u8404\u89A9\u8CED\u8DF3\u8E48\u9003\u9014\u9053\u90FD\u934D\u9676\u97DC\u6BD2\u7006\u7258\u72A2\u7368\u7763\u79BF\u7BE4\u7E9B\u8B80\u58A9\u60C7\u6566\u65FD\u66BE\u6C8C\u711E\u71C9\u8C5A\u9813\u4E6D\u7A81\u4EDD\u51AC\u51CD\u52D5\u540C\u61A7\u6771\u6850\u68DF\u6D1E\u6F7C\u75BC\u77B3\u7AE5\u80F4\u8463\u9285\u515C\u6597\u675C\u6793\u75D8\u7AC7\u8373\uF95A\u8C46\u9017\u982D\u5C6F\u81C0\u829A\u9041\u906F\u920D\u5F97\u5D9D\u6A59\u71C8\u767B\u7B49\u85E4\u8B04\u9127\u9A30\u5587\u61F6\uF95B\u7669\u7F85"],
      ["d5a1", "\u863F\u87BA\u88F8\u908F\uF95C\u6D1B\u70D9\u73DE\u7D61\u843D\uF95D\u916A\u99F1\uF95E\u4E82\u5375\u6B04\u6B12\u703E\u721B\u862D\u9E1E\u524C\u8FA3\u5D50\u64E5\u652C\u6B16\u6FEB\u7C43\u7E9C\u85CD\u8964\u89BD\u62C9\u81D8\u881F\u5ECA\u6717\u6D6A\u72FC\u7405\u746F\u8782\u90DE\u4F86\u5D0D\u5FA0\u840A\u51B7\u63A0\u7565\u4EAE\u5006\u5169\u51C9\u6881\u6A11\u7CAE\u7CB1\u7CE7\u826F\u8AD2\u8F1B\u91CF\u4FB6\u5137\u52F5\u5442\u5EEC\u616E\u623E\u65C5\u6ADA\u6FFE\u792A\u85DC\u8823\u95AD\u9A62\u9A6A\u9E97\u9ECE\u529B\u66C6\u6B77\u701D\u792B\u8F62\u9742\u6190\u6200\u6523\u6F23"],
      ["d6a1", "\u7149\u7489\u7DF4\u806F\u84EE\u8F26\u9023\u934A\u51BD\u5217\u52A3\u6D0C\u70C8\u88C2\u5EC9\u6582\u6BAE\u6FC2\u7C3E\u7375\u4EE4\u4F36\u56F9\uF95F\u5CBA\u5DBA\u601C\u73B2\u7B2D\u7F9A\u7FCE\u8046\u901E\u9234\u96F6\u9748\u9818\u9F61\u4F8B\u6FA7\u79AE\u91B4\u96B7\u52DE\uF960\u6488\u64C4\u6AD3\u6F5E\u7018\u7210\u76E7\u8001\u8606\u865C\u8DEF\u8F05\u9732\u9B6F\u9DFA\u9E75\u788C\u797F\u7DA0\u83C9\u9304\u9E7F\u9E93\u8AD6\u58DF\u5F04\u6727\u7027\u74CF\u7C60\u807E\u5121\u7028\u7262\u78CA\u8CC2\u8CDA\u8CF4\u96F7\u4E86\u50DA\u5BEE\u5ED6\u6599\u71CE\u7642\u77AD\u804A\u84FC"],
      ["d7a1", "\u907C\u9B27\u9F8D\u58D8\u5A41\u5C62\u6A13\u6DDA\u6F0F\u763B\u7D2F\u7E37\u851E\u8938\u93E4\u964B\u5289\u65D2\u67F3\u69B4\u6D41\u6E9C\u700F\u7409\u7460\u7559\u7624\u786B\u8B2C\u985E\u516D\u622E\u9678\u4F96\u502B\u5D19\u6DEA\u7DB8\u8F2A\u5F8B\u6144\u6817\uF961\u9686\u52D2\u808B\u51DC\u51CC\u695E\u7A1C\u7DBE\u83F1\u9675\u4FDA\u5229\u5398\u540F\u550E\u5C65\u60A7\u674E\u68A8\u6D6C\u7281\u72F8\u7406\u7483\uF962\u75E2\u7C6C\u7F79\u7FB8\u8389\u88CF\u88E1\u91CC\u91D0\u96E2\u9BC9\u541D\u6F7E\u71D0\u7498\u85FA\u8EAA\u96A3\u9C57\u9E9F\u6797\u6DCB\u7433\u81E8\u9716\u782C"],
      ["d8a1", "\u7ACB\u7B20\u7C92\u6469\u746A\u75F2\u78BC\u78E8\u99AC\u9B54\u9EBB\u5BDE\u5E55\u6F20\u819C\u83AB\u9088\u4E07\u534D\u5A29\u5DD2\u5F4E\u6162\u633D\u6669\u66FC\u6EFF\u6F2B\u7063\u779E\u842C\u8513\u883B\u8F13\u9945\u9C3B\u551C\u62B9\u672B\u6CAB\u8309\u896A\u977A\u4EA1\u5984\u5FD8\u5FD9\u671B\u7DB2\u7F54\u8292\u832B\u83BD\u8F1E\u9099\u57CB\u59B9\u5A92\u5BD0\u6627\u679A\u6885\u6BCF\u7164\u7F75\u8CB7\u8CE3\u9081\u9B45\u8108\u8C8A\u964C\u9A40\u9EA5\u5B5F\u6C13\u731B\u76F2\u76DF\u840C\u51AA\u8993\u514D\u5195\u52C9\u68C9\u6C94\u7704\u7720\u7DBF\u7DEC\u9762\u9EB5\u6EC5"],
      ["d9a1", "\u8511\u51A5\u540D\u547D\u660E\u669D\u6927\u6E9F\u76BF\u7791\u8317\u84C2\u879F\u9169\u9298\u9CF4\u8882\u4FAE\u5192\u52DF\u59C6\u5E3D\u6155\u6478\u6479\u66AE\u67D0\u6A21\u6BCD\u6BDB\u725F\u7261\u7441\u7738\u77DB\u8017\u82BC\u8305\u8B00\u8B28\u8C8C\u6728\u6C90\u7267\u76EE\u7766\u7A46\u9DA9\u6B7F\u6C92\u5922\u6726\u8499\u536F\u5893\u5999\u5EDF\u63CF\u6634\u6773\u6E3A\u732B\u7AD7\u82D7\u9328\u52D9\u5DEB\u61AE\u61CB\u620A\u62C7\u64AB\u65E0\u6959\u6B66\u6BCB\u7121\u73F7\u755D\u7E46\u821E\u8302\u856A\u8AA3\u8CBF\u9727\u9D61\u58A8\u9ED8\u5011\u520E\u543B\u554F\u6587"],
      ["daa1", "\u6C76\u7D0A\u7D0B\u805E\u868A\u9580\u96EF\u52FF\u6C95\u7269\u5473\u5A9A\u5C3E\u5D4B\u5F4C\u5FAE\u672A\u68B6\u6963\u6E3C\u6E44\u7709\u7C73\u7F8E\u8587\u8B0E\u8FF7\u9761\u9EF4\u5CB7\u60B6\u610D\u61AB\u654F\u65FB\u65FC\u6C11\u6CEF\u739F\u73C9\u7DE1\u9594\u5BC6\u871C\u8B10\u525D\u535A\u62CD\u640F\u64B2\u6734\u6A38\u6CCA\u73C0\u749E\u7B94\u7C95\u7E1B\u818A\u8236\u8584\u8FEB\u96F9\u99C1\u4F34\u534A\u53CD\u53DB\u62CC\u642C\u6500\u6591\u69C3\u6CEE\u6F58\u73ED\u7554\u7622\u76E4\u76FC\u78D0\u78FB\u792C\u7D46\u822C\u87E0\u8FD4\u9812\u98EF\u52C3\u62D4\u64A5\u6E24\u6F51"],
      ["dba1", "\u767C\u8DCB\u91B1\u9262\u9AEE\u9B43\u5023\u508D\u574A\u59A8\u5C28\u5E47\u5F77\u623F\u653E\u65B9\u65C1\u6609\u678B\u699C\u6EC2\u78C5\u7D21\u80AA\u8180\u822B\u82B3\u84A1\u868C\u8A2A\u8B17\u90A6\u9632\u9F90\u500D\u4FF3\uF963\u57F9\u5F98\u62DC\u6392\u676F\u6E43\u7119\u76C3\u80CC\u80DA\u88F4\u88F5\u8919\u8CE0\u8F29\u914D\u966A\u4F2F\u4F70\u5E1B\u67CF\u6822\u767D\u767E\u9B44\u5E61\u6A0A\u7169\u71D4\u756A\uF964\u7E41\u8543\u85E9\u98DC\u4F10\u7B4F\u7F70\u95A5\u51E1\u5E06\u68B5\u6C3E\u6C4E\u6CDB\u72AF\u7BC4\u8303\u6CD5\u743A\u50FB\u5288\u58C1\u64D8\u6A97\u74A7\u7656"],
      ["dca1", "\u78A7\u8617\u95E2\u9739\uF965\u535E\u5F01\u8B8A\u8FA8\u8FAF\u908A\u5225\u77A5\u9C49\u9F08\u4E19\u5002\u5175\u5C5B\u5E77\u661E\u663A\u67C4\u68C5\u70B3\u7501\u75C5\u79C9\u7ADD\u8F27\u9920\u9A08\u4FDD\u5821\u5831\u5BF6\u666E\u6B65\u6D11\u6E7A\u6F7D\u73E4\u752B\u83E9\u88DC\u8913\u8B5C\u8F14\u4F0F\u50D5\u5310\u535C\u5B93\u5FA9\u670D\u798F\u8179\u832F\u8514\u8907\u8986\u8F39\u8F3B\u99A5\u9C12\u672C\u4E76\u4FF8\u5949\u5C01\u5CEF\u5CF0\u6367\u68D2\u70FD\u71A2\u742B\u7E2B\u84EC\u8702\u9022\u92D2\u9CF3\u4E0D\u4ED8\u4FEF\u5085\u5256\u526F\u5426\u5490\u57E0\u592B\u5A66"],
      ["dda1", "\u5B5A\u5B75\u5BCC\u5E9C\uF966\u6276\u6577\u65A7\u6D6E\u6EA5\u7236\u7B26\u7C3F\u7F36\u8150\u8151\u819A\u8240\u8299\u83A9\u8A03\u8CA0\u8CE6\u8CFB\u8D74\u8DBA\u90E8\u91DC\u961C\u9644\u99D9\u9CE7\u5317\u5206\u5429\u5674\u58B3\u5954\u596E\u5FFF\u61A4\u626E\u6610\u6C7E\u711A\u76C6\u7C89\u7CDE\u7D1B\u82AC\u8CC1\u96F0\uF967\u4F5B\u5F17\u5F7F\u62C2\u5D29\u670B\u68DA\u787C\u7E43\u9D6C\u4E15\u5099\u5315\u532A\u5351\u5983\u5A62\u5E87\u60B2\u618A\u6249\u6279\u6590\u6787\u69A7\u6BD4\u6BD6\u6BD7\u6BD8\u6CB8\uF968\u7435\u75FA\u7812\u7891\u79D5\u79D8\u7C83\u7DCB\u7FE1\u80A5"],
      ["dea1", "\u813E\u81C2\u83F2\u871A\u88E8\u8AB9\u8B6C\u8CBB\u9119\u975E\u98DB\u9F3B\u56AC\u5B2A\u5F6C\u658C\u6AB3\u6BAF\u6D5C\u6FF1\u7015\u725D\u73AD\u8CA7\u8CD3\u983B\u6191\u6C37\u8058\u9A01\u4E4D\u4E8B\u4E9B\u4ED5\u4F3A\u4F3C\u4F7F\u4FDF\u50FF\u53F2\u53F8\u5506\u55E3\u56DB\u58EB\u5962\u5A11\u5BEB\u5BFA\u5C04\u5DF3\u5E2B\u5F99\u601D\u6368\u659C\u65AF\u67F6\u67FB\u68AD\u6B7B\u6C99\u6CD7\u6E23\u7009\u7345\u7802\u793E\u7940\u7960\u79C1\u7BE9\u7D17\u7D72\u8086\u820D\u838E\u84D1\u86C7\u88DF\u8A50\u8A5E\u8B1D\u8CDC\u8D66\u8FAD\u90AA\u98FC\u99DF\u9E9D\u524A\uF969\u6714\uF96A"],
      ["dfa1", "\u5098\u522A\u5C71\u6563\u6C55\u73CA\u7523\u759D\u7B97\u849C\u9178\u9730\u4E77\u6492\u6BBA\u715E\u85A9\u4E09\uF96B\u6749\u68EE\u6E17\u829F\u8518\u886B\u63F7\u6F81\u9212\u98AF\u4E0A\u50B7\u50CF\u511F\u5546\u55AA\u5617\u5B40\u5C19\u5CE0\u5E38\u5E8A\u5EA0\u5EC2\u60F3\u6851\u6A61\u6E58\u723D\u7240\u72C0\u76F8\u7965\u7BB1\u7FD4\u88F3\u89F4\u8A73\u8C61\u8CDE\u971C\u585E\u74BD\u8CFD\u55C7\uF96C\u7A61\u7D22\u8272\u7272\u751F\u7525\uF96D\u7B19\u5885\u58FB\u5DBC\u5E8F\u5EB6\u5F90\u6055\u6292\u637F\u654D\u6691\u66D9\u66F8\u6816\u68F2\u7280\u745E\u7B6E\u7D6E\u7DD6\u7F72"],
      ["e0a1", "\u80E5\u8212\u85AF\u897F\u8A93\u901D\u92E4\u9ECD\u9F20\u5915\u596D\u5E2D\u60DC\u6614\u6673\u6790\u6C50\u6DC5\u6F5F\u77F3\u78A9\u84C6\u91CB\u932B\u4ED9\u50CA\u5148\u5584\u5B0B\u5BA3\u6247\u657E\u65CB\u6E32\u717D\u7401\u7444\u7487\u74BF\u766C\u79AA\u7DDA\u7E55\u7FA8\u817A\u81B3\u8239\u861A\u87EC\u8A75\u8DE3\u9078\u9291\u9425\u994D\u9BAE\u5368\u5C51\u6954\u6CC4\u6D29\u6E2B\u820C\u859B\u893B\u8A2D\u8AAA\u96EA\u9F67\u5261\u66B9\u6BB2\u7E96\u87FE\u8D0D\u9583\u965D\u651D\u6D89\u71EE\uF96E\u57CE\u59D3\u5BAC\u6027\u60FA\u6210\u661F\u665F\u7329\u73F9\u76DB\u7701\u7B6C"],
      ["e1a1", "\u8056\u8072\u8165\u8AA0\u9192\u4E16\u52E2\u6B72\u6D17\u7A05\u7B39\u7D30\uF96F\u8CB0\u53EC\u562F\u5851\u5BB5\u5C0F\u5C11\u5DE2\u6240\u6383\u6414\u662D\u68B3\u6CBC\u6D88\u6EAF\u701F\u70A4\u71D2\u7526\u758F\u758E\u7619\u7B11\u7BE0\u7C2B\u7D20\u7D39\u852C\u856D\u8607\u8A34\u900D\u9061\u90B5\u92B7\u97F6\u9A37\u4FD7\u5C6C\u675F\u6D91\u7C9F\u7E8C\u8B16\u8D16\u901F\u5B6B\u5DFD\u640D\u84C0\u905C\u98E1\u7387\u5B8B\u609A\u677E\u6DDE\u8A1F\u8AA6\u9001\u980C\u5237\uF970\u7051\u788E\u9396\u8870\u91D7\u4FEE\u53D7\u55FD\u56DA\u5782\u58FD\u5AC2\u5B88\u5CAB\u5CC0\u5E25\u6101"],
      ["e2a1", "\u620D\u624B\u6388\u641C\u6536\u6578\u6A39\u6B8A\u6C34\u6D19\u6F31\u71E7\u72E9\u7378\u7407\u74B2\u7626\u7761\u79C0\u7A57\u7AEA\u7CB9\u7D8F\u7DAC\u7E61\u7F9E\u8129\u8331\u8490\u84DA\u85EA\u8896\u8AB0\u8B90\u8F38\u9042\u9083\u916C\u9296\u92B9\u968B\u96A7\u96A8\u96D6\u9700\u9808\u9996\u9AD3\u9B1A\u53D4\u587E\u5919\u5B70\u5BBF\u6DD1\u6F5A\u719F\u7421\u74B9\u8085\u83FD\u5DE1\u5F87\u5FAA\u6042\u65EC\u6812\u696F\u6A53\u6B89\u6D35\u6DF3\u73E3\u76FE\u77AC\u7B4D\u7D14\u8123\u821C\u8340\u84F4\u8563\u8A62\u8AC4\u9187\u931E\u9806\u99B4\u620C\u8853\u8FF0\u9265\u5D07\u5D27"],
      ["e3a1", "\u5D69\u745F\u819D\u8768\u6FD5\u62FE\u7FD2\u8936\u8972\u4E1E\u4E58\u50E7\u52DD\u5347\u627F\u6607\u7E69\u8805\u965E\u4F8D\u5319\u5636\u59CB\u5AA4\u5C38\u5C4E\u5C4D\u5E02\u5F11\u6043\u65BD\u662F\u6642\u67BE\u67F4\u731C\u77E2\u793A\u7FC5\u8494\u84CD\u8996\u8A66\u8A69\u8AE1\u8C55\u8C7A\u57F4\u5BD4\u5F0F\u606F\u62ED\u690D\u6B96\u6E5C\u7184\u7BD2\u8755\u8B58\u8EFE\u98DF\u98FE\u4F38\u4F81\u4FE1\u547B\u5A20\u5BB8\u613C\u65B0\u6668\u71FC\u7533\u795E\u7D33\u814E\u81E3\u8398\u85AA\u85CE\u8703\u8A0A\u8EAB\u8F9B\uF971\u8FC5\u5931\u5BA4\u5BE6\u6089\u5BE9\u5C0B\u5FC3\u6C81"],
      ["e4a1", "\uF972\u6DF1\u700B\u751A\u82AF\u8AF6\u4EC0\u5341\uF973\u96D9\u6C0F\u4E9E\u4FC4\u5152\u555E\u5A25\u5CE8\u6211\u7259\u82BD\u83AA\u86FE\u8859\u8A1D\u963F\u96C5\u9913\u9D09\u9D5D\u580A\u5CB3\u5DBD\u5E44\u60E1\u6115\u63E1\u6A02\u6E25\u9102\u9354\u984E\u9C10\u9F77\u5B89\u5CB8\u6309\u664F\u6848\u773C\u96C1\u978D\u9854\u9B9F\u65A1\u8B01\u8ECB\u95BC\u5535\u5CA9\u5DD6\u5EB5\u6697\u764C\u83F4\u95C7\u58D3\u62BC\u72CE\u9D28\u4EF0\u592E\u600F\u663B\u6B83\u79E7\u9D26\u5393\u54C0\u57C3\u5D16\u611B\u66D6\u6DAF\u788D\u827E\u9698\u9744\u5384\u627C\u6396\u6DB2\u7E0A\u814B\u984D"],
      ["e5a1", "\u6AFB\u7F4C\u9DAF\u9E1A\u4E5F\u503B\u51B6\u591C\u60F9\u63F6\u6930\u723A\u8036\uF974\u91CE\u5F31\uF975\uF976\u7D04\u82E5\u846F\u84BB\u85E5\u8E8D\uF977\u4F6F\uF978\uF979\u58E4\u5B43\u6059\u63DA\u6518\u656D\u6698\uF97A\u694A\u6A23\u6D0B\u7001\u716C\u75D2\u760D\u79B3\u7A70\uF97B\u7F8A\uF97C\u8944\uF97D\u8B93\u91C0\u967D\uF97E\u990A\u5704\u5FA1\u65BC\u6F01\u7600\u79A6\u8A9E\u99AD\u9B5A\u9F6C\u5104\u61B6\u6291\u6A8D\u81C6\u5043\u5830\u5F66\u7109\u8A00\u8AFA\u5B7C\u8616\u4FFA\u513C\u56B4\u5944\u63A9\u6DF9\u5DAA\u696D\u5186\u4E88\u4F59\uF97F\uF980\uF981\u5982\uF982"],
      ["e6a1", "\uF983\u6B5F\u6C5D\uF984\u74B5\u7916\uF985\u8207\u8245\u8339\u8F3F\u8F5D\uF986\u9918\uF987\uF988\uF989\u4EA6\uF98A\u57DF\u5F79\u6613\uF98B\uF98C\u75AB\u7E79\u8B6F\uF98D\u9006\u9A5B\u56A5\u5827\u59F8\u5A1F\u5BB4\uF98E\u5EF6\uF98F\uF990\u6350\u633B\uF991\u693D\u6C87\u6CBF\u6D8E\u6D93\u6DF5\u6F14\uF992\u70DF\u7136\u7159\uF993\u71C3\u71D5\uF994\u784F\u786F\uF995\u7B75\u7DE3\uF996\u7E2F\uF997\u884D\u8EDF\uF998\uF999\uF99A\u925B\uF99B\u9CF6\uF99C\uF99D\uF99E\u6085\u6D85\uF99F\u71B1\uF9A0\uF9A1\u95B1\u53AD\uF9A2\uF9A3\uF9A4\u67D3\uF9A5\u708E\u7130\u7430\u8276\u82D2"],
      ["e7a1", "\uF9A6\u95BB\u9AE5\u9E7D\u66C4\uF9A7\u71C1\u8449\uF9A8\uF9A9\u584B\uF9AA\uF9AB\u5DB8\u5F71\uF9AC\u6620\u668E\u6979\u69AE\u6C38\u6CF3\u6E36\u6F41\u6FDA\u701B\u702F\u7150\u71DF\u7370\uF9AD\u745B\uF9AE\u74D4\u76C8\u7A4E\u7E93\uF9AF\uF9B0\u82F1\u8A60\u8FCE\uF9B1\u9348\uF9B2\u9719\uF9B3\uF9B4\u4E42\u502A\uF9B5\u5208\u53E1\u66F3\u6C6D\u6FCA\u730A\u777F\u7A62\u82AE\u85DD\u8602\uF9B6\u88D4\u8A63\u8B7D\u8C6B\uF9B7\u92B3\uF9B8\u9713\u9810\u4E94\u4F0D\u4FC9\u50B2\u5348\u543E\u5433\u55DA\u5862\u58BA\u5967\u5A1B\u5BE4\u609F\uF9B9\u61CA\u6556\u65FF\u6664\u68A7\u6C5A\u6FB3"],
      ["e8a1", "\u70CF\u71AC\u7352\u7B7D\u8708\u8AA4\u9C32\u9F07\u5C4B\u6C83\u7344\u7389\u923A\u6EAB\u7465\u761F\u7A69\u7E15\u860A\u5140\u58C5\u64C1\u74EE\u7515\u7670\u7FC1\u9095\u96CD\u9954\u6E26\u74E6\u7AA9\u7AAA\u81E5\u86D9\u8778\u8A1B\u5A49\u5B8C\u5B9B\u68A1\u6900\u6D63\u73A9\u7413\u742C\u7897\u7DE9\u7FEB\u8118\u8155\u839E\u8C4C\u962E\u9811\u66F0\u5F80\u65FA\u6789\u6C6A\u738B\u502D\u5A03\u6B6A\u77EE\u5916\u5D6C\u5DCD\u7325\u754F\uF9BA\uF9BB\u50E5\u51F9\u582F\u592D\u5996\u59DA\u5BE5\uF9BC\uF9BD\u5DA2\u62D7\u6416\u6493\u64FE\uF9BE\u66DC\uF9BF\u6A48\uF9C0\u71FF\u7464\uF9C1"],
      ["e9a1", "\u7A88\u7AAF\u7E47\u7E5E\u8000\u8170\uF9C2\u87EF\u8981\u8B20\u9059\uF9C3\u9080\u9952\u617E\u6B32\u6D74\u7E1F\u8925\u8FB1\u4FD1\u50AD\u5197\u52C7\u57C7\u5889\u5BB9\u5EB8\u6142\u6995\u6D8C\u6E67\u6EB6\u7194\u7462\u7528\u752C\u8073\u8338\u84C9\u8E0A\u9394\u93DE\uF9C4\u4E8E\u4F51\u5076\u512A\u53C8\u53CB\u53F3\u5B87\u5BD3\u5C24\u611A\u6182\u65F4\u725B\u7397\u7440\u76C2\u7950\u7991\u79B9\u7D06\u7FBD\u828B\u85D5\u865E\u8FC2\u9047\u90F5\u91EA\u9685\u96E8\u96E9\u52D6\u5F67\u65ED\u6631\u682F\u715C\u7A36\u90C1\u980A\u4E91\uF9C5\u6A52\u6B9E\u6F90\u7189\u8018\u82B8\u8553"],
      ["eaa1", "\u904B\u9695\u96F2\u97FB\u851A\u9B31\u4E90\u718A\u96C4\u5143\u539F\u54E1\u5713\u5712\u57A3\u5A9B\u5AC4\u5BC3\u6028\u613F\u63F4\u6C85\u6D39\u6E72\u6E90\u7230\u733F\u7457\u82D1\u8881\u8F45\u9060\uF9C6\u9662\u9858\u9D1B\u6708\u8D8A\u925E\u4F4D\u5049\u50DE\u5371\u570D\u59D4\u5A01\u5C09\u6170\u6690\u6E2D\u7232\u744B\u7DEF\u80C3\u840E\u8466\u853F\u875F\u885B\u8918\u8B02\u9055\u97CB\u9B4F\u4E73\u4F91\u5112\u516A\uF9C7\u552F\u55A9\u5B7A\u5BA5\u5E7C\u5E7D\u5EBE\u60A0\u60DF\u6108\u6109\u63C4\u6538\u6709\uF9C8\u67D4\u67DA\uF9C9\u6961\u6962\u6CB9\u6D27\uF9CA\u6E38\uF9CB"],
      ["eba1", "\u6FE1\u7336\u7337\uF9CC\u745C\u7531\uF9CD\u7652\uF9CE\uF9CF\u7DAD\u81FE\u8438\u88D5\u8A98\u8ADB\u8AED\u8E30\u8E42\u904A\u903E\u907A\u9149\u91C9\u936E\uF9D0\uF9D1\u5809\uF9D2\u6BD3\u8089\u80B2\uF9D3\uF9D4\u5141\u596B\u5C39\uF9D5\uF9D6\u6F64\u73A7\u80E4\u8D07\uF9D7\u9217\u958F\uF9D8\uF9D9\uF9DA\uF9DB\u807F\u620E\u701C\u7D68\u878D\uF9DC\u57A0\u6069\u6147\u6BB7\u8ABE\u9280\u96B1\u4E59\u541F\u6DEB\u852D\u9670\u97F3\u98EE\u63D6\u6CE3\u9091\u51DD\u61C9\u81BA\u9DF9\u4F9D\u501A\u5100\u5B9C\u610F\u61FF\u64EC\u6905\u6BC5\u7591\u77E3\u7FA9\u8264\u858F\u87FB\u8863\u8ABC"],
      ["eca1", "\u8B70\u91AB\u4E8C\u4EE5\u4F0A\uF9DD\uF9DE\u5937\u59E8\uF9DF\u5DF2\u5F1B\u5F5B\u6021\uF9E0\uF9E1\uF9E2\uF9E3\u723E\u73E5\uF9E4\u7570\u75CD\uF9E5\u79FB\uF9E6\u800C\u8033\u8084\u82E1\u8351\uF9E7\uF9E8\u8CBD\u8CB3\u9087\uF9E9\uF9EA\u98F4\u990C\uF9EB\uF9EC\u7037\u76CA\u7FCA\u7FCC\u7FFC\u8B1A\u4EBA\u4EC1\u5203\u5370\uF9ED\u54BD\u56E0\u59FB\u5BC5\u5F15\u5FCD\u6E6E\uF9EE\uF9EF\u7D6A\u8335\uF9F0\u8693\u8A8D\uF9F1\u976D\u9777\uF9F2\uF9F3\u4E00\u4F5A\u4F7E\u58F9\u65E5\u6EA2\u9038\u93B0\u99B9\u4EFB\u58EC\u598A\u59D9\u6041\uF9F4\uF9F5\u7A14\uF9F6\u834F\u8CC3\u5165\u5344"],
      ["eda1", "\uF9F7\uF9F8\uF9F9\u4ECD\u5269\u5B55\u82BF\u4ED4\u523A\u54A8\u59C9\u59FF\u5B50\u5B57\u5B5C\u6063\u6148\u6ECB\u7099\u716E\u7386\u74F7\u75B5\u78C1\u7D2B\u8005\u81EA\u8328\u8517\u85C9\u8AEE\u8CC7\u96CC\u4F5C\u52FA\u56BC\u65AB\u6628\u707C\u70B8\u7235\u7DBD\u828D\u914C\u96C0\u9D72\u5B71\u68E7\u6B98\u6F7A\u76DE\u5C91\u66AB\u6F5B\u7BB4\u7C2A\u8836\u96DC\u4E08\u4ED7\u5320\u5834\u58BB\u58EF\u596C\u5C07\u5E33\u5E84\u5F35\u638C\u66B2\u6756\u6A1F\u6AA3\u6B0C\u6F3F\u7246\uF9FA\u7350\u748B\u7AE0\u7CA7\u8178\u81DF\u81E7\u838A\u846C\u8523\u8594\u85CF\u88DD\u8D13\u91AC\u9577"],
      ["eea1", "\u969C\u518D\u54C9\u5728\u5BB0\u624D\u6750\u683D\u6893\u6E3D\u6ED3\u707D\u7E21\u88C1\u8CA1\u8F09\u9F4B\u9F4E\u722D\u7B8F\u8ACD\u931A\u4F47\u4F4E\u5132\u5480\u59D0\u5E95\u62B5\u6775\u696E\u6A17\u6CAE\u6E1A\u72D9\u732A\u75BD\u7BB8\u7D35\u82E7\u83F9\u8457\u85F7\u8A5B\u8CAF\u8E87\u9019\u90B8\u96CE\u9F5F\u52E3\u540A\u5AE1\u5BC2\u6458\u6575\u6EF4\u72C4\uF9FB\u7684\u7A4D\u7B1B\u7C4D\u7E3E\u7FDF\u837B\u8B2B\u8CCA\u8D64\u8DE1\u8E5F\u8FEA\u8FF9\u9069\u93D1\u4F43\u4F7A\u50B3\u5168\u5178\u524D\u526A\u5861\u587C\u5960\u5C08\u5C55\u5EDB\u609B\u6230\u6813\u6BBF\u6C08\u6FB1"],
      ["efa1", "\u714E\u7420\u7530\u7538\u7551\u7672\u7B4C\u7B8B\u7BAD\u7BC6\u7E8F\u8A6E\u8F3E\u8F49\u923F\u9293\u9322\u942B\u96FB\u985A\u986B\u991E\u5207\u622A\u6298\u6D59\u7664\u7ACA\u7BC0\u7D76\u5360\u5CBE\u5E97\u6F38\u70B9\u7C98\u9711\u9B8E\u9EDE\u63A5\u647A\u8776\u4E01\u4E95\u4EAD\u505C\u5075\u5448\u59C3\u5B9A\u5E40\u5EAD\u5EF7\u5F81\u60C5\u633A\u653F\u6574\u65CC\u6676\u6678\u67FE\u6968\u6A89\u6B63\u6C40\u6DC0\u6DE8\u6E1F\u6E5E\u701E\u70A1\u738E\u73FD\u753A\u775B\u7887\u798E\u7A0B\u7A7D\u7CBE\u7D8E\u8247\u8A02\u8AEA\u8C9E\u912D\u914A\u91D8\u9266\u92CC\u9320\u9706\u9756"],
      ["f0a1", "\u975C\u9802\u9F0E\u5236\u5291\u557C\u5824\u5E1D\u5F1F\u608C\u63D0\u68AF\u6FDF\u796D\u7B2C\u81CD\u85BA\u88FD\u8AF8\u8E44\u918D\u9664\u969B\u973D\u984C\u9F4A\u4FCE\u5146\u51CB\u52A9\u5632\u5F14\u5F6B\u63AA\u64CD\u65E9\u6641\u66FA\u66F9\u671D\u689D\u68D7\u69FD\u6F15\u6F6E\u7167\u71E5\u722A\u74AA\u773A\u7956\u795A\u79DF\u7A20\u7A95\u7C97\u7CDF\u7D44\u7E70\u8087\u85FB\u86A4\u8A54\u8ABF\u8D99\u8E81\u9020\u906D\u91E3\u963B\u96D5\u9CE5\u65CF\u7C07\u8DB3\u93C3\u5B58\u5C0A\u5352\u62D9\u731D\u5027\u5B97\u5F9E\u60B0\u616B\u68D5\u6DD9\u742E\u7A2E\u7D42\u7D9C\u7E31\u816B"],
      ["f1a1", "\u8E2A\u8E35\u937E\u9418\u4F50\u5750\u5DE6\u5EA7\u632B\u7F6A\u4E3B\u4F4F\u4F8F\u505A\u59DD\u80C4\u546A\u5468\u55FE\u594F\u5B99\u5DDE\u5EDA\u665D\u6731\u67F1\u682A\u6CE8\u6D32\u6E4A\u6F8D\u70B7\u73E0\u7587\u7C4C\u7D02\u7D2C\u7DA2\u821F\u86DB\u8A3B\u8A85\u8D70\u8E8A\u8F33\u9031\u914E\u9152\u9444\u99D0\u7AF9\u7CA5\u4FCA\u5101\u51C6\u57C8\u5BEF\u5CFB\u6659\u6A3D\u6D5A\u6E96\u6FEC\u710C\u756F\u7AE3\u8822\u9021\u9075\u96CB\u99FF\u8301\u4E2D\u4EF2\u8846\u91CD\u537D\u6ADB\u696B\u6C41\u847A\u589E\u618E\u66FE\u62EF\u70DD\u7511\u75C7\u7E52\u84B8\u8B49\u8D08\u4E4B\u53EA"],
      ["f2a1", "\u54AB\u5730\u5740\u5FD7\u6301\u6307\u646F\u652F\u65E8\u667A\u679D\u67B3\u6B62\u6C60\u6C9A\u6F2C\u77E5\u7825\u7949\u7957\u7D19\u80A2\u8102\u81F3\u829D\u82B7\u8718\u8A8C\uF9FC\u8D04\u8DBE\u9072\u76F4\u7A19\u7A37\u7E54\u8077\u5507\u55D4\u5875\u632F\u6422\u6649\u664B\u686D\u699B\u6B84\u6D25\u6EB1\u73CD\u7468\u74A1\u755B\u75B9\u76E1\u771E\u778B\u79E6\u7E09\u7E1D\u81FB\u852F\u8897\u8A3A\u8CD1\u8EEB\u8FB0\u9032\u93AD\u9663\u9673\u9707\u4F84\u53F1\u59EA\u5AC9\u5E19\u684E\u74C6\u75BE\u79E9\u7A92\u81A3\u86ED\u8CEA\u8DCC\u8FED\u659F\u6715\uF9FD\u57F7\u6F57\u7DDD\u8F2F"],
      ["f3a1", "\u93F6\u96C6\u5FB5\u61F2\u6F84\u4E14\u4F98\u501F\u53C9\u55DF\u5D6F\u5DEE\u6B21\u6B64\u78CB\u7B9A\uF9FE\u8E49\u8ECA\u906E\u6349\u643E\u7740\u7A84\u932F\u947F\u9F6A\u64B0\u6FAF\u71E6\u74A8\u74DA\u7AC4\u7C12\u7E82\u7CB2\u7E98\u8B9A\u8D0A\u947D\u9910\u994C\u5239\u5BDF\u64E6\u672D\u7D2E\u50ED\u53C3\u5879\u6158\u6159\u61FA\u65AC\u7AD9\u8B92\u8B96\u5009\u5021\u5275\u5531\u5A3C\u5EE0\u5F70\u6134\u655E\u660C\u6636\u66A2\u69CD\u6EC4\u6F32\u7316\u7621\u7A93\u8139\u8259\u83D6\u84BC\u50B5\u57F0\u5BC0\u5BE8\u5F69\u63A1\u7826\u7DB5\u83DC\u8521\u91C7\u91F5\u518A\u67F5\u7B56"],
      ["f4a1", "\u8CAC\u51C4\u59BB\u60BD\u8655\u501C\uF9FF\u5254\u5C3A\u617D\u621A\u62D3\u64F2\u65A5\u6ECC\u7620\u810A\u8E60\u965F\u96BB\u4EDF\u5343\u5598\u5929\u5DDD\u64C5\u6CC9\u6DFA\u7394\u7A7F\u821B\u85A6\u8CE4\u8E10\u9077\u91E7\u95E1\u9621\u97C6\u51F8\u54F2\u5586\u5FB9\u64A4\u6F88\u7DB4\u8F1F\u8F4D\u9435\u50C9\u5C16\u6CBE\u6DFB\u751B\u77BB\u7C3D\u7C64\u8A79\u8AC2\u581E\u59BE\u5E16\u6377\u7252\u758A\u776B\u8ADC\u8CBC\u8F12\u5EF3\u6674\u6DF8\u807D\u83C1\u8ACB\u9751\u9BD6\uFA00\u5243\u66FF\u6D95\u6EEF\u7DE0\u8AE6\u902E\u905E\u9AD4\u521D\u527F\u54E8\u6194\u6284\u62DB\u68A2"],
      ["f5a1", "\u6912\u695A\u6A35\u7092\u7126\u785D\u7901\u790E\u79D2\u7A0D\u8096\u8278\u82D5\u8349\u8549\u8C82\u8D85\u9162\u918B\u91AE\u4FC3\u56D1\u71ED\u77D7\u8700\u89F8\u5BF8\u5FD6\u6751\u90A8\u53E2\u585A\u5BF5\u60A4\u6181\u6460\u7E3D\u8070\u8525\u9283\u64AE\u50AC\u5D14\u6700\u589C\u62BD\u63A8\u690E\u6978\u6A1E\u6E6B\u76BA\u79CB\u82BB\u8429\u8ACF\u8DA8\u8FFD\u9112\u914B\u919C\u9310\u9318\u939A\u96DB\u9A36\u9C0D\u4E11\u755C\u795D\u7AFA\u7B51\u7BC9\u7E2E\u84C4\u8E59\u8E74\u8EF8\u9010\u6625\u693F\u7443\u51FA\u672E\u9EDC\u5145\u5FE0\u6C96\u87F2\u885D\u8877\u60B4\u81B5\u8403"],
      ["f6a1", "\u8D05\u53D6\u5439\u5634\u5A36\u5C31\u708A\u7FE0\u805A\u8106\u81ED\u8DA3\u9189\u9A5F\u9DF2\u5074\u4EC4\u53A0\u60FB\u6E2C\u5C64\u4F88\u5024\u55E4\u5CD9\u5E5F\u6065\u6894\u6CBB\u6DC4\u71BE\u75D4\u75F4\u7661\u7A1A\u7A49\u7DC7\u7DFB\u7F6E\u81F4\u86A9\u8F1C\u96C9\u99B3\u9F52\u5247\u52C5\u98ED\u89AA\u4E03\u67D2\u6F06\u4FB5\u5BE2\u6795\u6C88\u6D78\u741B\u7827\u91DD\u937C\u87C4\u79E4\u7A31\u5FEB\u4ED6\u54A4\u553E\u58AE\u59A5\u60F0\u6253\u62D6\u6736\u6955\u8235\u9640\u99B1\u99DD\u502C\u5353\u5544\u577C\uFA01\u6258\uFA02\u64E2\u666B\u67DD\u6FC1\u6FEF\u7422\u7438\u8A17"],
      ["f7a1", "\u9438\u5451\u5606\u5766\u5F48\u619A\u6B4E\u7058\u70AD\u7DBB\u8A95\u596A\u812B\u63A2\u7708\u803D\u8CAA\u5854\u642D\u69BB\u5B95\u5E11\u6E6F\uFA03\u8569\u514C\u53F0\u592A\u6020\u614B\u6B86\u6C70\u6CF0\u7B1E\u80CE\u82D4\u8DC6\u90B0\u98B1\uFA04\u64C7\u6FA4\u6491\u6504\u514E\u5410\u571F\u8A0E\u615F\u6876\uFA05\u75DB\u7B52\u7D71\u901A\u5806\u69CC\u817F\u892A\u9000\u9839\u5078\u5957\u59AC\u6295\u900F\u9B2A\u615D\u7279\u95D6\u5761\u5A46\u5DF4\u628A\u64AD\u64FA\u6777\u6CE2\u6D3E\u722C\u7436\u7834\u7F77\u82AD\u8DDB\u9817\u5224\u5742\u677F\u7248\u74E3\u8CA9\u8FA6\u9211"],
      ["f8a1", "\u962A\u516B\u53ED\u634C\u4F69\u5504\u6096\u6557\u6C9B\u6D7F\u724C\u72FD\u7A17\u8987\u8C9D\u5F6D\u6F8E\u70F9\u81A8\u610E\u4FBF\u504F\u6241\u7247\u7BC7\u7DE8\u7FE9\u904D\u97AD\u9A19\u8CB6\u576A\u5E73\u67B0\u840D\u8A55\u5420\u5B16\u5E63\u5EE2\u5F0A\u6583\u80BA\u853D\u9589\u965B\u4F48\u5305\u530D\u530F\u5486\u54FA\u5703\u5E03\u6016\u629B\u62B1\u6355\uFA06\u6CE1\u6D66\u75B1\u7832\u80DE\u812F\u82DE\u8461\u84B2\u888D\u8912\u900B\u92EA\u98FD\u9B91\u5E45\u66B4\u66DD\u7011\u7206\uFA07\u4FF5\u527D\u5F6A\u6153\u6753\u6A19\u6F02\u74E2\u7968\u8868\u8C79\u98C7\u98C4\u9A43"],
      ["f9a1", "\u54C1\u7A1F\u6953\u8AF7\u8C4A\u98A8\u99AE\u5F7C\u62AB\u75B2\u76AE\u88AB\u907F\u9642\u5339\u5F3C\u5FC5\u6CCC\u73CC\u7562\u758B\u7B46\u82FE\u999D\u4E4F\u903C\u4E0B\u4F55\u53A6\u590F\u5EC8\u6630\u6CB3\u7455\u8377\u8766\u8CC0\u9050\u971E\u9C15\u58D1\u5B78\u8650\u8B14\u9DB4\u5BD2\u6068\u608D\u65F1\u6C57\u6F22\u6FA3\u701A\u7F55\u7FF0\u9591\u9592\u9650\u97D3\u5272\u8F44\u51FD\u542B\u54B8\u5563\u558A\u6ABB\u6DB5\u7DD8\u8266\u929C\u9677\u9E79\u5408\u54C8\u76D2\u86E4\u95A4\u95D4\u965C\u4EA2\u4F09\u59EE\u5AE6\u5DF7\u6052\u6297\u676D\u6841\u6C86\u6E2F\u7F38\u809B\u822A"],
      ["faa1", "\uFA08\uFA09\u9805\u4EA5\u5055\u54B3\u5793\u595A\u5B69\u5BB3\u61C8\u6977\u6D77\u7023\u87F9\u89E3\u8A72\u8AE7\u9082\u99ED\u9AB8\u52BE\u6838\u5016\u5E78\u674F\u8347\u884C\u4EAB\u5411\u56AE\u73E6\u9115\u97FF\u9909\u9957\u9999\u5653\u589F\u865B\u8A31\u61B2\u6AF6\u737B\u8ED2\u6B47\u96AA\u9A57\u5955\u7200\u8D6B\u9769\u4FD4\u5CF4\u5F26\u61F8\u665B\u6CEB\u70AB\u7384\u73B9\u73FE\u7729\u774D\u7D43\u7D62\u7E23\u8237\u8852\uFA0A\u8CE2\u9249\u986F\u5B51\u7A74\u8840\u9801\u5ACC\u4FE0\u5354\u593E\u5CFD\u633E\u6D79\u72F9\u8105\u8107\u83A2\u92CF\u9830\u4EA8\u5144\u5211\u578B"],
      ["fba1", "\u5F62\u6CC2\u6ECE\u7005\u7050\u70AF\u7192\u73E9\u7469\u834A\u87A2\u8861\u9008\u90A2\u93A3\u99A8\u516E\u5F57\u60E0\u6167\u66B3\u8559\u8E4A\u91AF\u978B\u4E4E\u4E92\u547C\u58D5\u58FA\u597D\u5CB5\u5F27\u6236\u6248\u660A\u6667\u6BEB\u6D69\u6DCF\u6E56\u6EF8\u6F94\u6FE0\u6FE9\u705D\u72D0\u7425\u745A\u74E0\u7693\u795C\u7CCA\u7E1E\u80E1\u82A6\u846B\u84BF\u864E\u865F\u8774\u8B77\u8C6A\u93AC\u9800\u9865\u60D1\u6216\u9177\u5A5A\u660F\u6DF7\u6E3E\u743F\u9B42\u5FFD\u60DA\u7B0F\u54C4\u5F18\u6C5E\u6CD3\u6D2A\u70D8\u7D05\u8679\u8A0C\u9D3B\u5316\u548C\u5B05\u6A3A\u706B\u7575"],
      ["fca1", "\u798D\u79BE\u82B1\u83EF\u8A71\u8B41\u8CA8\u9774\uFA0B\u64F4\u652B\u78BA\u78BB\u7A6B\u4E38\u559A\u5950\u5BA6\u5E7B\u60A3\u63DB\u6B61\u6665\u6853\u6E19\u7165\u74B0\u7D08\u9084\u9A69\u9C25\u6D3B\u6ED1\u733E\u8C41\u95CA\u51F0\u5E4C\u5FA8\u604D\u60F6\u6130\u614C\u6643\u6644\u69A5\u6CC1\u6E5F\u6EC9\u6F62\u714C\u749C\u7687\u7BC1\u7C27\u8352\u8757\u9051\u968D\u9EC3\u532F\u56DE\u5EFB\u5F8A\u6062\u6094\u61F7\u6666\u6703\u6A9C\u6DEE\u6FAE\u7070\u736A\u7E6A\u81BE\u8334\u86D4\u8AA8\u8CC4\u5283\u7372\u5B96\u6A6B\u9404\u54EE\u5686\u5B5D\u6548\u6585\u66C9\u689F\u6D8D\u6DC6"],
      ["fda1", "\u723B\u80B4\u9175\u9A4D\u4FAF\u5019\u539A\u540E\u543C\u5589\u55C5\u5E3F\u5F8C\u673D\u7166\u73DD\u9005\u52DB\u52F3\u5864\u58CE\u7104\u718F\u71FB\u85B0\u8A13\u6688\u85A8\u55A7\u6684\u714A\u8431\u5349\u5599\u6BC1\u5F59\u5FBD\u63EE\u6689\u7147\u8AF1\u8F1D\u9EBE\u4F11\u643A\u70CB\u7566\u8667\u6064\u8B4E\u9DF8\u5147\u51F6\u5308\u6D36\u80F8\u9ED1\u6615\u6B23\u7098\u75D5\u5403\u5C79\u7D07\u8A16\u6B20\u6B3D\u6B46\u5438\u6070\u6D3D\u7FD5\u8208\u50D6\u51DE\u559C\u566B\u56CD\u59EC\u5B09\u5E0C\u6199\u6198\u6231\u665E\u66E6\u7199\u71B9\u71BA\u72A7\u79A7\u7A00\u7FB2\u8A70"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp950.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["a140", "\u3000\uFF0C\u3001\u3002\uFF0E\u2027\uFF1B\uFF1A\uFF1F\uFF01\uFE30\u2026\u2025\uFE50\uFE51\uFE52\xB7\uFE54\uFE55\uFE56\uFE57\uFF5C\u2013\uFE31\u2014\uFE33\u2574\uFE34\uFE4F\uFF08\uFF09\uFE35\uFE36\uFF5B\uFF5D\uFE37\uFE38\u3014\u3015\uFE39\uFE3A\u3010\u3011\uFE3B\uFE3C\u300A\u300B\uFE3D\uFE3E\u3008\u3009\uFE3F\uFE40\u300C\u300D\uFE41\uFE42\u300E\u300F\uFE43\uFE44\uFE59\uFE5A"],
      ["a1a1", "\uFE5B\uFE5C\uFE5D\uFE5E\u2018\u2019\u201C\u201D\u301D\u301E\u2035\u2032\uFF03\uFF06\uFF0A\u203B\xA7\u3003\u25CB\u25CF\u25B3\u25B2\u25CE\u2606\u2605\u25C7\u25C6\u25A1\u25A0\u25BD\u25BC\u32A3\u2105\xAF\uFFE3\uFF3F\u02CD\uFE49\uFE4A\uFE4D\uFE4E\uFE4B\uFE4C\uFE5F\uFE60\uFE61\uFF0B\uFF0D\xD7\xF7\xB1\u221A\uFF1C\uFF1E\uFF1D\u2266\u2267\u2260\u221E\u2252\u2261\uFE62", 4, "\uFF5E\u2229\u222A\u22A5\u2220\u221F\u22BF\u33D2\u33D1\u222B\u222E\u2235\u2234\u2640\u2642\u2295\u2299\u2191\u2193\u2190\u2192\u2196\u2197\u2199\u2198\u2225\u2223\uFF0F"],
      ["a240", "\uFF3C\u2215\uFE68\uFF04\uFFE5\u3012\uFFE0\uFFE1\uFF05\uFF20\u2103\u2109\uFE69\uFE6A\uFE6B\u33D5\u339C\u339D\u339E\u33CE\u33A1\u338E\u338F\u33C4\xB0\u5159\u515B\u515E\u515D\u5161\u5163\u55E7\u74E9\u7CCE\u2581", 7, "\u258F\u258E\u258D\u258C\u258B\u258A\u2589\u253C\u2534\u252C\u2524\u251C\u2594\u2500\u2502\u2595\u250C\u2510\u2514\u2518\u256D"],
      ["a2a1", "\u256E\u2570\u256F\u2550\u255E\u256A\u2561\u25E2\u25E3\u25E5\u25E4\u2571\u2572\u2573\uFF10", 9, "\u2160", 9, "\u3021", 8, "\u5341\u5344\u5345\uFF21", 25, "\uFF41", 21],
      ["a340", "\uFF57\uFF58\uFF59\uFF5A\u0391", 16, "\u03A3", 6, "\u03B1", 16, "\u03C3", 6, "\u3105", 10],
      ["a3a1", "\u3110", 25, "\u02D9\u02C9\u02CA\u02C7\u02CB"],
      ["a3e1", "\u20AC"],
      ["a440", "\u4E00\u4E59\u4E01\u4E03\u4E43\u4E5D\u4E86\u4E8C\u4EBA\u513F\u5165\u516B\u51E0\u5200\u5201\u529B\u5315\u5341\u535C\u53C8\u4E09\u4E0B\u4E08\u4E0A\u4E2B\u4E38\u51E1\u4E45\u4E48\u4E5F\u4E5E\u4E8E\u4EA1\u5140\u5203\u52FA\u5343\u53C9\u53E3\u571F\u58EB\u5915\u5927\u5973\u5B50\u5B51\u5B53\u5BF8\u5C0F\u5C22\u5C38\u5C71\u5DDD\u5DE5\u5DF1\u5DF2\u5DF3\u5DFE\u5E72\u5EFE\u5F0B\u5F13\u624D"],
      ["a4a1", "\u4E11\u4E10\u4E0D\u4E2D\u4E30\u4E39\u4E4B\u5C39\u4E88\u4E91\u4E95\u4E92\u4E94\u4EA2\u4EC1\u4EC0\u4EC3\u4EC6\u4EC7\u4ECD\u4ECA\u4ECB\u4EC4\u5143\u5141\u5167\u516D\u516E\u516C\u5197\u51F6\u5206\u5207\u5208\u52FB\u52FE\u52FF\u5316\u5339\u5348\u5347\u5345\u535E\u5384\u53CB\u53CA\u53CD\u58EC\u5929\u592B\u592A\u592D\u5B54\u5C11\u5C24\u5C3A\u5C6F\u5DF4\u5E7B\u5EFF\u5F14\u5F15\u5FC3\u6208\u6236\u624B\u624E\u652F\u6587\u6597\u65A4\u65B9\u65E5\u66F0\u6708\u6728\u6B20\u6B62\u6B79\u6BCB\u6BD4\u6BDB\u6C0F\u6C34\u706B\u722A\u7236\u723B\u7247\u7259\u725B\u72AC\u738B\u4E19"],
      ["a540", "\u4E16\u4E15\u4E14\u4E18\u4E3B\u4E4D\u4E4F\u4E4E\u4EE5\u4ED8\u4ED4\u4ED5\u4ED6\u4ED7\u4EE3\u4EE4\u4ED9\u4EDE\u5145\u5144\u5189\u518A\u51AC\u51F9\u51FA\u51F8\u520A\u52A0\u529F\u5305\u5306\u5317\u531D\u4EDF\u534A\u5349\u5361\u5360\u536F\u536E\u53BB\u53EF\u53E4\u53F3\u53EC\u53EE\u53E9\u53E8\u53FC\u53F8\u53F5\u53EB\u53E6\u53EA\u53F2\u53F1\u53F0\u53E5\u53ED\u53FB\u56DB\u56DA\u5916"],
      ["a5a1", "\u592E\u5931\u5974\u5976\u5B55\u5B83\u5C3C\u5DE8\u5DE7\u5DE6\u5E02\u5E03\u5E73\u5E7C\u5F01\u5F18\u5F17\u5FC5\u620A\u6253\u6254\u6252\u6251\u65A5\u65E6\u672E\u672C\u672A\u672B\u672D\u6B63\u6BCD\u6C11\u6C10\u6C38\u6C41\u6C40\u6C3E\u72AF\u7384\u7389\u74DC\u74E6\u7518\u751F\u7528\u7529\u7530\u7531\u7532\u7533\u758B\u767D\u76AE\u76BF\u76EE\u77DB\u77E2\u77F3\u793A\u79BE\u7A74\u7ACB\u4E1E\u4E1F\u4E52\u4E53\u4E69\u4E99\u4EA4\u4EA6\u4EA5\u4EFF\u4F09\u4F19\u4F0A\u4F15\u4F0D\u4F10\u4F11\u4F0F\u4EF2\u4EF6\u4EFB\u4EF0\u4EF3\u4EFD\u4F01\u4F0B\u5149\u5147\u5146\u5148\u5168"],
      ["a640", "\u5171\u518D\u51B0\u5217\u5211\u5212\u520E\u5216\u52A3\u5308\u5321\u5320\u5370\u5371\u5409\u540F\u540C\u540A\u5410\u5401\u540B\u5404\u5411\u540D\u5408\u5403\u540E\u5406\u5412\u56E0\u56DE\u56DD\u5733\u5730\u5728\u572D\u572C\u572F\u5729\u5919\u591A\u5937\u5938\u5984\u5978\u5983\u597D\u5979\u5982\u5981\u5B57\u5B58\u5B87\u5B88\u5B85\u5B89\u5BFA\u5C16\u5C79\u5DDE\u5E06\u5E76\u5E74"],
      ["a6a1", "\u5F0F\u5F1B\u5FD9\u5FD6\u620E\u620C\u620D\u6210\u6263\u625B\u6258\u6536\u65E9\u65E8\u65EC\u65ED\u66F2\u66F3\u6709\u673D\u6734\u6731\u6735\u6B21\u6B64\u6B7B\u6C16\u6C5D\u6C57\u6C59\u6C5F\u6C60\u6C50\u6C55\u6C61\u6C5B\u6C4D\u6C4E\u7070\u725F\u725D\u767E\u7AF9\u7C73\u7CF8\u7F36\u7F8A\u7FBD\u8001\u8003\u800C\u8012\u8033\u807F\u8089\u808B\u808C\u81E3\u81EA\u81F3\u81FC\u820C\u821B\u821F\u826E\u8272\u827E\u866B\u8840\u884C\u8863\u897F\u9621\u4E32\u4EA8\u4F4D\u4F4F\u4F47\u4F57\u4F5E\u4F34\u4F5B\u4F55\u4F30\u4F50\u4F51\u4F3D\u4F3A\u4F38\u4F43\u4F54\u4F3C\u4F46\u4F63"],
      ["a740", "\u4F5C\u4F60\u4F2F\u4F4E\u4F36\u4F59\u4F5D\u4F48\u4F5A\u514C\u514B\u514D\u5175\u51B6\u51B7\u5225\u5224\u5229\u522A\u5228\u52AB\u52A9\u52AA\u52AC\u5323\u5373\u5375\u541D\u542D\u541E\u543E\u5426\u544E\u5427\u5446\u5443\u5433\u5448\u5442\u541B\u5429\u544A\u5439\u543B\u5438\u542E\u5435\u5436\u5420\u543C\u5440\u5431\u542B\u541F\u542C\u56EA\u56F0\u56E4\u56EB\u574A\u5751\u5740\u574D"],
      ["a7a1", "\u5747\u574E\u573E\u5750\u574F\u573B\u58EF\u593E\u599D\u5992\u59A8\u599E\u59A3\u5999\u5996\u598D\u59A4\u5993\u598A\u59A5\u5B5D\u5B5C\u5B5A\u5B5B\u5B8C\u5B8B\u5B8F\u5C2C\u5C40\u5C41\u5C3F\u5C3E\u5C90\u5C91\u5C94\u5C8C\u5DEB\u5E0C\u5E8F\u5E87\u5E8A\u5EF7\u5F04\u5F1F\u5F64\u5F62\u5F77\u5F79\u5FD8\u5FCC\u5FD7\u5FCD\u5FF1\u5FEB\u5FF8\u5FEA\u6212\u6211\u6284\u6297\u6296\u6280\u6276\u6289\u626D\u628A\u627C\u627E\u6279\u6273\u6292\u626F\u6298\u626E\u6295\u6293\u6291\u6286\u6539\u653B\u6538\u65F1\u66F4\u675F\u674E\u674F\u6750\u6751\u675C\u6756\u675E\u6749\u6746\u6760"],
      ["a840", "\u6753\u6757\u6B65\u6BCF\u6C42\u6C5E\u6C99\u6C81\u6C88\u6C89\u6C85\u6C9B\u6C6A\u6C7A\u6C90\u6C70\u6C8C\u6C68\u6C96\u6C92\u6C7D\u6C83\u6C72\u6C7E\u6C74\u6C86\u6C76\u6C8D\u6C94\u6C98\u6C82\u7076\u707C\u707D\u7078\u7262\u7261\u7260\u72C4\u72C2\u7396\u752C\u752B\u7537\u7538\u7682\u76EF\u77E3\u79C1\u79C0\u79BF\u7A76\u7CFB\u7F55\u8096\u8093\u809D\u8098\u809B\u809A\u80B2\u826F\u8292"],
      ["a8a1", "\u828B\u828D\u898B\u89D2\u8A00\u8C37\u8C46\u8C55\u8C9D\u8D64\u8D70\u8DB3\u8EAB\u8ECA\u8F9B\u8FB0\u8FC2\u8FC6\u8FC5\u8FC4\u5DE1\u9091\u90A2\u90AA\u90A6\u90A3\u9149\u91C6\u91CC\u9632\u962E\u9631\u962A\u962C\u4E26\u4E56\u4E73\u4E8B\u4E9B\u4E9E\u4EAB\u4EAC\u4F6F\u4F9D\u4F8D\u4F73\u4F7F\u4F6C\u4F9B\u4F8B\u4F86\u4F83\u4F70\u4F75\u4F88\u4F69\u4F7B\u4F96\u4F7E\u4F8F\u4F91\u4F7A\u5154\u5152\u5155\u5169\u5177\u5176\u5178\u51BD\u51FD\u523B\u5238\u5237\u523A\u5230\u522E\u5236\u5241\u52BE\u52BB\u5352\u5354\u5353\u5351\u5366\u5377\u5378\u5379\u53D6\u53D4\u53D7\u5473\u5475"],
      ["a940", "\u5496\u5478\u5495\u5480\u547B\u5477\u5484\u5492\u5486\u547C\u5490\u5471\u5476\u548C\u549A\u5462\u5468\u548B\u547D\u548E\u56FA\u5783\u5777\u576A\u5769\u5761\u5766\u5764\u577C\u591C\u5949\u5947\u5948\u5944\u5954\u59BE\u59BB\u59D4\u59B9\u59AE\u59D1\u59C6\u59D0\u59CD\u59CB\u59D3\u59CA\u59AF\u59B3\u59D2\u59C5\u5B5F\u5B64\u5B63\u5B97\u5B9A\u5B98\u5B9C\u5B99\u5B9B\u5C1A\u5C48\u5C45"],
      ["a9a1", "\u5C46\u5CB7\u5CA1\u5CB8\u5CA9\u5CAB\u5CB1\u5CB3\u5E18\u5E1A\u5E16\u5E15\u5E1B\u5E11\u5E78\u5E9A\u5E97\u5E9C\u5E95\u5E96\u5EF6\u5F26\u5F27\u5F29\u5F80\u5F81\u5F7F\u5F7C\u5FDD\u5FE0\u5FFD\u5FF5\u5FFF\u600F\u6014\u602F\u6035\u6016\u602A\u6015\u6021\u6027\u6029\u602B\u601B\u6216\u6215\u623F\u623E\u6240\u627F\u62C9\u62CC\u62C4\u62BF\u62C2\u62B9\u62D2\u62DB\u62AB\u62D3\u62D4\u62CB\u62C8\u62A8\u62BD\u62BC\u62D0\u62D9\u62C7\u62CD\u62B5\u62DA\u62B1\u62D8\u62D6\u62D7\u62C6\u62AC\u62CE\u653E\u65A7\u65BC\u65FA\u6614\u6613\u660C\u6606\u6602\u660E\u6600\u660F\u6615\u660A"],
      ["aa40", "\u6607\u670D\u670B\u676D\u678B\u6795\u6771\u679C\u6773\u6777\u6787\u679D\u6797\u676F\u6770\u677F\u6789\u677E\u6790\u6775\u679A\u6793\u677C\u676A\u6772\u6B23\u6B66\u6B67\u6B7F\u6C13\u6C1B\u6CE3\u6CE8\u6CF3\u6CB1\u6CCC\u6CE5\u6CB3\u6CBD\u6CBE\u6CBC\u6CE2\u6CAB\u6CD5\u6CD3\u6CB8\u6CC4\u6CB9\u6CC1\u6CAE\u6CD7\u6CC5\u6CF1\u6CBF\u6CBB\u6CE1\u6CDB\u6CCA\u6CAC\u6CEF\u6CDC\u6CD6\u6CE0"],
      ["aaa1", "\u7095\u708E\u7092\u708A\u7099\u722C\u722D\u7238\u7248\u7267\u7269\u72C0\u72CE\u72D9\u72D7\u72D0\u73A9\u73A8\u739F\u73AB\u73A5\u753D\u759D\u7599\u759A\u7684\u76C2\u76F2\u76F4\u77E5\u77FD\u793E\u7940\u7941\u79C9\u79C8\u7A7A\u7A79\u7AFA\u7CFE\u7F54\u7F8C\u7F8B\u8005\u80BA\u80A5\u80A2\u80B1\u80A1\u80AB\u80A9\u80B4\u80AA\u80AF\u81E5\u81FE\u820D\u82B3\u829D\u8299\u82AD\u82BD\u829F\u82B9\u82B1\u82AC\u82A5\u82AF\u82B8\u82A3\u82B0\u82BE\u82B7\u864E\u8671\u521D\u8868\u8ECB\u8FCE\u8FD4\u8FD1\u90B5\u90B8\u90B1\u90B6\u91C7\u91D1\u9577\u9580\u961C\u9640\u963F\u963B\u9644"],
      ["ab40", "\u9642\u96B9\u96E8\u9752\u975E\u4E9F\u4EAD\u4EAE\u4FE1\u4FB5\u4FAF\u4FBF\u4FE0\u4FD1\u4FCF\u4FDD\u4FC3\u4FB6\u4FD8\u4FDF\u4FCA\u4FD7\u4FAE\u4FD0\u4FC4\u4FC2\u4FDA\u4FCE\u4FDE\u4FB7\u5157\u5192\u5191\u51A0\u524E\u5243\u524A\u524D\u524C\u524B\u5247\u52C7\u52C9\u52C3\u52C1\u530D\u5357\u537B\u539A\u53DB\u54AC\u54C0\u54A8\u54CE\u54C9\u54B8\u54A6\u54B3\u54C7\u54C2\u54BD\u54AA\u54C1"],
      ["aba1", "\u54C4\u54C8\u54AF\u54AB\u54B1\u54BB\u54A9\u54A7\u54BF\u56FF\u5782\u578B\u57A0\u57A3\u57A2\u57CE\u57AE\u5793\u5955\u5951\u594F\u594E\u5950\u59DC\u59D8\u59FF\u59E3\u59E8\u5A03\u59E5\u59EA\u59DA\u59E6\u5A01\u59FB\u5B69\u5BA3\u5BA6\u5BA4\u5BA2\u5BA5\u5C01\u5C4E\u5C4F\u5C4D\u5C4B\u5CD9\u5CD2\u5DF7\u5E1D\u5E25\u5E1F\u5E7D\u5EA0\u5EA6\u5EFA\u5F08\u5F2D\u5F65\u5F88\u5F85\u5F8A\u5F8B\u5F87\u5F8C\u5F89\u6012\u601D\u6020\u6025\u600E\u6028\u604D\u6070\u6068\u6062\u6046\u6043\u606C\u606B\u606A\u6064\u6241\u62DC\u6316\u6309\u62FC\u62ED\u6301\u62EE\u62FD\u6307\u62F1\u62F7"],
      ["ac40", "\u62EF\u62EC\u62FE\u62F4\u6311\u6302\u653F\u6545\u65AB\u65BD\u65E2\u6625\u662D\u6620\u6627\u662F\u661F\u6628\u6631\u6624\u66F7\u67FF\u67D3\u67F1\u67D4\u67D0\u67EC\u67B6\u67AF\u67F5\u67E9\u67EF\u67C4\u67D1\u67B4\u67DA\u67E5\u67B8\u67CF\u67DE\u67F3\u67B0\u67D9\u67E2\u67DD\u67D2\u6B6A\u6B83\u6B86\u6BB5\u6BD2\u6BD7\u6C1F\u6CC9\u6D0B\u6D32\u6D2A\u6D41\u6D25\u6D0C\u6D31\u6D1E\u6D17"],
      ["aca1", "\u6D3B\u6D3D\u6D3E\u6D36\u6D1B\u6CF5\u6D39\u6D27\u6D38\u6D29\u6D2E\u6D35\u6D0E\u6D2B\u70AB\u70BA\u70B3\u70AC\u70AF\u70AD\u70B8\u70AE\u70A4\u7230\u7272\u726F\u7274\u72E9\u72E0\u72E1\u73B7\u73CA\u73BB\u73B2\u73CD\u73C0\u73B3\u751A\u752D\u754F\u754C\u754E\u754B\u75AB\u75A4\u75A5\u75A2\u75A3\u7678\u7686\u7687\u7688\u76C8\u76C6\u76C3\u76C5\u7701\u76F9\u76F8\u7709\u770B\u76FE\u76FC\u7707\u77DC\u7802\u7814\u780C\u780D\u7946\u7949\u7948\u7947\u79B9\u79BA\u79D1\u79D2\u79CB\u7A7F\u7A81\u7AFF\u7AFD\u7C7D\u7D02\u7D05\u7D00\u7D09\u7D07\u7D04\u7D06\u7F38\u7F8E\u7FBF\u8004"],
      ["ad40", "\u8010\u800D\u8011\u8036\u80D6\u80E5\u80DA\u80C3\u80C4\u80CC\u80E1\u80DB\u80CE\u80DE\u80E4\u80DD\u81F4\u8222\u82E7\u8303\u8305\u82E3\u82DB\u82E6\u8304\u82E5\u8302\u8309\u82D2\u82D7\u82F1\u8301\u82DC\u82D4\u82D1\u82DE\u82D3\u82DF\u82EF\u8306\u8650\u8679\u867B\u867A\u884D\u886B\u8981\u89D4\u8A08\u8A02\u8A03\u8C9E\u8CA0\u8D74\u8D73\u8DB4\u8ECD\u8ECC\u8FF0\u8FE6\u8FE2\u8FEA\u8FE5"],
      ["ada1", "\u8FED\u8FEB\u8FE4\u8FE8\u90CA\u90CE\u90C1\u90C3\u914B\u914A\u91CD\u9582\u9650\u964B\u964C\u964D\u9762\u9769\u97CB\u97ED\u97F3\u9801\u98A8\u98DB\u98DF\u9996\u9999\u4E58\u4EB3\u500C\u500D\u5023\u4FEF\u5026\u5025\u4FF8\u5029\u5016\u5006\u503C\u501F\u501A\u5012\u5011\u4FFA\u5000\u5014\u5028\u4FF1\u5021\u500B\u5019\u5018\u4FF3\u4FEE\u502D\u502A\u4FFE\u502B\u5009\u517C\u51A4\u51A5\u51A2\u51CD\u51CC\u51C6\u51CB\u5256\u525C\u5254\u525B\u525D\u532A\u537F\u539F\u539D\u53DF\u54E8\u5510\u5501\u5537\u54FC\u54E5\u54F2\u5506\u54FA\u5514\u54E9\u54ED\u54E1\u5509\u54EE\u54EA"],
      ["ae40", "\u54E6\u5527\u5507\u54FD\u550F\u5703\u5704\u57C2\u57D4\u57CB\u57C3\u5809\u590F\u5957\u5958\u595A\u5A11\u5A18\u5A1C\u5A1F\u5A1B\u5A13\u59EC\u5A20\u5A23\u5A29\u5A25\u5A0C\u5A09\u5B6B\u5C58\u5BB0\u5BB3\u5BB6\u5BB4\u5BAE\u5BB5\u5BB9\u5BB8\u5C04\u5C51\u5C55\u5C50\u5CED\u5CFD\u5CFB\u5CEA\u5CE8\u5CF0\u5CF6\u5D01\u5CF4\u5DEE\u5E2D\u5E2B\u5EAB\u5EAD\u5EA7\u5F31\u5F92\u5F91\u5F90\u6059"],
      ["aea1", "\u6063\u6065\u6050\u6055\u606D\u6069\u606F\u6084\u609F\u609A\u608D\u6094\u608C\u6085\u6096\u6247\u62F3\u6308\u62FF\u634E\u633E\u632F\u6355\u6342\u6346\u634F\u6349\u633A\u6350\u633D\u632A\u632B\u6328\u634D\u634C\u6548\u6549\u6599\u65C1\u65C5\u6642\u6649\u664F\u6643\u6652\u664C\u6645\u6641\u66F8\u6714\u6715\u6717\u6821\u6838\u6848\u6846\u6853\u6839\u6842\u6854\u6829\u68B3\u6817\u684C\u6851\u683D\u67F4\u6850\u6840\u683C\u6843\u682A\u6845\u6813\u6818\u6841\u6B8A\u6B89\u6BB7\u6C23\u6C27\u6C28\u6C26\u6C24\u6CF0\u6D6A\u6D95\u6D88\u6D87\u6D66\u6D78\u6D77\u6D59\u6D93"],
      ["af40", "\u6D6C\u6D89\u6D6E\u6D5A\u6D74\u6D69\u6D8C\u6D8A\u6D79\u6D85\u6D65\u6D94\u70CA\u70D8\u70E4\u70D9\u70C8\u70CF\u7239\u7279\u72FC\u72F9\u72FD\u72F8\u72F7\u7386\u73ED\u7409\u73EE\u73E0\u73EA\u73DE\u7554\u755D\u755C\u755A\u7559\u75BE\u75C5\u75C7\u75B2\u75B3\u75BD\u75BC\u75B9\u75C2\u75B8\u768B\u76B0\u76CA\u76CD\u76CE\u7729\u771F\u7720\u7728\u77E9\u7830\u7827\u7838\u781D\u7834\u7837"],
      ["afa1", "\u7825\u782D\u7820\u781F\u7832\u7955\u7950\u7960\u795F\u7956\u795E\u795D\u7957\u795A\u79E4\u79E3\u79E7\u79DF\u79E6\u79E9\u79D8\u7A84\u7A88\u7AD9\u7B06\u7B11\u7C89\u7D21\u7D17\u7D0B\u7D0A\u7D20\u7D22\u7D14\u7D10\u7D15\u7D1A\u7D1C\u7D0D\u7D19\u7D1B\u7F3A\u7F5F\u7F94\u7FC5\u7FC1\u8006\u8018\u8015\u8019\u8017\u803D\u803F\u80F1\u8102\u80F0\u8105\u80ED\u80F4\u8106\u80F8\u80F3\u8108\u80FD\u810A\u80FC\u80EF\u81ED\u81EC\u8200\u8210\u822A\u822B\u8228\u822C\u82BB\u832B\u8352\u8354\u834A\u8338\u8350\u8349\u8335\u8334\u834F\u8332\u8339\u8336\u8317\u8340\u8331\u8328\u8343"],
      ["b040", "\u8654\u868A\u86AA\u8693\u86A4\u86A9\u868C\u86A3\u869C\u8870\u8877\u8881\u8882\u887D\u8879\u8A18\u8A10\u8A0E\u8A0C\u8A15\u8A0A\u8A17\u8A13\u8A16\u8A0F\u8A11\u8C48\u8C7A\u8C79\u8CA1\u8CA2\u8D77\u8EAC\u8ED2\u8ED4\u8ECF\u8FB1\u9001\u9006\u8FF7\u9000\u8FFA\u8FF4\u9003\u8FFD\u9005\u8FF8\u9095\u90E1\u90DD\u90E2\u9152\u914D\u914C\u91D8\u91DD\u91D7\u91DC\u91D9\u9583\u9662\u9663\u9661"],
      ["b0a1", "\u965B\u965D\u9664\u9658\u965E\u96BB\u98E2\u99AC\u9AA8\u9AD8\u9B25\u9B32\u9B3C\u4E7E\u507A\u507D\u505C\u5047\u5043\u504C\u505A\u5049\u5065\u5076\u504E\u5055\u5075\u5074\u5077\u504F\u500F\u506F\u506D\u515C\u5195\u51F0\u526A\u526F\u52D2\u52D9\u52D8\u52D5\u5310\u530F\u5319\u533F\u5340\u533E\u53C3\u66FC\u5546\u556A\u5566\u5544\u555E\u5561\u5543\u554A\u5531\u5556\u554F\u5555\u552F\u5564\u5538\u552E\u555C\u552C\u5563\u5533\u5541\u5557\u5708\u570B\u5709\u57DF\u5805\u580A\u5806\u57E0\u57E4\u57FA\u5802\u5835\u57F7\u57F9\u5920\u5962\u5A36\u5A41\u5A49\u5A66\u5A6A\u5A40"],
      ["b140", "\u5A3C\u5A62\u5A5A\u5A46\u5A4A\u5B70\u5BC7\u5BC5\u5BC4\u5BC2\u5BBF\u5BC6\u5C09\u5C08\u5C07\u5C60\u5C5C\u5C5D\u5D07\u5D06\u5D0E\u5D1B\u5D16\u5D22\u5D11\u5D29\u5D14\u5D19\u5D24\u5D27\u5D17\u5DE2\u5E38\u5E36\u5E33\u5E37\u5EB7\u5EB8\u5EB6\u5EB5\u5EBE\u5F35\u5F37\u5F57\u5F6C\u5F69\u5F6B\u5F97\u5F99\u5F9E\u5F98\u5FA1\u5FA0\u5F9C\u607F\u60A3\u6089\u60A0\u60A8\u60CB\u60B4\u60E6\u60BD"],
      ["b1a1", "\u60C5\u60BB\u60B5\u60DC\u60BC\u60D8\u60D5\u60C6\u60DF\u60B8\u60DA\u60C7\u621A\u621B\u6248\u63A0\u63A7\u6372\u6396\u63A2\u63A5\u6377\u6367\u6398\u63AA\u6371\u63A9\u6389\u6383\u639B\u636B\u63A8\u6384\u6388\u6399\u63A1\u63AC\u6392\u638F\u6380\u637B\u6369\u6368\u637A\u655D\u6556\u6551\u6559\u6557\u555F\u654F\u6558\u6555\u6554\u659C\u659B\u65AC\u65CF\u65CB\u65CC\u65CE\u665D\u665A\u6664\u6668\u6666\u665E\u66F9\u52D7\u671B\u6881\u68AF\u68A2\u6893\u68B5\u687F\u6876\u68B1\u68A7\u6897\u68B0\u6883\u68C4\u68AD\u6886\u6885\u6894\u689D\u68A8\u689F\u68A1\u6882\u6B32\u6BBA"],
      ["b240", "\u6BEB\u6BEC\u6C2B\u6D8E\u6DBC\u6DF3\u6DD9\u6DB2\u6DE1\u6DCC\u6DE4\u6DFB\u6DFA\u6E05\u6DC7\u6DCB\u6DAF\u6DD1\u6DAE\u6DDE\u6DF9\u6DB8\u6DF7\u6DF5\u6DC5\u6DD2\u6E1A\u6DB5\u6DDA\u6DEB\u6DD8\u6DEA\u6DF1\u6DEE\u6DE8\u6DC6\u6DC4\u6DAA\u6DEC\u6DBF\u6DE6\u70F9\u7109\u710A\u70FD\u70EF\u723D\u727D\u7281\u731C\u731B\u7316\u7313\u7319\u7387\u7405\u740A\u7403\u7406\u73FE\u740D\u74E0\u74F6"],
      ["b2a1", "\u74F7\u751C\u7522\u7565\u7566\u7562\u7570\u758F\u75D4\u75D5\u75B5\u75CA\u75CD\u768E\u76D4\u76D2\u76DB\u7737\u773E\u773C\u7736\u7738\u773A\u786B\u7843\u784E\u7965\u7968\u796D\u79FB\u7A92\u7A95\u7B20\u7B28\u7B1B\u7B2C\u7B26\u7B19\u7B1E\u7B2E\u7C92\u7C97\u7C95\u7D46\u7D43\u7D71\u7D2E\u7D39\u7D3C\u7D40\u7D30\u7D33\u7D44\u7D2F\u7D42\u7D32\u7D31\u7F3D\u7F9E\u7F9A\u7FCC\u7FCE\u7FD2\u801C\u804A\u8046\u812F\u8116\u8123\u812B\u8129\u8130\u8124\u8202\u8235\u8237\u8236\u8239\u838E\u839E\u8398\u8378\u83A2\u8396\u83BD\u83AB\u8392\u838A\u8393\u8389\u83A0\u8377\u837B\u837C"],
      ["b340", "\u8386\u83A7\u8655\u5F6A\u86C7\u86C0\u86B6\u86C4\u86B5\u86C6\u86CB\u86B1\u86AF\u86C9\u8853\u889E\u8888\u88AB\u8892\u8896\u888D\u888B\u8993\u898F\u8A2A\u8A1D\u8A23\u8A25\u8A31\u8A2D\u8A1F\u8A1B\u8A22\u8C49\u8C5A\u8CA9\u8CAC\u8CAB\u8CA8\u8CAA\u8CA7\u8D67\u8D66\u8DBE\u8DBA\u8EDB\u8EDF\u9019\u900D\u901A\u9017\u9023\u901F\u901D\u9010\u9015\u901E\u9020\u900F\u9022\u9016\u901B\u9014"],
      ["b3a1", "\u90E8\u90ED\u90FD\u9157\u91CE\u91F5\u91E6\u91E3\u91E7\u91ED\u91E9\u9589\u966A\u9675\u9673\u9678\u9670\u9674\u9676\u9677\u966C\u96C0\u96EA\u96E9\u7AE0\u7ADF\u9802\u9803\u9B5A\u9CE5\u9E75\u9E7F\u9EA5\u9EBB\u50A2\u508D\u5085\u5099\u5091\u5080\u5096\u5098\u509A\u6700\u51F1\u5272\u5274\u5275\u5269\u52DE\u52DD\u52DB\u535A\u53A5\u557B\u5580\u55A7\u557C\u558A\u559D\u5598\u5582\u559C\u55AA\u5594\u5587\u558B\u5583\u55B3\u55AE\u559F\u553E\u55B2\u559A\u55BB\u55AC\u55B1\u557E\u5589\u55AB\u5599\u570D\u582F\u582A\u5834\u5824\u5830\u5831\u5821\u581D\u5820\u58F9\u58FA\u5960"],
      ["b440", "\u5A77\u5A9A\u5A7F\u5A92\u5A9B\u5AA7\u5B73\u5B71\u5BD2\u5BCC\u5BD3\u5BD0\u5C0A\u5C0B\u5C31\u5D4C\u5D50\u5D34\u5D47\u5DFD\u5E45\u5E3D\u5E40\u5E43\u5E7E\u5ECA\u5EC1\u5EC2\u5EC4\u5F3C\u5F6D\u5FA9\u5FAA\u5FA8\u60D1\u60E1\u60B2\u60B6\u60E0\u611C\u6123\u60FA\u6115\u60F0\u60FB\u60F4\u6168\u60F1\u610E\u60F6\u6109\u6100\u6112\u621F\u6249\u63A3\u638C\u63CF\u63C0\u63E9\u63C9\u63C6\u63CD"],
      ["b4a1", "\u63D2\u63E3\u63D0\u63E1\u63D6\u63ED\u63EE\u6376\u63F4\u63EA\u63DB\u6452\u63DA\u63F9\u655E\u6566\u6562\u6563\u6591\u6590\u65AF\u666E\u6670\u6674\u6676\u666F\u6691\u667A\u667E\u6677\u66FE\u66FF\u671F\u671D\u68FA\u68D5\u68E0\u68D8\u68D7\u6905\u68DF\u68F5\u68EE\u68E7\u68F9\u68D2\u68F2\u68E3\u68CB\u68CD\u690D\u6912\u690E\u68C9\u68DA\u696E\u68FB\u6B3E\u6B3A\u6B3D\u6B98\u6B96\u6BBC\u6BEF\u6C2E\u6C2F\u6C2C\u6E2F\u6E38\u6E54\u6E21\u6E32\u6E67\u6E4A\u6E20\u6E25\u6E23\u6E1B\u6E5B\u6E58\u6E24\u6E56\u6E6E\u6E2D\u6E26\u6E6F\u6E34\u6E4D\u6E3A\u6E2C\u6E43\u6E1D\u6E3E\u6ECB"],
      ["b540", "\u6E89\u6E19\u6E4E\u6E63\u6E44\u6E72\u6E69\u6E5F\u7119\u711A\u7126\u7130\u7121\u7136\u716E\u711C\u724C\u7284\u7280\u7336\u7325\u7334\u7329\u743A\u742A\u7433\u7422\u7425\u7435\u7436\u7434\u742F\u741B\u7426\u7428\u7525\u7526\u756B\u756A\u75E2\u75DB\u75E3\u75D9\u75D8\u75DE\u75E0\u767B\u767C\u7696\u7693\u76B4\u76DC\u774F\u77ED\u785D\u786C\u786F\u7A0D\u7A08\u7A0B\u7A05\u7A00\u7A98"],
      ["b5a1", "\u7A97\u7A96\u7AE5\u7AE3\u7B49\u7B56\u7B46\u7B50\u7B52\u7B54\u7B4D\u7B4B\u7B4F\u7B51\u7C9F\u7CA5\u7D5E\u7D50\u7D68\u7D55\u7D2B\u7D6E\u7D72\u7D61\u7D66\u7D62\u7D70\u7D73\u5584\u7FD4\u7FD5\u800B\u8052\u8085\u8155\u8154\u814B\u8151\u814E\u8139\u8146\u813E\u814C\u8153\u8174\u8212\u821C\u83E9\u8403\u83F8\u840D\u83E0\u83C5\u840B\u83C1\u83EF\u83F1\u83F4\u8457\u840A\u83F0\u840C\u83CC\u83FD\u83F2\u83CA\u8438\u840E\u8404\u83DC\u8407\u83D4\u83DF\u865B\u86DF\u86D9\u86ED\u86D4\u86DB\u86E4\u86D0\u86DE\u8857\u88C1\u88C2\u88B1\u8983\u8996\u8A3B\u8A60\u8A55\u8A5E\u8A3C\u8A41"],
      ["b640", "\u8A54\u8A5B\u8A50\u8A46\u8A34\u8A3A\u8A36\u8A56\u8C61\u8C82\u8CAF\u8CBC\u8CB3\u8CBD\u8CC1\u8CBB\u8CC0\u8CB4\u8CB7\u8CB6\u8CBF\u8CB8\u8D8A\u8D85\u8D81\u8DCE\u8DDD\u8DCB\u8DDA\u8DD1\u8DCC\u8DDB\u8DC6\u8EFB\u8EF8\u8EFC\u8F9C\u902E\u9035\u9031\u9038\u9032\u9036\u9102\u90F5\u9109\u90FE\u9163\u9165\u91CF\u9214\u9215\u9223\u9209\u921E\u920D\u9210\u9207\u9211\u9594\u958F\u958B\u9591"],
      ["b6a1", "\u9593\u9592\u958E\u968A\u968E\u968B\u967D\u9685\u9686\u968D\u9672\u9684\u96C1\u96C5\u96C4\u96C6\u96C7\u96EF\u96F2\u97CC\u9805\u9806\u9808\u98E7\u98EA\u98EF\u98E9\u98F2\u98ED\u99AE\u99AD\u9EC3\u9ECD\u9ED1\u4E82\u50AD\u50B5\u50B2\u50B3\u50C5\u50BE\u50AC\u50B7\u50BB\u50AF\u50C7\u527F\u5277\u527D\u52DF\u52E6\u52E4\u52E2\u52E3\u532F\u55DF\u55E8\u55D3\u55E6\u55CE\u55DC\u55C7\u55D1\u55E3\u55E4\u55EF\u55DA\u55E1\u55C5\u55C6\u55E5\u55C9\u5712\u5713\u585E\u5851\u5858\u5857\u585A\u5854\u586B\u584C\u586D\u584A\u5862\u5852\u584B\u5967\u5AC1\u5AC9\u5ACC\u5ABE\u5ABD\u5ABC"],
      ["b740", "\u5AB3\u5AC2\u5AB2\u5D69\u5D6F\u5E4C\u5E79\u5EC9\u5EC8\u5F12\u5F59\u5FAC\u5FAE\u611A\u610F\u6148\u611F\u60F3\u611B\u60F9\u6101\u6108\u614E\u614C\u6144\u614D\u613E\u6134\u6127\u610D\u6106\u6137\u6221\u6222\u6413\u643E\u641E\u642A\u642D\u643D\u642C\u640F\u641C\u6414\u640D\u6436\u6416\u6417\u6406\u656C\u659F\u65B0\u6697\u6689\u6687\u6688\u6696\u6684\u6698\u668D\u6703\u6994\u696D"],
      ["b7a1", "\u695A\u6977\u6960\u6954\u6975\u6930\u6982\u694A\u6968\u696B\u695E\u6953\u6979\u6986\u695D\u6963\u695B\u6B47\u6B72\u6BC0\u6BBF\u6BD3\u6BFD\u6EA2\u6EAF\u6ED3\u6EB6\u6EC2\u6E90\u6E9D\u6EC7\u6EC5\u6EA5\u6E98\u6EBC\u6EBA\u6EAB\u6ED1\u6E96\u6E9C\u6EC4\u6ED4\u6EAA\u6EA7\u6EB4\u714E\u7159\u7169\u7164\u7149\u7167\u715C\u716C\u7166\u714C\u7165\u715E\u7146\u7168\u7156\u723A\u7252\u7337\u7345\u733F\u733E\u746F\u745A\u7455\u745F\u745E\u7441\u743F\u7459\u745B\u745C\u7576\u7578\u7600\u75F0\u7601\u75F2\u75F1\u75FA\u75FF\u75F4\u75F3\u76DE\u76DF\u775B\u776B\u7766\u775E\u7763"],
      ["b840", "\u7779\u776A\u776C\u775C\u7765\u7768\u7762\u77EE\u788E\u78B0\u7897\u7898\u788C\u7889\u787C\u7891\u7893\u787F\u797A\u797F\u7981\u842C\u79BD\u7A1C\u7A1A\u7A20\u7A14\u7A1F\u7A1E\u7A9F\u7AA0\u7B77\u7BC0\u7B60\u7B6E\u7B67\u7CB1\u7CB3\u7CB5\u7D93\u7D79\u7D91\u7D81\u7D8F\u7D5B\u7F6E\u7F69\u7F6A\u7F72\u7FA9\u7FA8\u7FA4\u8056\u8058\u8086\u8084\u8171\u8170\u8178\u8165\u816E\u8173\u816B"],
      ["b8a1", "\u8179\u817A\u8166\u8205\u8247\u8482\u8477\u843D\u8431\u8475\u8466\u846B\u8449\u846C\u845B\u843C\u8435\u8461\u8463\u8469\u846D\u8446\u865E\u865C\u865F\u86F9\u8713\u8708\u8707\u8700\u86FE\u86FB\u8702\u8703\u8706\u870A\u8859\u88DF\u88D4\u88D9\u88DC\u88D8\u88DD\u88E1\u88CA\u88D5\u88D2\u899C\u89E3\u8A6B\u8A72\u8A73\u8A66\u8A69\u8A70\u8A87\u8A7C\u8A63\u8AA0\u8A71\u8A85\u8A6D\u8A62\u8A6E\u8A6C\u8A79\u8A7B\u8A3E\u8A68\u8C62\u8C8A\u8C89\u8CCA\u8CC7\u8CC8\u8CC4\u8CB2\u8CC3\u8CC2\u8CC5\u8DE1\u8DDF\u8DE8\u8DEF\u8DF3\u8DFA\u8DEA\u8DE4\u8DE6\u8EB2\u8F03\u8F09\u8EFE\u8F0A"],
      ["b940", "\u8F9F\u8FB2\u904B\u904A\u9053\u9042\u9054\u903C\u9055\u9050\u9047\u904F\u904E\u904D\u9051\u903E\u9041\u9112\u9117\u916C\u916A\u9169\u91C9\u9237\u9257\u9238\u923D\u9240\u923E\u925B\u924B\u9264\u9251\u9234\u9249\u924D\u9245\u9239\u923F\u925A\u9598\u9698\u9694\u9695\u96CD\u96CB\u96C9\u96CA\u96F7\u96FB\u96F9\u96F6\u9756\u9774\u9776\u9810\u9811\u9813\u980A\u9812\u980C\u98FC\u98F4"],
      ["b9a1", "\u98FD\u98FE\u99B3\u99B1\u99B4\u9AE1\u9CE9\u9E82\u9F0E\u9F13\u9F20\u50E7\u50EE\u50E5\u50D6\u50ED\u50DA\u50D5\u50CF\u50D1\u50F1\u50CE\u50E9\u5162\u51F3\u5283\u5282\u5331\u53AD\u55FE\u5600\u561B\u5617\u55FD\u5614\u5606\u5609\u560D\u560E\u55F7\u5616\u561F\u5608\u5610\u55F6\u5718\u5716\u5875\u587E\u5883\u5893\u588A\u5879\u5885\u587D\u58FD\u5925\u5922\u5924\u596A\u5969\u5AE1\u5AE6\u5AE9\u5AD7\u5AD6\u5AD8\u5AE3\u5B75\u5BDE\u5BE7\u5BE1\u5BE5\u5BE6\u5BE8\u5BE2\u5BE4\u5BDF\u5C0D\u5C62\u5D84\u5D87\u5E5B\u5E63\u5E55\u5E57\u5E54\u5ED3\u5ED6\u5F0A\u5F46\u5F70\u5FB9\u6147"],
      ["ba40", "\u613F\u614B\u6177\u6162\u6163\u615F\u615A\u6158\u6175\u622A\u6487\u6458\u6454\u64A4\u6478\u645F\u647A\u6451\u6467\u6434\u646D\u647B\u6572\u65A1\u65D7\u65D6\u66A2\u66A8\u669D\u699C\u69A8\u6995\u69C1\u69AE\u69D3\u69CB\u699B\u69B7\u69BB\u69AB\u69B4\u69D0\u69CD\u69AD\u69CC\u69A6\u69C3\u69A3\u6B49\u6B4C\u6C33\u6F33\u6F14\u6EFE\u6F13\u6EF4\u6F29\u6F3E\u6F20\u6F2C\u6F0F\u6F02\u6F22"],
      ["baa1", "\u6EFF\u6EEF\u6F06\u6F31\u6F38\u6F32\u6F23\u6F15\u6F2B\u6F2F\u6F88\u6F2A\u6EEC\u6F01\u6EF2\u6ECC\u6EF7\u7194\u7199\u717D\u718A\u7184\u7192\u723E\u7292\u7296\u7344\u7350\u7464\u7463\u746A\u7470\u746D\u7504\u7591\u7627\u760D\u760B\u7609\u7613\u76E1\u76E3\u7784\u777D\u777F\u7761\u78C1\u789F\u78A7\u78B3\u78A9\u78A3\u798E\u798F\u798D\u7A2E\u7A31\u7AAA\u7AA9\u7AED\u7AEF\u7BA1\u7B95\u7B8B\u7B75\u7B97\u7B9D\u7B94\u7B8F\u7BB8\u7B87\u7B84\u7CB9\u7CBD\u7CBE\u7DBB\u7DB0\u7D9C\u7DBD\u7DBE\u7DA0\u7DCA\u7DB4\u7DB2\u7DB1\u7DBA\u7DA2\u7DBF\u7DB5\u7DB8\u7DAD\u7DD2\u7DC7\u7DAC"],
      ["bb40", "\u7F70\u7FE0\u7FE1\u7FDF\u805E\u805A\u8087\u8150\u8180\u818F\u8188\u818A\u817F\u8182\u81E7\u81FA\u8207\u8214\u821E\u824B\u84C9\u84BF\u84C6\u84C4\u8499\u849E\u84B2\u849C\u84CB\u84B8\u84C0\u84D3\u8490\u84BC\u84D1\u84CA\u873F\u871C\u873B\u8722\u8725\u8734\u8718\u8755\u8737\u8729\u88F3\u8902\u88F4\u88F9\u88F8\u88FD\u88E8\u891A\u88EF\u8AA6\u8A8C\u8A9E\u8AA3\u8A8D\u8AA1\u8A93\u8AA4"],
      ["bba1", "\u8AAA\u8AA5\u8AA8\u8A98\u8A91\u8A9A\u8AA7\u8C6A\u8C8D\u8C8C\u8CD3\u8CD1\u8CD2\u8D6B\u8D99\u8D95\u8DFC\u8F14\u8F12\u8F15\u8F13\u8FA3\u9060\u9058\u905C\u9063\u9059\u905E\u9062\u905D\u905B\u9119\u9118\u911E\u9175\u9178\u9177\u9174\u9278\u9280\u9285\u9298\u9296\u927B\u9293\u929C\u92A8\u927C\u9291\u95A1\u95A8\u95A9\u95A3\u95A5\u95A4\u9699\u969C\u969B\u96CC\u96D2\u9700\u977C\u9785\u97F6\u9817\u9818\u98AF\u98B1\u9903\u9905\u990C\u9909\u99C1\u9AAF\u9AB0\u9AE6\u9B41\u9B42\u9CF4\u9CF6\u9CF3\u9EBC\u9F3B\u9F4A\u5104\u5100\u50FB\u50F5\u50F9\u5102\u5108\u5109\u5105\u51DC"],
      ["bc40", "\u5287\u5288\u5289\u528D\u528A\u52F0\u53B2\u562E\u563B\u5639\u5632\u563F\u5634\u5629\u5653\u564E\u5657\u5674\u5636\u562F\u5630\u5880\u589F\u589E\u58B3\u589C\u58AE\u58A9\u58A6\u596D\u5B09\u5AFB\u5B0B\u5AF5\u5B0C\u5B08\u5BEE\u5BEC\u5BE9\u5BEB\u5C64\u5C65\u5D9D\u5D94\u5E62\u5E5F\u5E61\u5EE2\u5EDA\u5EDF\u5EDD\u5EE3\u5EE0\u5F48\u5F71\u5FB7\u5FB5\u6176\u6167\u616E\u615D\u6155\u6182"],
      ["bca1", "\u617C\u6170\u616B\u617E\u61A7\u6190\u61AB\u618E\u61AC\u619A\u61A4\u6194\u61AE\u622E\u6469\u646F\u6479\u649E\u64B2\u6488\u6490\u64B0\u64A5\u6493\u6495\u64A9\u6492\u64AE\u64AD\u64AB\u649A\u64AC\u6499\u64A2\u64B3\u6575\u6577\u6578\u66AE\u66AB\u66B4\u66B1\u6A23\u6A1F\u69E8\u6A01\u6A1E\u6A19\u69FD\u6A21\u6A13\u6A0A\u69F3\u6A02\u6A05\u69ED\u6A11\u6B50\u6B4E\u6BA4\u6BC5\u6BC6\u6F3F\u6F7C\u6F84\u6F51\u6F66\u6F54\u6F86\u6F6D\u6F5B\u6F78\u6F6E\u6F8E\u6F7A\u6F70\u6F64\u6F97\u6F58\u6ED5\u6F6F\u6F60\u6F5F\u719F\u71AC\u71B1\u71A8\u7256\u729B\u734E\u7357\u7469\u748B\u7483"],
      ["bd40", "\u747E\u7480\u757F\u7620\u7629\u761F\u7624\u7626\u7621\u7622\u769A\u76BA\u76E4\u778E\u7787\u778C\u7791\u778B\u78CB\u78C5\u78BA\u78CA\u78BE\u78D5\u78BC\u78D0\u7A3F\u7A3C\u7A40\u7A3D\u7A37\u7A3B\u7AAF\u7AAE\u7BAD\u7BB1\u7BC4\u7BB4\u7BC6\u7BC7\u7BC1\u7BA0\u7BCC\u7CCA\u7DE0\u7DF4\u7DEF\u7DFB\u7DD8\u7DEC\u7DDD\u7DE8\u7DE3\u7DDA\u7DDE\u7DE9\u7D9E\u7DD9\u7DF2\u7DF9\u7F75\u7F77\u7FAF"],
      ["bda1", "\u7FE9\u8026\u819B\u819C\u819D\u81A0\u819A\u8198\u8517\u853D\u851A\u84EE\u852C\u852D\u8513\u8511\u8523\u8521\u8514\u84EC\u8525\u84FF\u8506\u8782\u8774\u8776\u8760\u8766\u8778\u8768\u8759\u8757\u874C\u8753\u885B\u885D\u8910\u8907\u8912\u8913\u8915\u890A\u8ABC\u8AD2\u8AC7\u8AC4\u8A95\u8ACB\u8AF8\u8AB2\u8AC9\u8AC2\u8ABF\u8AB0\u8AD6\u8ACD\u8AB6\u8AB9\u8ADB\u8C4C\u8C4E\u8C6C\u8CE0\u8CDE\u8CE6\u8CE4\u8CEC\u8CED\u8CE2\u8CE3\u8CDC\u8CEA\u8CE1\u8D6D\u8D9F\u8DA3\u8E2B\u8E10\u8E1D\u8E22\u8E0F\u8E29\u8E1F\u8E21\u8E1E\u8EBA\u8F1D\u8F1B\u8F1F\u8F29\u8F26\u8F2A\u8F1C\u8F1E"],
      ["be40", "\u8F25\u9069\u906E\u9068\u906D\u9077\u9130\u912D\u9127\u9131\u9187\u9189\u918B\u9183\u92C5\u92BB\u92B7\u92EA\u92AC\u92E4\u92C1\u92B3\u92BC\u92D2\u92C7\u92F0\u92B2\u95AD\u95B1\u9704\u9706\u9707\u9709\u9760\u978D\u978B\u978F\u9821\u982B\u981C\u98B3\u990A\u9913\u9912\u9918\u99DD\u99D0\u99DF\u99DB\u99D1\u99D5\u99D2\u99D9\u9AB7\u9AEE\u9AEF\u9B27\u9B45\u9B44\u9B77\u9B6F\u9D06\u9D09"],
      ["bea1", "\u9D03\u9EA9\u9EBE\u9ECE\u58A8\u9F52\u5112\u5118\u5114\u5110\u5115\u5180\u51AA\u51DD\u5291\u5293\u52F3\u5659\u566B\u5679\u5669\u5664\u5678\u566A\u5668\u5665\u5671\u566F\u566C\u5662\u5676\u58C1\u58BE\u58C7\u58C5\u596E\u5B1D\u5B34\u5B78\u5BF0\u5C0E\u5F4A\u61B2\u6191\u61A9\u618A\u61CD\u61B6\u61BE\u61CA\u61C8\u6230\u64C5\u64C1\u64CB\u64BB\u64BC\u64DA\u64C4\u64C7\u64C2\u64CD\u64BF\u64D2\u64D4\u64BE\u6574\u66C6\u66C9\u66B9\u66C4\u66C7\u66B8\u6A3D\u6A38\u6A3A\u6A59\u6A6B\u6A58\u6A39\u6A44\u6A62\u6A61\u6A4B\u6A47\u6A35\u6A5F\u6A48\u6B59\u6B77\u6C05\u6FC2\u6FB1\u6FA1"],
      ["bf40", "\u6FC3\u6FA4\u6FC1\u6FA7\u6FB3\u6FC0\u6FB9\u6FB6\u6FA6\u6FA0\u6FB4\u71BE\u71C9\u71D0\u71D2\u71C8\u71D5\u71B9\u71CE\u71D9\u71DC\u71C3\u71C4\u7368\u749C\u74A3\u7498\u749F\u749E\u74E2\u750C\u750D\u7634\u7638\u763A\u76E7\u76E5\u77A0\u779E\u779F\u77A5\u78E8\u78DA\u78EC\u78E7\u79A6\u7A4D\u7A4E\u7A46\u7A4C\u7A4B\u7ABA\u7BD9\u7C11\u7BC9\u7BE4\u7BDB\u7BE1\u7BE9\u7BE6\u7CD5\u7CD6\u7E0A"],
      ["bfa1", "\u7E11\u7E08\u7E1B\u7E23\u7E1E\u7E1D\u7E09\u7E10\u7F79\u7FB2\u7FF0\u7FF1\u7FEE\u8028\u81B3\u81A9\u81A8\u81FB\u8208\u8258\u8259\u854A\u8559\u8548\u8568\u8569\u8543\u8549\u856D\u856A\u855E\u8783\u879F\u879E\u87A2\u878D\u8861\u892A\u8932\u8925\u892B\u8921\u89AA\u89A6\u8AE6\u8AFA\u8AEB\u8AF1\u8B00\u8ADC\u8AE7\u8AEE\u8AFE\u8B01\u8B02\u8AF7\u8AED\u8AF3\u8AF6\u8AFC\u8C6B\u8C6D\u8C93\u8CF4\u8E44\u8E31\u8E34\u8E42\u8E39\u8E35\u8F3B\u8F2F\u8F38\u8F33\u8FA8\u8FA6\u9075\u9074\u9078\u9072\u907C\u907A\u9134\u9192\u9320\u9336\u92F8\u9333\u932F\u9322\u92FC\u932B\u9304\u931A"],
      ["c040", "\u9310\u9326\u9321\u9315\u932E\u9319\u95BB\u96A7\u96A8\u96AA\u96D5\u970E\u9711\u9716\u970D\u9713\u970F\u975B\u975C\u9766\u9798\u9830\u9838\u983B\u9837\u982D\u9839\u9824\u9910\u9928\u991E\u991B\u9921\u991A\u99ED\u99E2\u99F1\u9AB8\u9ABC\u9AFB\u9AED\u9B28\u9B91\u9D15\u9D23\u9D26\u9D28\u9D12\u9D1B\u9ED8\u9ED4\u9F8D\u9F9C\u512A\u511F\u5121\u5132\u52F5\u568E\u5680\u5690\u5685\u5687"],
      ["c0a1", "\u568F\u58D5\u58D3\u58D1\u58CE\u5B30\u5B2A\u5B24\u5B7A\u5C37\u5C68\u5DBC\u5DBA\u5DBD\u5DB8\u5E6B\u5F4C\u5FBD\u61C9\u61C2\u61C7\u61E6\u61CB\u6232\u6234\u64CE\u64CA\u64D8\u64E0\u64F0\u64E6\u64EC\u64F1\u64E2\u64ED\u6582\u6583\u66D9\u66D6\u6A80\u6A94\u6A84\u6AA2\u6A9C\u6ADB\u6AA3\u6A7E\u6A97\u6A90\u6AA0\u6B5C\u6BAE\u6BDA\u6C08\u6FD8\u6FF1\u6FDF\u6FE0\u6FDB\u6FE4\u6FEB\u6FEF\u6F80\u6FEC\u6FE1\u6FE9\u6FD5\u6FEE\u6FF0\u71E7\u71DF\u71EE\u71E6\u71E5\u71ED\u71EC\u71F4\u71E0\u7235\u7246\u7370\u7372\u74A9\u74B0\u74A6\u74A8\u7646\u7642\u764C\u76EA\u77B3\u77AA\u77B0\u77AC"],
      ["c140", "\u77A7\u77AD\u77EF\u78F7\u78FA\u78F4\u78EF\u7901\u79A7\u79AA\u7A57\u7ABF\u7C07\u7C0D\u7BFE\u7BF7\u7C0C\u7BE0\u7CE0\u7CDC\u7CDE\u7CE2\u7CDF\u7CD9\u7CDD\u7E2E\u7E3E\u7E46\u7E37\u7E32\u7E43\u7E2B\u7E3D\u7E31\u7E45\u7E41\u7E34\u7E39\u7E48\u7E35\u7E3F\u7E2F\u7F44\u7FF3\u7FFC\u8071\u8072\u8070\u806F\u8073\u81C6\u81C3\u81BA\u81C2\u81C0\u81BF\u81BD\u81C9\u81BE\u81E8\u8209\u8271\u85AA"],
      ["c1a1", "\u8584\u857E\u859C\u8591\u8594\u85AF\u859B\u8587\u85A8\u858A\u8667\u87C0\u87D1\u87B3\u87D2\u87C6\u87AB\u87BB\u87BA\u87C8\u87CB\u893B\u8936\u8944\u8938\u893D\u89AC\u8B0E\u8B17\u8B19\u8B1B\u8B0A\u8B20\u8B1D\u8B04\u8B10\u8C41\u8C3F\u8C73\u8CFA\u8CFD\u8CFC\u8CF8\u8CFB\u8DA8\u8E49\u8E4B\u8E48\u8E4A\u8F44\u8F3E\u8F42\u8F45\u8F3F\u907F\u907D\u9084\u9081\u9082\u9080\u9139\u91A3\u919E\u919C\u934D\u9382\u9328\u9375\u934A\u9365\u934B\u9318\u937E\u936C\u935B\u9370\u935A\u9354\u95CA\u95CB\u95CC\u95C8\u95C6\u96B1\u96B8\u96D6\u971C\u971E\u97A0\u97D3\u9846\u98B6\u9935\u9A01"],
      ["c240", "\u99FF\u9BAE\u9BAB\u9BAA\u9BAD\u9D3B\u9D3F\u9E8B\u9ECF\u9EDE\u9EDC\u9EDD\u9EDB\u9F3E\u9F4B\u53E2\u5695\u56AE\u58D9\u58D8\u5B38\u5F5D\u61E3\u6233\u64F4\u64F2\u64FE\u6506\u64FA\u64FB\u64F7\u65B7\u66DC\u6726\u6AB3\u6AAC\u6AC3\u6ABB\u6AB8\u6AC2\u6AAE\u6AAF\u6B5F\u6B78\u6BAF\u7009\u700B\u6FFE\u7006\u6FFA\u7011\u700F\u71FB\u71FC\u71FE\u71F8\u7377\u7375\u74A7\u74BF\u7515\u7656\u7658"],
      ["c2a1", "\u7652\u77BD\u77BF\u77BB\u77BC\u790E\u79AE\u7A61\u7A62\u7A60\u7AC4\u7AC5\u7C2B\u7C27\u7C2A\u7C1E\u7C23\u7C21\u7CE7\u7E54\u7E55\u7E5E\u7E5A\u7E61\u7E52\u7E59\u7F48\u7FF9\u7FFB\u8077\u8076\u81CD\u81CF\u820A\u85CF\u85A9\u85CD\u85D0\u85C9\u85B0\u85BA\u85B9\u85A6\u87EF\u87EC\u87F2\u87E0\u8986\u89B2\u89F4\u8B28\u8B39\u8B2C\u8B2B\u8C50\u8D05\u8E59\u8E63\u8E66\u8E64\u8E5F\u8E55\u8EC0\u8F49\u8F4D\u9087\u9083\u9088\u91AB\u91AC\u91D0\u9394\u938A\u9396\u93A2\u93B3\u93AE\u93AC\u93B0\u9398\u939A\u9397\u95D4\u95D6\u95D0\u95D5\u96E2\u96DC\u96D9\u96DB\u96DE\u9724\u97A3\u97A6"],
      ["c340", "\u97AD\u97F9\u984D\u984F\u984C\u984E\u9853\u98BA\u993E\u993F\u993D\u992E\u99A5\u9A0E\u9AC1\u9B03\u9B06\u9B4F\u9B4E\u9B4D\u9BCA\u9BC9\u9BFD\u9BC8\u9BC0\u9D51\u9D5D\u9D60\u9EE0\u9F15\u9F2C\u5133\u56A5\u58DE\u58DF\u58E2\u5BF5\u9F90\u5EEC\u61F2\u61F7\u61F6\u61F5\u6500\u650F\u66E0\u66DD\u6AE5\u6ADD\u6ADA\u6AD3\u701B\u701F\u7028\u701A\u701D\u7015\u7018\u7206\u720D\u7258\u72A2\u7378"],
      ["c3a1", "\u737A\u74BD\u74CA\u74E3\u7587\u7586\u765F\u7661\u77C7\u7919\u79B1\u7A6B\u7A69\u7C3E\u7C3F\u7C38\u7C3D\u7C37\u7C40\u7E6B\u7E6D\u7E79\u7E69\u7E6A\u7F85\u7E73\u7FB6\u7FB9\u7FB8\u81D8\u85E9\u85DD\u85EA\u85D5\u85E4\u85E5\u85F7\u87FB\u8805\u880D\u87F9\u87FE\u8960\u895F\u8956\u895E\u8B41\u8B5C\u8B58\u8B49\u8B5A\u8B4E\u8B4F\u8B46\u8B59\u8D08\u8D0A\u8E7C\u8E72\u8E87\u8E76\u8E6C\u8E7A\u8E74\u8F54\u8F4E\u8FAD\u908A\u908B\u91B1\u91AE\u93E1\u93D1\u93DF\u93C3\u93C8\u93DC\u93DD\u93D6\u93E2\u93CD\u93D8\u93E4\u93D7\u93E8\u95DC\u96B4\u96E3\u972A\u9727\u9761\u97DC\u97FB\u985E"],
      ["c440", "\u9858\u985B\u98BC\u9945\u9949\u9A16\u9A19\u9B0D\u9BE8\u9BE7\u9BD6\u9BDB\u9D89\u9D61\u9D72\u9D6A\u9D6C\u9E92\u9E97\u9E93\u9EB4\u52F8\u56A8\u56B7\u56B6\u56B4\u56BC\u58E4\u5B40\u5B43\u5B7D\u5BF6\u5DC9\u61F8\u61FA\u6518\u6514\u6519\u66E6\u6727\u6AEC\u703E\u7030\u7032\u7210\u737B\u74CF\u7662\u7665\u7926\u792A\u792C\u792B\u7AC7\u7AF6\u7C4C\u7C43\u7C4D\u7CEF\u7CF0\u8FAE\u7E7D\u7E7C"],
      ["c4a1", "\u7E82\u7F4C\u8000\u81DA\u8266\u85FB\u85F9\u8611\u85FA\u8606\u860B\u8607\u860A\u8814\u8815\u8964\u89BA\u89F8\u8B70\u8B6C\u8B66\u8B6F\u8B5F\u8B6B\u8D0F\u8D0D\u8E89\u8E81\u8E85\u8E82\u91B4\u91CB\u9418\u9403\u93FD\u95E1\u9730\u98C4\u9952\u9951\u99A8\u9A2B\u9A30\u9A37\u9A35\u9C13\u9C0D\u9E79\u9EB5\u9EE8\u9F2F\u9F5F\u9F63\u9F61\u5137\u5138\u56C1\u56C0\u56C2\u5914\u5C6C\u5DCD\u61FC\u61FE\u651D\u651C\u6595\u66E9\u6AFB\u6B04\u6AFA\u6BB2\u704C\u721B\u72A7\u74D6\u74D4\u7669\u77D3\u7C50\u7E8F\u7E8C\u7FBC\u8617\u862D\u861A\u8823\u8822\u8821\u881F\u896A\u896C\u89BD\u8B74"],
      ["c540", "\u8B77\u8B7D\u8D13\u8E8A\u8E8D\u8E8B\u8F5F\u8FAF\u91BA\u942E\u9433\u9435\u943A\u9438\u9432\u942B\u95E2\u9738\u9739\u9732\u97FF\u9867\u9865\u9957\u9A45\u9A43\u9A40\u9A3E\u9ACF\u9B54\u9B51\u9C2D\u9C25\u9DAF\u9DB4\u9DC2\u9DB8\u9E9D\u9EEF\u9F19\u9F5C\u9F66\u9F67\u513C\u513B\u56C8\u56CA\u56C9\u5B7F\u5DD4\u5DD2\u5F4E\u61FF\u6524\u6B0A\u6B61\u7051\u7058\u7380\u74E4\u758A\u766E\u766C"],
      ["c5a1", "\u79B3\u7C60\u7C5F\u807E\u807D\u81DF\u8972\u896F\u89FC\u8B80\u8D16\u8D17\u8E91\u8E93\u8F61\u9148\u9444\u9451\u9452\u973D\u973E\u97C3\u97C1\u986B\u9955\u9A55\u9A4D\u9AD2\u9B1A\u9C49\u9C31\u9C3E\u9C3B\u9DD3\u9DD7\u9F34\u9F6C\u9F6A\u9F94\u56CC\u5DD6\u6200\u6523\u652B\u652A\u66EC\u6B10\u74DA\u7ACA\u7C64\u7C63\u7C65\u7E93\u7E96\u7E94\u81E2\u8638\u863F\u8831\u8B8A\u9090\u908F\u9463\u9460\u9464\u9768\u986F\u995C\u9A5A\u9A5B\u9A57\u9AD3\u9AD4\u9AD1\u9C54\u9C57\u9C56\u9DE5\u9E9F\u9EF4\u56D1\u58E9\u652C\u705E\u7671\u7672\u77D7\u7F50\u7F88\u8836\u8839\u8862\u8B93\u8B92"],
      ["c640", "\u8B96\u8277\u8D1B\u91C0\u946A\u9742\u9748\u9744\u97C6\u9870\u9A5F\u9B22\u9B58\u9C5F\u9DF9\u9DFA\u9E7C\u9E7D\u9F07\u9F77\u9F72\u5EF3\u6B16\u7063\u7C6C\u7C6E\u883B\u89C0\u8EA1\u91C1\u9472\u9470\u9871\u995E\u9AD6\u9B23\u9ECC\u7064\u77DA\u8B9A\u9477\u97C9\u9A62\u9A65\u7E9C\u8B9C\u8EAA\u91C5\u947D\u947E\u947C\u9C77\u9C78\u9EF7\u8C54\u947F\u9E1A\u7228\u9A6A\u9B31\u9E1B\u9E1E\u7C72"],
      ["c940", "\u4E42\u4E5C\u51F5\u531A\u5382\u4E07\u4E0C\u4E47\u4E8D\u56D7\uFA0C\u5C6E\u5F73\u4E0F\u5187\u4E0E\u4E2E\u4E93\u4EC2\u4EC9\u4EC8\u5198\u52FC\u536C\u53B9\u5720\u5903\u592C\u5C10\u5DFF\u65E1\u6BB3\u6BCC\u6C14\u723F\u4E31\u4E3C\u4EE8\u4EDC\u4EE9\u4EE1\u4EDD\u4EDA\u520C\u531C\u534C\u5722\u5723\u5917\u592F\u5B81\u5B84\u5C12\u5C3B\u5C74\u5C73\u5E04\u5E80\u5E82\u5FC9\u6209\u6250\u6C15"],
      ["c9a1", "\u6C36\u6C43\u6C3F\u6C3B\u72AE\u72B0\u738A\u79B8\u808A\u961E\u4F0E\u4F18\u4F2C\u4EF5\u4F14\u4EF1\u4F00\u4EF7\u4F08\u4F1D\u4F02\u4F05\u4F22\u4F13\u4F04\u4EF4\u4F12\u51B1\u5213\u5209\u5210\u52A6\u5322\u531F\u534D\u538A\u5407\u56E1\u56DF\u572E\u572A\u5734\u593C\u5980\u597C\u5985\u597B\u597E\u5977\u597F\u5B56\u5C15\u5C25\u5C7C\u5C7A\u5C7B\u5C7E\u5DDF\u5E75\u5E84\u5F02\u5F1A\u5F74\u5FD5\u5FD4\u5FCF\u625C\u625E\u6264\u6261\u6266\u6262\u6259\u6260\u625A\u6265\u65EF\u65EE\u673E\u6739\u6738\u673B\u673A\u673F\u673C\u6733\u6C18\u6C46\u6C52\u6C5C\u6C4F\u6C4A\u6C54\u6C4B"],
      ["ca40", "\u6C4C\u7071\u725E\u72B4\u72B5\u738E\u752A\u767F\u7A75\u7F51\u8278\u827C\u8280\u827D\u827F\u864D\u897E\u9099\u9097\u9098\u909B\u9094\u9622\u9624\u9620\u9623\u4F56\u4F3B\u4F62\u4F49\u4F53\u4F64\u4F3E\u4F67\u4F52\u4F5F\u4F41\u4F58\u4F2D\u4F33\u4F3F\u4F61\u518F\u51B9\u521C\u521E\u5221\u52AD\u52AE\u5309\u5363\u5372\u538E\u538F\u5430\u5437\u542A\u5454\u5445\u5419\u541C\u5425\u5418"],
      ["caa1", "\u543D\u544F\u5441\u5428\u5424\u5447\u56EE\u56E7\u56E5\u5741\u5745\u574C\u5749\u574B\u5752\u5906\u5940\u59A6\u5998\u59A0\u5997\u598E\u59A2\u5990\u598F\u59A7\u59A1\u5B8E\u5B92\u5C28\u5C2A\u5C8D\u5C8F\u5C88\u5C8B\u5C89\u5C92\u5C8A\u5C86\u5C93\u5C95\u5DE0\u5E0A\u5E0E\u5E8B\u5E89\u5E8C\u5E88\u5E8D\u5F05\u5F1D\u5F78\u5F76\u5FD2\u5FD1\u5FD0\u5FED\u5FE8\u5FEE\u5FF3\u5FE1\u5FE4\u5FE3\u5FFA\u5FEF\u5FF7\u5FFB\u6000\u5FF4\u623A\u6283\u628C\u628E\u628F\u6294\u6287\u6271\u627B\u627A\u6270\u6281\u6288\u6277\u627D\u6272\u6274\u6537\u65F0\u65F4\u65F3\u65F2\u65F5\u6745\u6747"],
      ["cb40", "\u6759\u6755\u674C\u6748\u675D\u674D\u675A\u674B\u6BD0\u6C19\u6C1A\u6C78\u6C67\u6C6B\u6C84\u6C8B\u6C8F\u6C71\u6C6F\u6C69\u6C9A\u6C6D\u6C87\u6C95\u6C9C\u6C66\u6C73\u6C65\u6C7B\u6C8E\u7074\u707A\u7263\u72BF\u72BD\u72C3\u72C6\u72C1\u72BA\u72C5\u7395\u7397\u7393\u7394\u7392\u753A\u7539\u7594\u7595\u7681\u793D\u8034\u8095\u8099\u8090\u8092\u809C\u8290\u828F\u8285\u828E\u8291\u8293"],
      ["cba1", "\u828A\u8283\u8284\u8C78\u8FC9\u8FBF\u909F\u90A1\u90A5\u909E\u90A7\u90A0\u9630\u9628\u962F\u962D\u4E33\u4F98\u4F7C\u4F85\u4F7D\u4F80\u4F87\u4F76\u4F74\u4F89\u4F84\u4F77\u4F4C\u4F97\u4F6A\u4F9A\u4F79\u4F81\u4F78\u4F90\u4F9C\u4F94\u4F9E\u4F92\u4F82\u4F95\u4F6B\u4F6E\u519E\u51BC\u51BE\u5235\u5232\u5233\u5246\u5231\u52BC\u530A\u530B\u533C\u5392\u5394\u5487\u547F\u5481\u5491\u5482\u5488\u546B\u547A\u547E\u5465\u546C\u5474\u5466\u548D\u546F\u5461\u5460\u5498\u5463\u5467\u5464\u56F7\u56F9\u576F\u5772\u576D\u576B\u5771\u5770\u5776\u5780\u5775\u577B\u5773\u5774\u5762"],
      ["cc40", "\u5768\u577D\u590C\u5945\u59B5\u59BA\u59CF\u59CE\u59B2\u59CC\u59C1\u59B6\u59BC\u59C3\u59D6\u59B1\u59BD\u59C0\u59C8\u59B4\u59C7\u5B62\u5B65\u5B93\u5B95\u5C44\u5C47\u5CAE\u5CA4\u5CA0\u5CB5\u5CAF\u5CA8\u5CAC\u5C9F\u5CA3\u5CAD\u5CA2\u5CAA\u5CA7\u5C9D\u5CA5\u5CB6\u5CB0\u5CA6\u5E17\u5E14\u5E19\u5F28\u5F22\u5F23\u5F24\u5F54\u5F82\u5F7E\u5F7D\u5FDE\u5FE5\u602D\u6026\u6019\u6032\u600B"],
      ["cca1", "\u6034\u600A\u6017\u6033\u601A\u601E\u602C\u6022\u600D\u6010\u602E\u6013\u6011\u600C\u6009\u601C\u6214\u623D\u62AD\u62B4\u62D1\u62BE\u62AA\u62B6\u62CA\u62AE\u62B3\u62AF\u62BB\u62A9\u62B0\u62B8\u653D\u65A8\u65BB\u6609\u65FC\u6604\u6612\u6608\u65FB\u6603\u660B\u660D\u6605\u65FD\u6611\u6610\u66F6\u670A\u6785\u676C\u678E\u6792\u6776\u677B\u6798\u6786\u6784\u6774\u678D\u678C\u677A\u679F\u6791\u6799\u6783\u677D\u6781\u6778\u6779\u6794\u6B25\u6B80\u6B7E\u6BDE\u6C1D\u6C93\u6CEC\u6CEB\u6CEE\u6CD9\u6CB6\u6CD4\u6CAD\u6CE7\u6CB7\u6CD0\u6CC2\u6CBA\u6CC3\u6CC6\u6CED\u6CF2"],
      ["cd40", "\u6CD2\u6CDD\u6CB4\u6C8A\u6C9D\u6C80\u6CDE\u6CC0\u6D30\u6CCD\u6CC7\u6CB0\u6CF9\u6CCF\u6CE9\u6CD1\u7094\u7098\u7085\u7093\u7086\u7084\u7091\u7096\u7082\u709A\u7083\u726A\u72D6\u72CB\u72D8\u72C9\u72DC\u72D2\u72D4\u72DA\u72CC\u72D1\u73A4\u73A1\u73AD\u73A6\u73A2\u73A0\u73AC\u739D\u74DD\u74E8\u753F\u7540\u753E\u758C\u7598\u76AF\u76F3\u76F1\u76F0\u76F5\u77F8\u77FC\u77F9\u77FB\u77FA"],
      ["cda1", "\u77F7\u7942\u793F\u79C5\u7A78\u7A7B\u7AFB\u7C75\u7CFD\u8035\u808F\u80AE\u80A3\u80B8\u80B5\u80AD\u8220\u82A0\u82C0\u82AB\u829A\u8298\u829B\u82B5\u82A7\u82AE\u82BC\u829E\u82BA\u82B4\u82A8\u82A1\u82A9\u82C2\u82A4\u82C3\u82B6\u82A2\u8670\u866F\u866D\u866E\u8C56\u8FD2\u8FCB\u8FD3\u8FCD\u8FD6\u8FD5\u8FD7\u90B2\u90B4\u90AF\u90B3\u90B0\u9639\u963D\u963C\u963A\u9643\u4FCD\u4FC5\u4FD3\u4FB2\u4FC9\u4FCB\u4FC1\u4FD4\u4FDC\u4FD9\u4FBB\u4FB3\u4FDB\u4FC7\u4FD6\u4FBA\u4FC0\u4FB9\u4FEC\u5244\u5249\u52C0\u52C2\u533D\u537C\u5397\u5396\u5399\u5398\u54BA\u54A1\u54AD\u54A5\u54CF"],
      ["ce40", "\u54C3\u830D\u54B7\u54AE\u54D6\u54B6\u54C5\u54C6\u54A0\u5470\u54BC\u54A2\u54BE\u5472\u54DE\u54B0\u57B5\u579E\u579F\u57A4\u578C\u5797\u579D\u579B\u5794\u5798\u578F\u5799\u57A5\u579A\u5795\u58F4\u590D\u5953\u59E1\u59DE\u59EE\u5A00\u59F1\u59DD\u59FA\u59FD\u59FC\u59F6\u59E4\u59F2\u59F7\u59DB\u59E9\u59F3\u59F5\u59E0\u59FE\u59F4\u59ED\u5BA8\u5C4C\u5CD0\u5CD8\u5CCC\u5CD7\u5CCB\u5CDB"],
      ["cea1", "\u5CDE\u5CDA\u5CC9\u5CC7\u5CCA\u5CD6\u5CD3\u5CD4\u5CCF\u5CC8\u5CC6\u5CCE\u5CDF\u5CF8\u5DF9\u5E21\u5E22\u5E23\u5E20\u5E24\u5EB0\u5EA4\u5EA2\u5E9B\u5EA3\u5EA5\u5F07\u5F2E\u5F56\u5F86\u6037\u6039\u6054\u6072\u605E\u6045\u6053\u6047\u6049\u605B\u604C\u6040\u6042\u605F\u6024\u6044\u6058\u6066\u606E\u6242\u6243\u62CF\u630D\u630B\u62F5\u630E\u6303\u62EB\u62F9\u630F\u630C\u62F8\u62F6\u6300\u6313\u6314\u62FA\u6315\u62FB\u62F0\u6541\u6543\u65AA\u65BF\u6636\u6621\u6632\u6635\u661C\u6626\u6622\u6633\u662B\u663A\u661D\u6634\u6639\u662E\u670F\u6710\u67C1\u67F2\u67C8\u67BA"],
      ["cf40", "\u67DC\u67BB\u67F8\u67D8\u67C0\u67B7\u67C5\u67EB\u67E4\u67DF\u67B5\u67CD\u67B3\u67F7\u67F6\u67EE\u67E3\u67C2\u67B9\u67CE\u67E7\u67F0\u67B2\u67FC\u67C6\u67ED\u67CC\u67AE\u67E6\u67DB\u67FA\u67C9\u67CA\u67C3\u67EA\u67CB\u6B28\u6B82\u6B84\u6BB6\u6BD6\u6BD8\u6BE0\u6C20\u6C21\u6D28\u6D34\u6D2D\u6D1F\u6D3C\u6D3F\u6D12\u6D0A\u6CDA\u6D33\u6D04\u6D19\u6D3A\u6D1A\u6D11\u6D00\u6D1D\u6D42"],
      ["cfa1", "\u6D01\u6D18\u6D37\u6D03\u6D0F\u6D40\u6D07\u6D20\u6D2C\u6D08\u6D22\u6D09\u6D10\u70B7\u709F\u70BE\u70B1\u70B0\u70A1\u70B4\u70B5\u70A9\u7241\u7249\u724A\u726C\u7270\u7273\u726E\u72CA\u72E4\u72E8\u72EB\u72DF\u72EA\u72E6\u72E3\u7385\u73CC\u73C2\u73C8\u73C5\u73B9\u73B6\u73B5\u73B4\u73EB\u73BF\u73C7\u73BE\u73C3\u73C6\u73B8\u73CB\u74EC\u74EE\u752E\u7547\u7548\u75A7\u75AA\u7679\u76C4\u7708\u7703\u7704\u7705\u770A\u76F7\u76FB\u76FA\u77E7\u77E8\u7806\u7811\u7812\u7805\u7810\u780F\u780E\u7809\u7803\u7813\u794A\u794C\u794B\u7945\u7944\u79D5\u79CD\u79CF\u79D6\u79CE\u7A80"],
      ["d040", "\u7A7E\u7AD1\u7B00\u7B01\u7C7A\u7C78\u7C79\u7C7F\u7C80\u7C81\u7D03\u7D08\u7D01\u7F58\u7F91\u7F8D\u7FBE\u8007\u800E\u800F\u8014\u8037\u80D8\u80C7\u80E0\u80D1\u80C8\u80C2\u80D0\u80C5\u80E3\u80D9\u80DC\u80CA\u80D5\u80C9\u80CF\u80D7\u80E6\u80CD\u81FF\u8221\u8294\u82D9\u82FE\u82F9\u8307\u82E8\u8300\u82D5\u833A\u82EB\u82D6\u82F4\u82EC\u82E1\u82F2\u82F5\u830C\u82FB\u82F6\u82F0\u82EA"],
      ["d0a1", "\u82E4\u82E0\u82FA\u82F3\u82ED\u8677\u8674\u867C\u8673\u8841\u884E\u8867\u886A\u8869\u89D3\u8A04\u8A07\u8D72\u8FE3\u8FE1\u8FEE\u8FE0\u90F1\u90BD\u90BF\u90D5\u90C5\u90BE\u90C7\u90CB\u90C8\u91D4\u91D3\u9654\u964F\u9651\u9653\u964A\u964E\u501E\u5005\u5007\u5013\u5022\u5030\u501B\u4FF5\u4FF4\u5033\u5037\u502C\u4FF6\u4FF7\u5017\u501C\u5020\u5027\u5035\u502F\u5031\u500E\u515A\u5194\u5193\u51CA\u51C4\u51C5\u51C8\u51CE\u5261\u525A\u5252\u525E\u525F\u5255\u5262\u52CD\u530E\u539E\u5526\u54E2\u5517\u5512\u54E7\u54F3\u54E4\u551A\u54FF\u5504\u5508\u54EB\u5511\u5505\u54F1"],
      ["d140", "\u550A\u54FB\u54F7\u54F8\u54E0\u550E\u5503\u550B\u5701\u5702\u57CC\u5832\u57D5\u57D2\u57BA\u57C6\u57BD\u57BC\u57B8\u57B6\u57BF\u57C7\u57D0\u57B9\u57C1\u590E\u594A\u5A19\u5A16\u5A2D\u5A2E\u5A15\u5A0F\u5A17\u5A0A\u5A1E\u5A33\u5B6C\u5BA7\u5BAD\u5BAC\u5C03\u5C56\u5C54\u5CEC\u5CFF\u5CEE\u5CF1\u5CF7\u5D00\u5CF9\u5E29\u5E28\u5EA8\u5EAE\u5EAA\u5EAC\u5F33\u5F30\u5F67\u605D\u605A\u6067"],
      ["d1a1", "\u6041\u60A2\u6088\u6080\u6092\u6081\u609D\u6083\u6095\u609B\u6097\u6087\u609C\u608E\u6219\u6246\u62F2\u6310\u6356\u632C\u6344\u6345\u6336\u6343\u63E4\u6339\u634B\u634A\u633C\u6329\u6341\u6334\u6358\u6354\u6359\u632D\u6347\u6333\u635A\u6351\u6338\u6357\u6340\u6348\u654A\u6546\u65C6\u65C3\u65C4\u65C2\u664A\u665F\u6647\u6651\u6712\u6713\u681F\u681A\u6849\u6832\u6833\u683B\u684B\u684F\u6816\u6831\u681C\u6835\u682B\u682D\u682F\u684E\u6844\u6834\u681D\u6812\u6814\u6826\u6828\u682E\u684D\u683A\u6825\u6820\u6B2C\u6B2F\u6B2D\u6B31\u6B34\u6B6D\u8082\u6B88\u6BE6\u6BE4"],
      ["d240", "\u6BE8\u6BE3\u6BE2\u6BE7\u6C25\u6D7A\u6D63\u6D64\u6D76\u6D0D\u6D61\u6D92\u6D58\u6D62\u6D6D\u6D6F\u6D91\u6D8D\u6DEF\u6D7F\u6D86\u6D5E\u6D67\u6D60\u6D97\u6D70\u6D7C\u6D5F\u6D82\u6D98\u6D2F\u6D68\u6D8B\u6D7E\u6D80\u6D84\u6D16\u6D83\u6D7B\u6D7D\u6D75\u6D90\u70DC\u70D3\u70D1\u70DD\u70CB\u7F39\u70E2\u70D7\u70D2\u70DE\u70E0\u70D4\u70CD\u70C5\u70C6\u70C7\u70DA\u70CE\u70E1\u7242\u7278"],
      ["d2a1", "\u7277\u7276\u7300\u72FA\u72F4\u72FE\u72F6\u72F3\u72FB\u7301\u73D3\u73D9\u73E5\u73D6\u73BC\u73E7\u73E3\u73E9\u73DC\u73D2\u73DB\u73D4\u73DD\u73DA\u73D7\u73D8\u73E8\u74DE\u74DF\u74F4\u74F5\u7521\u755B\u755F\u75B0\u75C1\u75BB\u75C4\u75C0\u75BF\u75B6\u75BA\u768A\u76C9\u771D\u771B\u7710\u7713\u7712\u7723\u7711\u7715\u7719\u771A\u7722\u7727\u7823\u782C\u7822\u7835\u782F\u7828\u782E\u782B\u7821\u7829\u7833\u782A\u7831\u7954\u795B\u794F\u795C\u7953\u7952\u7951\u79EB\u79EC\u79E0\u79EE\u79ED\u79EA\u79DC\u79DE\u79DD\u7A86\u7A89\u7A85\u7A8B\u7A8C\u7A8A\u7A87\u7AD8\u7B10"],
      ["d340", "\u7B04\u7B13\u7B05\u7B0F\u7B08\u7B0A\u7B0E\u7B09\u7B12\u7C84\u7C91\u7C8A\u7C8C\u7C88\u7C8D\u7C85\u7D1E\u7D1D\u7D11\u7D0E\u7D18\u7D16\u7D13\u7D1F\u7D12\u7D0F\u7D0C\u7F5C\u7F61\u7F5E\u7F60\u7F5D\u7F5B\u7F96\u7F92\u7FC3\u7FC2\u7FC0\u8016\u803E\u8039\u80FA\u80F2\u80F9\u80F5\u8101\u80FB\u8100\u8201\u822F\u8225\u8333\u832D\u8344\u8319\u8351\u8325\u8356\u833F\u8341\u8326\u831C\u8322"],
      ["d3a1", "\u8342\u834E\u831B\u832A\u8308\u833C\u834D\u8316\u8324\u8320\u8337\u832F\u8329\u8347\u8345\u834C\u8353\u831E\u832C\u834B\u8327\u8348\u8653\u8652\u86A2\u86A8\u8696\u868D\u8691\u869E\u8687\u8697\u8686\u868B\u869A\u8685\u86A5\u8699\u86A1\u86A7\u8695\u8698\u868E\u869D\u8690\u8694\u8843\u8844\u886D\u8875\u8876\u8872\u8880\u8871\u887F\u886F\u8883\u887E\u8874\u887C\u8A12\u8C47\u8C57\u8C7B\u8CA4\u8CA3\u8D76\u8D78\u8DB5\u8DB7\u8DB6\u8ED1\u8ED3\u8FFE\u8FF5\u9002\u8FFF\u8FFB\u9004\u8FFC\u8FF6\u90D6\u90E0\u90D9\u90DA\u90E3\u90DF\u90E5\u90D8\u90DB\u90D7\u90DC\u90E4\u9150"],
      ["d440", "\u914E\u914F\u91D5\u91E2\u91DA\u965C\u965F\u96BC\u98E3\u9ADF\u9B2F\u4E7F\u5070\u506A\u5061\u505E\u5060\u5053\u504B\u505D\u5072\u5048\u504D\u5041\u505B\u504A\u5062\u5015\u5045\u505F\u5069\u506B\u5063\u5064\u5046\u5040\u506E\u5073\u5057\u5051\u51D0\u526B\u526D\u526C\u526E\u52D6\u52D3\u532D\u539C\u5575\u5576\u553C\u554D\u5550\u5534\u552A\u5551\u5562\u5536\u5535\u5530\u5552\u5545"],
      ["d4a1", "\u550C\u5532\u5565\u554E\u5539\u5548\u552D\u553B\u5540\u554B\u570A\u5707\u57FB\u5814\u57E2\u57F6\u57DC\u57F4\u5800\u57ED\u57FD\u5808\u57F8\u580B\u57F3\u57CF\u5807\u57EE\u57E3\u57F2\u57E5\u57EC\u57E1\u580E\u57FC\u5810\u57E7\u5801\u580C\u57F1\u57E9\u57F0\u580D\u5804\u595C\u5A60\u5A58\u5A55\u5A67\u5A5E\u5A38\u5A35\u5A6D\u5A50\u5A5F\u5A65\u5A6C\u5A53\u5A64\u5A57\u5A43\u5A5D\u5A52\u5A44\u5A5B\u5A48\u5A8E\u5A3E\u5A4D\u5A39\u5A4C\u5A70\u5A69\u5A47\u5A51\u5A56\u5A42\u5A5C\u5B72\u5B6E\u5BC1\u5BC0\u5C59\u5D1E\u5D0B\u5D1D\u5D1A\u5D20\u5D0C\u5D28\u5D0D\u5D26\u5D25\u5D0F"],
      ["d540", "\u5D30\u5D12\u5D23\u5D1F\u5D2E\u5E3E\u5E34\u5EB1\u5EB4\u5EB9\u5EB2\u5EB3\u5F36\u5F38\u5F9B\u5F96\u5F9F\u608A\u6090\u6086\u60BE\u60B0\u60BA\u60D3\u60D4\u60CF\u60E4\u60D9\u60DD\u60C8\u60B1\u60DB\u60B7\u60CA\u60BF\u60C3\u60CD\u60C0\u6332\u6365\u638A\u6382\u637D\u63BD\u639E\u63AD\u639D\u6397\u63AB\u638E\u636F\u6387\u6390\u636E\u63AF\u6375\u639C\u636D\u63AE\u637C\u63A4\u633B\u639F"],
      ["d5a1", "\u6378\u6385\u6381\u6391\u638D\u6370\u6553\u65CD\u6665\u6661\u665B\u6659\u665C\u6662\u6718\u6879\u6887\u6890\u689C\u686D\u686E\u68AE\u68AB\u6956\u686F\u68A3\u68AC\u68A9\u6875\u6874\u68B2\u688F\u6877\u6892\u687C\u686B\u6872\u68AA\u6880\u6871\u687E\u689B\u6896\u688B\u68A0\u6889\u68A4\u6878\u687B\u6891\u688C\u688A\u687D\u6B36\u6B33\u6B37\u6B38\u6B91\u6B8F\u6B8D\u6B8E\u6B8C\u6C2A\u6DC0\u6DAB\u6DB4\u6DB3\u6E74\u6DAC\u6DE9\u6DE2\u6DB7\u6DF6\u6DD4\u6E00\u6DC8\u6DE0\u6DDF\u6DD6\u6DBE\u6DE5\u6DDC\u6DDD\u6DDB\u6DF4\u6DCA\u6DBD\u6DED\u6DF0\u6DBA\u6DD5\u6DC2\u6DCF\u6DC9"],
      ["d640", "\u6DD0\u6DF2\u6DD3\u6DFD\u6DD7\u6DCD\u6DE3\u6DBB\u70FA\u710D\u70F7\u7117\u70F4\u710C\u70F0\u7104\u70F3\u7110\u70FC\u70FF\u7106\u7113\u7100\u70F8\u70F6\u710B\u7102\u710E\u727E\u727B\u727C\u727F\u731D\u7317\u7307\u7311\u7318\u730A\u7308\u72FF\u730F\u731E\u7388\u73F6\u73F8\u73F5\u7404\u7401\u73FD\u7407\u7400\u73FA\u73FC\u73FF\u740C\u740B\u73F4\u7408\u7564\u7563\u75CE\u75D2\u75CF"],
      ["d6a1", "\u75CB\u75CC\u75D1\u75D0\u768F\u7689\u76D3\u7739\u772F\u772D\u7731\u7732\u7734\u7733\u773D\u7725\u773B\u7735\u7848\u7852\u7849\u784D\u784A\u784C\u7826\u7845\u7850\u7964\u7967\u7969\u796A\u7963\u796B\u7961\u79BB\u79FA\u79F8\u79F6\u79F7\u7A8F\u7A94\u7A90\u7B35\u7B47\u7B34\u7B25\u7B30\u7B22\u7B24\u7B33\u7B18\u7B2A\u7B1D\u7B31\u7B2B\u7B2D\u7B2F\u7B32\u7B38\u7B1A\u7B23\u7C94\u7C98\u7C96\u7CA3\u7D35\u7D3D\u7D38\u7D36\u7D3A\u7D45\u7D2C\u7D29\u7D41\u7D47\u7D3E\u7D3F\u7D4A\u7D3B\u7D28\u7F63\u7F95\u7F9C\u7F9D\u7F9B\u7FCA\u7FCB\u7FCD\u7FD0\u7FD1\u7FC7\u7FCF\u7FC9\u801F"],
      ["d740", "\u801E\u801B\u8047\u8043\u8048\u8118\u8125\u8119\u811B\u812D\u811F\u812C\u811E\u8121\u8115\u8127\u811D\u8122\u8211\u8238\u8233\u823A\u8234\u8232\u8274\u8390\u83A3\u83A8\u838D\u837A\u8373\u83A4\u8374\u838F\u8381\u8395\u8399\u8375\u8394\u83A9\u837D\u8383\u838C\u839D\u839B\u83AA\u838B\u837E\u83A5\u83AF\u8388\u8397\u83B0\u837F\u83A6\u8387\u83AE\u8376\u839A\u8659\u8656\u86BF\u86B7"],
      ["d7a1", "\u86C2\u86C1\u86C5\u86BA\u86B0\u86C8\u86B9\u86B3\u86B8\u86CC\u86B4\u86BB\u86BC\u86C3\u86BD\u86BE\u8852\u8889\u8895\u88A8\u88A2\u88AA\u889A\u8891\u88A1\u889F\u8898\u88A7\u8899\u889B\u8897\u88A4\u88AC\u888C\u8893\u888E\u8982\u89D6\u89D9\u89D5\u8A30\u8A27\u8A2C\u8A1E\u8C39\u8C3B\u8C5C\u8C5D\u8C7D\u8CA5\u8D7D\u8D7B\u8D79\u8DBC\u8DC2\u8DB9\u8DBF\u8DC1\u8ED8\u8EDE\u8EDD\u8EDC\u8ED7\u8EE0\u8EE1\u9024\u900B\u9011\u901C\u900C\u9021\u90EF\u90EA\u90F0\u90F4\u90F2\u90F3\u90D4\u90EB\u90EC\u90E9\u9156\u9158\u915A\u9153\u9155\u91EC\u91F4\u91F1\u91F3\u91F8\u91E4\u91F9\u91EA"],
      ["d840", "\u91EB\u91F7\u91E8\u91EE\u957A\u9586\u9588\u967C\u966D\u966B\u9671\u966F\u96BF\u976A\u9804\u98E5\u9997\u509B\u5095\u5094\u509E\u508B\u50A3\u5083\u508C\u508E\u509D\u5068\u509C\u5092\u5082\u5087\u515F\u51D4\u5312\u5311\u53A4\u53A7\u5591\u55A8\u55A5\u55AD\u5577\u5645\u55A2\u5593\u5588\u558F\u55B5\u5581\u55A3\u5592\u55A4\u557D\u558C\u55A6\u557F\u5595\u55A1\u558E\u570C\u5829\u5837"],
      ["d8a1", "\u5819\u581E\u5827\u5823\u5828\u57F5\u5848\u5825\u581C\u581B\u5833\u583F\u5836\u582E\u5839\u5838\u582D\u582C\u583B\u5961\u5AAF\u5A94\u5A9F\u5A7A\u5AA2\u5A9E\u5A78\u5AA6\u5A7C\u5AA5\u5AAC\u5A95\u5AAE\u5A37\u5A84\u5A8A\u5A97\u5A83\u5A8B\u5AA9\u5A7B\u5A7D\u5A8C\u5A9C\u5A8F\u5A93\u5A9D\u5BEA\u5BCD\u5BCB\u5BD4\u5BD1\u5BCA\u5BCE\u5C0C\u5C30\u5D37\u5D43\u5D6B\u5D41\u5D4B\u5D3F\u5D35\u5D51\u5D4E\u5D55\u5D33\u5D3A\u5D52\u5D3D\u5D31\u5D59\u5D42\u5D39\u5D49\u5D38\u5D3C\u5D32\u5D36\u5D40\u5D45\u5E44\u5E41\u5F58\u5FA6\u5FA5\u5FAB\u60C9\u60B9\u60CC\u60E2\u60CE\u60C4\u6114"],
      ["d940", "\u60F2\u610A\u6116\u6105\u60F5\u6113\u60F8\u60FC\u60FE\u60C1\u6103\u6118\u611D\u6110\u60FF\u6104\u610B\u624A\u6394\u63B1\u63B0\u63CE\u63E5\u63E8\u63EF\u63C3\u649D\u63F3\u63CA\u63E0\u63F6\u63D5\u63F2\u63F5\u6461\u63DF\u63BE\u63DD\u63DC\u63C4\u63D8\u63D3\u63C2\u63C7\u63CC\u63CB\u63C8\u63F0\u63D7\u63D9\u6532\u6567\u656A\u6564\u655C\u6568\u6565\u658C\u659D\u659E\u65AE\u65D0\u65D2"],
      ["d9a1", "\u667C\u666C\u667B\u6680\u6671\u6679\u666A\u6672\u6701\u690C\u68D3\u6904\u68DC\u692A\u68EC\u68EA\u68F1\u690F\u68D6\u68F7\u68EB\u68E4\u68F6\u6913\u6910\u68F3\u68E1\u6907\u68CC\u6908\u6970\u68B4\u6911\u68EF\u68C6\u6914\u68F8\u68D0\u68FD\u68FC\u68E8\u690B\u690A\u6917\u68CE\u68C8\u68DD\u68DE\u68E6\u68F4\u68D1\u6906\u68D4\u68E9\u6915\u6925\u68C7\u6B39\u6B3B\u6B3F\u6B3C\u6B94\u6B97\u6B99\u6B95\u6BBD\u6BF0\u6BF2\u6BF3\u6C30\u6DFC\u6E46\u6E47\u6E1F\u6E49\u6E88\u6E3C\u6E3D\u6E45\u6E62\u6E2B\u6E3F\u6E41\u6E5D\u6E73\u6E1C\u6E33\u6E4B\u6E40\u6E51\u6E3B\u6E03\u6E2E\u6E5E"],
      ["da40", "\u6E68\u6E5C\u6E61\u6E31\u6E28\u6E60\u6E71\u6E6B\u6E39\u6E22\u6E30\u6E53\u6E65\u6E27\u6E78\u6E64\u6E77\u6E55\u6E79\u6E52\u6E66\u6E35\u6E36\u6E5A\u7120\u711E\u712F\u70FB\u712E\u7131\u7123\u7125\u7122\u7132\u711F\u7128\u713A\u711B\u724B\u725A\u7288\u7289\u7286\u7285\u728B\u7312\u730B\u7330\u7322\u7331\u7333\u7327\u7332\u732D\u7326\u7323\u7335\u730C\u742E\u742C\u7430\u742B\u7416"],
      ["daa1", "\u741A\u7421\u742D\u7431\u7424\u7423\u741D\u7429\u7420\u7432\u74FB\u752F\u756F\u756C\u75E7\u75DA\u75E1\u75E6\u75DD\u75DF\u75E4\u75D7\u7695\u7692\u76DA\u7746\u7747\u7744\u774D\u7745\u774A\u774E\u774B\u774C\u77DE\u77EC\u7860\u7864\u7865\u785C\u786D\u7871\u786A\u786E\u7870\u7869\u7868\u785E\u7862\u7974\u7973\u7972\u7970\u7A02\u7A0A\u7A03\u7A0C\u7A04\u7A99\u7AE6\u7AE4\u7B4A\u7B3B\u7B44\u7B48\u7B4C\u7B4E\u7B40\u7B58\u7B45\u7CA2\u7C9E\u7CA8\u7CA1\u7D58\u7D6F\u7D63\u7D53\u7D56\u7D67\u7D6A\u7D4F\u7D6D\u7D5C\u7D6B\u7D52\u7D54\u7D69\u7D51\u7D5F\u7D4E\u7F3E\u7F3F\u7F65"],
      ["db40", "\u7F66\u7FA2\u7FA0\u7FA1\u7FD7\u8051\u804F\u8050\u80FE\u80D4\u8143\u814A\u8152\u814F\u8147\u813D\u814D\u813A\u81E6\u81EE\u81F7\u81F8\u81F9\u8204\u823C\u823D\u823F\u8275\u833B\u83CF\u83F9\u8423\u83C0\u83E8\u8412\u83E7\u83E4\u83FC\u83F6\u8410\u83C6\u83C8\u83EB\u83E3\u83BF\u8401\u83DD\u83E5\u83D8\u83FF\u83E1\u83CB\u83CE\u83D6\u83F5\u83C9\u8409\u840F\u83DE\u8411\u8406\u83C2\u83F3"],
      ["dba1", "\u83D5\u83FA\u83C7\u83D1\u83EA\u8413\u83C3\u83EC\u83EE\u83C4\u83FB\u83D7\u83E2\u841B\u83DB\u83FE\u86D8\u86E2\u86E6\u86D3\u86E3\u86DA\u86EA\u86DD\u86EB\u86DC\u86EC\u86E9\u86D7\u86E8\u86D1\u8848\u8856\u8855\u88BA\u88D7\u88B9\u88B8\u88C0\u88BE\u88B6\u88BC\u88B7\u88BD\u88B2\u8901\u88C9\u8995\u8998\u8997\u89DD\u89DA\u89DB\u8A4E\u8A4D\u8A39\u8A59\u8A40\u8A57\u8A58\u8A44\u8A45\u8A52\u8A48\u8A51\u8A4A\u8A4C\u8A4F\u8C5F\u8C81\u8C80\u8CBA\u8CBE\u8CB0\u8CB9\u8CB5\u8D84\u8D80\u8D89\u8DD8\u8DD3\u8DCD\u8DC7\u8DD6\u8DDC\u8DCF\u8DD5\u8DD9\u8DC8\u8DD7\u8DC5\u8EEF\u8EF7\u8EFA"],
      ["dc40", "\u8EF9\u8EE6\u8EEE\u8EE5\u8EF5\u8EE7\u8EE8\u8EF6\u8EEB\u8EF1\u8EEC\u8EF4\u8EE9\u902D\u9034\u902F\u9106\u912C\u9104\u90FF\u90FC\u9108\u90F9\u90FB\u9101\u9100\u9107\u9105\u9103\u9161\u9164\u915F\u9162\u9160\u9201\u920A\u9225\u9203\u921A\u9226\u920F\u920C\u9200\u9212\u91FF\u91FD\u9206\u9204\u9227\u9202\u921C\u9224\u9219\u9217\u9205\u9216\u957B\u958D\u958C\u9590\u9687\u967E\u9688"],
      ["dca1", "\u9689\u9683\u9680\u96C2\u96C8\u96C3\u96F1\u96F0\u976C\u9770\u976E\u9807\u98A9\u98EB\u9CE6\u9EF9\u4E83\u4E84\u4EB6\u50BD\u50BF\u50C6\u50AE\u50C4\u50CA\u50B4\u50C8\u50C2\u50B0\u50C1\u50BA\u50B1\u50CB\u50C9\u50B6\u50B8\u51D7\u527A\u5278\u527B\u527C\u55C3\u55DB\u55CC\u55D0\u55CB\u55CA\u55DD\u55C0\u55D4\u55C4\u55E9\u55BF\u55D2\u558D\u55CF\u55D5\u55E2\u55D6\u55C8\u55F2\u55CD\u55D9\u55C2\u5714\u5853\u5868\u5864\u584F\u584D\u5849\u586F\u5855\u584E\u585D\u5859\u5865\u585B\u583D\u5863\u5871\u58FC\u5AC7\u5AC4\u5ACB\u5ABA\u5AB8\u5AB1\u5AB5\u5AB0\u5ABF\u5AC8\u5ABB\u5AC6"],
      ["dd40", "\u5AB7\u5AC0\u5ACA\u5AB4\u5AB6\u5ACD\u5AB9\u5A90\u5BD6\u5BD8\u5BD9\u5C1F\u5C33\u5D71\u5D63\u5D4A\u5D65\u5D72\u5D6C\u5D5E\u5D68\u5D67\u5D62\u5DF0\u5E4F\u5E4E\u5E4A\u5E4D\u5E4B\u5EC5\u5ECC\u5EC6\u5ECB\u5EC7\u5F40\u5FAF\u5FAD\u60F7\u6149\u614A\u612B\u6145\u6136\u6132\u612E\u6146\u612F\u614F\u6129\u6140\u6220\u9168\u6223\u6225\u6224\u63C5\u63F1\u63EB\u6410\u6412\u6409\u6420\u6424"],
      ["dda1", "\u6433\u6443\u641F\u6415\u6418\u6439\u6437\u6422\u6423\u640C\u6426\u6430\u6428\u6441\u6435\u642F\u640A\u641A\u6440\u6425\u6427\u640B\u63E7\u641B\u642E\u6421\u640E\u656F\u6592\u65D3\u6686\u668C\u6695\u6690\u668B\u668A\u6699\u6694\u6678\u6720\u6966\u695F\u6938\u694E\u6962\u6971\u693F\u6945\u696A\u6939\u6942\u6957\u6959\u697A\u6948\u6949\u6935\u696C\u6933\u693D\u6965\u68F0\u6978\u6934\u6969\u6940\u696F\u6944\u6976\u6958\u6941\u6974\u694C\u693B\u694B\u6937\u695C\u694F\u6951\u6932\u6952\u692F\u697B\u693C\u6B46\u6B45\u6B43\u6B42\u6B48\u6B41\u6B9B\uFA0D\u6BFB\u6BFC"],
      ["de40", "\u6BF9\u6BF7\u6BF8\u6E9B\u6ED6\u6EC8\u6E8F\u6EC0\u6E9F\u6E93\u6E94\u6EA0\u6EB1\u6EB9\u6EC6\u6ED2\u6EBD\u6EC1\u6E9E\u6EC9\u6EB7\u6EB0\u6ECD\u6EA6\u6ECF\u6EB2\u6EBE\u6EC3\u6EDC\u6ED8\u6E99\u6E92\u6E8E\u6E8D\u6EA4\u6EA1\u6EBF\u6EB3\u6ED0\u6ECA\u6E97\u6EAE\u6EA3\u7147\u7154\u7152\u7163\u7160\u7141\u715D\u7162\u7172\u7178\u716A\u7161\u7142\u7158\u7143\u714B\u7170\u715F\u7150\u7153"],
      ["dea1", "\u7144\u714D\u715A\u724F\u728D\u728C\u7291\u7290\u728E\u733C\u7342\u733B\u733A\u7340\u734A\u7349\u7444\u744A\u744B\u7452\u7451\u7457\u7440\u744F\u7450\u744E\u7442\u7446\u744D\u7454\u74E1\u74FF\u74FE\u74FD\u751D\u7579\u7577\u6983\u75EF\u760F\u7603\u75F7\u75FE\u75FC\u75F9\u75F8\u7610\u75FB\u75F6\u75ED\u75F5\u75FD\u7699\u76B5\u76DD\u7755\u775F\u7760\u7752\u7756\u775A\u7769\u7767\u7754\u7759\u776D\u77E0\u7887\u789A\u7894\u788F\u7884\u7895\u7885\u7886\u78A1\u7883\u7879\u7899\u7880\u7896\u787B\u797C\u7982\u797D\u7979\u7A11\u7A18\u7A19\u7A12\u7A17\u7A15\u7A22\u7A13"],
      ["df40", "\u7A1B\u7A10\u7AA3\u7AA2\u7A9E\u7AEB\u7B66\u7B64\u7B6D\u7B74\u7B69\u7B72\u7B65\u7B73\u7B71\u7B70\u7B61\u7B78\u7B76\u7B63\u7CB2\u7CB4\u7CAF\u7D88\u7D86\u7D80\u7D8D\u7D7F\u7D85\u7D7A\u7D8E\u7D7B\u7D83\u7D7C\u7D8C\u7D94\u7D84\u7D7D\u7D92\u7F6D\u7F6B\u7F67\u7F68\u7F6C\u7FA6\u7FA5\u7FA7\u7FDB\u7FDC\u8021\u8164\u8160\u8177\u815C\u8169\u815B\u8162\u8172\u6721\u815E\u8176\u8167\u816F"],
      ["dfa1", "\u8144\u8161\u821D\u8249\u8244\u8240\u8242\u8245\u84F1\u843F\u8456\u8476\u8479\u848F\u848D\u8465\u8451\u8440\u8486\u8467\u8430\u844D\u847D\u845A\u8459\u8474\u8473\u845D\u8507\u845E\u8437\u843A\u8434\u847A\u8443\u8478\u8432\u8445\u8429\u83D9\u844B\u842F\u8442\u842D\u845F\u8470\u8439\u844E\u844C\u8452\u846F\u84C5\u848E\u843B\u8447\u8436\u8433\u8468\u847E\u8444\u842B\u8460\u8454\u846E\u8450\u870B\u8704\u86F7\u870C\u86FA\u86D6\u86F5\u874D\u86F8\u870E\u8709\u8701\u86F6\u870D\u8705\u88D6\u88CB\u88CD\u88CE\u88DE\u88DB\u88DA\u88CC\u88D0\u8985\u899B\u89DF\u89E5\u89E4"],
      ["e040", "\u89E1\u89E0\u89E2\u89DC\u89E6\u8A76\u8A86\u8A7F\u8A61\u8A3F\u8A77\u8A82\u8A84\u8A75\u8A83\u8A81\u8A74\u8A7A\u8C3C\u8C4B\u8C4A\u8C65\u8C64\u8C66\u8C86\u8C84\u8C85\u8CCC\u8D68\u8D69\u8D91\u8D8C\u8D8E\u8D8F\u8D8D\u8D93\u8D94\u8D90\u8D92\u8DF0\u8DE0\u8DEC\u8DF1\u8DEE\u8DD0\u8DE9\u8DE3\u8DE2\u8DE7\u8DF2\u8DEB\u8DF4\u8F06\u8EFF\u8F01\u8F00\u8F05\u8F07\u8F08\u8F02\u8F0B\u9052\u903F"],
      ["e0a1", "\u9044\u9049\u903D\u9110\u910D\u910F\u9111\u9116\u9114\u910B\u910E\u916E\u916F\u9248\u9252\u9230\u923A\u9266\u9233\u9265\u925E\u9283\u922E\u924A\u9246\u926D\u926C\u924F\u9260\u9267\u926F\u9236\u9261\u9270\u9231\u9254\u9263\u9250\u9272\u924E\u9253\u924C\u9256\u9232\u959F\u959C\u959E\u959B\u9692\u9693\u9691\u9697\u96CE\u96FA\u96FD\u96F8\u96F5\u9773\u9777\u9778\u9772\u980F\u980D\u980E\u98AC\u98F6\u98F9\u99AF\u99B2\u99B0\u99B5\u9AAD\u9AAB\u9B5B\u9CEA\u9CED\u9CE7\u9E80\u9EFD\u50E6\u50D4\u50D7\u50E8\u50F3\u50DB\u50EA\u50DD\u50E4\u50D3\u50EC\u50F0\u50EF\u50E3\u50E0"],
      ["e140", "\u51D8\u5280\u5281\u52E9\u52EB\u5330\u53AC\u5627\u5615\u560C\u5612\u55FC\u560F\u561C\u5601\u5613\u5602\u55FA\u561D\u5604\u55FF\u55F9\u5889\u587C\u5890\u5898\u5886\u5881\u587F\u5874\u588B\u587A\u5887\u5891\u588E\u5876\u5882\u5888\u587B\u5894\u588F\u58FE\u596B\u5ADC\u5AEE\u5AE5\u5AD5\u5AEA\u5ADA\u5AED\u5AEB\u5AF3\u5AE2\u5AE0\u5ADB\u5AEC\u5ADE\u5ADD\u5AD9\u5AE8\u5ADF\u5B77\u5BE0"],
      ["e1a1", "\u5BE3\u5C63\u5D82\u5D80\u5D7D\u5D86\u5D7A\u5D81\u5D77\u5D8A\u5D89\u5D88\u5D7E\u5D7C\u5D8D\u5D79\u5D7F\u5E58\u5E59\u5E53\u5ED8\u5ED1\u5ED7\u5ECE\u5EDC\u5ED5\u5ED9\u5ED2\u5ED4\u5F44\u5F43\u5F6F\u5FB6\u612C\u6128\u6141\u615E\u6171\u6173\u6152\u6153\u6172\u616C\u6180\u6174\u6154\u617A\u615B\u6165\u613B\u616A\u6161\u6156\u6229\u6227\u622B\u642B\u644D\u645B\u645D\u6474\u6476\u6472\u6473\u647D\u6475\u6466\u64A6\u644E\u6482\u645E\u645C\u644B\u6453\u6460\u6450\u647F\u643F\u646C\u646B\u6459\u6465\u6477\u6573\u65A0\u66A1\u66A0\u669F\u6705\u6704\u6722\u69B1\u69B6\u69C9"],
      ["e240", "\u69A0\u69CE\u6996\u69B0\u69AC\u69BC\u6991\u6999\u698E\u69A7\u698D\u69A9\u69BE\u69AF\u69BF\u69C4\u69BD\u69A4\u69D4\u69B9\u69CA\u699A\u69CF\u69B3\u6993\u69AA\u69A1\u699E\u69D9\u6997\u6990\u69C2\u69B5\u69A5\u69C6\u6B4A\u6B4D\u6B4B\u6B9E\u6B9F\u6BA0\u6BC3\u6BC4\u6BFE\u6ECE\u6EF5\u6EF1\u6F03\u6F25\u6EF8\u6F37\u6EFB\u6F2E\u6F09\u6F4E\u6F19\u6F1A\u6F27\u6F18\u6F3B\u6F12\u6EED\u6F0A"],
      ["e2a1", "\u6F36\u6F73\u6EF9\u6EEE\u6F2D\u6F40\u6F30\u6F3C\u6F35\u6EEB\u6F07\u6F0E\u6F43\u6F05\u6EFD\u6EF6\u6F39\u6F1C\u6EFC\u6F3A\u6F1F\u6F0D\u6F1E\u6F08\u6F21\u7187\u7190\u7189\u7180\u7185\u7182\u718F\u717B\u7186\u7181\u7197\u7244\u7253\u7297\u7295\u7293\u7343\u734D\u7351\u734C\u7462\u7473\u7471\u7475\u7472\u7467\u746E\u7500\u7502\u7503\u757D\u7590\u7616\u7608\u760C\u7615\u7611\u760A\u7614\u76B8\u7781\u777C\u7785\u7782\u776E\u7780\u776F\u777E\u7783\u78B2\u78AA\u78B4\u78AD\u78A8\u787E\u78AB\u789E\u78A5\u78A0\u78AC\u78A2\u78A4\u7998\u798A\u798B\u7996\u7995\u7994\u7993"],
      ["e340", "\u7997\u7988\u7992\u7990\u7A2B\u7A4A\u7A30\u7A2F\u7A28\u7A26\u7AA8\u7AAB\u7AAC\u7AEE\u7B88\u7B9C\u7B8A\u7B91\u7B90\u7B96\u7B8D\u7B8C\u7B9B\u7B8E\u7B85\u7B98\u5284\u7B99\u7BA4\u7B82\u7CBB\u7CBF\u7CBC\u7CBA\u7DA7\u7DB7\u7DC2\u7DA3\u7DAA\u7DC1\u7DC0\u7DC5\u7D9D\u7DCE\u7DC4\u7DC6\u7DCB\u7DCC\u7DAF\u7DB9\u7D96\u7DBC\u7D9F\u7DA6\u7DAE\u7DA9\u7DA1\u7DC9\u7F73\u7FE2\u7FE3\u7FE5\u7FDE"],
      ["e3a1", "\u8024\u805D\u805C\u8189\u8186\u8183\u8187\u818D\u818C\u818B\u8215\u8497\u84A4\u84A1\u849F\u84BA\u84CE\u84C2\u84AC\u84AE\u84AB\u84B9\u84B4\u84C1\u84CD\u84AA\u849A\u84B1\u84D0\u849D\u84A7\u84BB\u84A2\u8494\u84C7\u84CC\u849B\u84A9\u84AF\u84A8\u84D6\u8498\u84B6\u84CF\u84A0\u84D7\u84D4\u84D2\u84DB\u84B0\u8491\u8661\u8733\u8723\u8728\u876B\u8740\u872E\u871E\u8721\u8719\u871B\u8743\u872C\u8741\u873E\u8746\u8720\u8732\u872A\u872D\u873C\u8712\u873A\u8731\u8735\u8742\u8726\u8727\u8738\u8724\u871A\u8730\u8711\u88F7\u88E7\u88F1\u88F2\u88FA\u88FE\u88EE\u88FC\u88F6\u88FB"],
      ["e440", "\u88F0\u88EC\u88EB\u899D\u89A1\u899F\u899E\u89E9\u89EB\u89E8\u8AAB\u8A99\u8A8B\u8A92\u8A8F\u8A96\u8C3D\u8C68\u8C69\u8CD5\u8CCF\u8CD7\u8D96\u8E09\u8E02\u8DFF\u8E0D\u8DFD\u8E0A\u8E03\u8E07\u8E06\u8E05\u8DFE\u8E00\u8E04\u8F10\u8F11\u8F0E\u8F0D\u9123\u911C\u9120\u9122\u911F\u911D\u911A\u9124\u9121\u911B\u917A\u9172\u9179\u9173\u92A5\u92A4\u9276\u929B\u927A\u92A0\u9294\u92AA\u928D"],
      ["e4a1", "\u92A6\u929A\u92AB\u9279\u9297\u927F\u92A3\u92EE\u928E\u9282\u9295\u92A2\u927D\u9288\u92A1\u928A\u9286\u928C\u9299\u92A7\u927E\u9287\u92A9\u929D\u928B\u922D\u969E\u96A1\u96FF\u9758\u977D\u977A\u977E\u9783\u9780\u9782\u977B\u9784\u9781\u977F\u97CE\u97CD\u9816\u98AD\u98AE\u9902\u9900\u9907\u999D\u999C\u99C3\u99B9\u99BB\u99BA\u99C2\u99BD\u99C7\u9AB1\u9AE3\u9AE7\u9B3E\u9B3F\u9B60\u9B61\u9B5F\u9CF1\u9CF2\u9CF5\u9EA7\u50FF\u5103\u5130\u50F8\u5106\u5107\u50F6\u50FE\u510B\u510C\u50FD\u510A\u528B\u528C\u52F1\u52EF\u5648\u5642\u564C\u5635\u5641\u564A\u5649\u5646\u5658"],
      ["e540", "\u565A\u5640\u5633\u563D\u562C\u563E\u5638\u562A\u563A\u571A\u58AB\u589D\u58B1\u58A0\u58A3\u58AF\u58AC\u58A5\u58A1\u58FF\u5AFF\u5AF4\u5AFD\u5AF7\u5AF6\u5B03\u5AF8\u5B02\u5AF9\u5B01\u5B07\u5B05\u5B0F\u5C67\u5D99\u5D97\u5D9F\u5D92\u5DA2\u5D93\u5D95\u5DA0\u5D9C\u5DA1\u5D9A\u5D9E\u5E69\u5E5D\u5E60\u5E5C\u7DF3\u5EDB\u5EDE\u5EE1\u5F49\u5FB2\u618B\u6183\u6179\u61B1\u61B0\u61A2\u6189"],
      ["e5a1", "\u619B\u6193\u61AF\u61AD\u619F\u6192\u61AA\u61A1\u618D\u6166\u61B3\u622D\u646E\u6470\u6496\u64A0\u6485\u6497\u649C\u648F\u648B\u648A\u648C\u64A3\u649F\u6468\u64B1\u6498\u6576\u657A\u6579\u657B\u65B2\u65B3\u66B5\u66B0\u66A9\u66B2\u66B7\u66AA\u66AF\u6A00\u6A06\u6A17\u69E5\u69F8\u6A15\u69F1\u69E4\u6A20\u69FF\u69EC\u69E2\u6A1B\u6A1D\u69FE\u6A27\u69F2\u69EE\u6A14\u69F7\u69E7\u6A40\u6A08\u69E6\u69FB\u6A0D\u69FC\u69EB\u6A09\u6A04\u6A18\u6A25\u6A0F\u69F6\u6A26\u6A07\u69F4\u6A16\u6B51\u6BA5\u6BA3\u6BA2\u6BA6\u6C01\u6C00\u6BFF\u6C02\u6F41\u6F26\u6F7E\u6F87\u6FC6\u6F92"],
      ["e640", "\u6F8D\u6F89\u6F8C\u6F62\u6F4F\u6F85\u6F5A\u6F96\u6F76\u6F6C\u6F82\u6F55\u6F72\u6F52\u6F50\u6F57\u6F94\u6F93\u6F5D\u6F00\u6F61\u6F6B\u6F7D\u6F67\u6F90\u6F53\u6F8B\u6F69\u6F7F\u6F95\u6F63\u6F77\u6F6A\u6F7B\u71B2\u71AF\u719B\u71B0\u71A0\u719A\u71A9\u71B5\u719D\u71A5\u719E\u71A4\u71A1\u71AA\u719C\u71A7\u71B3\u7298\u729A\u7358\u7352\u735E\u735F\u7360\u735D\u735B\u7361\u735A\u7359"],
      ["e6a1", "\u7362\u7487\u7489\u748A\u7486\u7481\u747D\u7485\u7488\u747C\u7479\u7508\u7507\u757E\u7625\u761E\u7619\u761D\u761C\u7623\u761A\u7628\u761B\u769C\u769D\u769E\u769B\u778D\u778F\u7789\u7788\u78CD\u78BB\u78CF\u78CC\u78D1\u78CE\u78D4\u78C8\u78C3\u78C4\u78C9\u799A\u79A1\u79A0\u799C\u79A2\u799B\u6B76\u7A39\u7AB2\u7AB4\u7AB3\u7BB7\u7BCB\u7BBE\u7BAC\u7BCE\u7BAF\u7BB9\u7BCA\u7BB5\u7CC5\u7CC8\u7CCC\u7CCB\u7DF7\u7DDB\u7DEA\u7DE7\u7DD7\u7DE1\u7E03\u7DFA\u7DE6\u7DF6\u7DF1\u7DF0\u7DEE\u7DDF\u7F76\u7FAC\u7FB0\u7FAD\u7FED\u7FEB\u7FEA\u7FEC\u7FE6\u7FE8\u8064\u8067\u81A3\u819F"],
      ["e740", "\u819E\u8195\u81A2\u8199\u8197\u8216\u824F\u8253\u8252\u8250\u824E\u8251\u8524\u853B\u850F\u8500\u8529\u850E\u8509\u850D\u851F\u850A\u8527\u851C\u84FB\u852B\u84FA\u8508\u850C\u84F4\u852A\u84F2\u8515\u84F7\u84EB\u84F3\u84FC\u8512\u84EA\u84E9\u8516\u84FE\u8528\u851D\u852E\u8502\u84FD\u851E\u84F6\u8531\u8526\u84E7\u84E8\u84F0\u84EF\u84F9\u8518\u8520\u8530\u850B\u8519\u852F\u8662"],
      ["e7a1", "\u8756\u8763\u8764\u8777\u87E1\u8773\u8758\u8754\u875B\u8752\u8761\u875A\u8751\u875E\u876D\u876A\u8750\u874E\u875F\u875D\u876F\u876C\u877A\u876E\u875C\u8765\u874F\u877B\u8775\u8762\u8767\u8769\u885A\u8905\u890C\u8914\u890B\u8917\u8918\u8919\u8906\u8916\u8911\u890E\u8909\u89A2\u89A4\u89A3\u89ED\u89F0\u89EC\u8ACF\u8AC6\u8AB8\u8AD3\u8AD1\u8AD4\u8AD5\u8ABB\u8AD7\u8ABE\u8AC0\u8AC5\u8AD8\u8AC3\u8ABA\u8ABD\u8AD9\u8C3E\u8C4D\u8C8F\u8CE5\u8CDF\u8CD9\u8CE8\u8CDA\u8CDD\u8CE7\u8DA0\u8D9C\u8DA1\u8D9B\u8E20\u8E23\u8E25\u8E24\u8E2E\u8E15\u8E1B\u8E16\u8E11\u8E19\u8E26\u8E27"],
      ["e840", "\u8E14\u8E12\u8E18\u8E13\u8E1C\u8E17\u8E1A\u8F2C\u8F24\u8F18\u8F1A\u8F20\u8F23\u8F16\u8F17\u9073\u9070\u906F\u9067\u906B\u912F\u912B\u9129\u912A\u9132\u9126\u912E\u9185\u9186\u918A\u9181\u9182\u9184\u9180\u92D0\u92C3\u92C4\u92C0\u92D9\u92B6\u92CF\u92F1\u92DF\u92D8\u92E9\u92D7\u92DD\u92CC\u92EF\u92C2\u92E8\u92CA\u92C8\u92CE\u92E6\u92CD\u92D5\u92C9\u92E0\u92DE\u92E7\u92D1\u92D3"],
      ["e8a1", "\u92B5\u92E1\u92C6\u92B4\u957C\u95AC\u95AB\u95AE\u95B0\u96A4\u96A2\u96D3\u9705\u9708\u9702\u975A\u978A\u978E\u9788\u97D0\u97CF\u981E\u981D\u9826\u9829\u9828\u9820\u981B\u9827\u98B2\u9908\u98FA\u9911\u9914\u9916\u9917\u9915\u99DC\u99CD\u99CF\u99D3\u99D4\u99CE\u99C9\u99D6\u99D8\u99CB\u99D7\u99CC\u9AB3\u9AEC\u9AEB\u9AF3\u9AF2\u9AF1\u9B46\u9B43\u9B67\u9B74\u9B71\u9B66\u9B76\u9B75\u9B70\u9B68\u9B64\u9B6C\u9CFC\u9CFA\u9CFD\u9CFF\u9CF7\u9D07\u9D00\u9CF9\u9CFB\u9D08\u9D05\u9D04\u9E83\u9ED3\u9F0F\u9F10\u511C\u5113\u5117\u511A\u5111\u51DE\u5334\u53E1\u5670\u5660\u566E"],
      ["e940", "\u5673\u5666\u5663\u566D\u5672\u565E\u5677\u571C\u571B\u58C8\u58BD\u58C9\u58BF\u58BA\u58C2\u58BC\u58C6\u5B17\u5B19\u5B1B\u5B21\u5B14\u5B13\u5B10\u5B16\u5B28\u5B1A\u5B20\u5B1E\u5BEF\u5DAC\u5DB1\u5DA9\u5DA7\u5DB5\u5DB0\u5DAE\u5DAA\u5DA8\u5DB2\u5DAD\u5DAF\u5DB4\u5E67\u5E68\u5E66\u5E6F\u5EE9\u5EE7\u5EE6\u5EE8\u5EE5\u5F4B\u5FBC\u619D\u61A8\u6196\u61C5\u61B4\u61C6\u61C1\u61CC\u61BA"],
      ["e9a1", "\u61BF\u61B8\u618C\u64D7\u64D6\u64D0\u64CF\u64C9\u64BD\u6489\u64C3\u64DB\u64F3\u64D9\u6533\u657F\u657C\u65A2\u66C8\u66BE\u66C0\u66CA\u66CB\u66CF\u66BD\u66BB\u66BA\u66CC\u6723\u6A34\u6A66\u6A49\u6A67\u6A32\u6A68\u6A3E\u6A5D\u6A6D\u6A76\u6A5B\u6A51\u6A28\u6A5A\u6A3B\u6A3F\u6A41\u6A6A\u6A64\u6A50\u6A4F\u6A54\u6A6F\u6A69\u6A60\u6A3C\u6A5E\u6A56\u6A55\u6A4D\u6A4E\u6A46\u6B55\u6B54\u6B56\u6BA7\u6BAA\u6BAB\u6BC8\u6BC7\u6C04\u6C03\u6C06\u6FAD\u6FCB\u6FA3\u6FC7\u6FBC\u6FCE\u6FC8\u6F5E\u6FC4\u6FBD\u6F9E\u6FCA\u6FA8\u7004\u6FA5\u6FAE\u6FBA\u6FAC\u6FAA\u6FCF\u6FBF\u6FB8"],
      ["ea40", "\u6FA2\u6FC9\u6FAB\u6FCD\u6FAF\u6FB2\u6FB0\u71C5\u71C2\u71BF\u71B8\u71D6\u71C0\u71C1\u71CB\u71D4\u71CA\u71C7\u71CF\u71BD\u71D8\u71BC\u71C6\u71DA\u71DB\u729D\u729E\u7369\u7366\u7367\u736C\u7365\u736B\u736A\u747F\u749A\u74A0\u7494\u7492\u7495\u74A1\u750B\u7580\u762F\u762D\u7631\u763D\u7633\u763C\u7635\u7632\u7630\u76BB\u76E6\u779A\u779D\u77A1\u779C\u779B\u77A2\u77A3\u7795\u7799"],
      ["eaa1", "\u7797\u78DD\u78E9\u78E5\u78EA\u78DE\u78E3\u78DB\u78E1\u78E2\u78ED\u78DF\u78E0\u79A4\u7A44\u7A48\u7A47\u7AB6\u7AB8\u7AB5\u7AB1\u7AB7\u7BDE\u7BE3\u7BE7\u7BDD\u7BD5\u7BE5\u7BDA\u7BE8\u7BF9\u7BD4\u7BEA\u7BE2\u7BDC\u7BEB\u7BD8\u7BDF\u7CD2\u7CD4\u7CD7\u7CD0\u7CD1\u7E12\u7E21\u7E17\u7E0C\u7E1F\u7E20\u7E13\u7E0E\u7E1C\u7E15\u7E1A\u7E22\u7E0B\u7E0F\u7E16\u7E0D\u7E14\u7E25\u7E24\u7F43\u7F7B\u7F7C\u7F7A\u7FB1\u7FEF\u802A\u8029\u806C\u81B1\u81A6\u81AE\u81B9\u81B5\u81AB\u81B0\u81AC\u81B4\u81B2\u81B7\u81A7\u81F2\u8255\u8256\u8257\u8556\u8545\u856B\u854D\u8553\u8561\u8558"],
      ["eb40", "\u8540\u8546\u8564\u8541\u8562\u8544\u8551\u8547\u8563\u853E\u855B\u8571\u854E\u856E\u8575\u8555\u8567\u8560\u858C\u8566\u855D\u8554\u8565\u856C\u8663\u8665\u8664\u879B\u878F\u8797\u8793\u8792\u8788\u8781\u8796\u8798\u8779\u8787\u87A3\u8785\u8790\u8791\u879D\u8784\u8794\u879C\u879A\u8789\u891E\u8926\u8930\u892D\u892E\u8927\u8931\u8922\u8929\u8923\u892F\u892C\u891F\u89F1\u8AE0"],
      ["eba1", "\u8AE2\u8AF2\u8AF4\u8AF5\u8ADD\u8B14\u8AE4\u8ADF\u8AF0\u8AC8\u8ADE\u8AE1\u8AE8\u8AFF\u8AEF\u8AFB\u8C91\u8C92\u8C90\u8CF5\u8CEE\u8CF1\u8CF0\u8CF3\u8D6C\u8D6E\u8DA5\u8DA7\u8E33\u8E3E\u8E38\u8E40\u8E45\u8E36\u8E3C\u8E3D\u8E41\u8E30\u8E3F\u8EBD\u8F36\u8F2E\u8F35\u8F32\u8F39\u8F37\u8F34\u9076\u9079\u907B\u9086\u90FA\u9133\u9135\u9136\u9193\u9190\u9191\u918D\u918F\u9327\u931E\u9308\u931F\u9306\u930F\u937A\u9338\u933C\u931B\u9323\u9312\u9301\u9346\u932D\u930E\u930D\u92CB\u931D\u92FA\u9325\u9313\u92F9\u92F7\u9334\u9302\u9324\u92FF\u9329\u9339\u9335\u932A\u9314\u930C"],
      ["ec40", "\u930B\u92FE\u9309\u9300\u92FB\u9316\u95BC\u95CD\u95BE\u95B9\u95BA\u95B6\u95BF\u95B5\u95BD\u96A9\u96D4\u970B\u9712\u9710\u9799\u9797\u9794\u97F0\u97F8\u9835\u982F\u9832\u9924\u991F\u9927\u9929\u999E\u99EE\u99EC\u99E5\u99E4\u99F0\u99E3\u99EA\u99E9\u99E7\u9AB9\u9ABF\u9AB4\u9ABB\u9AF6\u9AFA\u9AF9\u9AF7\u9B33\u9B80\u9B85\u9B87\u9B7C\u9B7E\u9B7B\u9B82\u9B93\u9B92\u9B90\u9B7A\u9B95"],
      ["eca1", "\u9B7D\u9B88\u9D25\u9D17\u9D20\u9D1E\u9D14\u9D29\u9D1D\u9D18\u9D22\u9D10\u9D19\u9D1F\u9E88\u9E86\u9E87\u9EAE\u9EAD\u9ED5\u9ED6\u9EFA\u9F12\u9F3D\u5126\u5125\u5122\u5124\u5120\u5129\u52F4\u5693\u568C\u568D\u5686\u5684\u5683\u567E\u5682\u567F\u5681\u58D6\u58D4\u58CF\u58D2\u5B2D\u5B25\u5B32\u5B23\u5B2C\u5B27\u5B26\u5B2F\u5B2E\u5B7B\u5BF1\u5BF2\u5DB7\u5E6C\u5E6A\u5FBE\u5FBB\u61C3\u61B5\u61BC\u61E7\u61E0\u61E5\u61E4\u61E8\u61DE\u64EF\u64E9\u64E3\u64EB\u64E4\u64E8\u6581\u6580\u65B6\u65DA\u66D2\u6A8D\u6A96\u6A81\u6AA5\u6A89\u6A9F\u6A9B\u6AA1\u6A9E\u6A87\u6A93\u6A8E"],
      ["ed40", "\u6A95\u6A83\u6AA8\u6AA4\u6A91\u6A7F\u6AA6\u6A9A\u6A85\u6A8C\u6A92\u6B5B\u6BAD\u6C09\u6FCC\u6FA9\u6FF4\u6FD4\u6FE3\u6FDC\u6FED\u6FE7\u6FE6\u6FDE\u6FF2\u6FDD\u6FE2\u6FE8\u71E1\u71F1\u71E8\u71F2\u71E4\u71F0\u71E2\u7373\u736E\u736F\u7497\u74B2\u74AB\u7490\u74AA\u74AD\u74B1\u74A5\u74AF\u7510\u7511\u7512\u750F\u7584\u7643\u7648\u7649\u7647\u76A4\u76E9\u77B5\u77AB\u77B2\u77B7\u77B6"],
      ["eda1", "\u77B4\u77B1\u77A8\u77F0\u78F3\u78FD\u7902\u78FB\u78FC\u78F2\u7905\u78F9\u78FE\u7904\u79AB\u79A8\u7A5C\u7A5B\u7A56\u7A58\u7A54\u7A5A\u7ABE\u7AC0\u7AC1\u7C05\u7C0F\u7BF2\u7C00\u7BFF\u7BFB\u7C0E\u7BF4\u7C0B\u7BF3\u7C02\u7C09\u7C03\u7C01\u7BF8\u7BFD\u7C06\u7BF0\u7BF1\u7C10\u7C0A\u7CE8\u7E2D\u7E3C\u7E42\u7E33\u9848\u7E38\u7E2A\u7E49\u7E40\u7E47\u7E29\u7E4C\u7E30\u7E3B\u7E36\u7E44\u7E3A\u7F45\u7F7F\u7F7E\u7F7D\u7FF4\u7FF2\u802C\u81BB\u81C4\u81CC\u81CA\u81C5\u81C7\u81BC\u81E9\u825B\u825A\u825C\u8583\u8580\u858F\u85A7\u8595\u85A0\u858B\u85A3\u857B\u85A4\u859A\u859E"],
      ["ee40", "\u8577\u857C\u8589\u85A1\u857A\u8578\u8557\u858E\u8596\u8586\u858D\u8599\u859D\u8581\u85A2\u8582\u8588\u8585\u8579\u8576\u8598\u8590\u859F\u8668\u87BE\u87AA\u87AD\u87C5\u87B0\u87AC\u87B9\u87B5\u87BC\u87AE\u87C9\u87C3\u87C2\u87CC\u87B7\u87AF\u87C4\u87CA\u87B4\u87B6\u87BF\u87B8\u87BD\u87DE\u87B2\u8935\u8933\u893C\u893E\u8941\u8952\u8937\u8942\u89AD\u89AF\u89AE\u89F2\u89F3\u8B1E"],
      ["eea1", "\u8B18\u8B16\u8B11\u8B05\u8B0B\u8B22\u8B0F\u8B12\u8B15\u8B07\u8B0D\u8B08\u8B06\u8B1C\u8B13\u8B1A\u8C4F\u8C70\u8C72\u8C71\u8C6F\u8C95\u8C94\u8CF9\u8D6F\u8E4E\u8E4D\u8E53\u8E50\u8E4C\u8E47\u8F43\u8F40\u9085\u907E\u9138\u919A\u91A2\u919B\u9199\u919F\u91A1\u919D\u91A0\u93A1\u9383\u93AF\u9364\u9356\u9347\u937C\u9358\u935C\u9376\u9349\u9350\u9351\u9360\u936D\u938F\u934C\u936A\u9379\u9357\u9355\u9352\u934F\u9371\u9377\u937B\u9361\u935E\u9363\u9367\u9380\u934E\u9359\u95C7\u95C0\u95C9\u95C3\u95C5\u95B7\u96AE\u96B0\u96AC\u9720\u971F\u9718\u971D\u9719\u979A\u97A1\u979C"],
      ["ef40", "\u979E\u979D\u97D5\u97D4\u97F1\u9841\u9844\u984A\u9849\u9845\u9843\u9925\u992B\u992C\u992A\u9933\u9932\u992F\u992D\u9931\u9930\u9998\u99A3\u99A1\u9A02\u99FA\u99F4\u99F7\u99F9\u99F8\u99F6\u99FB\u99FD\u99FE\u99FC\u9A03\u9ABE\u9AFE\u9AFD\u9B01\u9AFC\u9B48\u9B9A\u9BA8\u9B9E\u9B9B\u9BA6\u9BA1\u9BA5\u9BA4\u9B86\u9BA2\u9BA0\u9BAF\u9D33\u9D41\u9D67\u9D36\u9D2E\u9D2F\u9D31\u9D38\u9D30"],
      ["efa1", "\u9D45\u9D42\u9D43\u9D3E\u9D37\u9D40\u9D3D\u7FF5\u9D2D\u9E8A\u9E89\u9E8D\u9EB0\u9EC8\u9EDA\u9EFB\u9EFF\u9F24\u9F23\u9F22\u9F54\u9FA0\u5131\u512D\u512E\u5698\u569C\u5697\u569A\u569D\u5699\u5970\u5B3C\u5C69\u5C6A\u5DC0\u5E6D\u5E6E\u61D8\u61DF\u61ED\u61EE\u61F1\u61EA\u61F0\u61EB\u61D6\u61E9\u64FF\u6504\u64FD\u64F8\u6501\u6503\u64FC\u6594\u65DB\u66DA\u66DB\u66D8\u6AC5\u6AB9\u6ABD\u6AE1\u6AC6\u6ABA\u6AB6\u6AB7\u6AC7\u6AB4\u6AAD\u6B5E\u6BC9\u6C0B\u7007\u700C\u700D\u7001\u7005\u7014\u700E\u6FFF\u7000\u6FFB\u7026\u6FFC\u6FF7\u700A\u7201\u71FF\u71F9\u7203\u71FD\u7376"],
      ["f040", "\u74B8\u74C0\u74B5\u74C1\u74BE\u74B6\u74BB\u74C2\u7514\u7513\u765C\u7664\u7659\u7650\u7653\u7657\u765A\u76A6\u76BD\u76EC\u77C2\u77BA\u78FF\u790C\u7913\u7914\u7909\u7910\u7912\u7911\u79AD\u79AC\u7A5F\u7C1C\u7C29\u7C19\u7C20\u7C1F\u7C2D\u7C1D\u7C26\u7C28\u7C22\u7C25\u7C30\u7E5C\u7E50\u7E56\u7E63\u7E58\u7E62\u7E5F\u7E51\u7E60\u7E57\u7E53\u7FB5\u7FB3\u7FF7\u7FF8\u8075\u81D1\u81D2"],
      ["f0a1", "\u81D0\u825F\u825E\u85B4\u85C6\u85C0\u85C3\u85C2\u85B3\u85B5\u85BD\u85C7\u85C4\u85BF\u85CB\u85CE\u85C8\u85C5\u85B1\u85B6\u85D2\u8624\u85B8\u85B7\u85BE\u8669\u87E7\u87E6\u87E2\u87DB\u87EB\u87EA\u87E5\u87DF\u87F3\u87E4\u87D4\u87DC\u87D3\u87ED\u87D8\u87E3\u87A4\u87D7\u87D9\u8801\u87F4\u87E8\u87DD\u8953\u894B\u894F\u894C\u8946\u8950\u8951\u8949\u8B2A\u8B27\u8B23\u8B33\u8B30\u8B35\u8B47\u8B2F\u8B3C\u8B3E\u8B31\u8B25\u8B37\u8B26\u8B36\u8B2E\u8B24\u8B3B\u8B3D\u8B3A\u8C42\u8C75\u8C99\u8C98\u8C97\u8CFE\u8D04\u8D02\u8D00\u8E5C\u8E62\u8E60\u8E57\u8E56\u8E5E\u8E65\u8E67"],
      ["f140", "\u8E5B\u8E5A\u8E61\u8E5D\u8E69\u8E54\u8F46\u8F47\u8F48\u8F4B\u9128\u913A\u913B\u913E\u91A8\u91A5\u91A7\u91AF\u91AA\u93B5\u938C\u9392\u93B7\u939B\u939D\u9389\u93A7\u938E\u93AA\u939E\u93A6\u9395\u9388\u9399\u939F\u938D\u93B1\u9391\u93B2\u93A4\u93A8\u93B4\u93A3\u93A5\u95D2\u95D3\u95D1\u96B3\u96D7\u96DA\u5DC2\u96DF\u96D8\u96DD\u9723\u9722\u9725\u97AC\u97AE\u97A8\u97AB\u97A4\u97AA"],
      ["f1a1", "\u97A2\u97A5\u97D7\u97D9\u97D6\u97D8\u97FA\u9850\u9851\u9852\u98B8\u9941\u993C\u993A\u9A0F\u9A0B\u9A09\u9A0D\u9A04\u9A11\u9A0A\u9A05\u9A07\u9A06\u9AC0\u9ADC\u9B08\u9B04\u9B05\u9B29\u9B35\u9B4A\u9B4C\u9B4B\u9BC7\u9BC6\u9BC3\u9BBF\u9BC1\u9BB5\u9BB8\u9BD3\u9BB6\u9BC4\u9BB9\u9BBD\u9D5C\u9D53\u9D4F\u9D4A\u9D5B\u9D4B\u9D59\u9D56\u9D4C\u9D57\u9D52\u9D54\u9D5F\u9D58\u9D5A\u9E8E\u9E8C\u9EDF\u9F01\u9F00\u9F16\u9F25\u9F2B\u9F2A\u9F29\u9F28\u9F4C\u9F55\u5134\u5135\u5296\u52F7\u53B4\u56AB\u56AD\u56A6\u56A7\u56AA\u56AC\u58DA\u58DD\u58DB\u5912\u5B3D\u5B3E\u5B3F\u5DC3\u5E70"],
      ["f240", "\u5FBF\u61FB\u6507\u6510\u650D\u6509\u650C\u650E\u6584\u65DE\u65DD\u66DE\u6AE7\u6AE0\u6ACC\u6AD1\u6AD9\u6ACB\u6ADF\u6ADC\u6AD0\u6AEB\u6ACF\u6ACD\u6ADE\u6B60\u6BB0\u6C0C\u7019\u7027\u7020\u7016\u702B\u7021\u7022\u7023\u7029\u7017\u7024\u701C\u702A\u720C\u720A\u7207\u7202\u7205\u72A5\u72A6\u72A4\u72A3\u72A1\u74CB\u74C5\u74B7\u74C3\u7516\u7660\u77C9\u77CA\u77C4\u77F1\u791D\u791B"],
      ["f2a1", "\u7921\u791C\u7917\u791E\u79B0\u7A67\u7A68\u7C33\u7C3C\u7C39\u7C2C\u7C3B\u7CEC\u7CEA\u7E76\u7E75\u7E78\u7E70\u7E77\u7E6F\u7E7A\u7E72\u7E74\u7E68\u7F4B\u7F4A\u7F83\u7F86\u7FB7\u7FFD\u7FFE\u8078\u81D7\u81D5\u8264\u8261\u8263\u85EB\u85F1\u85ED\u85D9\u85E1\u85E8\u85DA\u85D7\u85EC\u85F2\u85F8\u85D8\u85DF\u85E3\u85DC\u85D1\u85F0\u85E6\u85EF\u85DE\u85E2\u8800\u87FA\u8803\u87F6\u87F7\u8809\u880C\u880B\u8806\u87FC\u8808\u87FF\u880A\u8802\u8962\u895A\u895B\u8957\u8961\u895C\u8958\u895D\u8959\u8988\u89B7\u89B6\u89F6\u8B50\u8B48\u8B4A\u8B40\u8B53\u8B56\u8B54\u8B4B\u8B55"],
      ["f340", "\u8B51\u8B42\u8B52\u8B57\u8C43\u8C77\u8C76\u8C9A\u8D06\u8D07\u8D09\u8DAC\u8DAA\u8DAD\u8DAB\u8E6D\u8E78\u8E73\u8E6A\u8E6F\u8E7B\u8EC2\u8F52\u8F51\u8F4F\u8F50\u8F53\u8FB4\u9140\u913F\u91B0\u91AD\u93DE\u93C7\u93CF\u93C2\u93DA\u93D0\u93F9\u93EC\u93CC\u93D9\u93A9\u93E6\u93CA\u93D4\u93EE\u93E3\u93D5\u93C4\u93CE\u93C0\u93D2\u93E7\u957D\u95DA\u95DB\u96E1\u9729\u972B\u972C\u9728\u9726"],
      ["f3a1", "\u97B3\u97B7\u97B6\u97DD\u97DE\u97DF\u985C\u9859\u985D\u9857\u98BF\u98BD\u98BB\u98BE\u9948\u9947\u9943\u99A6\u99A7\u9A1A\u9A15\u9A25\u9A1D\u9A24\u9A1B\u9A22\u9A20\u9A27\u9A23\u9A1E\u9A1C\u9A14\u9AC2\u9B0B\u9B0A\u9B0E\u9B0C\u9B37\u9BEA\u9BEB\u9BE0\u9BDE\u9BE4\u9BE6\u9BE2\u9BF0\u9BD4\u9BD7\u9BEC\u9BDC\u9BD9\u9BE5\u9BD5\u9BE1\u9BDA\u9D77\u9D81\u9D8A\u9D84\u9D88\u9D71\u9D80\u9D78\u9D86\u9D8B\u9D8C\u9D7D\u9D6B\u9D74\u9D75\u9D70\u9D69\u9D85\u9D73\u9D7B\u9D82\u9D6F\u9D79\u9D7F\u9D87\u9D68\u9E94\u9E91\u9EC0\u9EFC\u9F2D\u9F40\u9F41\u9F4D\u9F56\u9F57\u9F58\u5337\u56B2"],
      ["f440", "\u56B5\u56B3\u58E3\u5B45\u5DC6\u5DC7\u5EEE\u5EEF\u5FC0\u5FC1\u61F9\u6517\u6516\u6515\u6513\u65DF\u66E8\u66E3\u66E4\u6AF3\u6AF0\u6AEA\u6AE8\u6AF9\u6AF1\u6AEE\u6AEF\u703C\u7035\u702F\u7037\u7034\u7031\u7042\u7038\u703F\u703A\u7039\u7040\u703B\u7033\u7041\u7213\u7214\u72A8\u737D\u737C\u74BA\u76AB\u76AA\u76BE\u76ED\u77CC\u77CE\u77CF\u77CD\u77F2\u7925\u7923\u7927\u7928\u7924\u7929"],
      ["f4a1", "\u79B2\u7A6E\u7A6C\u7A6D\u7AF7\u7C49\u7C48\u7C4A\u7C47\u7C45\u7CEE\u7E7B\u7E7E\u7E81\u7E80\u7FBA\u7FFF\u8079\u81DB\u81D9\u820B\u8268\u8269\u8622\u85FF\u8601\u85FE\u861B\u8600\u85F6\u8604\u8609\u8605\u860C\u85FD\u8819\u8810\u8811\u8817\u8813\u8816\u8963\u8966\u89B9\u89F7\u8B60\u8B6A\u8B5D\u8B68\u8B63\u8B65\u8B67\u8B6D\u8DAE\u8E86\u8E88\u8E84\u8F59\u8F56\u8F57\u8F55\u8F58\u8F5A\u908D\u9143\u9141\u91B7\u91B5\u91B2\u91B3\u940B\u9413\u93FB\u9420\u940F\u9414\u93FE\u9415\u9410\u9428\u9419\u940D\u93F5\u9400\u93F7\u9407\u940E\u9416\u9412\u93FA\u9409\u93F8\u940A\u93FF"],
      ["f540", "\u93FC\u940C\u93F6\u9411\u9406\u95DE\u95E0\u95DF\u972E\u972F\u97B9\u97BB\u97FD\u97FE\u9860\u9862\u9863\u985F\u98C1\u98C2\u9950\u994E\u9959\u994C\u994B\u9953\u9A32\u9A34\u9A31\u9A2C\u9A2A\u9A36\u9A29\u9A2E\u9A38\u9A2D\u9AC7\u9ACA\u9AC6\u9B10\u9B12\u9B11\u9C0B\u9C08\u9BF7\u9C05\u9C12\u9BF8\u9C40\u9C07\u9C0E\u9C06\u9C17\u9C14\u9C09\u9D9F\u9D99\u9DA4\u9D9D\u9D92\u9D98\u9D90\u9D9B"],
      ["f5a1", "\u9DA0\u9D94\u9D9C\u9DAA\u9D97\u9DA1\u9D9A\u9DA2\u9DA8\u9D9E\u9DA3\u9DBF\u9DA9\u9D96\u9DA6\u9DA7\u9E99\u9E9B\u9E9A\u9EE5\u9EE4\u9EE7\u9EE6\u9F30\u9F2E\u9F5B\u9F60\u9F5E\u9F5D\u9F59\u9F91\u513A\u5139\u5298\u5297\u56C3\u56BD\u56BE\u5B48\u5B47\u5DCB\u5DCF\u5EF1\u61FD\u651B\u6B02\u6AFC\u6B03\u6AF8\u6B00\u7043\u7044\u704A\u7048\u7049\u7045\u7046\u721D\u721A\u7219\u737E\u7517\u766A\u77D0\u792D\u7931\u792F\u7C54\u7C53\u7CF2\u7E8A\u7E87\u7E88\u7E8B\u7E86\u7E8D\u7F4D\u7FBB\u8030\u81DD\u8618\u862A\u8626\u861F\u8623\u861C\u8619\u8627\u862E\u8621\u8620\u8629\u861E\u8625"],
      ["f640", "\u8829\u881D\u881B\u8820\u8824\u881C\u882B\u884A\u896D\u8969\u896E\u896B\u89FA\u8B79\u8B78\u8B45\u8B7A\u8B7B\u8D10\u8D14\u8DAF\u8E8E\u8E8C\u8F5E\u8F5B\u8F5D\u9146\u9144\u9145\u91B9\u943F\u943B\u9436\u9429\u943D\u943C\u9430\u9439\u942A\u9437\u942C\u9440\u9431\u95E5\u95E4\u95E3\u9735\u973A\u97BF\u97E1\u9864\u98C9\u98C6\u98C0\u9958\u9956\u9A39\u9A3D\u9A46\u9A44\u9A42\u9A41\u9A3A"],
      ["f6a1", "\u9A3F\u9ACD\u9B15\u9B17\u9B18\u9B16\u9B3A\u9B52\u9C2B\u9C1D\u9C1C\u9C2C\u9C23\u9C28\u9C29\u9C24\u9C21\u9DB7\u9DB6\u9DBC\u9DC1\u9DC7\u9DCA\u9DCF\u9DBE\u9DC5\u9DC3\u9DBB\u9DB5\u9DCE\u9DB9\u9DBA\u9DAC\u9DC8\u9DB1\u9DAD\u9DCC\u9DB3\u9DCD\u9DB2\u9E7A\u9E9C\u9EEB\u9EEE\u9EED\u9F1B\u9F18\u9F1A\u9F31\u9F4E\u9F65\u9F64\u9F92\u4EB9\u56C6\u56C5\u56CB\u5971\u5B4B\u5B4C\u5DD5\u5DD1\u5EF2\u6521\u6520\u6526\u6522\u6B0B\u6B08\u6B09\u6C0D\u7055\u7056\u7057\u7052\u721E\u721F\u72A9\u737F\u74D8\u74D5\u74D9\u74D7\u766D\u76AD\u7935\u79B4\u7A70\u7A71\u7C57\u7C5C\u7C59\u7C5B\u7C5A"],
      ["f740", "\u7CF4\u7CF1\u7E91\u7F4F\u7F87\u81DE\u826B\u8634\u8635\u8633\u862C\u8632\u8636\u882C\u8828\u8826\u882A\u8825\u8971\u89BF\u89BE\u89FB\u8B7E\u8B84\u8B82\u8B86\u8B85\u8B7F\u8D15\u8E95\u8E94\u8E9A\u8E92\u8E90\u8E96\u8E97\u8F60\u8F62\u9147\u944C\u9450\u944A\u944B\u944F\u9447\u9445\u9448\u9449\u9446\u973F\u97E3\u986A\u9869\u98CB\u9954\u995B\u9A4E\u9A53\u9A54\u9A4C\u9A4F\u9A48\u9A4A"],
      ["f7a1", "\u9A49\u9A52\u9A50\u9AD0\u9B19\u9B2B\u9B3B\u9B56\u9B55\u9C46\u9C48\u9C3F\u9C44\u9C39\u9C33\u9C41\u9C3C\u9C37\u9C34\u9C32\u9C3D\u9C36\u9DDB\u9DD2\u9DDE\u9DDA\u9DCB\u9DD0\u9DDC\u9DD1\u9DDF\u9DE9\u9DD9\u9DD8\u9DD6\u9DF5\u9DD5\u9DDD\u9EB6\u9EF0\u9F35\u9F33\u9F32\u9F42\u9F6B\u9F95\u9FA2\u513D\u5299\u58E8\u58E7\u5972\u5B4D\u5DD8\u882F\u5F4F\u6201\u6203\u6204\u6529\u6525\u6596\u66EB\u6B11\u6B12\u6B0F\u6BCA\u705B\u705A\u7222\u7382\u7381\u7383\u7670\u77D4\u7C67\u7C66\u7E95\u826C\u863A\u8640\u8639\u863C\u8631\u863B\u863E\u8830\u8832\u882E\u8833\u8976\u8974\u8973\u89FE"],
      ["f840", "\u8B8C\u8B8E\u8B8B\u8B88\u8C45\u8D19\u8E98\u8F64\u8F63\u91BC\u9462\u9455\u945D\u9457\u945E\u97C4\u97C5\u9800\u9A56\u9A59\u9B1E\u9B1F\u9B20\u9C52\u9C58\u9C50\u9C4A\u9C4D\u9C4B\u9C55\u9C59\u9C4C\u9C4E\u9DFB\u9DF7\u9DEF\u9DE3\u9DEB\u9DF8\u9DE4\u9DF6\u9DE1\u9DEE\u9DE6\u9DF2\u9DF0\u9DE2\u9DEC\u9DF4\u9DF3\u9DE8\u9DED\u9EC2\u9ED0\u9EF2\u9EF3\u9F06\u9F1C\u9F38\u9F37\u9F36\u9F43\u9F4F"],
      ["f8a1", "\u9F71\u9F70\u9F6E\u9F6F\u56D3\u56CD\u5B4E\u5C6D\u652D\u66ED\u66EE\u6B13\u705F\u7061\u705D\u7060\u7223\u74DB\u74E5\u77D5\u7938\u79B7\u79B6\u7C6A\u7E97\u7F89\u826D\u8643\u8838\u8837\u8835\u884B\u8B94\u8B95\u8E9E\u8E9F\u8EA0\u8E9D\u91BE\u91BD\u91C2\u946B\u9468\u9469\u96E5\u9746\u9743\u9747\u97C7\u97E5\u9A5E\u9AD5\u9B59\u9C63\u9C67\u9C66\u9C62\u9C5E\u9C60\u9E02\u9DFE\u9E07\u9E03\u9E06\u9E05\u9E00\u9E01\u9E09\u9DFF\u9DFD\u9E04\u9EA0\u9F1E\u9F46\u9F74\u9F75\u9F76\u56D4\u652E\u65B8\u6B18\u6B19\u6B17\u6B1A\u7062\u7226\u72AA\u77D8\u77D9\u7939\u7C69\u7C6B\u7CF6\u7E9A"],
      ["f940", "\u7E98\u7E9B\u7E99\u81E0\u81E1\u8646\u8647\u8648\u8979\u897A\u897C\u897B\u89FF\u8B98\u8B99\u8EA5\u8EA4\u8EA3\u946E\u946D\u946F\u9471\u9473\u9749\u9872\u995F\u9C68\u9C6E\u9C6D\u9E0B\u9E0D\u9E10\u9E0F\u9E12\u9E11\u9EA1\u9EF5\u9F09\u9F47\u9F78\u9F7B\u9F7A\u9F79\u571E\u7066\u7C6F\u883C\u8DB2\u8EA6\u91C3\u9474\u9478\u9476\u9475\u9A60\u9C74\u9C73\u9C71\u9C75\u9E14\u9E13\u9EF6\u9F0A"],
      ["f9a1", "\u9FA4\u7068\u7065\u7CF7\u866A\u883E\u883D\u883F\u8B9E\u8C9C\u8EA9\u8EC9\u974B\u9873\u9874\u98CC\u9961\u99AB\u9A64\u9A66\u9A67\u9B24\u9E15\u9E17\u9F48\u6207\u6B1E\u7227\u864C\u8EA8\u9482\u9480\u9481\u9A69\u9A68\u9B2E\u9E19\u7229\u864B\u8B9F\u9483\u9C79\u9EB7\u7675\u9A6B\u9C7A\u9E1D\u7069\u706A\u9EA4\u9F7E\u9F49\u9F98\u7881\u92B9\u88CF\u58BB\u6052\u7CA7\u5AFA\u2554\u2566\u2557\u2560\u256C\u2563\u255A\u2569\u255D\u2552\u2564\u2555\u255E\u256A\u2561\u2558\u2567\u255B\u2553\u2565\u2556\u255F\u256B\u2562\u2559\u2568\u255C\u2551\u2550\u256D\u256E\u2570\u256F\u2593"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS({
  "node_modules/iconv-lite/encodings/tables/big5-added.json"(exports2, module2) {
    module2.exports = [
      ["8740", "\u43F0\u4C32\u4603\u45A6\u4578\u{27267}\u4D77\u45B3\u{27CB1}\u4CE2\u{27CC5}\u3B95\u4736\u4744\u4C47\u4C40\u{242BF}\u{23617}\u{27352}\u{26E8B}\u{270D2}\u4C57\u{2A351}\u474F\u45DA\u4C85\u{27C6C}\u4D07\u4AA4\u46A1\u{26B23}\u7225\u{25A54}\u{21A63}\u{23E06}\u{23F61}\u664D\u56FB"],
      ["8767", "\u7D95\u591D\u{28BB9}\u3DF4\u9734\u{27BEF}\u5BDB\u{21D5E}\u5AA4\u3625\u{29EB0}\u5AD1\u5BB7\u5CFC\u676E\u8593\u{29945}\u7461\u749D\u3875\u{21D53}\u{2369E}\u{26021}\u3EEC"],
      ["87a1", "\u{258DE}\u3AF5\u7AFC\u9F97\u{24161}\u{2890D}\u{231EA}\u{20A8A}\u{2325E}\u430A\u8484\u9F96\u942F\u4930\u8613\u5896\u974A\u9218\u79D0\u7A32\u6660\u6A29\u889D\u744C\u7BC5\u6782\u7A2C\u524F\u9046\u34E6\u73C4\u{25DB9}\u74C6\u9FC7\u57B3\u492F\u544C\u4131\u{2368E}\u5818\u7A72\u{27B65}\u8B8F\u46AE\u{26E88}\u4181\u{25D99}\u7BAE\u{224BC}\u9FC8\u{224C1}\u{224C9}\u{224CC}\u9FC9\u8504\u{235BB}\u40B4\u9FCA\u44E1\u{2ADFF}\u62C1\u706E\u9FCB"],
      ["8840", "\u31C0", 4, "\u{2010C}\u31C5\u{200D1}\u{200CD}\u31C6\u31C7\u{200CB}\u{21FE8}\u31C8\u{200CA}\u31C9\u31CA\u31CB\u31CC\u{2010E}\u31CD\u31CE\u0100\xC1\u01CD\xC0\u0112\xC9\u011A\xC8\u014C\xD3\u01D1\xD2\u0FFF\xCA\u0304\u1EBE\u0FFF\xCA\u030C\u1EC0\xCA\u0101\xE1\u01CE\xE0\u0251\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA"],
      ["88a1", "\u01DC\xFC\u0FFF\xEA\u0304\u1EBF\u0FFF\xEA\u030C\u1EC1\xEA\u0261\u23DA\u23DB"],
      ["8940", "\u{2A3A9}\u{21145}"],
      ["8943", "\u650A"],
      ["8946", "\u4E3D\u6EDD\u9D4E\u91DF"],
      ["894c", "\u{27735}\u6491\u4F1A\u4F28\u4FA8\u5156\u5174\u519C\u51E4\u52A1\u52A8\u533B\u534E\u53D1\u53D8\u56E2\u58F0\u5904\u5907\u5932\u5934\u5B66\u5B9E\u5B9F\u5C9A\u5E86\u603B\u6589\u67FE\u6804\u6865\u6D4E\u70BC\u7535\u7EA4\u7EAC\u7EBA\u7EC7\u7ECF\u7EDF\u7F06\u7F37\u827A\u82CF\u836F\u89C6\u8BBE\u8BE2\u8F66\u8F67\u8F6E"],
      ["89a1", "\u7411\u7CFC\u7DCD\u6946\u7AC9\u5227"],
      ["89ab", "\u918C\u78B8\u915E\u80BC"],
      ["89b0", "\u8D0B\u80F6\u{209E7}"],
      ["89b5", "\u809F\u9EC7\u4CCD\u9DC9\u9E0C\u4C3E\u{29DF6}\u{2700E}\u9E0A\u{2A133}\u35C1"],
      ["89c1", "\u6E9A\u823E\u7519"],
      ["89c5", "\u4911\u9A6C\u9A8F\u9F99\u7987\u{2846C}\u{21DCA}\u{205D0}\u{22AE6}\u4E24\u4E81\u4E80\u4E87\u4EBF\u4EEB\u4F37\u344C\u4FBD\u3E48\u5003\u5088\u347D\u3493\u34A5\u5186\u5905\u51DB\u51FC\u5205\u4E89\u5279\u5290\u5327\u35C7\u53A9\u3551\u53B0\u3553\u53C2\u5423\u356D\u3572\u3681\u5493\u54A3\u54B4\u54B9\u54D0\u54EF\u5518\u5523\u5528\u3598\u553F\u35A5\u35BF\u55D7\u35C5"],
      ["8a40", "\u{27D84}\u5525"],
      ["8a43", "\u{20C42}\u{20D15}\u{2512B}\u5590\u{22CC6}\u39EC\u{20341}\u8E46\u{24DB8}\u{294E5}\u4053\u{280BE}\u777A\u{22C38}\u3A34\u47D5\u{2815D}\u{269F2}\u{24DEA}\u64DD\u{20D7C}\u{20FB4}\u{20CD5}\u{210F4}\u648D\u8E7E\u{20E96}\u{20C0B}\u{20F64}\u{22CA9}\u{28256}\u{244D3}"],
      ["8a64", "\u{20D46}\u{29A4D}\u{280E9}\u47F4\u{24EA7}\u{22CC2}\u9AB2\u3A67\u{295F4}\u3FED\u3506\u{252C7}\u{297D4}\u{278C8}\u{22D44}\u9D6E\u9815"],
      ["8a76", "\u43D9\u{260A5}\u64B4\u54E3\u{22D4C}\u{22BCA}\u{21077}\u39FB\u{2106F}"],
      ["8aa1", "\u{266DA}\u{26716}\u{279A0}\u64EA\u{25052}\u{20C43}\u8E68\u{221A1}\u{28B4C}\u{20731}"],
      ["8aac", "\u480B\u{201A9}\u3FFA\u5873\u{22D8D}"],
      ["8ab2", "\u{245C8}\u{204FC}\u{26097}\u{20F4C}\u{20D96}\u5579\u40BB\u43BA"],
      ["8abb", "\u4AB4\u{22A66}\u{2109D}\u81AA\u98F5\u{20D9C}\u6379\u39FE\u{22775}\u8DC0\u56A1\u647C\u3E43"],
      ["8ac9", "\u{2A601}\u{20E09}\u{22ACF}\u{22CC9}"],
      ["8ace", "\u{210C8}\u{239C2}\u3992\u3A06\u{2829B}\u3578\u{25E49}\u{220C7}\u5652\u{20F31}\u{22CB2}\u{29720}\u34BC\u6C3D\u{24E3B}"],
      ["8adf", "\u{27574}\u{22E8B}\u{22208}\u{2A65B}\u{28CCD}\u{20E7A}\u{20C34}\u{2681C}\u7F93\u{210CF}\u{22803}\u{22939}\u35FB\u{251E3}\u{20E8C}\u{20F8D}\u{20EAA}\u3F93\u{20F30}\u{20D47}\u{2114F}\u{20E4C}"],
      ["8af6", "\u{20EAB}\u{20BA9}\u{20D48}\u{210C0}\u{2113D}\u3FF9\u{22696}\u6432\u{20FAD}"],
      ["8b40", "\u{233F4}\u{27639}\u{22BCE}\u{20D7E}\u{20D7F}\u{22C51}\u{22C55}\u3A18\u{20E98}\u{210C7}\u{20F2E}\u{2A632}\u{26B50}\u{28CD2}\u{28D99}\u{28CCA}\u95AA\u54CC\u82C4\u55B9"],
      ["8b55", "\u{29EC3}\u9C26\u9AB6\u{2775E}\u{22DEE}\u7140\u816D\u80EC\u5C1C\u{26572}\u8134\u3797\u535F\u{280BD}\u91B6\u{20EFA}\u{20E0F}\u{20E77}\u{20EFB}\u35DD\u{24DEB}\u3609\u{20CD6}\u56AF\u{227B5}\u{210C9}\u{20E10}\u{20E78}\u{21078}\u{21148}\u{28207}\u{21455}\u{20E79}\u{24E50}\u{22DA4}\u5A54\u{2101D}\u{2101E}\u{210F5}\u{210F6}\u579C\u{20E11}"],
      ["8ba1", "\u{27694}\u{282CD}\u{20FB5}\u{20E7B}\u{2517E}\u3703\u{20FB6}\u{21180}\u{252D8}\u{2A2BD}\u{249DA}\u{2183A}\u{24177}\u{2827C}\u5899\u5268\u361A\u{2573D}\u7BB2\u5B68\u4800\u4B2C\u9F27\u49E7\u9C1F\u9B8D\u{25B74}\u{2313D}\u55FB\u35F2\u5689\u4E28\u5902\u{21BC1}\u{2F878}\u9751\u{20086}\u4E5B\u4EBB\u353E\u5C23\u5F51\u5FC4\u38FA\u624C\u6535\u6B7A\u6C35\u6C3A\u706C\u722B\u4E2C\u72AD\u{248E9}\u7F52\u793B\u7CF9\u7F53\u{2626A}\u34C1"],
      ["8bde", "\u{2634B}\u8002\u8080\u{26612}\u{26951}\u535D\u8864\u89C1\u{278B2}\u8BA0\u8D1D\u9485\u9578\u957F\u95E8\u{28E0F}\u97E6\u9875\u98CE\u98DE\u9963\u{29810}\u9C7C\u9E1F\u9EC4\u6B6F\uF907\u4E37\u{20087}\u961D\u6237\u94A2"],
      ["8c40", "\u503B\u6DFE\u{29C73}\u9FA6\u3DC9\u888F\u{2414E}\u7077\u5CF5\u4B20\u{251CD}\u3559\u{25D30}\u6122\u{28A32}\u8FA7\u91F6\u7191\u6719\u73BA\u{23281}\u{2A107}\u3C8B\u{21980}\u4B10\u78E4\u7402\u51AE\u{2870F}\u4009\u6A63\u{2A2BA}\u4223\u860F\u{20A6F}\u7A2A\u{29947}\u{28AEA}\u9755\u704D\u5324\u{2207E}\u93F4\u76D9\u{289E3}\u9FA7\u77DD\u4EA3\u4FF0\u50BC\u4E2F\u4F17\u9FA8\u5434\u7D8B\u5892\u58D0\u{21DB6}\u5E92\u5E99\u5FC2\u{22712}\u658B"],
      ["8ca1", "\u{233F9}\u6919\u6A43\u{23C63}\u6CFF"],
      ["8ca7", "\u7200\u{24505}\u738C\u3EDB\u{24A13}\u5B15\u74B9\u8B83\u{25CA4}\u{25695}\u7A93\u7BEC\u7CC3\u7E6C\u82F8\u8597\u9FA9\u8890\u9FAA\u8EB9\u9FAB\u8FCF\u855F\u99E0\u9221\u9FAC\u{28DB9}\u{2143F}\u4071\u42A2\u5A1A"],
      ["8cc9", "\u9868\u676B\u4276\u573D"],
      ["8cce", "\u85D6\u{2497B}\u82BF\u{2710D}\u4C81\u{26D74}\u5D7B\u{26B15}\u{26FBE}\u9FAD\u9FAE\u5B96\u9FAF\u66E7\u7E5B\u6E57\u79CA\u3D88\u44C3\u{23256}\u{22796}\u439A\u4536"],
      ["8ce6", "\u5CD5\u{23B1A}\u8AF9\u5C78\u3D12\u{23551}\u5D78\u9FB2\u7157\u4558\u{240EC}\u{21E23}\u4C77\u3978\u344A\u{201A4}\u{26C41}\u8ACC\u4FB4\u{20239}\u59BF\u816C\u9856\u{298FA}\u5F3B"],
      ["8d40", "\u{20B9F}"],
      ["8d42", "\u{221C1}\u{2896D}\u4102\u46BB\u{29079}\u3F07\u9FB3\u{2A1B5}\u40F8\u37D6\u46F7\u{26C46}\u417C\u{286B2}\u{273FF}\u456D\u38D4\u{2549A}\u4561\u451B\u4D89\u4C7B\u4D76\u45EA\u3FC8\u{24B0F}\u3661\u44DE\u44BD\u41ED\u5D3E\u5D48\u5D56\u3DFC\u380F\u5DA4\u5DB9\u3820\u3838\u5E42\u5EBD\u5F25\u5F83\u3908\u3914\u393F\u394D\u60D7\u613D\u5CE5\u3989\u61B7\u61B9\u61CF\u39B8\u622C\u6290\u62E5\u6318\u39F8\u56B1"],
      ["8da1", "\u3A03\u63E2\u63FB\u6407\u645A\u3A4B\u64C0\u5D15\u5621\u9F9F\u3A97\u6586\u3ABD\u65FF\u6653\u3AF2\u6692\u3B22\u6716\u3B42\u67A4\u6800\u3B58\u684A\u6884\u3B72\u3B71\u3B7B\u6909\u6943\u725C\u6964\u699F\u6985\u3BBC\u69D6\u3BDD\u6A65\u6A74\u6A71\u6A82\u3BEC\u6A99\u3BF2\u6AAB\u6AB5\u6AD4\u6AF6\u6B81\u6BC1\u6BEA\u6C75\u6CAA\u3CCB\u6D02\u6D06\u6D26\u6D81\u3CEF\u6DA4\u6DB1\u6E15\u6E18\u6E29\u6E86\u{289C0}\u6EBB\u6EE2\u6EDA\u9F7F\u6EE8\u6EE9\u6F24\u6F34\u3D46\u{23F41}\u6F81\u6FBE\u3D6A\u3D75\u71B7\u5C99\u3D8A\u702C\u3D91\u7050\u7054\u706F\u707F\u7089\u{20325}\u43C1\u35F1\u{20ED8}"],
      ["8e40", "\u{23ED7}\u57BE\u{26ED3}\u713E\u{257E0}\u364E\u69A2\u{28BE9}\u5B74\u7A49\u{258E1}\u{294D9}\u7A65\u7A7D\u{259AC}\u7ABB\u7AB0\u7AC2\u7AC3\u71D1\u{2648D}\u41CA\u7ADA\u7ADD\u7AEA\u41EF\u54B2\u{25C01}\u7B0B\u7B55\u7B29\u{2530E}\u{25CFE}\u7BA2\u7B6F\u839C\u{25BB4}\u{26C7F}\u7BD0\u8421\u7B92\u7BB8\u{25D20}\u3DAD\u{25C65}\u8492\u7BFA\u7C06\u7C35\u{25CC1}\u7C44\u7C83\u{24882}\u7CA6\u667D\u{24578}\u7CC9\u7CC7\u7CE6\u7C74\u7CF3\u7CF5\u7CCE"],
      ["8ea1", "\u7E67\u451D\u{26E44}\u7D5D\u{26ED6}\u748D\u7D89\u7DAB\u7135\u7DB3\u7DD2\u{24057}\u{26029}\u7DE4\u3D13\u7DF5\u{217F9}\u7DE5\u{2836D}\u7E1D\u{26121}\u{2615A}\u7E6E\u7E92\u432B\u946C\u7E27\u7F40\u7F41\u7F47\u7936\u{262D0}\u99E1\u7F97\u{26351}\u7FA3\u{21661}\u{20068}\u455C\u{23766}\u4503\u{2833A}\u7FFA\u{26489}\u8005\u8008\u801D\u8028\u802F\u{2A087}\u{26CC3}\u803B\u803C\u8061\u{22714}\u4989\u{26626}\u{23DE3}\u{266E8}\u6725\u80A7\u{28A48}\u8107\u811A\u58B0\u{226F6}\u6C7F\u{26498}\u{24FB8}\u64E7\u{2148A}\u8218\u{2185E}\u6A53\u{24A65}\u{24A95}\u447A\u8229\u{20B0D}\u{26A52}\u{23D7E}\u4FF9\u{214FD}\u84E2\u8362\u{26B0A}\u{249A7}\u{23530}\u{21773}\u{23DF8}\u82AA\u691B\u{2F994}\u41DB"],
      ["8f40", "\u854B\u82D0\u831A\u{20E16}\u{217B4}\u36C1\u{2317D}\u{2355A}\u827B\u82E2\u8318\u{23E8B}\u{26DA3}\u{26B05}\u{26B97}\u{235CE}\u3DBF\u831D\u55EC\u8385\u450B\u{26DA5}\u83AC\u83C1\u83D3\u347E\u{26ED4}\u6A57\u855A\u3496\u{26E42}\u{22EEF}\u8458\u{25BE4}\u8471\u3DD3\u44E4\u6AA7\u844A\u{23CB5}\u7958\u84A8\u{26B96}\u{26E77}\u{26E43}\u84DE\u840F\u8391\u44A0\u8493\u84E4\u{25C91}\u4240\u{25CC0}\u4543\u8534\u5AF2\u{26E99}\u4527\u8573\u4516\u67BF\u8616"],
      ["8fa1", "\u{28625}\u{2863B}\u85C1\u{27088}\u8602\u{21582}\u{270CD}\u{2F9B2}\u456A\u8628\u3648\u{218A2}\u53F7\u{2739A}\u867E\u8771\u{2A0F8}\u87EE\u{22C27}\u87B1\u87DA\u880F\u5661\u866C\u6856\u460F\u8845\u8846\u{275E0}\u{23DB9}\u{275E4}\u885E\u889C\u465B\u88B4\u88B5\u63C1\u88C5\u7777\u{2770F}\u8987\u898A\u89A6\u89A9\u89A7\u89BC\u{28A25}\u89E7\u{27924}\u{27ABD}\u8A9C\u7793\u91FE\u8A90\u{27A59}\u7AE9\u{27B3A}\u{23F8F}\u4713\u{27B38}\u717C\u8B0C\u8B1F\u{25430}\u{25565}\u8B3F\u8B4C\u8B4D\u8AA9\u{24A7A}\u8B90\u8B9B\u8AAF\u{216DF}\u4615\u884F\u8C9B\u{27D54}\u{27D8F}\u{2F9D4}\u3725\u{27D53}\u8CD6\u{27D98}\u{27DBD}\u8D12\u8D03\u{21910}\u8CDB\u705C\u8D11\u{24CC9}\u3ED0\u8D77"],
      ["9040", "\u8DA9\u{28002}\u{21014}\u{2498A}\u3B7C\u{281BC}\u{2710C}\u7AE7\u8EAD\u8EB6\u8EC3\u92D4\u8F19\u8F2D\u{28365}\u{28412}\u8FA5\u9303\u{2A29F}\u{20A50}\u8FB3\u492A\u{289DE}\u{2853D}\u{23DBB}\u5EF8\u{23262}\u8FF9\u{2A014}\u{286BC}\u{28501}\u{22325}\u3980\u{26ED7}\u9037\u{2853C}\u{27ABE}\u9061\u{2856C}\u{2860B}\u90A8\u{28713}\u90C4\u{286E6}\u90AE\u90FD\u9167\u3AF0\u91A9\u91C4\u7CAC\u{28933}\u{21E89}\u920E\u6C9F\u9241\u9262\u{255B9}\u92B9\u{28AC6}\u{23C9B}\u{28B0C}\u{255DB}"],
      ["90a1", "\u{20D31}\u932C\u936B\u{28AE1}\u{28BEB}\u708F\u5AC3\u{28AE2}\u{28AE5}\u4965\u9244\u{28BEC}\u{28C39}\u{28BFF}\u9373\u945B\u8EBC\u9585\u95A6\u9426\u95A0\u6FF6\u42B9\u{2267A}\u{286D8}\u{2127C}\u{23E2E}\u49DF\u6C1C\u967B\u9696\u416C\u96A3\u{26ED5}\u61DA\u96B6\u78F5\u{28AE0}\u96BD\u53CC\u49A1\u{26CB8}\u{20274}\u{26410}\u{290AF}\u{290E5}\u{24AD1}\u{21915}\u{2330A}\u9731\u8642\u9736\u4A0F\u453D\u4585\u{24AE9}\u7075\u5B41\u971B\u975C\u{291D5}\u9757\u5B4A\u{291EB}\u975F\u9425\u50D0\u{230B7}\u{230BC}\u9789\u979F\u97B1\u97BE\u97C0\u97D2\u97E0\u{2546C}\u97EE\u741C\u{29433}\u97FF\u97F5\u{2941D}\u{2797A}\u4AD1\u9834\u9833\u984B\u9866\u3B0E\u{27175}\u3D51\u{20630}\u{2415C}"],
      ["9140", "\u{25706}\u98CA\u98B7\u98C8\u98C7\u4AFF\u{26D27}\u{216D3}\u55B0\u98E1\u98E6\u98EC\u9378\u9939\u{24A29}\u4B72\u{29857}\u{29905}\u99F5\u9A0C\u9A3B\u9A10\u9A58\u{25725}\u36C4\u{290B1}\u{29BD5}\u9AE0\u9AE2\u{29B05}\u9AF4\u4C0E\u9B14\u9B2D\u{28600}\u5034\u9B34\u{269A8}\u38C3\u{2307D}\u9B50\u9B40\u{29D3E}\u5A45\u{21863}\u9B8E\u{2424B}\u9C02\u9BFF\u9C0C\u{29E68}\u9DD4\u{29FB7}\u{2A192}\u{2A1AB}\u{2A0E1}\u{2A123}\u{2A1DF}\u9D7E\u9D83\u{2A134}\u9E0E\u6888"],
      ["91a1", "\u9DC4\u{2215B}\u{2A193}\u{2A220}\u{2193B}\u{2A233}\u9D39\u{2A0B9}\u{2A2B4}\u9E90\u9E95\u9E9E\u9EA2\u4D34\u9EAA\u9EAF\u{24364}\u9EC1\u3B60\u39E5\u3D1D\u4F32\u37BE\u{28C2B}\u9F02\u9F08\u4B96\u9424\u{26DA2}\u9F17\u9F16\u9F39\u569F\u568A\u9F45\u99B8\u{2908B}\u97F2\u847F\u9F62\u9F69\u7ADC\u9F8E\u7216\u4BBE\u{24975}\u{249BB}\u7177\u{249F8}\u{24348}\u{24A51}\u739E\u{28BDA}\u{218FA}\u799F\u{2897E}\u{28E36}\u9369\u93F3\u{28A44}\u92EC\u9381\u93CB\u{2896C}\u{244B9}\u7217\u3EEB\u7772\u7A43\u70D0\u{24473}\u{243F8}\u717E\u{217EF}\u70A3\u{218BE}\u{23599}\u3EC7\u{21885}\u{2542F}\u{217F8}\u3722\u{216FB}\u{21839}\u36E1\u{21774}\u{218D1}\u{25F4B}\u3723\u{216C0}\u575B\u{24A25}\u{213FE}\u{212A8}"],
      ["9240", "\u{213C6}\u{214B6}\u8503\u{236A6}\u8503\u8455\u{24994}\u{27165}\u{23E31}\u{2555C}\u{23EFB}\u{27052}\u44F4\u{236EE}\u{2999D}\u{26F26}\u67F9\u3733\u3C15\u3DE7\u586C\u{21922}\u6810\u4057\u{2373F}\u{240E1}\u{2408B}\u{2410F}\u{26C21}\u54CB\u569E\u{266B1}\u5692\u{20FDF}\u{20BA8}\u{20E0D}\u93C6\u{28B13}\u939C\u4EF8\u512B\u3819\u{24436}\u4EBC\u{20465}\u{2037F}\u4F4B\u4F8A\u{25651}\u5A68\u{201AB}\u{203CB}\u3999\u{2030A}\u{20414}\u3435\u4F29\u{202C0}\u{28EB3}\u{20275}\u8ADA\u{2020C}\u4E98"],
      ["92a1", "\u50CD\u510D\u4FA2\u4F03\u{24A0E}\u{23E8A}\u4F42\u502E\u506C\u5081\u4FCC\u4FE5\u5058\u50FC\u5159\u515B\u515D\u515E\u6E76\u{23595}\u{23E39}\u{23EBF}\u6D72\u{21884}\u{23E89}\u51A8\u51C3\u{205E0}\u44DD\u{204A3}\u{20492}\u{20491}\u8D7A\u{28A9C}\u{2070E}\u5259\u52A4\u{20873}\u52E1\u936E\u467A\u718C\u{2438C}\u{20C20}\u{249AC}\u{210E4}\u69D1\u{20E1D}\u7479\u3EDE\u7499\u7414\u7456\u7398\u4B8E\u{24ABC}\u{2408D}\u53D0\u3584\u720F\u{240C9}\u55B4\u{20345}\u54CD\u{20BC6}\u571D\u925D\u96F4\u9366\u57DD\u578D\u577F\u363E\u58CB\u5A99\u{28A46}\u{216FA}\u{2176F}\u{21710}\u5A2C\u59B8\u928F\u5A7E\u5ACF\u5A12\u{25946}\u{219F3}\u{21861}\u{24295}\u36F5\u6D05\u7443\u5A21\u{25E83}"],
      ["9340", "\u5A81\u{28BD7}\u{20413}\u93E0\u748C\u{21303}\u7105\u4972\u9408\u{289FB}\u93BD\u37A0\u5C1E\u5C9E\u5E5E\u5E48\u{21996}\u{2197C}\u{23AEE}\u5ECD\u5B4F\u{21903}\u{21904}\u3701\u{218A0}\u36DD\u{216FE}\u36D3\u812A\u{28A47}\u{21DBA}\u{23472}\u{289A8}\u5F0C\u5F0E\u{21927}\u{217AB}\u5A6B\u{2173B}\u5B44\u8614\u{275FD}\u8860\u607E\u{22860}\u{2262B}\u5FDB\u3EB8\u{225AF}\u{225BE}\u{29088}\u{26F73}\u61C0\u{2003E}\u{20046}\u{2261B}\u6199\u6198\u6075\u{22C9B}\u{22D07}\u{246D4}\u{2914D}"],
      ["93a1", "\u6471\u{24665}\u{22B6A}\u3A29\u{22B22}\u{23450}\u{298EA}\u{22E78}\u6337\u{2A45B}\u64B6\u6331\u63D1\u{249E3}\u{22D67}\u62A4\u{22CA1}\u643B\u656B\u6972\u3BF4\u{2308E}\u{232AD}\u{24989}\u{232AB}\u550D\u{232E0}\u{218D9}\u{2943F}\u66CE\u{23289}\u{231B3}\u3AE0\u4190\u{25584}\u{28B22}\u{2558F}\u{216FC}\u{2555B}\u{25425}\u78EE\u{23103}\u{2182A}\u{23234}\u3464\u{2320F}\u{23182}\u{242C9}\u668E\u{26D24}\u666B\u4B93\u6630\u{27870}\u{21DEB}\u6663\u{232D2}\u{232E1}\u661E\u{25872}\u38D1\u{2383A}\u{237BC}\u3B99\u{237A2}\u{233FE}\u74D0\u3B96\u678F\u{2462A}\u68B6\u681E\u3BC4\u6ABE\u3863\u{237D5}\u{24487}\u6A33\u6A52\u6AC9\u6B05\u{21912}\u6511\u6898\u6A4C\u3BD7\u6A7A\u6B57\u{23FC0}\u{23C9A}\u93A0\u92F2\u{28BEA}\u{28ACB}"],
      ["9440", "\u9289\u{2801E}\u{289DC}\u9467\u6DA5\u6F0B\u{249EC}\u6D67\u{23F7F}\u3D8F\u6E04\u{2403C}\u5A3D\u6E0A\u5847\u6D24\u7842\u713B\u{2431A}\u{24276}\u70F1\u7250\u7287\u7294\u{2478F}\u{24725}\u5179\u{24AA4}\u{205EB}\u747A\u{23EF8}\u{2365F}\u{24A4A}\u{24917}\u{25FE1}\u3F06\u3EB1\u{24ADF}\u{28C23}\u{23F35}\u60A7\u3EF3\u74CC\u743C\u9387\u7437\u449F\u{26DEA}\u4551\u7583\u3F63\u{24CD9}\u{24D06}\u3F58\u7555\u7673\u{2A5C6}\u3B19\u7468\u{28ACC}\u{249AB}\u{2498E}\u3AFB"],
      ["94a1", "\u3DCD\u{24A4E}\u3EFF\u{249C5}\u{248F3}\u91FA\u5732\u9342\u{28AE3}\u{21864}\u50DF\u{25221}\u{251E7}\u7778\u{23232}\u770E\u770F\u777B\u{24697}\u{23781}\u3A5E\u{248F0}\u7438\u749B\u3EBF\u{24ABA}\u{24AC7}\u40C8\u{24A96}\u{261AE}\u9307\u{25581}\u781E\u788D\u7888\u78D2\u73D0\u7959\u{27741}\u{256E3}\u410E\u799B\u8496\u79A5\u6A2D\u{23EFA}\u7A3A\u79F4\u416E\u{216E6}\u4132\u9235\u79F1\u{20D4C}\u{2498C}\u{20299}\u{23DBA}\u{2176E}\u3597\u556B\u3570\u36AA\u{201D4}\u{20C0D}\u7AE2\u5A59\u{226F5}\u{25AAF}\u{25A9C}\u5A0D\u{2025B}\u78F0\u5A2A\u{25BC6}\u7AFE\u41F9\u7C5D\u7C6D\u4211\u{25BB3}\u{25EBC}\u{25EA6}\u7CCD\u{249F9}\u{217B0}\u7C8E\u7C7C\u7CAE\u6AB2\u7DDC\u7E07\u7DD3\u7F4E\u{26261}"],
      ["9540", "\u{2615C}\u{27B48}\u7D97\u{25E82}\u426A\u{26B75}\u{20916}\u67D6\u{2004E}\u{235CF}\u57C4\u{26412}\u{263F8}\u{24962}\u7FDD\u7B27\u{2082C}\u{25AE9}\u{25D43}\u7B0C\u{25E0E}\u99E6\u8645\u9A63\u6A1C\u{2343F}\u39E2\u{249F7}\u{265AD}\u9A1F\u{265A0}\u8480\u{27127}\u{26CD1}\u44EA\u8137\u4402\u80C6\u8109\u8142\u{267B4}\u98C3\u{26A42}\u8262\u8265\u{26A51}\u8453\u{26DA7}\u8610\u{2721B}\u5A86\u417F\u{21840}\u5B2B\u{218A1}\u5AE4\u{218D8}\u86A0\u{2F9BC}\u{23D8F}\u882D\u{27422}\u5A02"],
      ["95a1", "\u886E\u4F45\u8887\u88BF\u88E6\u8965\u894D\u{25683}\u8954\u{27785}\u{27784}\u{28BF5}\u{28BD9}\u{28B9C}\u{289F9}\u3EAD\u84A3\u46F5\u46CF\u37F2\u8A3D\u8A1C\u{29448}\u5F4D\u922B\u{24284}\u65D4\u7129\u70C4\u{21845}\u9D6D\u8C9F\u8CE9\u{27DDC}\u599A\u77C3\u59F0\u436E\u36D4\u8E2A\u8EA7\u{24C09}\u8F30\u8F4A\u42F4\u6C58\u6FBB\u{22321}\u489B\u6F79\u6E8B\u{217DA}\u9BE9\u36B5\u{2492F}\u90BB\u9097\u5571\u4906\u91BB\u9404\u{28A4B}\u4062\u{28AFC}\u9427\u{28C1D}\u{28C3B}\u84E5\u8A2B\u9599\u95A7\u9597\u9596\u{28D34}\u7445\u3EC2\u{248FF}\u{24A42}\u{243EA}\u3EE7\u{23225}\u968F\u{28EE7}\u{28E66}\u{28E65}\u3ECC\u{249ED}\u{24A78}\u{23FEE}\u7412\u746B\u3EFC\u9741\u{290B0}"],
      ["9640", "\u6847\u4A1D\u{29093}\u{257DF}\u975D\u9368\u{28989}\u{28C26}\u{28B2F}\u{263BE}\u92BA\u5B11\u8B69\u493C\u73F9\u{2421B}\u979B\u9771\u9938\u{20F26}\u5DC1\u{28BC5}\u{24AB2}\u981F\u{294DA}\u92F6\u{295D7}\u91E5\u44C0\u{28B50}\u{24A67}\u{28B64}\u98DC\u{28A45}\u3F00\u922A\u4925\u8414\u993B\u994D\u{27B06}\u3DFD\u999B\u4B6F\u99AA\u9A5C\u{28B65}\u{258C8}\u6A8F\u9A21\u5AFE\u9A2F\u{298F1}\u4B90\u{29948}\u99BC\u4BBD\u4B97\u937D\u5872\u{21302}\u5822\u{249B8}"],
      ["96a1", "\u{214E8}\u7844\u{2271F}\u{23DB8}\u68C5\u3D7D\u9458\u3927\u6150\u{22781}\u{2296B}\u6107\u9C4F\u9C53\u9C7B\u9C35\u9C10\u9B7F\u9BCF\u{29E2D}\u9B9F\u{2A1F5}\u{2A0FE}\u9D21\u4CAE\u{24104}\u9E18\u4CB0\u9D0C\u{2A1B4}\u{2A0ED}\u{2A0F3}\u{2992F}\u9DA5\u84BD\u{26E12}\u{26FDF}\u{26B82}\u85FC\u4533\u{26DA4}\u{26E84}\u{26DF0}\u8420\u85EE\u{26E00}\u{237D7}\u{26064}\u79E2\u{2359C}\u{23640}\u492D\u{249DE}\u3D62\u93DB\u92BE\u9348\u{202BF}\u78B9\u9277\u944D\u4FE4\u3440\u9064\u{2555D}\u783D\u7854\u78B6\u784B\u{21757}\u{231C9}\u{24941}\u369A\u4F72\u6FDA\u6FD9\u701E\u701E\u5414\u{241B5}\u57BB\u58F3\u578A\u9D16\u57D7\u7134\u34AF\u{241AC}\u71EB\u{26C40}\u{24F97}\u5B28\u{217B5}\u{28A49}"],
      ["9740", "\u610C\u5ACE\u5A0B\u42BC\u{24488}\u372C\u4B7B\u{289FC}\u93BB\u93B8\u{218D6}\u{20F1D}\u8472\u{26CC0}\u{21413}\u{242FA}\u{22C26}\u{243C1}\u5994\u{23DB7}\u{26741}\u7DA8\u{2615B}\u{260A4}\u{249B9}\u{2498B}\u{289FA}\u92E5\u73E2\u3EE9\u74B4\u{28B63}\u{2189F}\u3EE1\u{24AB3}\u6AD8\u73F3\u73FB\u3ED6\u{24A3E}\u{24A94}\u{217D9}\u{24A66}\u{203A7}\u{21424}\u{249E5}\u7448\u{24916}\u70A5\u{24976}\u9284\u73E6\u935F\u{204FE}\u9331\u{28ACE}\u{28A16}\u9386\u{28BE7}\u{255D5}\u4935\u{28A82}\u716B"],
      ["97a1", "\u{24943}\u{20CFF}\u56A4\u{2061A}\u{20BEB}\u{20CB8}\u5502\u79C4\u{217FA}\u7DFE\u{216C2}\u{24A50}\u{21852}\u452E\u9401\u370A\u{28AC0}\u{249AD}\u59B0\u{218BF}\u{21883}\u{27484}\u5AA1\u36E2\u{23D5B}\u36B0\u925F\u5A79\u{28A81}\u{21862}\u9374\u3CCD\u{20AB4}\u4A96\u398A\u50F4\u3D69\u3D4C\u{2139C}\u7175\u42FB\u{28218}\u6E0F\u{290E4}\u44EB\u6D57\u{27E4F}\u7067\u6CAF\u3CD6\u{23FED}\u{23E2D}\u6E02\u6F0C\u3D6F\u{203F5}\u7551\u36BC\u34C8\u4680\u3EDA\u4871\u59C4\u926E\u493E\u8F41\u{28C1C}\u{26BC0}\u5812\u57C8\u36D6\u{21452}\u70FE\u{24362}\u{24A71}\u{22FE3}\u{212B0}\u{223BD}\u68B9\u6967\u{21398}\u{234E5}\u{27BF4}\u{236DF}\u{28A83}\u{237D6}\u{233FA}\u{24C9F}\u6A1A\u{236AD}\u{26CB7}\u843E\u44DF\u44CE"],
      ["9840", "\u{26D26}\u{26D51}\u{26C82}\u{26FDE}\u6F17\u{27109}\u833D\u{2173A}\u83ED\u{26C80}\u{27053}\u{217DB}\u5989\u5A82\u{217B3}\u5A61\u5A71\u{21905}\u{241FC}\u372D\u59EF\u{2173C}\u36C7\u718E\u9390\u669A\u{242A5}\u5A6E\u5A2B\u{24293}\u6A2B\u{23EF9}\u{27736}\u{2445B}\u{242CA}\u711D\u{24259}\u{289E1}\u4FB0\u{26D28}\u5CC2\u{244CE}\u{27E4D}\u{243BD}\u6A0C\u{24256}\u{21304}\u70A6\u7133\u{243E9}\u3DA5\u6CDF\u{2F825}\u{24A4F}\u7E65\u59EB\u5D2F\u3DF3\u5F5C\u{24A5D}\u{217DF}\u7DA4\u8426"],
      ["98a1", "\u5485\u{23AFA}\u{23300}\u{20214}\u577E\u{208D5}\u{20619}\u3FE5\u{21F9E}\u{2A2B6}\u7003\u{2915B}\u5D70\u738F\u7CD3\u{28A59}\u{29420}\u4FC8\u7FE7\u72CD\u7310\u{27AF4}\u7338\u7339\u{256F6}\u7341\u7348\u3EA9\u{27B18}\u906C\u71F5\u{248F2}\u73E1\u81F6\u3ECA\u770C\u3ED1\u6CA2\u56FD\u7419\u741E\u741F\u3EE2\u3EF0\u3EF4\u3EFA\u74D3\u3F0E\u3F53\u7542\u756D\u7572\u758D\u3F7C\u75C8\u75DC\u3FC0\u764D\u3FD7\u7674\u3FDC\u767A\u{24F5C}\u7188\u5623\u8980\u5869\u401D\u7743\u4039\u6761\u4045\u35DB\u7798\u406A\u406F\u5C5E\u77BE\u77CB\u58F2\u7818\u70B9\u781C\u40A8\u7839\u7847\u7851\u7866\u8448\u{25535}\u7933\u6803\u7932\u4103"],
      ["9940", "\u4109\u7991\u7999\u8FBB\u7A06\u8FBC\u4167\u7A91\u41B2\u7ABC\u8279\u41C4\u7ACF\u7ADB\u41CF\u4E21\u7B62\u7B6C\u7B7B\u7C12\u7C1B\u4260\u427A\u7C7B\u7C9C\u428C\u7CB8\u4294\u7CED\u8F93\u70C0\u{20CCF}\u7DCF\u7DD4\u7DD0\u7DFD\u7FAE\u7FB4\u729F\u4397\u8020\u8025\u7B39\u802E\u8031\u8054\u3DCC\u57B4\u70A0\u80B7\u80E9\u43ED\u810C\u732A\u810E\u8112\u7560\u8114\u4401\u3B39\u8156\u8159\u815A"],
      ["99a1", "\u4413\u583A\u817C\u8184\u4425\u8193\u442D\u81A5\u57EF\u81C1\u81E4\u8254\u448F\u82A6\u8276\u82CA\u82D8\u82FF\u44B0\u8357\u9669\u698A\u8405\u70F5\u8464\u60E3\u8488\u4504\u84BE\u84E1\u84F8\u8510\u8538\u8552\u453B\u856F\u8570\u85E0\u4577\u8672\u8692\u86B2\u86EF\u9645\u878B\u4606\u4617\u88AE\u88FF\u8924\u8947\u8991\u{27967}\u8A29\u8A38\u8A94\u8AB4\u8C51\u8CD4\u8CF2\u8D1C\u4798\u585F\u8DC3\u47ED\u4EEE\u8E3A\u55D8\u5754\u8E71\u55F5\u8EB0\u4837\u8ECE\u8EE2\u8EE4\u8EED\u8EF2\u8FB7\u8FC1\u8FCA\u8FCC\u9033\u99C4\u48AD\u98E0\u9213\u491E\u9228\u9258\u926B\u92B1\u92AE\u92BF"],
      ["9a40", "\u92E3\u92EB\u92F3\u92F4\u92FD\u9343\u9384\u93AD\u4945\u4951\u9EBF\u9417\u5301\u941D\u942D\u943E\u496A\u9454\u9479\u952D\u95A2\u49A7\u95F4\u9633\u49E5\u67A0\u4A24\u9740\u4A35\u97B2\u97C2\u5654\u4AE4\u60E8\u98B9\u4B19\u98F1\u5844\u990E\u9919\u51B4\u991C\u9937\u9942\u995D\u9962\u4B70\u99C5\u4B9D\u9A3C\u9B0F\u7A83\u9B69\u9B81\u9BDD\u9BF1\u9BF4\u4C6D\u9C20\u376F\u{21BC2}\u9D49\u9C3A"],
      ["9aa1", "\u9EFE\u5650\u9D93\u9DBD\u9DC0\u9DFC\u94F6\u8FB6\u9E7B\u9EAC\u9EB1\u9EBD\u9EC6\u94DC\u9EE2\u9EF1\u9EF8\u7AC8\u9F44\u{20094}\u{202B7}\u{203A0}\u691A\u94C3\u59AC\u{204D7}\u5840\u94C1\u37B9\u{205D5}\u{20615}\u{20676}\u{216BA}\u5757\u7173\u{20AC2}\u{20ACD}\u{20BBF}\u546A\u{2F83B}\u{20BCB}\u549E\u{20BFB}\u{20C3B}\u{20C53}\u{20C65}\u{20C7C}\u60E7\u{20C8D}\u567A\u{20CB5}\u{20CDD}\u{20CED}\u{20D6F}\u{20DB2}\u{20DC8}\u6955\u9C2F\u87A5\u{20E04}\u{20E0E}\u{20ED7}\u{20F90}\u{20F2D}\u{20E73}\u5C20\u{20FBC}\u5E0B\u{2105C}\u{2104F}\u{21076}\u671E\u{2107B}\u{21088}\u{21096}\u3647\u{210BF}\u{210D3}\u{2112F}\u{2113B}\u5364\u84AD\u{212E3}\u{21375}\u{21336}\u8B81\u{21577}\u{21619}\u{217C3}\u{217C7}\u4E78\u70BB\u{2182D}\u{2196A}"],
      ["9b40", "\u{21A2D}\u{21A45}\u{21C2A}\u{21C70}\u{21CAC}\u{21EC8}\u62C3\u{21ED5}\u{21F15}\u7198\u6855\u{22045}\u69E9\u36C8\u{2227C}\u{223D7}\u{223FA}\u{2272A}\u{22871}\u{2294F}\u82FD\u{22967}\u{22993}\u{22AD5}\u89A5\u{22AE8}\u8FA0\u{22B0E}\u97B8\u{22B3F}\u9847\u9ABD\u{22C4C}"],
      ["9b62", "\u{22C88}\u{22CB7}\u{25BE8}\u{22D08}\u{22D12}\u{22DB7}\u{22D95}\u{22E42}\u{22F74}\u{22FCC}\u{23033}\u{23066}\u{2331F}\u{233DE}\u5FB1\u6648\u66BF\u{27A79}\u{23567}\u{235F3}\u7201\u{249BA}\u77D7\u{2361A}\u{23716}\u7E87\u{20346}\u58B5\u670E"],
      ["9ba1", "\u6918\u{23AA7}\u{27657}\u{25FE2}\u{23E11}\u{23EB9}\u{275FE}\u{2209A}\u48D0\u4AB8\u{24119}\u{28A9A}\u{242EE}\u{2430D}\u{2403B}\u{24334}\u{24396}\u{24A45}\u{205CA}\u51D2\u{20611}\u599F\u{21EA8}\u3BBE\u{23CFF}\u{24404}\u{244D6}\u5788\u{24674}\u399B\u{2472F}\u{285E8}\u{299C9}\u3762\u{221C3}\u8B5E\u{28B4E}\u99D6\u{24812}\u{248FB}\u{24A15}\u7209\u{24AC0}\u{20C78}\u5965\u{24EA5}\u{24F86}\u{20779}\u8EDA\u{2502C}\u528F\u573F\u7171\u{25299}\u{25419}\u{23F4A}\u{24AA7}\u55BC\u{25446}\u{2546E}\u{26B52}\u91D4\u3473\u{2553F}\u{27632}\u{2555E}\u4718\u{25562}\u{25566}\u{257C7}\u{2493F}\u{2585D}\u5066\u34FB\u{233CC}\u60DE\u{25903}\u477C\u{28948}\u{25AAE}\u{25B89}\u{25C06}\u{21D90}\u57A1\u7151\u6FB6\u{26102}\u{27C12}\u9056\u{261B2}\u{24F9A}\u8B62\u{26402}\u{2644A}"],
      ["9c40", "\u5D5B\u{26BF7}\u8F36\u{26484}\u{2191C}\u8AEA\u{249F6}\u{26488}\u{23FEF}\u{26512}\u4BC0\u{265BF}\u{266B5}\u{2271B}\u9465\u{257E1}\u6195\u5A27\u{2F8CD}\u4FBB\u56B9\u{24521}\u{266FC}\u4E6A\u{24934}\u9656\u6D8F\u{26CBD}\u3618\u8977\u{26799}\u{2686E}\u{26411}\u{2685E}\u71DF\u{268C7}\u7B42\u{290C0}\u{20A11}\u{26926}\u9104\u{26939}\u7A45\u9DF0\u{269FA}\u9A26\u{26A2D}\u365F\u{26469}\u{20021}\u7983\u{26A34}\u{26B5B}\u5D2C\u{23519}\u83CF\u{26B9D}\u46D0\u{26CA4}\u753B\u8865\u{26DAE}\u58B6"],
      ["9ca1", "\u371C\u{2258D}\u{2704B}\u{271CD}\u3C54\u{27280}\u{27285}\u9281\u{2217A}\u{2728B}\u9330\u{272E6}\u{249D0}\u6C39\u949F\u{27450}\u{20EF8}\u8827\u88F5\u{22926}\u{28473}\u{217B1}\u6EB8\u{24A2A}\u{21820}\u39A4\u36B9\u5C10\u79E3\u453F\u66B6\u{29CAD}\u{298A4}\u8943\u{277CC}\u{27858}\u56D6\u40DF\u{2160A}\u39A1\u{2372F}\u{280E8}\u{213C5}\u71AD\u8366\u{279DD}\u{291A8}\u5A67\u4CB7\u{270AF}\u{289AB}\u{279FD}\u{27A0A}\u{27B0B}\u{27D66}\u{2417A}\u7B43\u797E\u{28009}\u6FB5\u{2A2DF}\u6A03\u{28318}\u53A2\u{26E07}\u93BF\u6836\u975D\u{2816F}\u{28023}\u{269B5}\u{213ED}\u{2322F}\u{28048}\u5D85\u{28C30}\u{28083}\u5715\u9823\u{28949}\u5DAB\u{24988}\u65BE\u69D5\u53D2\u{24AA5}\u{23F81}\u3C11\u6736\u{28090}\u{280F4}\u{2812E}\u{21FA1}\u{2814F}"],
      ["9d40", "\u{28189}\u{281AF}\u{2821A}\u{28306}\u{2832F}\u{2838A}\u35CA\u{28468}\u{286AA}\u48FA\u63E6\u{28956}\u7808\u9255\u{289B8}\u43F2\u{289E7}\u43DF\u{289E8}\u{28B46}\u{28BD4}\u59F8\u{28C09}\u8F0B\u{28FC5}\u{290EC}\u7B51\u{29110}\u{2913C}\u3DF7\u{2915E}\u{24ACA}\u8FD0\u728F\u568B\u{294E7}\u{295E9}\u{295B0}\u{295B8}\u{29732}\u{298D1}\u{29949}\u{2996A}\u{299C3}\u{29A28}\u{29B0E}\u{29D5A}\u{29D9B}\u7E9F\u{29EF8}\u{29F23}\u4CA4\u9547\u{2A293}\u71A2\u{2A2FF}\u4D91\u9012\u{2A5CB}\u4D9C\u{20C9C}\u8FBE\u55C1"],
      ["9da1", "\u8FBA\u{224B0}\u8FB9\u{24A93}\u4509\u7E7F\u6F56\u6AB1\u4EEA\u34E4\u{28B2C}\u{2789D}\u373A\u8E80\u{217F5}\u{28024}\u{28B6C}\u{28B99}\u{27A3E}\u{266AF}\u3DEB\u{27655}\u{23CB7}\u{25635}\u{25956}\u4E9A\u{25E81}\u{26258}\u56BF\u{20E6D}\u8E0E\u5B6D\u{23E88}\u{24C9E}\u63DE\u62D0\u{217F6}\u{2187B}\u6530\u562D\u{25C4A}\u541A\u{25311}\u3DC6\u{29D98}\u4C7D\u5622\u561E\u7F49\u{25ED8}\u5975\u{23D40}\u8770\u4E1C\u{20FEA}\u{20D49}\u{236BA}\u8117\u9D5E\u8D18\u763B\u9C45\u764E\u77B9\u9345\u5432\u8148\u82F7\u5625\u8132\u8418\u80BD\u55EA\u7962\u5643\u5416\u{20E9D}\u35CE\u5605\u55F1\u66F1\u{282E2}\u362D\u7534\u55F0\u55BA\u5497\u5572\u{20C41}\u{20C96}\u5ED0\u{25148}\u{20E76}\u{22C62}"],
      ["9e40", "\u{20EA2}\u9EAB\u7D5A\u55DE\u{21075}\u629D\u976D\u5494\u8CCD\u71F6\u9176\u63FC\u63B9\u63FE\u5569\u{22B43}\u9C72\u{22EB3}\u519A\u34DF\u{20DA7}\u51A7\u544D\u551E\u5513\u7666\u8E2D\u{2688A}\u75B1\u80B6\u8804\u8786\u88C7\u81B6\u841C\u{210C1}\u44EC\u7304\u{24706}\u5B90\u830B\u{26893}\u567B\u{226F4}\u{27D2F}\u{241A3}\u{27D73}\u{26ED0}\u{272B6}\u9170\u{211D9}\u9208\u{23CFC}\u{2A6A9}\u{20EAC}\u{20EF9}\u7266\u{21CA2}\u474E\u{24FC2}\u{27FF9}\u{20FEB}\u40FA"],
      ["9ea1", "\u9C5D\u651F\u{22DA0}\u48F3\u{247E0}\u{29D7C}\u{20FEC}\u{20E0A}\u6062\u{275A3}\u{20FED}"],
      ["9ead", "\u{26048}\u{21187}\u71A3\u7E8E\u9D50\u4E1A\u4E04\u3577\u5B0D\u6CB2\u5367\u36AC\u39DC\u537D\u36A5\u{24618}\u589A\u{24B6E}\u822D\u544B\u57AA\u{25A95}\u{20979}"],
      ["9ec5", "\u3A52\u{22465}\u7374\u{29EAC}\u4D09\u9BED\u{23CFE}\u{29F30}\u4C5B\u{24FA9}\u{2959E}\u{29FDE}\u845C\u{23DB6}\u{272B2}\u{267B3}\u{23720}\u632E\u7D25\u{23EF7}\u{23E2C}\u3A2A\u9008\u52CC\u3E74\u367A\u45E9\u{2048E}\u7640\u5AF0\u{20EB6}\u787A\u{27F2E}\u58A7\u40BF\u567C\u9B8B\u5D74\u7654\u{2A434}\u9E85\u4CE1\u75F9\u37FB\u6119\u{230DA}\u{243F2}"],
      ["9ef5", "\u565D\u{212A9}\u57A7\u{24963}\u{29E06}\u5234\u{270AE}\u35AD\u6C4A\u9D7C"],
      ["9f40", "\u7C56\u9B39\u57DE\u{2176C}\u5C53\u64D3\u{294D0}\u{26335}\u{27164}\u86AD\u{20D28}\u{26D22}\u{24AE2}\u{20D71}"],
      ["9f4f", "\u51FE\u{21F0F}\u5D8E\u9703\u{21DD1}\u9E81\u904C\u7B1F\u9B02\u5CD1\u7BA3\u6268\u6335\u9AFF\u7BCF\u9B2A\u7C7E\u9B2E\u7C42\u7C86\u9C15\u7BFC\u9B09\u9F17\u9C1B\u{2493E}\u9F5A\u5573\u5BC3\u4FFD\u9E98\u4FF2\u5260\u3E06\u52D1\u5767\u5056\u59B7\u5E12\u97C8\u9DAB\u8F5C\u5469\u97B4\u9940\u97BA\u532C\u6130"],
      ["9fa1", "\u692C\u53DA\u9C0A\u9D02\u4C3B\u9641\u6980\u50A6\u7546\u{2176D}\u99DA\u5273"],
      ["9fae", "\u9159\u9681\u915C"],
      ["9fb2", "\u9151\u{28E97}\u637F\u{26D23}\u6ACA\u5611\u918E\u757A\u6285\u{203FC}\u734F\u7C70\u{25C21}\u{23CFD}"],
      ["9fc1", "\u{24919}\u76D6\u9B9D\u4E2A\u{20CD4}\u83BE\u8842"],
      ["9fc9", "\u5C4A\u69C0\u50ED\u577A\u521F\u5DF5\u4ECE\u6C31\u{201F2}\u4F39\u549C\u54DA\u529A\u8D82\u35FE\u5F0C\u35F3"],
      ["9fdb", "\u6B52\u917C\u9FA5\u9B97\u982E\u98B4\u9ABA\u9EA8\u9E84\u717A\u7B14"],
      ["9fe7", "\u6BFA\u8818\u7F78"],
      ["9feb", "\u5620\u{2A64A}\u8E77\u9F53"],
      ["9ff0", "\u8DD4\u8E4F\u9E1C\u8E01\u6282\u{2837D}\u8E28\u8E75\u7AD3\u{24A77}\u7A3E\u78D8\u6CEA\u8A67\u7607"],
      ["a040", "\u{28A5A}\u9F26\u6CCE\u87D6\u75C3\u{2A2B2}\u7853\u{2F840}\u8D0C\u72E2\u7371\u8B2D\u7302\u74F1\u8CEB\u{24ABB}\u862F\u5FBA\u88A0\u44B7"],
      ["a055", "\u{2183B}\u{26E05}"],
      ["a058", "\u8A7E\u{2251B}"],
      ["a05b", "\u60FD\u7667\u9AD7\u9D44\u936E\u9B8F\u87F5"],
      ["a063", "\u880F\u8CF7\u732C\u9721\u9BB0\u35D6\u72B2\u4C07\u7C51\u994A\u{26159}\u6159\u4C04\u9E96\u617D"],
      ["a073", "\u575F\u616F\u62A6\u6239\u62CE\u3A5C\u61E2\u53AA\u{233F5}\u6364\u6802\u35D2"],
      ["a0a1", "\u5D57\u{28BC2}\u8FDA\u{28E39}"],
      ["a0a6", "\u50D9\u{21D46}\u7906\u5332\u9638\u{20F3B}\u4065"],
      ["a0ae", "\u77FE"],
      ["a0b0", "\u7CC2\u{25F1A}\u7CDA\u7A2D\u8066\u8063\u7D4D\u7505\u74F2\u8994\u821A\u670C\u8062\u{27486}\u805B\u74F0\u8103\u7724\u8989\u{267CC}\u7553\u{26ED1}\u87A9\u87CE\u81C8\u878C\u8A49\u8CAD\u8B43\u772B\u74F8\u84DA\u3635\u69B2\u8DA6"],
      ["a0d4", "\u89A9\u7468\u6DB9\u87C1\u{24011}\u74E7\u3DDB\u7176\u60A4\u619C\u3CD1\u7162\u6077"],
      ["a0e2", "\u7F71\u{28B2D}\u7250\u60E9\u4B7E\u5220\u3C18\u{23CC7}\u{25ED7}\u{27656}\u{25531}\u{21944}\u{212FE}\u{29903}\u{26DDC}\u{270AD}\u5CC1\u{261AD}\u{28A0F}\u{23677}\u{200EE}\u{26846}\u{24F0E}\u4562\u5B1F\u{2634C}\u9F50\u9EA6\u{2626B}"],
      ["a3c0", "\u2400", 31, "\u2421"],
      ["c6a1", "\u2460", 9, "\u2474", 9, "\u2170", 9, "\u4E36\u4E3F\u4E85\u4EA0\u5182\u5196\u51AB\u52F9\u5338\u5369\u53B6\u590A\u5B80\u5DDB\u2F33\u5E7F\u5EF4\u5F50\u5F61\u6534\u65E0\u7592\u7676\u8FB5\u96B6\xA8\u02C6\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\uFF3B\uFF3D\u273D\u3041", 23],
      ["c740", "\u3059", 58, "\u30A1\u30A2\u30A3\u30A4"],
      ["c7a1", "\u30A5", 81, "\u0410", 5, "\u0401\u0416", 4],
      ["c840", "\u041B", 26, "\u0451\u0436", 25, "\u21E7\u21B8\u21B9\u31CF\u{200CC}\u4E5A\u{2008A}\u5202\u4491"],
      ["c8a1", "\u9FB0\u5188\u9FB1\u{27607}"],
      ["c8cd", "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u309B\u309C\u2E80\u2E84\u2E86\u2E87\u2E88\u2E8A\u2E8C\u2E8D\u2E95\u2E9C\u2E9D\u2EA5\u2EA7\u2EAA\u2EAC\u2EAE\u2EB6\u2EBC\u2EBE\u2EC6\u2ECA\u2ECC\u2ECD\u2ECF\u2ED6\u2ED7\u2EDE\u2EE3"],
      ["c8f5", "\u0283\u0250\u025B\u0254\u0275\u0153\xF8\u014B\u028A\u026A"],
      ["f9fe", "\uFFED"],
      ["fa40", "\u{20547}\u92DB\u{205DF}\u{23FC5}\u854C\u42B5\u73EF\u51B5\u3649\u{24942}\u{289E4}\u9344\u{219DB}\u82EE\u{23CC8}\u783C\u6744\u62DF\u{24933}\u{289AA}\u{202A0}\u{26BB3}\u{21305}\u4FAB\u{224ED}\u5008\u{26D29}\u{27A84}\u{23600}\u{24AB1}\u{22513}\u5029\u{2037E}\u5FA4\u{20380}\u{20347}\u6EDB\u{2041F}\u507D\u5101\u347A\u510E\u986C\u3743\u8416\u{249A4}\u{20487}\u5160\u{233B4}\u516A\u{20BFF}\u{220FC}\u{202E5}\u{22530}\u{2058E}\u{23233}\u{21983}\u5B82\u877D\u{205B3}\u{23C99}\u51B2\u51B8"],
      ["faa1", "\u9D34\u51C9\u51CF\u51D1\u3CDC\u51D3\u{24AA6}\u51B3\u51E2\u5342\u51ED\u83CD\u693E\u{2372D}\u5F7B\u520B\u5226\u523C\u52B5\u5257\u5294\u52B9\u52C5\u7C15\u8542\u52E0\u860D\u{26B13}\u5305\u{28ADE}\u5549\u6ED9\u{23F80}\u{20954}\u{23FEC}\u5333\u5344\u{20BE2}\u6CCB\u{21726}\u681B\u73D5\u604A\u3EAA\u38CC\u{216E8}\u71DD\u44A2\u536D\u5374\u{286AB}\u537E\u537F\u{21596}\u{21613}\u77E6\u5393\u{28A9B}\u53A0\u53AB\u53AE\u73A7\u{25772}\u3F59\u739C\u53C1\u53C5\u6C49\u4E49\u57FE\u53D9\u3AAB\u{20B8F}\u53E0\u{23FEB}\u{22DA3}\u53F6\u{20C77}\u5413\u7079\u552B\u6657\u6D5B\u546D\u{26B53}\u{20D74}\u555D\u548F\u54A4\u47A6\u{2170D}\u{20EDD}\u3DB4\u{20D4D}"],
      ["fb40", "\u{289BC}\u{22698}\u5547\u4CED\u542F\u7417\u5586\u55A9\u5605\u{218D7}\u{2403A}\u4552\u{24435}\u66B3\u{210B4}\u5637\u66CD\u{2328A}\u66A4\u66AD\u564D\u564F\u78F1\u56F1\u9787\u53FE\u5700\u56EF\u56ED\u{28B66}\u3623\u{2124F}\u5746\u{241A5}\u6C6E\u708B\u5742\u36B1\u{26C7E}\u57E6\u{21416}\u5803\u{21454}\u{24363}\u5826\u{24BF5}\u585C\u58AA\u3561\u58E0\u58DC\u{2123C}\u58FB\u5BFF\u5743\u{2A150}\u{24278}\u93D3\u35A1\u591F\u68A6\u36C3\u6E59"],
      ["fba1", "\u{2163E}\u5A24\u5553\u{21692}\u8505\u59C9\u{20D4E}\u{26C81}\u{26D2A}\u{217DC}\u59D9\u{217FB}\u{217B2}\u{26DA6}\u6D71\u{21828}\u{216D5}\u59F9\u{26E45}\u5AAB\u5A63\u36E6\u{249A9}\u5A77\u3708\u5A96\u7465\u5AD3\u{26FA1}\u{22554}\u3D85\u{21911}\u3732\u{216B8}\u5E83\u52D0\u5B76\u6588\u5B7C\u{27A0E}\u4004\u485D\u{20204}\u5BD5\u6160\u{21A34}\u{259CC}\u{205A5}\u5BF3\u5B9D\u4D10\u5C05\u{21B44}\u5C13\u73CE\u5C14\u{21CA5}\u{26B28}\u5C49\u48DD\u5C85\u5CE9\u5CEF\u5D8B\u{21DF9}\u{21E37}\u5D10\u5D18\u5D46\u{21EA4}\u5CBA\u5DD7\u82FC\u382D\u{24901}\u{22049}\u{22173}\u8287\u3836\u3BC2\u5E2E\u6A8A\u5E75\u5E7A\u{244BC}\u{20CD3}\u53A6\u4EB7\u5ED0\u53A8\u{21771}\u5E09\u5EF4\u{28482}"],
      ["fc40", "\u5EF9\u5EFB\u38A0\u5EFC\u683E\u941B\u5F0D\u{201C1}\u{2F894}\u3ADE\u48AE\u{2133A}\u5F3A\u{26888}\u{223D0}\u5F58\u{22471}\u5F63\u97BD\u{26E6E}\u5F72\u9340\u{28A36}\u5FA7\u5DB6\u3D5F\u{25250}\u{21F6A}\u{270F8}\u{22668}\u91D6\u{2029E}\u{28A29}\u6031\u6685\u{21877}\u3963\u3DC7\u3639\u5790\u{227B4}\u7971\u3E40\u609E\u60A4\u60B3\u{24982}\u{2498F}\u{27A53}\u74A4\u50E1\u5AA0\u6164\u8424\u6142\u{2F8A6}\u{26ED2}\u6181\u51F4\u{20656}\u6187\u5BAA\u{23FB7}"],
      ["fca1", "\u{2285F}\u61D3\u{28B9D}\u{2995D}\u61D0\u3932\u{22980}\u{228C1}\u6023\u615C\u651E\u638B\u{20118}\u62C5\u{21770}\u62D5\u{22E0D}\u636C\u{249DF}\u3A17\u6438\u63F8\u{2138E}\u{217FC}\u6490\u6F8A\u{22E36}\u9814\u{2408C}\u{2571D}\u64E1\u64E5\u947B\u3A66\u643A\u3A57\u654D\u6F16\u{24A28}\u{24A23}\u6585\u656D\u655F\u{2307E}\u65B5\u{24940}\u4B37\u65D1\u40D8\u{21829}\u65E0\u65E3\u5FDF\u{23400}\u6618\u{231F7}\u{231F8}\u6644\u{231A4}\u{231A5}\u664B\u{20E75}\u6667\u{251E6}\u6673\u6674\u{21E3D}\u{23231}\u{285F4}\u{231C8}\u{25313}\u77C5\u{228F7}\u99A4\u6702\u{2439C}\u{24A21}\u3B2B\u69FA\u{237C2}\u675E\u6767\u6762\u{241CD}\u{290ED}\u67D7\u44E9\u6822\u6E50\u923C\u6801\u{233E6}\u{26DA0}\u685D"],
      ["fd40", "\u{2346F}\u69E1\u6A0B\u{28ADF}\u6973\u68C3\u{235CD}\u6901\u6900\u3D32\u3A01\u{2363C}\u3B80\u67AC\u6961\u{28A4A}\u42FC\u6936\u6998\u3BA1\u{203C9}\u8363\u5090\u69F9\u{23659}\u{2212A}\u6A45\u{23703}\u6A9D\u3BF3\u67B1\u6AC8\u{2919C}\u3C0D\u6B1D\u{20923}\u60DE\u6B35\u6B74\u{227CD}\u6EB5\u{23ADB}\u{203B5}\u{21958}\u3740\u5421\u{23B5A}\u6BE1\u{23EFC}\u6BDC\u6C37\u{2248B}\u{248F1}\u{26B51}\u6C5A\u8226\u6C79\u{23DBC}\u44C5\u{23DBD}\u{241A4}\u{2490C}\u{24900}"],
      ["fda1", "\u{23CC9}\u36E5\u3CEB\u{20D32}\u9B83\u{231F9}\u{22491}\u7F8F\u6837\u{26D25}\u{26DA1}\u{26DEB}\u6D96\u6D5C\u6E7C\u6F04\u{2497F}\u{24085}\u{26E72}\u8533\u{26F74}\u51C7\u6C9C\u6E1D\u842E\u{28B21}\u6E2F\u{23E2F}\u7453\u{23F82}\u79CC\u6E4F\u5A91\u{2304B}\u6FF8\u370D\u6F9D\u{23E30}\u6EFA\u{21497}\u{2403D}\u4555\u93F0\u6F44\u6F5C\u3D4E\u6F74\u{29170}\u3D3B\u6F9F\u{24144}\u6FD3\u{24091}\u{24155}\u{24039}\u{23FF0}\u{23FB4}\u{2413F}\u51DF\u{24156}\u{24157}\u{24140}\u{261DD}\u704B\u707E\u70A7\u7081\u70CC\u70D5\u70D6\u70DF\u4104\u3DE8\u71B4\u7196\u{24277}\u712B\u7145\u5A88\u714A\u716E\u5C9C\u{24365}\u714F\u9362\u{242C1}\u712C\u{2445A}\u{24A27}\u{24A22}\u71BA\u{28BE8}\u70BD\u720E"],
      ["fe40", "\u9442\u7215\u5911\u9443\u7224\u9341\u{25605}\u722E\u7240\u{24974}\u68BD\u7255\u7257\u3E55\u{23044}\u680D\u6F3D\u7282\u732A\u732B\u{24823}\u{2882B}\u48ED\u{28804}\u7328\u732E\u73CF\u73AA\u{20C3A}\u{26A2E}\u73C9\u7449\u{241E2}\u{216E7}\u{24A24}\u6623\u36C5\u{249B7}\u{2498D}\u{249FB}\u73F7\u7415\u6903\u{24A26}\u7439\u{205C3}\u3ED7\u745C\u{228AD}\u7460\u{28EB2}\u7447\u73E4\u7476\u83B9\u746C\u3730\u7474\u93F1\u6A2C\u7482\u4953\u{24A8C}"],
      ["fea1", "\u{2415F}\u{24A79}\u{28B8F}\u5B46\u{28C03}\u{2189E}\u74C8\u{21988}\u750E\u74E9\u751E\u{28ED9}\u{21A4B}\u5BD7\u{28EAC}\u9385\u754D\u754A\u7567\u756E\u{24F82}\u3F04\u{24D13}\u758E\u745D\u759E\u75B4\u7602\u762C\u7651\u764F\u766F\u7676\u{263F5}\u7690\u81EF\u37F8\u{26911}\u{2690E}\u76A1\u76A5\u76B7\u76CC\u{26F9F}\u8462\u{2509D}\u{2517D}\u{21E1C}\u771E\u7726\u7740\u64AF\u{25220}\u7758\u{232AC}\u77AF\u{28964}\u{28968}\u{216C1}\u77F4\u7809\u{21376}\u{24A12}\u68CA\u78AF\u78C7\u78D3\u96A5\u792E\u{255E0}\u78D7\u7934\u78B1\u{2760C}\u8FB8\u8884\u{28B2B}\u{26083}\u{2261C}\u7986\u8900\u6902\u7980\u{25857}\u799D\u{27B39}\u793C\u79A9\u6E2A\u{27126}\u3EA8\u79C6\u{2910D}\u79D4"]
    ];
  }
});

// node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS({
  "node_modules/iconv-lite/encodings/dbcs-data.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // == Japanese/ShiftJIS ====================================================
      // All japanese encodings are based on JIS X set of standards:
      // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
      // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
      //              Has several variations in 1978, 1983, 1990 and 1997.
      // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
      // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
      //              2 planes, first is superset of 0208, second - revised 0212.
      //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
      // Byte encodings are:
      //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
      //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
      //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
      //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
      //               0x00-0x7F       - lower part of 0201
      //               0x8E, 0xA1-0xDF - upper part of 0201
      //               (0xA1-0xFE)x2   - 0208 plane (94x94).
      //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
      //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
      //               Used as-is in ISO2022 family.
      //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
      //                0201-1976 Roman, 0208-1978, 0208-1983.
      //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
      //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
      //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
      //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
      //
      // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
      //
      // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
      "shiftjis": {
        type: "_dbcs",
        table: function() {
          return require_shiftjis();
        },
        encodeAdd: { "\xA5": 92, "\u203E": 126 },
        encodeSkipVals: [{ from: 60736, to: 63808 }]
      },
      "csshiftjis": "shiftjis",
      "mskanji": "shiftjis",
      "sjis": "shiftjis",
      "windows31j": "shiftjis",
      "ms31j": "shiftjis",
      "xsjis": "shiftjis",
      "windows932": "shiftjis",
      "ms932": "shiftjis",
      "932": "shiftjis",
      "cp932": "shiftjis",
      "eucjp": {
        type: "_dbcs",
        table: function() {
          return require_eucjp();
        },
        encodeAdd: { "\xA5": 92, "\u203E": 126 }
      },
      // TODO: KDDI extension to Shift_JIS
      // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
      // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
      // == Chinese/GBK ==========================================================
      // http://en.wikipedia.org/wiki/GBK
      // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
      // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
      "gb2312": "cp936",
      "gb231280": "cp936",
      "gb23121980": "cp936",
      "csgb2312": "cp936",
      "csiso58gb231280": "cp936",
      "euccn": "cp936",
      // Microsoft's CP936 is a subset and approximation of GBK.
      "windows936": "cp936",
      "ms936": "cp936",
      "936": "cp936",
      "cp936": {
        type: "_dbcs",
        table: function() {
          return require_cp936();
        }
      },
      // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
      "gbk": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        }
      },
      "xgbk": "gbk",
      "isoir58": "gbk",
      // GB18030 is an algorithmic extension of GBK.
      // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
      // http://icu-project.org/docs/papers/gb18030.html
      // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
      // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
      "gb18030": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        },
        gb18030: function() {
          return require_gb18030_ranges();
        },
        encodeSkipVals: [128],
        encodeAdd: { "\u20AC": 41699 }
      },
      "chinese": "gb18030",
      // == Korean ===============================================================
      // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
      "windows949": "cp949",
      "ms949": "cp949",
      "949": "cp949",
      "cp949": {
        type: "_dbcs",
        table: function() {
          return require_cp949();
        }
      },
      "cseuckr": "cp949",
      "csksc56011987": "cp949",
      "euckr": "cp949",
      "isoir149": "cp949",
      "korean": "cp949",
      "ksc56011987": "cp949",
      "ksc56011989": "cp949",
      "ksc5601": "cp949",
      // == Big5/Taiwan/Hong Kong ================================================
      // There are lots of tables for Big5 and cp950. Please see the following links for history:
      // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
      // Variations, in roughly number of defined chars:
      //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
      //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
      //  * Big5-2003 (Taiwan standard) almost superset of cp950.
      //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
      //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
      //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
      //    Plus, it has 4 combining sequences.
      //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
      //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
      //    Implementations are not consistent within browsers; sometimes labeled as just big5.
      //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
      //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
      //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
      //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
      //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
      // 
      // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
      // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
      "windows950": "cp950",
      "ms950": "cp950",
      "950": "cp950",
      "cp950": {
        type: "_dbcs",
        table: function() {
          return require_cp950();
        }
      },
      // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
      "big5": "big5hkscs",
      "big5hkscs": {
        type: "_dbcs",
        table: function() {
          return require_cp950().concat(require_big5_added());
        },
        encodeSkipVals: [
          // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
          // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
          // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
          36457,
          36463,
          36478,
          36523,
          36532,
          36557,
          36560,
          36695,
          36713,
          36718,
          36811,
          36862,
          36973,
          36986,
          37060,
          37084,
          37105,
          37311,
          37551,
          37552,
          37553,
          37554,
          37585,
          37959,
          38090,
          38361,
          38652,
          39285,
          39798,
          39800,
          39803,
          39878,
          39902,
          39916,
          39926,
          40002,
          40019,
          40034,
          40040,
          40043,
          40055,
          40124,
          40125,
          40144,
          40279,
          40282,
          40388,
          40431,
          40443,
          40617,
          40687,
          40701,
          40800,
          40907,
          41079,
          41180,
          41183,
          36812,
          37576,
          38468,
          38637,
          // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
          41636,
          41637,
          41639,
          41638,
          41676,
          41678
        ]
      },
      "cnbig5": "big5hkscs",
      "csbig5": "big5hkscs",
      "xxbig5": "big5hkscs"
    };
  }
});

// node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS({
  "node_modules/iconv-lite/encodings/index.js"(exports2, module2) {
    "use strict";
    var modules = [
      require_internal(),
      require_utf32(),
      require_utf16(),
      require_utf7(),
      require_sbcs_codec(),
      require_sbcs_data(),
      require_sbcs_data_generated(),
      require_dbcs_codec(),
      require_dbcs_data()
    ];
    for (i = 0; i < modules.length; i++) {
      module2 = modules[i];
      for (enc in module2)
        if (Object.prototype.hasOwnProperty.call(module2, enc))
          exports2[enc] = module2[enc];
    }
    var module2;
    var enc;
    var i;
  }
});

// node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS({
  "node_modules/iconv-lite/lib/streams.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    module2.exports = function(stream_module) {
      var Transform = stream_module.Transform;
      function IconvLiteEncoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.decodeStrings = false;
        Transform.call(this, options);
      }
      IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteEncoderStream }
      });
      IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
        if (typeof chunk != "string")
          return done(new Error("Iconv encoding stream needs strings as its input."));
        try {
          var res = this.conv.write(chunk);
          if (res && res.length) this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteEncoderStream.prototype._flush = function(done) {
        try {
          var res = this.conv.end();
          if (res && res.length) this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteEncoderStream.prototype.collect = function(cb) {
        var chunks = [];
        this.on("error", cb);
        this.on("data", function(chunk) {
          chunks.push(chunk);
        });
        this.on("end", function() {
          cb(null, Buffer2.concat(chunks));
        });
        return this;
      };
      function IconvLiteDecoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.encoding = this.encoding = "utf8";
        Transform.call(this, options);
      }
      IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteDecoderStream }
      });
      IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
        if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
          return done(new Error("Iconv decoding stream needs buffers as its input."));
        try {
          var res = this.conv.write(chunk);
          if (res && res.length) this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteDecoderStream.prototype._flush = function(done) {
        try {
          var res = this.conv.end();
          if (res && res.length) this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteDecoderStream.prototype.collect = function(cb) {
        var res = "";
        this.on("error", cb);
        this.on("data", function(chunk) {
          res += chunk;
        });
        this.on("end", function() {
          cb(null, res);
        });
        return this;
      };
      return {
        IconvLiteEncoderStream,
        IconvLiteDecoderStream
      };
    };
  }
});

// node_modules/iconv-lite/lib/index.js
var require_lib26 = __commonJS({
  "node_modules/iconv-lite/lib/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    var bomHandling = require_bom_handling();
    var iconv = module2.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "\uFFFD";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode(str, encoding, options) {
      str = "" + (str || "");
      var encoder = iconv.getEncoder(encoding, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings)
        iconv.encodings = require_encodings();
      var enc = iconv._canonicalizeEncoding(encoding);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);
      return decoder;
    };
    iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
      if (iconv.supportsStreams)
        return;
      var streams = require_streams()(stream_module2);
      iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
      iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
      iconv.encodeStream = function encodeStream(encoding, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
      };
      iconv.decodeStream = function decodeStream(encoding, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
      };
      iconv.supportsStreams = true;
    };
    var stream_module;
    try {
      stream_module = require("stream");
    } catch (e) {
    }
    if (stream_module && stream_module.Transform) {
      iconv.enableStreamingAPI(stream_module);
    } else {
      iconv.encodeStream = iconv.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
    if (false) {
      console.error("iconv-lite warning: js files use non-utf8 encoding. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
    }
  }
});

// node_modules/encoding/lib/encoding.js
var require_encoding = __commonJS({
  "node_modules/encoding/lib/encoding.js"(exports2, module2) {
    "use strict";
    var iconvLite = require_lib26();
    module2.exports.convert = convert;
    function convert(str, to, from) {
      from = checkEncoding(from || "UTF-8");
      to = checkEncoding(to || "UTF-8");
      str = str || "";
      var result;
      if (from !== "UTF-8" && typeof str === "string") {
        str = Buffer.from(str, "binary");
      }
      if (from === to) {
        if (typeof str === "string") {
          result = Buffer.from(str);
        } else {
          result = str;
        }
      } else {
        try {
          result = convertIconvLite(str, to, from);
        } catch (E) {
          console.error(E);
          result = str;
        }
      }
      if (typeof result === "string") {
        result = Buffer.from(result, "utf-8");
      }
      return result;
    }
    function convertIconvLite(str, to, from) {
      if (to === "UTF-8") {
        return iconvLite.decode(str, from);
      } else if (from === "UTF-8") {
        return iconvLite.encode(str, to);
      } else {
        return iconvLite.encode(iconvLite.decode(str, from), to);
      }
    }
    function checkEncoding(name) {
      return (name || "").toString().trim().replace(/^latin[\-_]?(\d+)$/i, "ISO-8859-$1").replace(/^win(?:dows)?[\-_]?(\d+)$/i, "WINDOWS-$1").replace(/^utf[\-_]?(\d+)$/i, "UTF-$1").replace(/^ks_c_5601\-1987$/i, "CP949").replace(/^us[\-_]?ascii$/i, "ASCII").toUpperCase();
    }
  }
});

// node_modules/minipass-fetch/lib/body.js
var require_body = __commonJS({
  "node_modules/minipass-fetch/lib/body.js"(exports2, module2) {
    "use strict";
    var { Minipass } = require_commonjs3();
    var MinipassSized = require_minipass_sized();
    var Blob = require_blob();
    var { BUFFER } = Blob;
    var FetchError = require_fetch_error();
    var convert;
    try {
      convert = require_encoding().convert;
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals");
    var CONSUME_BODY = Symbol("consumeBody");
    var Body = class {
      constructor(bodyArg, options = {}) {
        const { size = 0, timeout = 0 } = options;
        const body = bodyArg === void 0 || bodyArg === null ? null : isURLSearchParams(bodyArg) ? Buffer.from(bodyArg.toString()) : isBlob(bodyArg) ? bodyArg : Buffer.isBuffer(bodyArg) ? bodyArg : Object.prototype.toString.call(bodyArg) === "[object ArrayBuffer]" ? Buffer.from(bodyArg) : ArrayBuffer.isView(bodyArg) ? Buffer.from(bodyArg.buffer, bodyArg.byteOffset, bodyArg.byteLength) : Minipass.isStream(bodyArg) ? bodyArg : Buffer.from(String(bodyArg));
        this[INTERNALS] = {
          body,
          disturbed: false,
          error: null
        };
        this.size = size;
        this.timeout = timeout;
        if (Minipass.isStream(body)) {
          body.on("error", (er) => {
            const error = er.name === "AbortError" ? er : new FetchError(`Invalid response while trying to fetch ${this.url}: ${er.message}`, "system", er);
            this[INTERNALS].error = error;
          });
        }
      }
      get body() {
        return this[INTERNALS].body;
      }
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      }
      arrayBuffer() {
        return this[CONSUME_BODY]().then((buf) => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));
      }
      blob() {
        const ct = this.headers && this.headers.get("content-type") || "";
        return this[CONSUME_BODY]().then((buf) => Object.assign(
          new Blob([], { type: ct.toLowerCase() }),
          { [BUFFER]: buf }
        ));
      }
      async json() {
        const buf = await this[CONSUME_BODY]();
        try {
          return JSON.parse(buf.toString());
        } catch (er) {
          throw new FetchError(
            `invalid json response body at ${this.url} reason: ${er.message}`,
            "invalid-json"
          );
        }
      }
      text() {
        return this[CONSUME_BODY]().then((buf) => buf.toString());
      }
      buffer() {
        return this[CONSUME_BODY]();
      }
      textConverted() {
        return this[CONSUME_BODY]().then((buf) => convertBody(buf, this.headers));
      }
      [CONSUME_BODY]() {
        if (this[INTERNALS].disturbed) {
          return Promise.reject(new TypeError(`body used already for: ${this.url}`));
        }
        this[INTERNALS].disturbed = true;
        if (this[INTERNALS].error) {
          return Promise.reject(this[INTERNALS].error);
        }
        if (this.body === null) {
          return Promise.resolve(Buffer.alloc(0));
        }
        if (Buffer.isBuffer(this.body)) {
          return Promise.resolve(this.body);
        }
        const upstream = isBlob(this.body) ? this.body.stream() : this.body;
        if (!Minipass.isStream(upstream)) {
          return Promise.resolve(Buffer.alloc(0));
        }
        const stream = this.size && upstream instanceof MinipassSized ? upstream : !this.size && upstream instanceof Minipass && !(upstream instanceof MinipassSized) ? upstream : this.size ? new MinipassSized({ size: this.size }) : new Minipass();
        const resTimeout = this.timeout && stream.writable ? setTimeout(() => {
          stream.emit("error", new FetchError(
            `Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`,
            "body-timeout"
          ));
        }, this.timeout) : null;
        if (resTimeout && resTimeout.unref) {
          resTimeout.unref();
        }
        return new Promise((resolve) => {
          if (stream !== upstream) {
            upstream.on("error", (er) => stream.emit("error", er));
            upstream.pipe(stream);
          }
          resolve();
        }).then(() => stream.concat()).then((buf) => {
          clearTimeout(resTimeout);
          return buf;
        }).catch((er) => {
          clearTimeout(resTimeout);
          if (er.name === "AbortError" || er.name === "FetchError") {
            throw er;
          } else if (er.name === "RangeError") {
            throw new FetchError(`Could not create Buffer from response body for ${this.url}: ${er.message}`, "system", er);
          } else {
            throw new FetchError(`Invalid response body while trying to fetch ${this.url}: ${er.message}`, "system", er);
          }
        });
      }
      static clone(instance) {
        if (instance.bodyUsed) {
          throw new Error("cannot clone body after it is used");
        }
        const body = instance.body;
        if (Minipass.isStream(body) && typeof body.getBoundary !== "function") {
          const tee = new Minipass();
          const p1 = new Minipass();
          const p2 = new Minipass();
          tee.on("error", (er) => {
            p1.emit("error", er);
            p2.emit("error", er);
          });
          body.on("error", (er) => tee.emit("error", er));
          tee.pipe(p1);
          tee.pipe(p2);
          body.pipe(tee);
          instance[INTERNALS].body = p1;
          return p2;
        } else {
          return instance.body;
        }
      }
      static extractContentType(body) {
        return body === null || body === void 0 ? null : typeof body === "string" ? "text/plain;charset=UTF-8" : isURLSearchParams(body) ? "application/x-www-form-urlencoded;charset=UTF-8" : isBlob(body) ? body.type || null : Buffer.isBuffer(body) ? null : Object.prototype.toString.call(body) === "[object ArrayBuffer]" ? null : ArrayBuffer.isView(body) ? null : typeof body.getBoundary === "function" ? `multipart/form-data;boundary=${body.getBoundary()}` : Minipass.isStream(body) ? null : "text/plain;charset=UTF-8";
      }
      static getTotalBytes(instance) {
        const { body } = instance;
        return body === null || body === void 0 ? 0 : isBlob(body) ? body.size : Buffer.isBuffer(body) ? body.length : body && typeof body.getLengthSync === "function" && // detect form data input from form-data module
        (body._lengthRetrievers && /* istanbul ignore next */
        body._lengthRetrievers.length === 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) ? body.getLengthSync() : null;
      }
      static writeToStream(dest, instance) {
        const { body } = instance;
        if (body === null || body === void 0) {
          dest.end();
        } else if (Buffer.isBuffer(body) || typeof body === "string") {
          dest.end(body);
        } else {
          const stream = isBlob(body) ? body.stream() : body;
          stream.on("error", (er) => dest.emit("error", er)).pipe(dest);
        }
        return dest;
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    var isURLSearchParams = (obj) => (
      // Duck-typing as a necessary condition.
      typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function" ? false : obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function"
    );
    var isBlob = (obj) => typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    var convertBody = (buffer, headers) => {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers && headers.get("content-type");
      let charset = "utf-8";
      let res;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      const str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(
        buffer,
        "UTF-8",
        charset
      ).toString();
    };
    module2.exports = Body;
  }
});

// node_modules/minipass-fetch/lib/headers.js
var require_headers = __commonJS({
  "node_modules/minipass-fetch/lib/headers.js"(exports2, module2) {
    "use strict";
    var invalidTokenRegex = /[^^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    var validateName = (name) => {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    };
    var validateValue = (value) => {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    };
    var find = (map, name) => {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    };
    var MAP = Symbol("map");
    var Headers = class _Headers {
      constructor(init = void 0) {
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init === void 0 || init === null) {
          return;
        }
        if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method !== null && method !== void 0) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              const arrPair = Array.from(pair);
              if (arrPair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              pairs.push(arrPair);
            }
            for (const pair of pairs) {
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              this.append(key, init[key]);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      forEach(callback, thisArg = void 0) {
        let pairs = getHeaders(this);
        for (let i = 0; i < pairs.length; i++) {
          const [name, value] = pairs[i];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
        }
      }
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      raw() {
        return this[MAP];
      }
      keys() {
        return new HeadersIterator(this, "key");
      }
      values() {
        return new HeadersIterator(this, "value");
      }
      [Symbol.iterator]() {
        return new HeadersIterator(this, "key+value");
      }
      entries() {
        return new HeadersIterator(this, "key+value");
      }
      get [Symbol.toStringTag]() {
        return "Headers";
      }
      static exportNodeCompatibleHeaders(headers) {
        const obj = Object.assign(/* @__PURE__ */ Object.create(null), headers[MAP]);
        const hostHeaderKey = find(headers[MAP], "Host");
        if (hostHeaderKey !== void 0) {
          obj[hostHeaderKey] = obj[hostHeaderKey][0];
        }
        return obj;
      }
      static createHeadersLenient(obj) {
        const headers = new _Headers();
        for (const name of Object.keys(obj)) {
          if (invalidTokenRegex.test(name)) {
            continue;
          }
          if (Array.isArray(obj[name])) {
            for (const val of obj[name]) {
              if (invalidHeaderCharRegex.test(val)) {
                continue;
              }
              if (headers[MAP][name] === void 0) {
                headers[MAP][name] = [val];
              } else {
                headers[MAP][name].push(val);
              }
            }
          } else if (!invalidHeaderCharRegex.test(obj[name])) {
            headers[MAP][name] = [obj[name]];
          }
        }
        return headers;
      }
    };
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    var getHeaders = (headers, kind = "key+value") => Object.keys(headers[MAP]).sort().map(
      kind === "key" ? (k) => k.toLowerCase() : kind === "value" ? (k) => headers[MAP][k].join(", ") : (k) => [k.toLowerCase(), headers[MAP][k].join(", ")]
    );
    var INTERNAL = Symbol("internal");
    var HeadersIterator = class _HeadersIterator {
      constructor(target, kind) {
        this[INTERNAL] = {
          target,
          kind,
          index: 0
        };
      }
      get [Symbol.toStringTag]() {
        return "HeadersIterator";
      }
      next() {
        if (!this || Object.getPrototypeOf(this) !== _HeadersIterator.prototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        const { target, kind, index } = this[INTERNAL];
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index++;
        return { value: values[index], done: false };
      }
    };
    Object.setPrototypeOf(
      HeadersIterator.prototype,
      Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))
    );
    module2.exports = Headers;
  }
});

// node_modules/minipass-fetch/lib/response.js
var require_response = __commonJS({
  "node_modules/minipass-fetch/lib/response.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var { STATUS_CODES } = http;
    var Headers = require_headers();
    var Body = require_body();
    var { clone, extractContentType } = Body;
    var INTERNALS = Symbol("Response internals");
    var Response = class _Response extends Body {
      constructor(body = null, opts = {}) {
        super(body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body !== null && body !== void 0 && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter,
          trailer: Promise.resolve(opts.trailer || new Headers())
        };
      }
      get trailer() {
        return this[INTERNALS].trailer;
      }
      get url() {
        return this[INTERNALS].url || "";
      }
      get status() {
        return this[INTERNALS].status;
      }
      get ok() {
        return this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;
      }
      get redirected() {
        return this[INTERNALS].counter > 0;
      }
      get statusText() {
        return this[INTERNALS].statusText;
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          trailer: this.trailer
        });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    module2.exports = Response;
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
  }
});

// node_modules/minipass-fetch/package.json
var require_package2 = __commonJS({
  "node_modules/minipass-fetch/package.json"(exports2, module2) {
    module2.exports = {
      name: "minipass-fetch",
      version: "4.0.1",
      description: "An implementation of window.fetch in Node.js using Minipass streams",
      license: "MIT",
      main: "lib/index.js",
      scripts: {
        "test:tls-fixtures": "./test/fixtures/tls/setup.sh",
        test: "tap",
        snap: "tap",
        lint: "npm run eslint",
        postlint: "template-oss-check",
        lintfix: "npm run eslint -- --fix",
        posttest: "npm run lint",
        "template-oss-apply": "template-oss-apply --force",
        eslint: 'eslint "**/*.{js,cjs,ts,mjs,jsx,tsx}"'
      },
      tap: {
        "coverage-map": "map.js",
        "check-coverage": true,
        "nyc-arg": [
          "--exclude",
          "tap-snapshots/**"
        ]
      },
      devDependencies: {
        "@npmcli/eslint-config": "^5.0.0",
        "@npmcli/template-oss": "4.23.3",
        "@ungap/url-search-params": "^0.2.2",
        "abort-controller": "^3.0.0",
        "abortcontroller-polyfill": "~1.7.3",
        encoding: "^0.1.13",
        "form-data": "^4.0.0",
        nock: "^13.2.4",
        parted: "^0.1.1",
        "string-to-arraybuffer": "^1.0.2",
        tap: "^16.0.0"
      },
      dependencies: {
        minipass: "^7.0.3",
        "minipass-sized": "^1.0.3",
        minizlib: "^3.0.1"
      },
      optionalDependencies: {
        encoding: "^0.1.13"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/npm/minipass-fetch.git"
      },
      keywords: [
        "fetch",
        "minipass",
        "node-fetch",
        "window.fetch"
      ],
      files: [
        "bin/",
        "lib/"
      ],
      engines: {
        node: "^18.17.0 || >=20.5.0"
      },
      author: "GitHub Inc.",
      templateOSS: {
        "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
        version: "4.23.3",
        publish: "true"
      }
    };
  }
});

// node_modules/minipass-fetch/lib/request.js
var require_request = __commonJS({
  "node_modules/minipass-fetch/lib/request.js"(exports2, module2) {
    "use strict";
    var { URL: URL2 } = require("url");
    var { Minipass } = require_commonjs3();
    var Headers = require_headers();
    var { exportNodeCompatibleHeaders } = Headers;
    var Body = require_body();
    var { clone, extractContentType, getTotalBytes } = Body;
    var version = require_package2().version;
    var defaultUserAgent = `minipass-fetch/${version} (+https://github.com/isaacs/minipass-fetch)`;
    var INTERNALS = Symbol("Request internals");
    var isRequest = (input) => typeof input === "object" && typeof input[INTERNALS] === "object";
    var isAbortSignal = (signal) => {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    };
    var Request = class _Request extends Body {
      constructor(input, init = {}) {
        const parsedURL = isRequest(input) ? new URL2(input.url) : input && input.href ? new URL2(input.href) : new URL2(`${input}`);
        if (isRequest(input)) {
          init = { ...input[INTERNALS], ...init };
        } else if (!input || typeof input === "string") {
          input = {};
        }
        const method = (init.method || input.method || "GET").toUpperCase();
        const isGETHEAD = method === "GET" || method === "HEAD";
        if ((init.body !== null && init.body !== void 0 || isRequest(input) && input.body !== null) && isGETHEAD) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init.body !== null && init.body !== void 0 ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody !== null && inputBody !== void 0 && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        const signal = "signal" in init ? init.signal : null;
        if (signal !== null && signal !== void 0 && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal must be an instanceof AbortSignal");
        }
        const {
          ca,
          cert,
          ciphers,
          clientCertEngine,
          crl,
          dhparam,
          ecdhCurve,
          family,
          honorCipherOrder,
          key,
          passphrase,
          pfx,
          rejectUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0",
          secureOptions,
          secureProtocol,
          servername,
          sessionIdContext
        } = init;
        this[INTERNALS] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
          ca,
          cert,
          ciphers,
          clientCertEngine,
          crl,
          dhparam,
          ecdhCurve,
          family,
          honorCipherOrder,
          key,
          passphrase,
          pfx,
          rejectUnauthorized,
          secureOptions,
          secureProtocol,
          servername,
          sessionIdContext
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return this[INTERNALS].parsedURL.toString();
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      clone() {
        return new _Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
      static getNodeRequestOptions(request) {
        const parsedURL = request[INTERNALS].parsedURL;
        const headers = new Headers(request[INTERNALS].headers);
        if (!headers.has("Accept")) {
          headers.set("Accept", "*/*");
        }
        if (!/^https?:$/.test(parsedURL.protocol)) {
          throw new TypeError("Only HTTP(S) protocols are supported");
        }
        if (request.signal && Minipass.isStream(request.body) && typeof request.body.destroy !== "function") {
          throw new Error(
            "Cancellation of streamed requests with AbortSignal is not supported"
          );
        }
        const contentLengthValue = (request.body === null || request.body === void 0) && /^(POST|PUT)$/i.test(request.method) ? "0" : request.body !== null && request.body !== void 0 ? getTotalBytes(request) : null;
        if (contentLengthValue) {
          headers.set("Content-Length", contentLengthValue + "");
        }
        if (!headers.has("User-Agent")) {
          headers.set("User-Agent", defaultUserAgent);
        }
        if (request.compress && !headers.has("Accept-Encoding")) {
          headers.set("Accept-Encoding", "gzip,deflate");
        }
        const agent = typeof request.agent === "function" ? request.agent(parsedURL) : request.agent;
        if (!headers.has("Connection") && !agent) {
          headers.set("Connection", "close");
        }
        const {
          ca,
          cert,
          ciphers,
          clientCertEngine,
          crl,
          dhparam,
          ecdhCurve,
          family,
          honorCipherOrder,
          key,
          passphrase,
          pfx,
          rejectUnauthorized,
          secureOptions,
          secureProtocol,
          servername,
          sessionIdContext
        } = request[INTERNALS];
        const urlProps = {
          auth: parsedURL.username || parsedURL.password ? `${parsedURL.username}:${parsedURL.password}` : "",
          host: parsedURL.host,
          hostname: parsedURL.hostname,
          path: `${parsedURL.pathname}${parsedURL.search}`,
          port: parsedURL.port,
          protocol: parsedURL.protocol
        };
        return {
          ...urlProps,
          method: request.method,
          headers: exportNodeCompatibleHeaders(headers),
          agent,
          ca,
          cert,
          ciphers,
          clientCertEngine,
          crl,
          dhparam,
          ecdhCurve,
          family,
          honorCipherOrder,
          key,
          passphrase,
          pfx,
          rejectUnauthorized,
          secureOptions,
          secureProtocol,
          servername,
          sessionIdContext,
          timeout: request.timeout
        };
      }
    };
    module2.exports = Request;
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
  }
});

// node_modules/minipass-fetch/lib/abort-error.js
var require_abort_error = __commonJS({
  "node_modules/minipass-fetch/lib/abort-error.js"(exports2, module2) {
    "use strict";
    var AbortError = class extends Error {
      constructor(message) {
        super(message);
        this.code = "FETCH_ABORTED";
        this.type = "aborted";
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "AbortError";
      }
      // don't allow name to be overridden, but don't throw either
      set name(s) {
      }
    };
    module2.exports = AbortError;
  }
});

// node_modules/minipass-fetch/lib/index.js
var require_lib27 = __commonJS({
  "node_modules/minipass-fetch/lib/index.js"(exports2, module2) {
    "use strict";
    var { URL: URL2 } = require("url");
    var http = require("http");
    var https = require("https");
    var zlib = require_commonjs6();
    var { Minipass } = require_commonjs3();
    var Body = require_body();
    var { writeToStream, getTotalBytes } = Body;
    var Response = require_response();
    var Headers = require_headers();
    var { createHeadersLenient } = Headers;
    var Request = require_request();
    var { getNodeRequestOptions } = Request;
    var FetchError = require_fetch_error();
    var AbortError = require_abort_error();
    var fetch = async (url, opts) => {
      if (/^data:/.test(url)) {
        const request = new Request(url, opts);
        return Promise.resolve().then(() => new Promise((resolve, reject) => {
          let type, data;
          try {
            const { pathname, search } = new URL2(url);
            const split = pathname.split(",");
            if (split.length < 2) {
              throw new Error("invalid data: URI");
            }
            const mime = split.shift();
            const base64 = /;base64$/.test(mime);
            type = base64 ? mime.slice(0, -1 * ";base64".length) : mime;
            const rawData = decodeURIComponent(split.join(",") + search);
            data = base64 ? Buffer.from(rawData, "base64") : Buffer.from(rawData);
          } catch (er) {
            return reject(new FetchError(`[${request.method}] ${request.url} invalid URL, ${er.message}`, "system", er));
          }
          const { signal } = request;
          if (signal && signal.aborted) {
            return reject(new AbortError("The user aborted a request."));
          }
          const headers = { "Content-Length": data.length };
          if (type) {
            headers["Content-Type"] = type;
          }
          return resolve(new Response(data, { headers }));
        }));
      }
      return new Promise((resolve, reject) => {
        const request = new Request(url, opts);
        let options;
        try {
          options = getNodeRequestOptions(request);
        } catch (er) {
          return reject(er);
        }
        const send = (options.protocol === "https:" ? https : http).request;
        const { signal } = request;
        let response = null;
        const abort = () => {
          const error = new AbortError("The user aborted a request.");
          reject(error);
          if (Minipass.isStream(request.body) && typeof request.body.destroy === "function") {
            request.body.destroy(error);
          }
          if (response && response.body) {
            response.body.emit("error", error);
          }
        };
        if (signal && signal.aborted) {
          return abort();
        }
        const abortAndFinalize = () => {
          abort();
          finalize();
        };
        const finalize = () => {
          req.abort();
          if (signal) {
            signal.removeEventListener("abort", abortAndFinalize);
          }
          clearTimeout(reqTimeout);
        };
        const req = send(options);
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        let reqTimeout = null;
        if (request.timeout) {
          req.once("socket", () => {
            reqTimeout = setTimeout(() => {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", (er) => {
          if (req.res) {
            req.res.emit("error", er);
          }
          reject(new FetchError(`request to ${request.url} failed, reason: ${er.message}`, "system", er));
          finalize();
        });
        req.on("response", (res) => {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL2(location, request.url).toString();
            } catch {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            if (request.redirect === "error") {
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            } else if (request.redirect === "manual") {
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject(err);
                }
              }
            } else if (request.redirect === "follow" && locationURL !== null) {
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError(
                  "Cannot follow redirect with body being a readable stream",
                  "unsupported-redirect"
                ));
                finalize();
                return;
              }
              request.headers.set("host", new URL2(locationURL).host);
              const requestOpts = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout
              };
              const parsedOriginal = new URL2(request.url);
              const parsedRedirect = new URL2(locationURL);
              if (parsedOriginal.hostname !== parsedRedirect.hostname) {
                requestOpts.headers.delete("authorization");
                requestOpts.headers.delete("cookie");
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = void 0;
                requestOpts.headers.delete("content-length");
              }
              resolve(fetch(new Request(locationURL, requestOpts)));
              finalize();
              return;
            }
          }
          res.once("end", () => signal && signal.removeEventListener("abort", abortAndFinalize));
          const body = new Minipass();
          body.on("error", finalize);
          res.on(
            "error",
            /* istanbul ignore next */
            (er) => body.emit("error", er)
          );
          res.on("data", (chunk) => body.write(chunk));
          res.on("end", () => body.end());
          const responseOptions = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter,
            trailer: new Promise((resolveTrailer) => res.on("end", () => resolveTrailer(createHeadersLenient(res.trailers))))
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, responseOptions);
            resolve(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.constants.Z_SYNC_FLUSH,
            finishFlush: zlib.constants.Z_SYNC_FLUSH
          };
          if (codings === "gzip" || codings === "x-gzip") {
            const unzip = new zlib.Gunzip(zlibOptions);
            response = new Response(
              // exceedingly rare that the stream would have an error,
              // but just in case we proxy it to the stream in use.
              body.on(
                "error",
                /* istanbul ignore next */
                (er) => unzip.emit("error", er)
              ).pipe(unzip),
              responseOptions
            );
            resolve(response);
            return;
          }
          if (codings === "deflate" || codings === "x-deflate") {
            res.once("data", (chunk) => {
              const decoder2 = (chunk[0] & 15) === 8 ? new zlib.Inflate() : new zlib.InflateRaw();
              body.on(
                "error",
                /* istanbul ignore next */
                (er) => decoder2.emit("error", er)
              ).pipe(decoder2);
              response = new Response(decoder2, responseOptions);
              resolve(response);
            });
            return;
          }
          if (codings === "br") {
            try {
              var decoder = new zlib.BrotliDecompress();
            } catch (err) {
              reject(err);
              finalize();
              return;
            }
            body.on(
              "error",
              /* istanbul ignore next */
              (er) => decoder.emit("error", er)
            ).pipe(decoder);
            response = new Response(decoder, responseOptions);
            resolve(response);
            return;
          }
          response = new Response(body, responseOptions);
          resolve(response);
        });
        writeToStream(req, request);
      });
    };
    module2.exports = fetch;
    fetch.isRedirect = (code) => code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    fetch.Headers = Headers;
    fetch.Request = Request;
    fetch.Response = Response;
    fetch.FetchError = FetchError;
    fetch.AbortError = AbortError;
  }
});

// node_modules/npm-registry-fetch/package.json
var require_package3 = __commonJS({
  "node_modules/npm-registry-fetch/package.json"(exports2, module2) {
    module2.exports = {
      name: "npm-registry-fetch",
      version: "18.0.2",
      description: "Fetch-based http client for use with npm registry APIs",
      main: "lib",
      files: [
        "bin/",
        "lib/"
      ],
      scripts: {
        eslint: 'eslint "**/*.{js,cjs,ts,mjs,jsx,tsx}"',
        lint: "npm run eslint",
        lintfix: "npm run eslint -- --fix",
        test: "tap",
        posttest: "npm run lint",
        npmclilint: "npmcli-lint",
        postsnap: "npm run lintfix --",
        postlint: "template-oss-check",
        snap: "tap",
        "template-oss-apply": "template-oss-apply --force"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/npm/npm-registry-fetch.git"
      },
      keywords: [
        "npm",
        "registry",
        "fetch"
      ],
      author: "GitHub Inc.",
      license: "ISC",
      dependencies: {
        "@npmcli/redact": "^3.0.0",
        jsonparse: "^1.3.1",
        "make-fetch-happen": "^14.0.0",
        minipass: "^7.0.2",
        "minipass-fetch": "^4.0.0",
        minizlib: "^3.0.1",
        "npm-package-arg": "^12.0.0",
        "proc-log": "^5.0.0"
      },
      devDependencies: {
        "@npmcli/eslint-config": "^5.0.0",
        "@npmcli/template-oss": "4.23.4",
        cacache: "^19.0.1",
        nock: "^13.2.4",
        "require-inject": "^1.4.4",
        ssri: "^12.0.0",
        tap: "^16.0.1"
      },
      tap: {
        "check-coverage": true,
        "test-ignore": "test[\\\\/](util|cache)[\\\\/]",
        "nyc-arg": [
          "--exclude",
          "tap-snapshots/**"
        ]
      },
      engines: {
        node: "^18.17.0 || >=20.5.0"
      },
      templateOSS: {
        "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
        version: "4.23.4",
        publish: "true"
      }
    };
  }
});

// node_modules/npm-registry-fetch/lib/default-opts.js
var require_default_opts = __commonJS({
  "node_modules/npm-registry-fetch/lib/default-opts.js"(exports2, module2) {
    var pkg = require_package3();
    module2.exports = {
      maxSockets: 12,
      method: "GET",
      registry: "https://registry.npmjs.org/",
      timeout: 5 * 60 * 1e3,
      // 5 minutes
      strictSSL: true,
      noProxy: process.env.NOPROXY,
      userAgent: `${pkg.name}@${pkg.version}/node@${process.version}+${process.arch} (${process.platform})`
    };
  }
});

// node_modules/@npmcli/redact/lib/matchers.js
var require_matchers = __commonJS({
  "node_modules/@npmcli/redact/lib/matchers.js"(exports2, module2) {
    var TYPE_REGEX = "regex";
    var TYPE_URL = "url";
    var TYPE_PATH = "path";
    var NPM_SECRET = {
      type: TYPE_REGEX,
      pattern: /\b(npms?_)[a-zA-Z0-9]{36,48}\b/gi,
      replacement: `[REDACTED_NPM_SECRET]`
    };
    var AUTH_HEADER = {
      type: TYPE_REGEX,
      pattern: /\b(Basic\s+|Bearer\s+)[\w+=\-.]+\b/gi,
      replacement: `[REDACTED_AUTH_HEADER]`
    };
    var JSON_WEB_TOKEN = {
      type: TYPE_REGEX,
      pattern: /\b[A-Za-z0-9-_]{10,}(?!\.\d+\.)\.[A-Za-z0-9-_]{3,}\.[A-Za-z0-9-_]{20,}\b/gi,
      replacement: `[REDACTED_JSON_WEB_TOKEN]`
    };
    var UUID = {
      type: TYPE_REGEX,
      pattern: /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi,
      replacement: `[REDACTED_UUID]`
    };
    var URL_MATCHER = {
      type: TYPE_REGEX,
      pattern: /(?:https?|ftp):\/\/[^\s/"$.?#].[^\s"]*/gi,
      replacement: "[REDACTED_URL]"
    };
    var DEEP_HEADER_AUTHORIZATION = {
      type: TYPE_PATH,
      predicate: ({ path }) => path.endsWith(".headers.authorization"),
      replacement: "[REDACTED_HEADER_AUTHORIZATION]"
    };
    var DEEP_HEADER_SET_COOKIE = {
      type: TYPE_PATH,
      predicate: ({ path }) => path.endsWith(".headers.set-cookie"),
      replacement: "[REDACTED_HEADER_SET_COOKIE]"
    };
    var REWRITE_REQUEST = {
      type: TYPE_PATH,
      predicate: ({ path }) => path.endsWith(".request"),
      replacement: (input) => ({
        method: input?.method,
        path: input?.path,
        headers: input?.headers,
        url: input?.url
      })
    };
    var REWRITE_RESPONSE = {
      type: TYPE_PATH,
      predicate: ({ path }) => path.endsWith(".response"),
      replacement: (input) => ({
        data: input?.data,
        status: input?.status,
        headers: input?.headers
      })
    };
    module2.exports = {
      TYPE_REGEX,
      TYPE_URL,
      TYPE_PATH,
      NPM_SECRET,
      AUTH_HEADER,
      JSON_WEB_TOKEN,
      UUID,
      URL_MATCHER,
      DEEP_HEADER_AUTHORIZATION,
      DEEP_HEADER_SET_COOKIE,
      REWRITE_REQUEST,
      REWRITE_RESPONSE
    };
  }
});

// node_modules/@npmcli/redact/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/@npmcli/redact/lib/utils.js"(exports2, module2) {
    var {
      URL_MATCHER,
      TYPE_URL,
      TYPE_REGEX,
      TYPE_PATH
    } = require_matchers();
    var asterisk = (length = 0) => {
      length = typeof length === "string" ? length.length : length;
      if (length < 8) {
        return "*".repeat(8);
      }
      return "*".repeat(length);
    };
    var escapeRegExp = (text) => {
      return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, `\\$&`);
    };
    var urlEncodeRegexGroup = (value) => {
      const decoded = decodeURIComponent(value);
      const encoded = encodeURIComponent(value);
      const union = [.../* @__PURE__ */ new Set([encoded, decoded, value])].map(escapeRegExp).join("|");
      return union;
    };
    var urlEncodeRegexTag = (strings, ...values) => {
      let pattern = "";
      for (let i = 0; i < values.length; i++) {
        pattern += strings[i] + `(${urlEncodeRegexGroup(values[i])})`;
      }
      pattern += strings[strings.length - 1];
      return new RegExp(pattern);
    };
    var redactUrlHostnameMatcher = ({ hostname, replacement } = {}) => ({
      type: TYPE_URL,
      predicate: ({ url }) => url.hostname === hostname,
      pattern: ({ url }) => {
        return urlEncodeRegexTag`(^${url.protocol}//${url.username}:.+@)?${url.hostname}`;
      },
      replacement: `$1${replacement || asterisk()}`
    });
    var redactUrlSearchParamsMatcher = ({ param, replacement } = {}) => ({
      type: TYPE_URL,
      predicate: ({ url }) => url.searchParams.has(param),
      pattern: ({ url }) => urlEncodeRegexTag`(${param}=)${url.searchParams.get(param)}`,
      replacement: `$1${replacement || asterisk()}`
    });
    var redactUrlPasswordMatcher = ({ replacement } = {}) => ({
      type: TYPE_URL,
      predicate: ({ url }) => url.password,
      pattern: ({ url }) => urlEncodeRegexTag`(^${url.protocol}//${url.username}:)${url.password}`,
      replacement: `$1${replacement || asterisk()}`
    });
    var redactUrlReplacement = (...matchers) => (subValue) => {
      try {
        const url = new URL(subValue);
        return redactMatchers(...matchers)(subValue, { url });
      } catch (err) {
        return subValue;
      }
    };
    var redactUrlMatcher = (...matchers) => {
      return {
        ...URL_MATCHER,
        replacement: redactUrlReplacement(...matchers)
      };
    };
    var matcherFunctions = {
      [TYPE_REGEX]: (matcher) => (value) => {
        if (typeof value === "string") {
          value = value.replace(matcher.pattern, matcher.replacement);
        }
        return value;
      },
      [TYPE_URL]: (matcher) => (value, ctx) => {
        if (typeof value === "string") {
          try {
            const url = ctx?.url || new URL(value);
            const { predicate, pattern } = matcher;
            const predicateValue = predicate({ url });
            if (predicateValue) {
              value = value.replace(pattern({ url }), matcher.replacement);
            }
          } catch (_e) {
            return value;
          }
        }
        return value;
      },
      [TYPE_PATH]: (matcher) => (value, ctx) => {
        const rawPath = ctx?.path;
        const path = rawPath.join(".").toLowerCase();
        const { predicate, replacement } = matcher;
        const replace = typeof replacement === "function" ? replacement : () => replacement;
        const shouldRun = predicate({ rawPath, path });
        if (shouldRun) {
          value = replace(value, { rawPath, path });
        }
        return value;
      }
    };
    var redactMatcher = (matcher) => {
      return matcherFunctions[matcher.type](matcher);
    };
    var redactMatchers = (...matchers) => (value, ctx) => {
      const flatMatchers = matchers.flat();
      return flatMatchers.reduce((result, matcher) => {
        const fn = typeof matcher === "function" ? matcher : redactMatcher(matcher);
        return fn(result, ctx);
      }, value);
    };
    var redactDynamicReplacement = () => (value, start) => {
      if (typeof start === "number") {
        return asterisk(value);
      }
      return start + asterisk(value.substring(start.length).length);
    };
    var redactFixedReplacement = (length) => (_value, start) => {
      if (typeof start === "number") {
        return asterisk(length);
      }
      return start + asterisk(length);
    };
    var redactUrlPassword = (value, replacement) => {
      return redactMatchers(redactUrlPasswordMatcher({ replacement }))(value);
    };
    module2.exports = {
      asterisk,
      escapeRegExp,
      urlEncodeRegexGroup,
      urlEncodeRegexTag,
      redactUrlHostnameMatcher,
      redactUrlSearchParamsMatcher,
      redactUrlPasswordMatcher,
      redactUrlMatcher,
      redactUrlReplacement,
      redactDynamicReplacement,
      redactFixedReplacement,
      redactMatchers,
      redactUrlPassword
    };
  }
});

// node_modules/@npmcli/redact/lib/index.js
var require_lib28 = __commonJS({
  "node_modules/@npmcli/redact/lib/index.js"(exports2, module2) {
    var matchers = require_matchers();
    var { redactUrlPassword } = require_utils2();
    var REPLACE = "***";
    var redact = (value) => {
      if (typeof value !== "string" || !value) {
        return value;
      }
      return redactUrlPassword(value, REPLACE).replace(matchers.NPM_SECRET.pattern, `npm_${REPLACE}`).replace(matchers.UUID.pattern, REPLACE);
    };
    var splitAndRedact = (str) => {
      const splitChars = /[\s=]/g;
      let match = null;
      let result = "";
      let index = 0;
      while (match = splitChars.exec(str)) {
        result += redact(str.slice(index, match.index)) + match[0];
        index = splitChars.lastIndex;
      }
      return result + redact(str.slice(index));
    };
    var redactLog = (arg) => {
      if (typeof arg === "string") {
        return splitAndRedact(arg);
      } else if (Array.isArray(arg)) {
        return arg.map((a) => typeof a === "string" ? splitAndRedact(a) : a);
      }
      return arg;
    };
    module2.exports = {
      redact,
      redactLog
    };
  }
});

// node_modules/npm-registry-fetch/lib/check-response.js
var require_check_response = __commonJS({
  "node_modules/npm-registry-fetch/lib/check-response.js"(exports2, module2) {
    "use strict";
    var errors = require_errors3();
    var { Response } = require_lib27();
    var defaultOpts = require_default_opts();
    var { log } = require_lib4();
    var { redact: cleanUrl } = require_lib28();
    var moreInfoUrl = "https://github.com/npm/cli/wiki/No-auth-for-URI,-but-auth-present-for-scoped-registry";
    var checkResponse = async ({ method, uri, res, startTime, auth, opts }) => {
      opts = { ...defaultOpts, ...opts };
      if (res.headers.has("npm-notice") && !res.headers.has("x-local-cache")) {
        log.notice("", res.headers.get("npm-notice"));
      }
      if (res.status >= 400) {
        logRequest(method, res, startTime);
        if (auth && auth.scopeAuthKey && !auth.token && !auth.auth) {
          log.warn("registry", `No auth for URI, but auth present for scoped registry.

URI: ${uri}
Scoped Registry Key: ${auth.scopeAuthKey}

More info here: ${moreInfoUrl}`);
        }
        return checkErrors(method, res, startTime, opts);
      } else {
        res.body.on("end", () => logRequest(method, res, startTime, opts));
        if (opts.ignoreBody) {
          res.body.resume();
          return new Response(null, res);
        }
        return res;
      }
    };
    module2.exports = checkResponse;
    function logRequest(method, res, startTime) {
      const elapsedTime = Date.now() - startTime;
      const attempt = res.headers.get("x-fetch-attempts");
      const attemptStr = attempt && attempt > 1 ? ` attempt #${attempt}` : "";
      const cacheStatus = res.headers.get("x-local-cache-status");
      const cacheStr = cacheStatus ? ` (cache ${cacheStatus})` : "";
      const urlStr = cleanUrl(res.url);
      if (cacheStatus === "hit") {
        log.http(
          "cache",
          `${urlStr} ${elapsedTime}ms${attemptStr}${cacheStr}`
        );
      } else {
        log.http(
          "fetch",
          `${method.toUpperCase()} ${res.status} ${urlStr} ${elapsedTime}ms${attemptStr}${cacheStr}`
        );
      }
    }
    function checkErrors(method, res, startTime, opts) {
      return res.buffer().catch(() => null).then((body) => {
        let parsed = body;
        try {
          parsed = JSON.parse(body.toString("utf8"));
        } catch {
        }
        if (res.status === 401 && res.headers.get("www-authenticate")) {
          const auth = res.headers.get("www-authenticate").split(/,\s*/).map((s) => s.toLowerCase());
          if (auth.indexOf("ipaddress") !== -1) {
            throw new errors.HttpErrorAuthIPAddress(
              method,
              res,
              parsed,
              opts.spec
            );
          } else if (auth.indexOf("otp") !== -1) {
            throw new errors.HttpErrorAuthOTP(
              method,
              res,
              parsed,
              opts.spec
            );
          } else {
            throw new errors.HttpErrorAuthUnknown(
              method,
              res,
              parsed,
              opts.spec
            );
          }
        } else if (res.status === 401 && body != null && /one-time pass/.test(body.toString("utf8"))) {
          throw new errors.HttpErrorAuthOTP(
            method,
            res,
            parsed,
            opts.spec
          );
        } else {
          throw new errors.HttpErrorGeneral(
            method,
            res,
            parsed,
            opts.spec
          );
        }
      });
    }
  }
});

// node_modules/npm-registry-fetch/lib/auth.js
var require_auth = __commonJS({
  "node_modules/npm-registry-fetch/lib/auth.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var npa = require_npa();
    var { URL: URL2 } = require("url");
    var regFromURI = (uri, opts) => {
      const parsed = new URL2(uri);
      let regKey = `//${parsed.host}${parsed.pathname}`;
      while (regKey.length > "//".length) {
        const authKey = hasAuth(regKey, opts);
        if (authKey) {
          return { regKey, authKey };
        }
        regKey = regKey.replace(/([^/]+|\/)$/, "");
      }
      return { regKey: false, authKey: null };
    };
    var hasAuth = (regKey, opts) => {
      if (opts[`${regKey}:_authToken`]) {
        return "_authToken";
      }
      if (opts[`${regKey}:_auth`]) {
        return "_auth";
      }
      if (opts[`${regKey}:username`] && opts[`${regKey}:_password`]) {
        return "username";
      }
      if (opts[`${regKey}:certfile`] && opts[`${regKey}:keyfile`]) {
        return "certfile";
      }
      return false;
    };
    var sameHost = (a, b) => {
      const parsedA = new URL2(a);
      const parsedB = new URL2(b);
      return parsedA.host === parsedB.host;
    };
    var getRegistry = (opts) => {
      const { spec } = opts;
      const { scope: specScope, subSpec } = spec ? npa(spec) : {};
      const subSpecScope = subSpec && subSpec.scope;
      const scope = subSpec ? subSpecScope : specScope;
      const scopeReg = scope && opts[`${scope}:registry`];
      return scopeReg || opts.registry;
    };
    var maybeReadFile = (file) => {
      try {
        return fs2.readFileSync(file, "utf8");
      } catch (er) {
        if (er.code !== "ENOENT") {
          throw er;
        }
        return null;
      }
    };
    var getAuth = (uri, opts = {}) => {
      const { forceAuth } = opts;
      if (!uri) {
        throw new Error("URI is required");
      }
      const { regKey, authKey } = regFromURI(uri, forceAuth || opts);
      if (forceAuth && !regKey) {
        return new Auth({
          // if we force auth we don't want to refer back to anything in config
          regKey: false,
          authKey: null,
          scopeAuthKey: null,
          token: forceAuth._authToken || forceAuth.token,
          username: forceAuth.username,
          password: forceAuth._password || forceAuth.password,
          auth: forceAuth._auth || forceAuth.auth,
          certfile: forceAuth.certfile,
          keyfile: forceAuth.keyfile
        });
      }
      if (!regKey) {
        const registry = getRegistry(opts);
        if (registry && uri !== registry && sameHost(uri, registry)) {
          return getAuth(registry, opts);
        } else if (registry !== opts.registry) {
          const { regKey: scopeAuthKey, authKey: _authKey } = regFromURI(registry, opts);
          return new Auth({ scopeAuthKey, regKey: scopeAuthKey, authKey: _authKey });
        }
      }
      const {
        [`${regKey}:_authToken`]: token,
        [`${regKey}:username`]: username,
        [`${regKey}:_password`]: password,
        [`${regKey}:_auth`]: auth,
        [`${regKey}:certfile`]: certfile,
        [`${regKey}:keyfile`]: keyfile
      } = opts;
      return new Auth({
        scopeAuthKey: null,
        regKey,
        authKey,
        token,
        auth,
        username,
        password,
        certfile,
        keyfile
      });
    };
    var Auth = class {
      constructor({
        token,
        auth,
        username,
        password,
        scopeAuthKey,
        certfile,
        keyfile,
        regKey,
        authKey
      }) {
        this.scopeAuthKey = scopeAuthKey;
        this.regKey = regKey;
        this.authKey = authKey;
        this.token = null;
        this.auth = null;
        this.isBasicAuth = false;
        this.cert = null;
        this.key = null;
        if (token) {
          this.token = token;
        } else if (auth) {
          this.auth = auth;
        } else if (username && password) {
          const p = Buffer.from(password, "base64").toString("utf8");
          this.auth = Buffer.from(`${username}:${p}`, "utf8").toString("base64");
          this.isBasicAuth = true;
        }
        if (certfile && keyfile) {
          const cert = maybeReadFile(certfile, "utf-8");
          const key = maybeReadFile(keyfile, "utf-8");
          if (cert && key) {
            this.cert = cert;
            this.key = key;
          }
        }
      }
    };
    module2.exports = getAuth;
  }
});

// node_modules/make-fetch-happen/lib/options.js
var require_options2 = __commonJS({
  "node_modules/make-fetch-happen/lib/options.js"(exports2, module2) {
    var dns = require("dns");
    var conditionalHeaders = [
      "if-modified-since",
      "if-none-match",
      "if-unmodified-since",
      "if-match",
      "if-range"
    ];
    var configureOptions = (opts) => {
      const { strictSSL, ...options } = { ...opts };
      options.method = options.method ? options.method.toUpperCase() : "GET";
      if (strictSSL === void 0 || strictSSL === null) {
        options.rejectUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0";
      } else {
        options.rejectUnauthorized = strictSSL !== false;
      }
      if (!options.retry) {
        options.retry = { retries: 0 };
      } else if (typeof options.retry === "string") {
        const retries = parseInt(options.retry, 10);
        if (isFinite(retries)) {
          options.retry = { retries };
        } else {
          options.retry = { retries: 0 };
        }
      } else if (typeof options.retry === "number") {
        options.retry = { retries: options.retry };
      } else {
        options.retry = { retries: 0, ...options.retry };
      }
      options.dns = { ttl: 5 * 60 * 1e3, lookup: dns.lookup, ...options.dns };
      options.cache = options.cache || "default";
      if (options.cache === "default") {
        const hasConditionalHeader = Object.keys(options.headers || {}).some((name) => {
          return conditionalHeaders.includes(name.toLowerCase());
        });
        if (hasConditionalHeader) {
          options.cache = "no-store";
        }
      }
      options.cacheAdditionalHeaders = options.cacheAdditionalHeaders || [];
      if (options.cacheManager && !options.cachePath) {
        options.cachePath = options.cacheManager;
      }
      return options;
    };
    module2.exports = configureOptions;
  }
});

// node_modules/http-cache-semantics/index.js
var require_http_cache_semantics = __commonJS({
  "node_modules/http-cache-semantics/index.js"(exports2, module2) {
    "use strict";
    var statusCodeCacheableByDefault = /* @__PURE__ */ new Set([
      200,
      203,
      204,
      206,
      300,
      301,
      308,
      404,
      405,
      410,
      414,
      501
    ]);
    var understoodStatuses = /* @__PURE__ */ new Set([
      200,
      203,
      204,
      300,
      301,
      302,
      303,
      307,
      308,
      404,
      405,
      410,
      414,
      501
    ]);
    var errorStatusCodes = /* @__PURE__ */ new Set([
      500,
      502,
      503,
      504
    ]);
    var hopByHopHeaders = {
      date: true,
      // included, because we add Age update Date
      connection: true,
      "keep-alive": true,
      "proxy-authenticate": true,
      "proxy-authorization": true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true
    };
    var excludedFromRevalidationUpdate = {
      // Since the old body is reused, it doesn't make sense to change properties of the body
      "content-length": true,
      "content-encoding": true,
      "transfer-encoding": true,
      "content-range": true
    };
    function toNumberOrZero(s) {
      const n = parseInt(s, 10);
      return isFinite(n) ? n : 0;
    }
    function isErrorResponse(response) {
      if (!response) {
        return true;
      }
      return errorStatusCodes.has(response.status);
    }
    function parseCacheControl(header) {
      const cc = {};
      if (!header) return cc;
      const parts = header.trim().split(/,/);
      for (const part of parts) {
        const [k, v] = part.split(/=/, 2);
        cc[k.trim()] = v === void 0 ? true : v.trim().replace(/^"|"$/g, "");
      }
      return cc;
    }
    function formatCacheControl(cc) {
      let parts = [];
      for (const k in cc) {
        const v = cc[k];
        parts.push(v === true ? k : k + "=" + v);
      }
      if (!parts.length) {
        return void 0;
      }
      return parts.join(", ");
    }
    module2.exports = class CachePolicy {
      constructor(req, res, {
        shared,
        cacheHeuristic,
        immutableMinTimeToLive,
        ignoreCargoCult,
        _fromObject
      } = {}) {
        if (_fromObject) {
          this._fromObject(_fromObject);
          return;
        }
        if (!res || !res.headers) {
          throw Error("Response headers missing");
        }
        this._assertRequestHasHeaders(req);
        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._cacheHeuristic = void 0 !== cacheHeuristic ? cacheHeuristic : 0.1;
        this._immutableMinTtl = void 0 !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1e3;
        this._status = "status" in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers["cache-control"]);
        this._method = "method" in req ? req.method : "GET";
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null;
        this._reqcc = parseCacheControl(req.headers["cache-control"]);
        if (ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
          delete this._rescc["pre-check"];
          delete this._rescc["post-check"];
          delete this._rescc["no-cache"];
          delete this._rescc["no-store"];
          delete this._rescc["must-revalidate"];
          this._resHeaders = Object.assign({}, this._resHeaders, {
            "cache-control": formatCacheControl(this._rescc)
          });
          delete this._resHeaders.expires;
          delete this._resHeaders.pragma;
        }
        if (res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma)) {
          this._rescc["no-cache"] = true;
        }
      }
      now() {
        return Date.now();
      }
      storable() {
        return !!(!this._reqcc["no-store"] && // A cache MUST NOT store a response to any request, unless:
        // The request method is understood by the cache and defined as being cacheable, and
        ("GET" === this._method || "HEAD" === this._method || "POST" === this._method && this._hasExplicitExpiration()) && // the response status code is understood by the cache, and
        understoodStatuses.has(this._status) && // the "no-store" cache directive does not appear in request or response header fields, and
        !this._rescc["no-store"] && // the "private" response directive does not appear in the response, if the cache is shared, and
        (!this._isShared || !this._rescc.private) && // the Authorization header field does not appear in the request, if the cache is shared,
        (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && // the response either:
        // contains an Expires header field, or
        (this._resHeaders.expires || // contains a max-age response directive, or
        // contains a s-maxage response directive and the cache is shared, or
        // contains a public response directive.
        this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || // has a status code that is defined as cacheable by default
        statusCodeCacheableByDefault.has(this._status)));
      }
      _hasExplicitExpiration() {
        return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
      }
      _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
          throw Error("Request headers missing");
        }
      }
      satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);
        const requestCC = parseCacheControl(req.headers["cache-control"]);
        if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
          return false;
        }
        if (requestCC["max-age"] && this.age() > requestCC["max-age"]) {
          return false;
        }
        if (requestCC["min-fresh"] && this.timeToLive() < 1e3 * requestCC["min-fresh"]) {
          return false;
        }
        if (this.stale()) {
          const allowsStale = requestCC["max-stale"] && !this._rescc["must-revalidate"] && (true === requestCC["max-stale"] || requestCC["max-stale"] > this.age() - this.maxAge());
          if (!allowsStale) {
            return false;
          }
        }
        return this._requestMatches(req, false);
      }
      _requestMatches(req, allowHeadMethod) {
        return (!this._url || this._url === req.url) && this._host === req.headers.host && // the request method associated with the stored response allows it to be used for the presented request, and
        (!req.method || this._method === req.method || allowHeadMethod && "HEAD" === req.method) && // selecting header fields nominated by the stored response (if any) match those presented, and
        this._varyMatches(req);
      }
      _allowsStoringAuthenticated() {
        return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
      }
      _varyMatches(req) {
        if (!this._resHeaders.vary) {
          return true;
        }
        if (this._resHeaders.vary === "*") {
          return false;
        }
        const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for (const name of fields) {
          if (req.headers[name] !== this._reqHeaders[name]) return false;
        }
        return true;
      }
      _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for (const name in inHeaders) {
          if (hopByHopHeaders[name]) continue;
          headers[name] = inHeaders[name];
        }
        if (inHeaders.connection) {
          const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
          for (const name of tokens) {
            delete headers[name];
          }
        }
        if (headers.warning) {
          const warnings = headers.warning.split(/,/).filter((warning) => {
            return !/^\s*1[0-9][0-9]/.test(warning);
          });
          if (!warnings.length) {
            delete headers.warning;
          } else {
            headers.warning = warnings.join(",").trim();
          }
        }
        return headers;
      }
      responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();
        if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
          headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
      }
      /**
       * Value of the Date response header or current time if Date was invalid
       * @return timestamp
       */
      date() {
        const serverDate = Date.parse(this._resHeaders.date);
        if (isFinite(serverDate)) {
          return serverDate;
        }
        return this._responseTime;
      }
      /**
       * Value of the Age header, in seconds, updated for the current time.
       * May be fractional.
       *
       * @return Number
       */
      age() {
        let age = this._ageValue();
        const residentTime = (this.now() - this._responseTime) / 1e3;
        return age + residentTime;
      }
      _ageValue() {
        return toNumberOrZero(this._resHeaders.age);
      }
      /**
       * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
       *
       * For an up-to-date value, see `timeToLive()`.
       *
       * @return Number
       */
      maxAge() {
        if (!this.storable() || this._rescc["no-cache"]) {
          return 0;
        }
        if (this._isShared && (this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable)) {
          return 0;
        }
        if (this._resHeaders.vary === "*") {
          return 0;
        }
        if (this._isShared) {
          if (this._rescc["proxy-revalidate"]) {
            return 0;
          }
          if (this._rescc["s-maxage"]) {
            return toNumberOrZero(this._rescc["s-maxage"]);
          }
        }
        if (this._rescc["max-age"]) {
          return toNumberOrZero(this._rescc["max-age"]);
        }
        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
        const serverDate = this.date();
        if (this._resHeaders.expires) {
          const expires = Date.parse(this._resHeaders.expires);
          if (Number.isNaN(expires) || expires < serverDate) {
            return 0;
          }
          return Math.max(defaultMinTtl, (expires - serverDate) / 1e3);
        }
        if (this._resHeaders["last-modified"]) {
          const lastModified = Date.parse(this._resHeaders["last-modified"]);
          if (isFinite(lastModified) && serverDate > lastModified) {
            return Math.max(
              defaultMinTtl,
              (serverDate - lastModified) / 1e3 * this._cacheHeuristic
            );
          }
        }
        return defaultMinTtl;
      }
      timeToLive() {
        const age = this.maxAge() - this.age();
        const staleIfErrorAge = age + toNumberOrZero(this._rescc["stale-if-error"]);
        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
        return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1e3;
      }
      stale() {
        return this.maxAge() <= this.age();
      }
      _useStaleIfError() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
      }
      useStaleWhileRevalidate() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-while-revalidate"]) > this.age();
      }
      static fromObject(obj) {
        return new this(void 0, void 0, { _fromObject: obj });
      }
      _fromObject(obj) {
        if (this._responseTime) throw Error("Reinitialized");
        if (!obj || obj.v !== 1) throw Error("Invalid serialization");
        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
      }
      toObject() {
        return {
          v: 1,
          t: this._responseTime,
          sh: this._isShared,
          ch: this._cacheHeuristic,
          imm: this._immutableMinTtl,
          st: this._status,
          resh: this._resHeaders,
          rescc: this._rescc,
          m: this._method,
          u: this._url,
          h: this._host,
          a: this._noAuthorization,
          reqh: this._reqHeaders,
          reqcc: this._reqcc
        };
      }
      /**
       * Headers for sending to the origin server to revalidate stale response.
       * Allows server to return 304 to allow reuse of the previous response.
       *
       * Hop by hop headers are always stripped.
       * Revalidation headers may be added or removed, depending on request.
       */
      revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
        delete headers["if-range"];
        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
          delete headers["if-none-match"];
          delete headers["if-modified-since"];
          return headers;
        }
        if (this._resHeaders.etag) {
          headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
        }
        const forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
        if (forbidsWeakValidators) {
          delete headers["if-modified-since"];
          if (headers["if-none-match"]) {
            const etags = headers["if-none-match"].split(/,/).filter((etag) => {
              return !/^\s*W\//.test(etag);
            });
            if (!etags.length) {
              delete headers["if-none-match"];
            } else {
              headers["if-none-match"] = etags.join(",").trim();
            }
          }
        } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) {
          headers["if-modified-since"] = this._resHeaders["last-modified"];
        }
        return headers;
      }
      /**
       * Creates new CachePolicy with information combined from the previews response,
       * and the new revalidation response.
       *
       * Returns {policy, modified} where modified is a boolean indicating
       * whether the response body has been modified, and old cached body can't be used.
       *
       * @return {Object} {policy: CachePolicy, modified: Boolean}
       */
      revalidatedPolicy(request, response) {
        this._assertRequestHasHeaders(request);
        if (this._useStaleIfError() && isErrorResponse(response)) {
          return {
            modified: false,
            matches: false,
            policy: this
          };
        }
        if (!response || !response.headers) {
          throw Error("Response headers missing");
        }
        let matches = false;
        if (response.status !== void 0 && response.status != 304) {
          matches = false;
        } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
          matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
          matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "");
        } else if (this._resHeaders["last-modified"]) {
          matches = this._resHeaders["last-modified"] === response.headers["last-modified"];
        } else {
          if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"]) {
            matches = true;
          }
        }
        if (!matches) {
          return {
            policy: new this.constructor(request, response),
            // Client receiving 304 without body, even if it's invalid/mismatched has no option
            // but to reuse a cached body. We don't have a good way to tell clients to do
            // error recovery in such case.
            modified: response.status != 304,
            matches: false
          };
        }
        const headers = {};
        for (const k in this._resHeaders) {
          headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
        }
        const newResponse = Object.assign({}, response, {
          status: this._status,
          method: this._method,
          headers
        });
        return {
          policy: new this.constructor(request, newResponse, {
            shared: this._isShared,
            cacheHeuristic: this._cacheHeuristic,
            immutableMinTimeToLive: this._immutableMinTtl
          }),
          modified: false,
          matches: true
        };
      }
    };
  }
});

// node_modules/negotiator/lib/charset.js
var require_charset = __commonJS({
  "node_modules/negotiator/lib/charset.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredCharsets;
    module2.exports.preferredCharsets = preferredCharsets;
    var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptCharset(accept) {
      var accepts = accept.split(",");
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var charset = parseCharset(accepts[i].trim(), i);
        if (charset) {
          accepts[j++] = charset;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseCharset(str, i) {
      var match = simpleCharsetRegExp.exec(str);
      if (!match) return null;
      var charset = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split("=");
          if (p[0] === "q") {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
      return {
        charset,
        q,
        i
      };
    }
    function getCharsetPriority(charset, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(charset, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(charset, spec, index) {
      var s = 0;
      if (spec.charset.toLowerCase() === charset.toLowerCase()) {
        s |= 1;
      } else if (spec.charset !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredCharsets(accept, provided) {
      var accepts = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getCharsetPriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullCharset(spec) {
      return spec.charset;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/encoding.js
var require_encoding2 = __commonJS({
  "node_modules/negotiator/lib/encoding.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredEncodings;
    module2.exports.preferredEncodings = preferredEncodings;
    var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptEncoding(accept) {
      var accepts = accept.split(",");
      var hasIdentity = false;
      var minQuality = 1;
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var encoding = parseEncoding(accepts[i].trim(), i);
        if (encoding) {
          accepts[j++] = encoding;
          hasIdentity = hasIdentity || specify("identity", encoding);
          minQuality = Math.min(minQuality, encoding.q || 1);
        }
      }
      if (!hasIdentity) {
        accepts[j++] = {
          encoding: "identity",
          q: minQuality,
          i
        };
      }
      accepts.length = j;
      return accepts;
    }
    function parseEncoding(str, i) {
      var match = simpleEncodingRegExp.exec(str);
      if (!match) return null;
      var encoding = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split("=");
          if (p[0] === "q") {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
      return {
        encoding,
        q,
        i
      };
    }
    function getEncodingPriority(encoding, accepted, index) {
      var priority = { encoding, o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(encoding, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(encoding, spec, index) {
      var s = 0;
      if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
        s |= 1;
      } else if (spec.encoding !== "*") {
        return null;
      }
      return {
        encoding,
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredEncodings(accept, provided, preferred) {
      var accepts = parseAcceptEncoding(accept || "");
      var comparator = preferred ? function comparator2(a, b) {
        if (a.q !== b.q) {
          return b.q - a.q;
        }
        var aPreferred = preferred.indexOf(a.encoding);
        var bPreferred = preferred.indexOf(b.encoding);
        if (aPreferred === -1 && bPreferred === -1) {
          return b.s - a.s || a.o - b.o || a.i - b.i;
        }
        if (aPreferred !== -1 && bPreferred !== -1) {
          return aPreferred - bPreferred;
        }
        return aPreferred === -1 ? 1 : -1;
      } : compareSpecs;
      if (!provided) {
        return accepts.filter(isQuality).sort(comparator).map(getFullEncoding);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getEncodingPriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(comparator).map(function getEncoding(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i;
    }
    function getFullEncoding(spec) {
      return spec.encoding;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/language.js
var require_language = __commonJS({
  "node_modules/negotiator/lib/language.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredLanguages;
    module2.exports.preferredLanguages = preferredLanguages;
    var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
    function parseAcceptLanguage(accept) {
      var accepts = accept.split(",");
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var language = parseLanguage(accepts[i].trim(), i);
        if (language) {
          accepts[j++] = language;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseLanguage(str, i) {
      var match = simpleLanguageRegExp.exec(str);
      if (!match) return null;
      var prefix = match[1];
      var suffix = match[2];
      var full = prefix;
      if (suffix) full += "-" + suffix;
      var q = 1;
      if (match[3]) {
        var params = match[3].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].split("=");
          if (p[0] === "q") q = parseFloat(p[1]);
        }
      }
      return {
        prefix,
        suffix,
        q,
        i,
        full
      };
    }
    function getLanguagePriority(language, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(language, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(language, spec, index) {
      var p = parseLanguage(language);
      if (!p) return null;
      var s = 0;
      if (spec.full.toLowerCase() === p.full.toLowerCase()) {
        s |= 4;
      } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
        s |= 2;
      } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
        s |= 1;
      } else if (spec.full !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredLanguages(accept, provided) {
      var accepts = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getLanguagePriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullLanguage(spec) {
      return spec.full;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/mediaType.js
var require_mediaType = __commonJS({
  "node_modules/negotiator/lib/mediaType.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredMediaTypes;
    module2.exports.preferredMediaTypes = preferredMediaTypes;
    var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
    function parseAccept(accept) {
      var accepts = splitMediaTypes(accept);
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var mediaType = parseMediaType(accepts[i].trim(), i);
        if (mediaType) {
          accepts[j++] = mediaType;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseMediaType(str, i) {
      var match = simpleMediaTypeRegExp.exec(str);
      if (!match) return null;
      var params = /* @__PURE__ */ Object.create(null);
      var q = 1;
      var subtype = match[2];
      var type = match[1];
      if (match[3]) {
        var kvps = splitParameters(match[3]).map(splitKeyValuePair);
        for (var j = 0; j < kvps.length; j++) {
          var pair = kvps[j];
          var key = pair[0].toLowerCase();
          var val = pair[1];
          var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.slice(1, -1) : val;
          if (key === "q") {
            q = parseFloat(value);
            break;
          }
          params[key] = value;
        }
      }
      return {
        type,
        subtype,
        params,
        q,
        i
      };
    }
    function getMediaTypePriority(type, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(type, accepted[i], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(type, spec, index) {
      var p = parseMediaType(type);
      var s = 0;
      if (!p) {
        return null;
      }
      if (spec.type.toLowerCase() == p.type.toLowerCase()) {
        s |= 4;
      } else if (spec.type != "*") {
        return null;
      }
      if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
        s |= 2;
      } else if (spec.subtype != "*") {
        return null;
      }
      var keys = Object.keys(spec.params);
      if (keys.length > 0) {
        if (keys.every(function(k) {
          return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
        })) {
          s |= 1;
        } else {
          return null;
        }
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    function preferredMediaTypes(accept, provided) {
      var accepts = parseAccept(accept === void 0 ? "*/*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getMediaTypePriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullType(spec) {
      return spec.type + "/" + spec.subtype;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
    function quoteCount(string) {
      var count = 0;
      var index = 0;
      while ((index = string.indexOf('"', index)) !== -1) {
        count++;
        index++;
      }
      return count;
    }
    function splitKeyValuePair(str) {
      var index = str.indexOf("=");
      var key;
      var val;
      if (index === -1) {
        key = str;
      } else {
        key = str.slice(0, index);
        val = str.slice(index + 1);
      }
      return [key, val];
    }
    function splitMediaTypes(accept) {
      var accepts = accept.split(",");
      for (var i = 1, j = 0; i < accepts.length; i++) {
        if (quoteCount(accepts[j]) % 2 == 0) {
          accepts[++j] = accepts[i];
        } else {
          accepts[j] += "," + accepts[i];
        }
      }
      accepts.length = j + 1;
      return accepts;
    }
    function splitParameters(str) {
      var parameters = str.split(";");
      for (var i = 1, j = 0; i < parameters.length; i++) {
        if (quoteCount(parameters[j]) % 2 == 0) {
          parameters[++j] = parameters[i];
        } else {
          parameters[j] += ";" + parameters[i];
        }
      }
      parameters.length = j + 1;
      for (var i = 0; i < parameters.length; i++) {
        parameters[i] = parameters[i].trim();
      }
      return parameters;
    }
  }
});

// node_modules/negotiator/index.js
var require_negotiator = __commonJS({
  "node_modules/negotiator/index.js"(exports2, module2) {
    "use strict";
    var preferredCharsets = require_charset();
    var preferredEncodings = require_encoding2();
    var preferredLanguages = require_language();
    var preferredMediaTypes = require_mediaType();
    module2.exports = Negotiator;
    module2.exports.Negotiator = Negotiator;
    function Negotiator(request) {
      if (!(this instanceof Negotiator)) {
        return new Negotiator(request);
      }
      this.request = request;
    }
    Negotiator.prototype.charset = function charset(available) {
      var set = this.charsets(available);
      return set && set[0];
    };
    Negotiator.prototype.charsets = function charsets(available) {
      return preferredCharsets(this.request.headers["accept-charset"], available);
    };
    Negotiator.prototype.encoding = function encoding(available, opts) {
      var set = this.encodings(available, opts);
      return set && set[0];
    };
    Negotiator.prototype.encodings = function encodings(available, options) {
      var opts = options || {};
      return preferredEncodings(this.request.headers["accept-encoding"], available, opts.preferred);
    };
    Negotiator.prototype.language = function language(available) {
      var set = this.languages(available);
      return set && set[0];
    };
    Negotiator.prototype.languages = function languages(available) {
      return preferredLanguages(this.request.headers["accept-language"], available);
    };
    Negotiator.prototype.mediaType = function mediaType(available) {
      var set = this.mediaTypes(available);
      return set && set[0];
    };
    Negotiator.prototype.mediaTypes = function mediaTypes(available) {
      return preferredMediaTypes(this.request.headers.accept, available);
    };
    Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
    Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
    Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
    Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
    Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
    Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
    Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
    Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  }
});

// node_modules/make-fetch-happen/lib/cache/policy.js
var require_policy = __commonJS({
  "node_modules/make-fetch-happen/lib/cache/policy.js"(exports2, module2) {
    var CacheSemantics = require_http_cache_semantics();
    var Negotiator = require_negotiator();
    var ssri = require_lib15();
    var policyOptions = {
      shared: false,
      ignoreCargoCult: true
    };
    var emptyResponse = { status: 200, headers: {} };
    var requestObject = (request) => {
      const _obj = {
        method: request.method,
        url: request.url,
        headers: {},
        compress: request.compress
      };
      request.headers.forEach((value, key) => {
        _obj.headers[key] = value;
      });
      return _obj;
    };
    var responseObject = (response) => {
      const _obj = {
        status: response.status,
        headers: {}
      };
      response.headers.forEach((value, key) => {
        _obj.headers[key] = value;
      });
      return _obj;
    };
    var CachePolicy = class {
      constructor({ entry, request, response, options }) {
        this.entry = entry;
        this.request = requestObject(request);
        this.response = responseObject(response);
        this.options = options;
        this.policy = new CacheSemantics(this.request, this.response, policyOptions);
        if (this.entry) {
          this.policy._responseTime = this.entry.metadata.time;
        }
      }
      // static method to quickly determine if a request alone is storable
      static storable(request, options) {
        if (!options.cachePath) {
          return false;
        }
        if (options.cache === "no-store") {
          return false;
        }
        if (!["GET", "HEAD"].includes(request.method)) {
          return false;
        }
        const policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions);
        return policy.storable();
      }
      // returns true if the policy satisfies the request
      satisfies(request) {
        const _req = requestObject(request);
        if (this.request.headers.host !== _req.headers.host) {
          return false;
        }
        if (this.request.compress !== _req.compress) {
          return false;
        }
        const negotiatorA = new Negotiator(this.request);
        const negotiatorB = new Negotiator(_req);
        if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes())) {
          return false;
        }
        if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages())) {
          return false;
        }
        if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings())) {
          return false;
        }
        if (this.options.integrity) {
          return ssri.parse(this.options.integrity).match(this.entry.integrity);
        }
        return true;
      }
      // returns true if the request and response allow caching
      storable() {
        return this.policy.storable();
      }
      // NOTE: this is a hack to avoid parsing the cache-control
      // header ourselves, it returns true if the response's
      // cache-control contains must-revalidate
      get mustRevalidate() {
        return !!this.policy._rescc["must-revalidate"];
      }
      // returns true if the cached response requires revalidation
      // for the given request
      needsRevalidation(request) {
        const _req = requestObject(request);
        _req.method = "GET";
        return !this.policy.satisfiesWithoutRevalidation(_req);
      }
      responseHeaders() {
        return this.policy.responseHeaders();
      }
      // returns a new object containing the appropriate headers
      // to send a revalidation request
      revalidationHeaders(request) {
        const _req = requestObject(request);
        return this.policy.revalidationHeaders(_req);
      }
      // returns true if the request/response was revalidated
      // successfully. returns false if a new response was received
      revalidated(request, response) {
        const _req = requestObject(request);
        const _res = responseObject(response);
        const policy = this.policy.revalidatedPolicy(_req, _res);
        return !policy.modified;
      }
    };
    module2.exports = CachePolicy;
  }
});

// node_modules/make-fetch-happen/lib/cache/errors.js
var require_errors4 = __commonJS({
  "node_modules/make-fetch-happen/lib/cache/errors.js"(exports2, module2) {
    var NotCachedError = class extends Error {
      constructor(url) {
        super(`request to ${url} failed: cache mode is 'only-if-cached' but no cached response is available.`);
        this.code = "ENOTCACHED";
      }
    };
    module2.exports = {
      NotCachedError
    };
  }
});

// node_modules/make-fetch-happen/lib/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/make-fetch-happen/lib/pipeline.js"(exports2, module2) {
    "use strict";
    var MinipassPipeline = require_minipass_pipeline();
    var CachingMinipassPipeline = class extends MinipassPipeline {
      #events = [];
      #data = /* @__PURE__ */ new Map();
      constructor(opts, ...streams) {
        super();
        this.#events = opts.events;
        if (streams.length) {
          this.push(...streams);
        }
      }
      on(event, handler) {
        if (this.#events.includes(event) && this.#data.has(event)) {
          return handler(...this.#data.get(event));
        }
        return super.on(event, handler);
      }
      emit(event, ...data) {
        if (this.#events.includes(event)) {
          this.#data.set(event, data);
        }
        return super.emit(event, ...data);
      }
    };
    module2.exports = CachingMinipassPipeline;
  }
});

// node_modules/make-fetch-happen/lib/cache/key.js
var require_key = __commonJS({
  "node_modules/make-fetch-happen/lib/cache/key.js"(exports2, module2) {
    var { URL: URL2, format } = require("url");
    var formatOptions = {
      auth: false,
      fragment: false,
      search: true,
      unicode: false
    };
    var cacheKey = (request) => {
      const parsed = new URL2(request.url);
      return `make-fetch-happen:request-cache:${format(parsed, formatOptions)}`;
    };
    module2.exports = cacheKey;
  }
});

// node_modules/@npmcli/agent/lib/dns.js
var require_dns = __commonJS({
  "node_modules/@npmcli/agent/lib/dns.js"(exports2, module2) {
    "use strict";
    var { LRUCache } = require_commonjs2();
    var dns = require("dns");
    var cache = new LRUCache({ max: 50 });
    var getOptions = ({
      family = 0,
      hints = dns.ADDRCONFIG,
      all = false,
      verbatim = void 0,
      ttl = 5 * 60 * 1e3,
      lookup = dns.lookup
    }) => ({
      // hints and lookup are returned since both are top level properties to (net|tls).connect
      hints,
      lookup: (hostname, ...args) => {
        const callback = args.pop();
        const lookupOptions = args[0] ?? {};
        const options = {
          family,
          hints,
          all,
          verbatim,
          ...typeof lookupOptions === "number" ? { family: lookupOptions } : lookupOptions
        };
        const key = JSON.stringify({ hostname, ...options });
        if (cache.has(key)) {
          const cached = cache.get(key);
          return process.nextTick(callback, null, ...cached);
        }
        lookup(hostname, options, (err, ...result) => {
          if (err) {
            return callback(err);
          }
          cache.set(key, result, { ttl });
          return callback(null, ...result);
        });
      }
    });
    module2.exports = {
      cache,
      getOptions
    };
  }
});

// node_modules/@npmcli/agent/lib/options.js
var require_options3 = __commonJS({
  "node_modules/@npmcli/agent/lib/options.js"(exports2, module2) {
    "use strict";
    var dns = require_dns();
    var normalizeOptions = (opts) => {
      const family = parseInt(opts.family ?? "0", 10);
      const keepAlive = opts.keepAlive ?? true;
      const normalized = {
        // nodejs http agent options. these are all the defaults
        // but kept here to increase the likelihood of cache hits
        // https://nodejs.org/api/http.html#new-agentoptions
        keepAliveMsecs: keepAlive ? 1e3 : void 0,
        maxSockets: opts.maxSockets ?? 15,
        maxTotalSockets: Infinity,
        maxFreeSockets: keepAlive ? 256 : void 0,
        scheduling: "fifo",
        // then spread the rest of the options
        ...opts,
        // we already set these to their defaults that we want
        family,
        keepAlive,
        // our custom timeout options
        timeouts: {
          // the standard timeout option is mapped to our idle timeout
          // and then deleted below
          idle: opts.timeout ?? 0,
          connection: 0,
          response: 0,
          transfer: 0,
          ...opts.timeouts
        },
        // get the dns options that go at the top level of socket connection
        ...dns.getOptions({ family, ...opts.dns })
      };
      delete normalized.timeout;
      return normalized;
    };
    var createKey = (obj) => {
      let key = "";
      const sorted = Object.entries(obj).sort((a, b) => a[0] - b[0]);
      for (let [k, v] of sorted) {
        if (v == null) {
          v = "null";
        } else if (v instanceof URL) {
          v = v.toString();
        } else if (typeof v === "object") {
          v = createKey(v);
        }
        key += `${k}:${v}:`;
      }
      return key;
    };
    var cacheOptions = ({ secureEndpoint, ...options }) => createKey({
      secureEndpoint: !!secureEndpoint,
      // socket connect options
      family: options.family,
      hints: options.hints,
      localAddress: options.localAddress,
      // tls specific connect options
      strictSsl: secureEndpoint ? !!options.rejectUnauthorized : false,
      ca: secureEndpoint ? options.ca : null,
      cert: secureEndpoint ? options.cert : null,
      key: secureEndpoint ? options.key : null,
      // http agent options
      keepAlive: options.keepAlive,
      keepAliveMsecs: options.keepAliveMsecs,
      maxSockets: options.maxSockets,
      maxTotalSockets: options.maxTotalSockets,
      maxFreeSockets: options.maxFreeSockets,
      scheduling: options.scheduling,
      // timeout options
      timeouts: options.timeouts,
      // proxy
      proxy: options.proxy
    });
    module2.exports = {
      normalizeOptions,
      cacheOptions
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/agent-base/dist/helpers.js
var require_helpers = __commonJS({
  "node_modules/agent-base/dist/helpers.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.req = exports2.json = exports2.toBuffer = void 0;
    var http = __importStar(require("http"));
    var https = __importStar(require("https"));
    async function toBuffer(stream) {
      let length = 0;
      const chunks = [];
      for await (const chunk of stream) {
        length += chunk.length;
        chunks.push(chunk);
      }
      return Buffer.concat(chunks, length);
    }
    exports2.toBuffer = toBuffer;
    async function json(stream) {
      const buf = await toBuffer(stream);
      const str = buf.toString("utf8");
      try {
        return JSON.parse(str);
      } catch (_err) {
        const err = _err;
        err.message += ` (input: ${str})`;
        throw err;
      }
    }
    exports2.json = json;
    function req(url, opts = {}) {
      const href = typeof url === "string" ? url : url.href;
      const req2 = (href.startsWith("https:") ? https : http).request(url, opts);
      const promise = new Promise((resolve, reject) => {
        req2.once("response", resolve).once("error", reject).end();
      });
      req2.then = promise.then.bind(promise);
      return req2;
    }
    exports2.req = req;
  }
});

// node_modules/agent-base/dist/index.js
var require_dist = __commonJS({
  "node_modules/agent-base/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Agent = void 0;
    var net = __importStar(require("net"));
    var http = __importStar(require("http"));
    var https_1 = require("https");
    __exportStar(require_helpers(), exports2);
    var INTERNAL = Symbol("AgentBaseInternalState");
    var Agent = class extends http.Agent {
      constructor(opts) {
        super(opts);
        this[INTERNAL] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(options) {
        if (options) {
          if (typeof options.secureEndpoint === "boolean") {
            return options.secureEndpoint;
          }
          if (typeof options.protocol === "string") {
            return options.protocol === "https:";
          }
        }
        const { stack } = new Error();
        if (typeof stack !== "string")
          return false;
        return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(name) {
        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
          return null;
        }
        if (!this.sockets[name]) {
          this.sockets[name] = [];
        }
        const fakeSocket = new net.Socket({ writable: false });
        this.sockets[name].push(fakeSocket);
        this.totalSocketCount++;
        return fakeSocket;
      }
      decrementSockets(name, socket) {
        if (!this.sockets[name] || socket === null) {
          return;
        }
        const sockets = this.sockets[name];
        const index = sockets.indexOf(socket);
        if (index !== -1) {
          sockets.splice(index, 1);
          this.totalSocketCount--;
          if (sockets.length === 0) {
            delete this.sockets[name];
          }
        }
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(options) {
        const secureEndpoint = typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options);
        if (secureEndpoint) {
          return https_1.Agent.prototype.getName.call(this, options);
        }
        return super.getName(options);
      }
      createSocket(req, options, cb) {
        const connectOpts = {
          ...options,
          secureEndpoint: this.isSecureEndpoint(options)
        };
        const name = this.getName(connectOpts);
        const fakeSocket = this.incrementSockets(name);
        Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
          this.decrementSockets(name, fakeSocket);
          if (socket instanceof http.Agent) {
            try {
              return socket.addRequest(req, connectOpts);
            } catch (err) {
              return cb(err);
            }
          }
          this[INTERNAL].currentSocket = socket;
          super.createSocket(req, options, cb);
        }, (err) => {
          this.decrementSockets(name, fakeSocket);
          cb(err);
        });
      }
      createConnection() {
        const socket = this[INTERNAL].currentSocket;
        this[INTERNAL].currentSocket = void 0;
        if (!socket) {
          throw new Error("No socket was returned in the `connect()` function");
        }
        return socket;
      }
      get defaultPort() {
        return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
      }
      set defaultPort(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].defaultPort = v;
        }
      }
      get protocol() {
        return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
      }
      set protocol(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].protocol = v;
        }
      }
    };
    exports2.Agent = Agent;
  }
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/http-proxy-agent/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpProxyAgent = void 0;
    var net = __importStar(require("net"));
    var tls = __importStar(require("tls"));
    var debug_1 = __importDefault(require_src());
    var events_1 = require("events");
    var agent_base_1 = require_dist();
    var url_1 = require("url");
    var debug = (0, debug_1.default)("http-proxy-agent");
    var HttpProxyAgent = class extends agent_base_1.Agent {
      constructor(proxy, opts) {
        super(opts);
        this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = opts?.headers ?? {};
        debug("Creating new HttpProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = {
          ...opts ? omit(opts, "headers") : null,
          host,
          port
        };
      }
      addRequest(req, opts) {
        req._header = null;
        this.setRequestProps(req, opts);
        super.addRequest(req, opts);
      }
      setRequestProps(req, opts) {
        const { proxy } = this;
        const protocol = opts.secureEndpoint ? "https:" : "http:";
        const hostname = req.getHeader("host") || "localhost";
        const base = `${protocol}//${hostname}`;
        const url = new url_1.URL(req.path, base);
        if (opts.port !== 80) {
          url.port = String(opts.port);
        }
        req.path = String(url);
        const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
        if (proxy.username || proxy.password) {
          const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
        }
        if (!headers["Proxy-Connection"]) {
          headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
        }
        for (const name of Object.keys(headers)) {
          const value = headers[name];
          if (value) {
            req.setHeader(name, value);
          }
        }
      }
      async connect(req, opts) {
        req._header = null;
        if (!req.path.includes("://")) {
          this.setRequestProps(req, opts);
        }
        let first;
        let endOfHeaders;
        debug("Regenerating stored HTTP header string for request");
        req._implicitHeader();
        if (req.outputData && req.outputData.length > 0) {
          debug("Patching connection write() output buffer with updated header");
          first = req.outputData[0].data;
          endOfHeaders = first.indexOf("\r\n\r\n") + 4;
          req.outputData[0].data = req._header + first.substring(endOfHeaders);
          debug("Output buffer: %o", req.outputData[0].data);
        }
        let socket;
        if (this.proxy.protocol === "https:") {
          debug("Creating `tls.Socket`: %o", this.connectOpts);
          socket = tls.connect(this.connectOpts);
        } else {
          debug("Creating `net.Socket`: %o", this.connectOpts);
          socket = net.connect(this.connectOpts);
        }
        await (0, events_1.once)(socket, "connect");
        return socket;
      }
    };
    HttpProxyAgent.protocols = ["http", "https"];
    exports2.HttpProxyAgent = HttpProxyAgent;
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseProxyResponse = void 0;
    var debug_1 = __importDefault(require_src());
    var debug = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("readable", read);
        }
        function onend() {
          cleanup();
          debug("onend");
          reject(new Error("Proxy connection ended before receiving CONNECT response"));
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
          const firstLine = headerParts.shift();
          if (!firstLine) {
            socket.destroy();
            return reject(new Error("No header received from proxy CONNECT response"));
          }
          const firstLineParts = firstLine.split(" ");
          const statusCode = +firstLineParts[1];
          const statusText = firstLineParts.slice(2).join(" ");
          const headers = {};
          for (const header of headerParts) {
            if (!header)
              continue;
            const firstColon = header.indexOf(":");
            if (firstColon === -1) {
              socket.destroy();
              return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
            }
            const key = header.slice(0, firstColon).toLowerCase();
            const value = header.slice(firstColon + 1).trimStart();
            const current = headers[key];
            if (typeof current === "string") {
              headers[key] = [current, value];
            } else if (Array.isArray(current)) {
              current.push(value);
            } else {
              headers[key] = value;
            }
          }
          debug("got proxy server response: %o %o", firstLine, headers);
          cleanup();
          resolve({
            connect: {
              statusCode,
              statusText,
              headers
            },
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("end", onend);
        read();
      });
    }
    exports2.parseProxyResponse = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpsProxyAgent = void 0;
    var net = __importStar(require("net"));
    var tls = __importStar(require("tls"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_dist();
    var url_1 = require("url");
    var parse_proxy_response_1 = require_parse_proxy_response();
    var debug = (0, debug_1.default)("https-proxy-agent");
    var setServernameFromNonIpHost = (options) => {
      if (options.servername === void 0 && options.host && !net.isIP(options.host)) {
        return {
          ...options,
          servername: options.host
        };
      }
      return options;
    };
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(proxy, opts) {
        super(opts);
        this.options = { path: void 0 };
        this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = opts?.headers ?? {};
        debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = {
          // Attempt to negotiate http/1.1 for proxy servers that support http/2
          ALPNProtocols: ["http/1.1"],
          ...opts ? omit(opts, "headers") : null,
          host,
          port
        };
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       */
      async connect(req, opts) {
        const { proxy } = this;
        if (!opts.host) {
          throw new TypeError('No "host" provided');
        }
        let socket;
        if (proxy.protocol === "https:") {
          debug("Creating `tls.Socket`: %o", this.connectOpts);
          socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
        } else {
          debug("Creating `net.Socket`: %o", this.connectOpts);
          socket = net.connect(this.connectOpts);
        }
        const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
        if (proxy.username || proxy.password) {
          const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
        }
        headers.Host = `${host}:${opts.port}`;
        if (!headers["Proxy-Connection"]) {
          headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
        }
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
        socket.write(`${payload}\r
`);
        const { connect, buffered } = await proxyResponsePromise;
        req.emit("proxyConnect", connect);
        this.emit("proxyConnect", connect, req);
        if (connect.statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            debug("Upgrading socket connection to TLS");
            return tls.connect({
              ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
              socket
            });
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net.Socket({ writable: false });
        fakeSocket.readable = true;
        req.once("socket", (s) => {
          debug("Replaying proxy buffer for failed request");
          (0, assert_1.default)(s.listenerCount("data") > 0);
          s.push(buffered);
          s.push(null);
        });
        return fakeSocket;
      }
    };
    HttpsProxyAgent.protocols = ["http", "https"];
    exports2.HttpsProxyAgent = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/smart-buffer/build/utils.js
var require_utils3 = __commonJS({
  "node_modules/smart-buffer/build/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var buffer_1 = require("buffer");
    var ERRORS = {
      INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
      INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
      INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
      INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
      INVALID_OFFSET: "An invalid offset value was provided.",
      INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
      INVALID_LENGTH: "An invalid length value was provided.",
      INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
      INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
      INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
      INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
      INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
    };
    exports2.ERRORS = ERRORS;
    function checkEncoding(encoding) {
      if (!buffer_1.Buffer.isEncoding(encoding)) {
        throw new Error(ERRORS.INVALID_ENCODING);
      }
    }
    exports2.checkEncoding = checkEncoding;
    function isFiniteInteger(value) {
      return typeof value === "number" && isFinite(value) && isInteger(value);
    }
    exports2.isFiniteInteger = isFiniteInteger;
    function checkOffsetOrLengthValue(value, offset) {
      if (typeof value === "number") {
        if (!isFiniteInteger(value) || value < 0) {
          throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
        }
      } else {
        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
      }
    }
    function checkLengthValue(length) {
      checkOffsetOrLengthValue(length, false);
    }
    exports2.checkLengthValue = checkLengthValue;
    function checkOffsetValue(offset) {
      checkOffsetOrLengthValue(offset, true);
    }
    exports2.checkOffsetValue = checkOffsetValue;
    function checkTargetOffset(offset, buff) {
      if (offset < 0 || offset > buff.length) {
        throw new Error(ERRORS.INVALID_TARGET_OFFSET);
      }
    }
    exports2.checkTargetOffset = checkTargetOffset;
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }
    function bigIntAndBufferInt64Check(bufferMethod) {
      if (typeof BigInt === "undefined") {
        throw new Error("Platform does not support JS BigInt type.");
      }
      if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
      }
    }
    exports2.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
  }
});

// node_modules/smart-buffer/build/smartbuffer.js
var require_smartbuffer = __commonJS({
  "node_modules/smart-buffer/build/smartbuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils3();
    var DEFAULT_SMARTBUFFER_SIZE = 4096;
    var DEFAULT_SMARTBUFFER_ENCODING = "utf8";
    var SmartBuffer = class _SmartBuffer {
      /**
       * Creates a new SmartBuffer instance.
       *
       * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.
       */
      constructor(options) {
        this.length = 0;
        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
        this._writeOffset = 0;
        this._readOffset = 0;
        if (_SmartBuffer.isSmartBufferOptions(options)) {
          if (options.encoding) {
            utils_1.checkEncoding(options.encoding);
            this._encoding = options.encoding;
          }
          if (options.size) {
            if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
              this._buff = Buffer.allocUnsafe(options.size);
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
            }
          } else if (options.buff) {
            if (Buffer.isBuffer(options.buff)) {
              this._buff = options.buff;
              this.length = options.buff.length;
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
            }
          } else {
            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
          }
        } else {
          if (typeof options !== "undefined") {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
          }
          this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
        }
      }
      /**
       * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.
       *
       * @param size { Number } The size of the internal Buffer.
       * @param encoding { String } The BufferEncoding to use for strings.
       *
       * @return { SmartBuffer }
       */
      static fromSize(size, encoding) {
        return new this({
          size,
          encoding
        });
      }
      /**
       * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.
       *
       * @param buffer { Buffer } The Buffer to use as the internal Buffer value.
       * @param encoding { String } The BufferEncoding to use for strings.
       *
       * @return { SmartBuffer }
       */
      static fromBuffer(buff, encoding) {
        return new this({
          buff,
          encoding
        });
      }
      /**
       * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.
       *
       * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.
       */
      static fromOptions(options) {
        return new this(options);
      }
      /**
       * Type checking function that determines if an object is a SmartBufferOptions object.
       */
      static isSmartBufferOptions(options) {
        const castOptions = options;
        return castOptions && (castOptions.encoding !== void 0 || castOptions.size !== void 0 || castOptions.buff !== void 0);
      }
      // Signed integers
      /**
       * Reads an Int8 value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
      }
      /**
       * Reads an Int16BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
      }
      /**
       * Reads an Int16LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
      }
      /**
       * Reads an Int32BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
      }
      /**
       * Reads an Int32LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
      }
      /**
       * Reads a BigInt64BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
      }
      /**
       * Reads a BigInt64LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
      }
      /**
       * Writes an Int8 value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt8(value, offset) {
        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
        return this;
      }
      /**
       * Inserts an Int8 value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
      }
      /**
       * Writes an Int16BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      /**
       * Inserts an Int16BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      /**
       * Writes an Int16LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      /**
       * Inserts an Int16LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      /**
       * Writes an Int32BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      /**
       * Inserts an Int32BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      /**
       * Writes an Int32LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      /**
       * Inserts an Int32LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      /**
       * Writes a BigInt64BE value to the current write position (or at optional offset).
       *
       * @param value { BigInt } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      /**
       * Inserts a BigInt64BE value at the given offset value.
       *
       * @param value { BigInt } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      /**
       * Writes a BigInt64LE value to the current write position (or at optional offset).
       *
       * @param value { BigInt } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      /**
       * Inserts a Int64LE value at the given offset value.
       *
       * @param value { BigInt } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      // Unsigned Integers
      /**
       * Reads an UInt8 value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
      }
      /**
       * Reads an UInt16BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
      }
      /**
       * Reads an UInt16LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
      }
      /**
       * Reads an UInt32BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
      }
      /**
       * Reads an UInt32LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
      }
      /**
       * Reads a BigUInt64BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigUInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
      }
      /**
       * Reads a BigUInt64LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigUInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
      }
      /**
       * Writes an UInt8 value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt8(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      /**
       * Inserts an UInt8 value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      /**
       * Writes an UInt16BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      /**
       * Inserts an UInt16BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      /**
       * Writes an UInt16LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      /**
       * Inserts an UInt16LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      /**
       * Writes an UInt32BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      /**
       * Inserts an UInt32BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      /**
       * Writes an UInt32LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      /**
       * Inserts an UInt32LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      /**
       * Writes a BigUInt64BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      /**
       * Inserts a BigUInt64BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      /**
       * Writes a BigUInt64LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      /**
       * Inserts a BigUInt64LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      // Floating Point
      /**
       * Reads an FloatBE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readFloatBE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
      }
      /**
       * Reads an FloatLE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readFloatLE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
      }
      /**
       * Writes a FloatBE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeFloatBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      /**
       * Inserts a FloatBE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertFloatBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      /**
       * Writes a FloatLE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeFloatLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      /**
       * Inserts a FloatLE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertFloatLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      // Double Floating Point
      /**
       * Reads an DoublEBE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readDoubleBE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
      }
      /**
       * Reads an DoubleLE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readDoubleLE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
      }
      /**
       * Writes a DoubleBE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeDoubleBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      /**
       * Inserts a DoubleBE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertDoubleBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      /**
       * Writes a DoubleLE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeDoubleLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      /**
       * Inserts a DoubleLE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertDoubleLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      // Strings
      /**
       * Reads a String from the current read position.
       *
       * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for
       *             the string (Defaults to instance level encoding).
       * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
       *
       * @return { String }
       */
      readString(arg1, encoding) {
        let lengthVal;
        if (typeof arg1 === "number") {
          utils_1.checkLengthValue(arg1);
          lengthVal = Math.min(arg1, this.length - this._readOffset);
        } else {
          encoding = arg1;
          lengthVal = this.length - this._readOffset;
        }
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
        this._readOffset += lengthVal;
        return value;
      }
      /**
       * Inserts a String
       *
       * @param value { String } The String value to insert.
       * @param offset { Number } The offset to insert the string at.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      insertString(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        return this._handleString(value, true, offset, encoding);
      }
      /**
       * Writes a String
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      writeString(value, arg2, encoding) {
        return this._handleString(value, false, arg2, encoding);
      }
      /**
       * Reads a null-terminated String from the current read position.
       *
       * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
       *
       * @return { String }
       */
      readStringNT(encoding) {
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value.toString(encoding || this._encoding);
      }
      /**
       * Inserts a null-terminated String.
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      insertStringNT(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        this.insertString(value, offset, encoding);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      /**
       * Writes a null-terminated String.
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      writeStringNT(value, arg2, encoding) {
        this.writeString(value, arg2, encoding);
        this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
        return this;
      }
      // Buffers
      /**
       * Reads a Buffer from the internal read position.
       *
       * @param length { Number } The length of data to read as a Buffer.
       *
       * @return { Buffer }
       */
      readBuffer(length) {
        if (typeof length !== "undefined") {
          utils_1.checkLengthValue(length);
        }
        const lengthVal = typeof length === "number" ? length : this.length;
        const endPoint = Math.min(this.length, this._readOffset + lengthVal);
        const value = this._buff.slice(this._readOffset, endPoint);
        this._readOffset = endPoint;
        return value;
      }
      /**
       * Writes a Buffer to the current write position.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      insertBuffer(value, offset) {
        utils_1.checkOffsetValue(offset);
        return this._handleBuffer(value, true, offset);
      }
      /**
       * Writes a Buffer to the current write position.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      writeBuffer(value, offset) {
        return this._handleBuffer(value, false, offset);
      }
      /**
       * Reads a null-terminated Buffer from the current read poisiton.
       *
       * @return { Buffer }
       */
      readBufferNT() {
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value;
      }
      /**
       * Inserts a null-terminated Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      insertBufferNT(value, offset) {
        utils_1.checkOffsetValue(offset);
        this.insertBuffer(value, offset);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      /**
       * Writes a null-terminated Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      writeBufferNT(value, offset) {
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
        }
        this.writeBuffer(value, offset);
        this.writeUInt8(0, typeof offset === "number" ? offset + value.length : this._writeOffset);
        return this;
      }
      /**
       * Clears the SmartBuffer instance to its original empty state.
       */
      clear() {
        this._writeOffset = 0;
        this._readOffset = 0;
        this.length = 0;
        return this;
      }
      /**
       * Gets the remaining data left to be read from the SmartBuffer instance.
       *
       * @return { Number }
       */
      remaining() {
        return this.length - this._readOffset;
      }
      /**
       * Gets the current read offset value of the SmartBuffer instance.
       *
       * @return { Number }
       */
      get readOffset() {
        return this._readOffset;
      }
      /**
       * Sets the read offset value of the SmartBuffer instance.
       *
       * @param offset { Number } - The offset value to set.
       */
      set readOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._readOffset = offset;
      }
      /**
       * Gets the current write offset value of the SmartBuffer instance.
       *
       * @return { Number }
       */
      get writeOffset() {
        return this._writeOffset;
      }
      /**
       * Sets the write offset value of the SmartBuffer instance.
       *
       * @param offset { Number } - The offset value to set.
       */
      set writeOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._writeOffset = offset;
      }
      /**
       * Gets the currently set string encoding of the SmartBuffer instance.
       *
       * @return { BufferEncoding } The string Buffer encoding currently set.
       */
      get encoding() {
        return this._encoding;
      }
      /**
       * Sets the string encoding of the SmartBuffer instance.
       *
       * @param encoding { BufferEncoding } The string Buffer encoding to set.
       */
      set encoding(encoding) {
        utils_1.checkEncoding(encoding);
        this._encoding = encoding;
      }
      /**
       * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)
       *
       * @return { Buffer } The Buffer value.
       */
      get internalBuffer() {
        return this._buff;
      }
      /**
       * Gets the value of the internal managed Buffer (Includes managed data only)
       *
       * @param { Buffer }
       */
      toBuffer() {
        return this._buff.slice(0, this.length);
      }
      /**
       * Gets the String value of the internal managed Buffer
       *
       * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).
       */
      toString(encoding) {
        const encodingVal = typeof encoding === "string" ? encoding : this._encoding;
        utils_1.checkEncoding(encodingVal);
        return this._buff.toString(encodingVal, 0, this.length);
      }
      /**
       * Destroys the SmartBuffer instance.
       */
      destroy() {
        this.clear();
        return this;
      }
      /**
       * Handles inserting and writing strings.
       *
       * @param value { String } The String value to insert.
       * @param isInsert { Boolean } True if inserting a string, false if writing.
       * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       */
      _handleString(value, isInsert, arg3, encoding) {
        let offsetVal = this._writeOffset;
        let encodingVal = this._encoding;
        if (typeof arg3 === "number") {
          offsetVal = arg3;
        } else if (typeof arg3 === "string") {
          utils_1.checkEncoding(arg3);
          encodingVal = arg3;
        }
        if (typeof encoding === "string") {
          utils_1.checkEncoding(encoding);
          encodingVal = encoding;
        }
        const byteLength = Buffer.byteLength(value, encodingVal);
        if (isInsert) {
          this.ensureInsertable(byteLength, offsetVal);
        } else {
          this._ensureWriteable(byteLength, offsetVal);
        }
        this._buff.write(value, offsetVal, byteLength, encodingVal);
        if (isInsert) {
          this._writeOffset += byteLength;
        } else {
          if (typeof arg3 === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
          } else {
            this._writeOffset += byteLength;
          }
        }
        return this;
      }
      /**
       * Handles writing or insert of a Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       */
      _handleBuffer(value, isInsert, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        if (isInsert) {
          this.ensureInsertable(value.length, offsetVal);
        } else {
          this._ensureWriteable(value.length, offsetVal);
        }
        value.copy(this._buff, offsetVal);
        if (isInsert) {
          this._writeOffset += value.length;
        } else {
          if (typeof offset === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
          } else {
            this._writeOffset += value.length;
          }
        }
        return this;
      }
      /**
       * Ensures that the internal Buffer is large enough to read data.
       *
       * @param length { Number } The length of the data that needs to be read.
       * @param offset { Number } The offset of the data that needs to be read.
       */
      ensureReadable(length, offset) {
        let offsetVal = this._readOffset;
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
          offsetVal = offset;
        }
        if (offsetVal < 0 || offsetVal + length > this.length) {
          throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to insert data.
       *
       * @param dataLength { Number } The length of the data that needs to be written.
       * @param offset { Number } The offset of the data to be written.
       */
      ensureInsertable(dataLength, offset) {
        utils_1.checkOffsetValue(offset);
        this._ensureCapacity(this.length + dataLength);
        if (offset < this.length) {
          this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
        }
        if (offset + dataLength > this.length) {
          this.length = offset + dataLength;
        } else {
          this.length += dataLength;
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to write data.
       *
       * @param dataLength { Number } The length of the data that needs to be written.
       * @param offset { Number } The offset of the data to be written (defaults to writeOffset).
       */
      _ensureWriteable(dataLength, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureCapacity(offsetVal + dataLength);
        if (offsetVal + dataLength > this.length) {
          this.length = offsetVal + dataLength;
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to write at least the given amount of data.
       *
       * @param minLength { Number } The minimum length of the data needs to be written.
       */
      _ensureCapacity(minLength) {
        const oldLength = this._buff.length;
        if (minLength > oldLength) {
          let data = this._buff;
          let newLength = oldLength * 3 / 2 + 1;
          if (newLength < minLength) {
            newLength = minLength;
          }
          this._buff = Buffer.allocUnsafe(newLength);
          data.copy(this._buff, 0, 0, oldLength);
        }
      }
      /**
       * Reads a numeric number value using the provided function.
       *
       * @typeparam T { number | bigint } The type of the value to be read
       *
       * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes read.
       * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.
       *
       * @returns { T } the number value
       */
      _readNumberValue(func, byteSize, offset) {
        this.ensureReadable(byteSize, offset);
        const value = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
        if (typeof offset === "undefined") {
          this._readOffset += byteSize;
        }
        return value;
      }
      /**
       * Inserts a numeric number value based on the given offset and value.
       *
       * @typeparam T { number | bigint } The type of the value to be written
       *
       * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes written.
       * @param value { T } The number value to write.
       * @param offset { Number } the offset to write the number at (REQUIRED).
       *
       * @returns SmartBuffer this buffer
       */
      _insertNumberValue(func, byteSize, value, offset) {
        utils_1.checkOffsetValue(offset);
        this.ensureInsertable(byteSize, offset);
        func.call(this._buff, value, offset);
        this._writeOffset += byteSize;
        return this;
      }
      /**
       * Writes a numeric number value based on the given offset and value.
       *
       * @typeparam T { number | bigint } The type of the value to be written
       *
       * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes written.
       * @param value { T } The number value to write.
       * @param offset { Number } the offset to write the number at (REQUIRED).
       *
       * @returns SmartBuffer this buffer
       */
      _writeNumberValue(func, byteSize, value, offset) {
        if (typeof offset === "number") {
          if (offset < 0) {
            throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
          }
          utils_1.checkOffsetValue(offset);
        }
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureWriteable(byteSize, offsetVal);
        func.call(this._buff, value, offsetVal);
        if (typeof offset === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
        } else {
          this._writeOffset += byteSize;
        }
        return this;
      }
    };
    exports2.SmartBuffer = SmartBuffer;
  }
});

// node_modules/socks/build/common/constants.js
var require_constants4 = __commonJS({
  "node_modules/socks/build/common/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SOCKS5_NO_ACCEPTABLE_AUTH = exports2.SOCKS5_CUSTOM_AUTH_END = exports2.SOCKS5_CUSTOM_AUTH_START = exports2.SOCKS_INCOMING_PACKET_SIZES = exports2.SocksClientState = exports2.Socks5Response = exports2.Socks5HostType = exports2.Socks5Auth = exports2.Socks4Response = exports2.SocksCommand = exports2.ERRORS = exports2.DEFAULT_TIMEOUT = void 0;
    var DEFAULT_TIMEOUT = 3e4;
    exports2.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    var ERRORS = {
      InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
      InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
      InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
      InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
      InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
      InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
      InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
      InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
      InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
      InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
      NegotiationError: "Negotiation error",
      SocketClosed: "Socket closed",
      ProxyConnectionTimedOut: "Proxy connection timed out",
      InternalError: "SocksClient internal error (this should not happen)",
      InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
      Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
      InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
      Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
      InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
      InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
      InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
      InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
      Socks5AuthenticationFailed: "Socks5 Authentication failed",
      InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
      InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
      InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
      Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
    };
    exports2.ERRORS = ERRORS;
    var SOCKS_INCOMING_PACKET_SIZES = {
      Socks5InitialHandshakeResponse: 2,
      Socks5UserPassAuthenticationResponse: 2,
      // Command response + incoming connection (bind)
      Socks5ResponseHeader: 5,
      // We need at least 5 to read the hostname length, then we wait for the address+port information.
      Socks5ResponseIPv4: 10,
      // 4 header + 4 ip + 2 port
      Socks5ResponseIPv6: 22,
      // 4 header + 16 ip + 2 port
      Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
      // 4 header + 1 host length + host + 2 port
      // Command response + incoming connection (bind)
      Socks4Response: 8
      // 2 header + 2 port + 4 ip
    };
    exports2.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
    var SocksCommand;
    (function(SocksCommand2) {
      SocksCommand2[SocksCommand2["connect"] = 1] = "connect";
      SocksCommand2[SocksCommand2["bind"] = 2] = "bind";
      SocksCommand2[SocksCommand2["associate"] = 3] = "associate";
    })(SocksCommand || (exports2.SocksCommand = SocksCommand = {}));
    var Socks4Response;
    (function(Socks4Response2) {
      Socks4Response2[Socks4Response2["Granted"] = 90] = "Granted";
      Socks4Response2[Socks4Response2["Failed"] = 91] = "Failed";
      Socks4Response2[Socks4Response2["Rejected"] = 92] = "Rejected";
      Socks4Response2[Socks4Response2["RejectedIdent"] = 93] = "RejectedIdent";
    })(Socks4Response || (exports2.Socks4Response = Socks4Response = {}));
    var Socks5Auth;
    (function(Socks5Auth2) {
      Socks5Auth2[Socks5Auth2["NoAuth"] = 0] = "NoAuth";
      Socks5Auth2[Socks5Auth2["GSSApi"] = 1] = "GSSApi";
      Socks5Auth2[Socks5Auth2["UserPass"] = 2] = "UserPass";
    })(Socks5Auth || (exports2.Socks5Auth = Socks5Auth = {}));
    var SOCKS5_CUSTOM_AUTH_START = 128;
    exports2.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
    var SOCKS5_CUSTOM_AUTH_END = 254;
    exports2.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
    var SOCKS5_NO_ACCEPTABLE_AUTH = 255;
    exports2.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
    var Socks5Response;
    (function(Socks5Response2) {
      Socks5Response2[Socks5Response2["Granted"] = 0] = "Granted";
      Socks5Response2[Socks5Response2["Failure"] = 1] = "Failure";
      Socks5Response2[Socks5Response2["NotAllowed"] = 2] = "NotAllowed";
      Socks5Response2[Socks5Response2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
      Socks5Response2[Socks5Response2["HostUnreachable"] = 4] = "HostUnreachable";
      Socks5Response2[Socks5Response2["ConnectionRefused"] = 5] = "ConnectionRefused";
      Socks5Response2[Socks5Response2["TTLExpired"] = 6] = "TTLExpired";
      Socks5Response2[Socks5Response2["CommandNotSupported"] = 7] = "CommandNotSupported";
      Socks5Response2[Socks5Response2["AddressNotSupported"] = 8] = "AddressNotSupported";
    })(Socks5Response || (exports2.Socks5Response = Socks5Response = {}));
    var Socks5HostType;
    (function(Socks5HostType2) {
      Socks5HostType2[Socks5HostType2["IPv4"] = 1] = "IPv4";
      Socks5HostType2[Socks5HostType2["Hostname"] = 3] = "Hostname";
      Socks5HostType2[Socks5HostType2["IPv6"] = 4] = "IPv6";
    })(Socks5HostType || (exports2.Socks5HostType = Socks5HostType = {}));
    var SocksClientState;
    (function(SocksClientState2) {
      SocksClientState2[SocksClientState2["Created"] = 0] = "Created";
      SocksClientState2[SocksClientState2["Connecting"] = 1] = "Connecting";
      SocksClientState2[SocksClientState2["Connected"] = 2] = "Connected";
      SocksClientState2[SocksClientState2["SentInitialHandshake"] = 3] = "SentInitialHandshake";
      SocksClientState2[SocksClientState2["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
      SocksClientState2[SocksClientState2["SentAuthentication"] = 5] = "SentAuthentication";
      SocksClientState2[SocksClientState2["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
      SocksClientState2[SocksClientState2["SentFinalHandshake"] = 7] = "SentFinalHandshake";
      SocksClientState2[SocksClientState2["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
      SocksClientState2[SocksClientState2["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
      SocksClientState2[SocksClientState2["Established"] = 10] = "Established";
      SocksClientState2[SocksClientState2["Disconnected"] = 11] = "Disconnected";
      SocksClientState2[SocksClientState2["Error"] = 99] = "Error";
    })(SocksClientState || (exports2.SocksClientState = SocksClientState = {}));
  }
});

// node_modules/socks/build/common/util.js
var require_util = __commonJS({
  "node_modules/socks/build/common/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shuffleArray = exports2.SocksClientError = void 0;
    var SocksClientError = class extends Error {
      constructor(message, options) {
        super(message);
        this.options = options;
      }
    };
    exports2.SocksClientError = SocksClientError;
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    exports2.shuffleArray = shuffleArray;
  }
});

// node_modules/ip-address/dist/common.js
var require_common2 = __commonJS({
  "node_modules/ip-address/dist/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isCorrect = exports2.isInSubnet = void 0;
    function isInSubnet(address) {
      if (this.subnetMask < address.subnetMask) {
        return false;
      }
      if (this.mask(address.subnetMask) === address.mask()) {
        return true;
      }
      return false;
    }
    exports2.isInSubnet = isInSubnet;
    function isCorrect(defaultBits) {
      return function() {
        if (this.addressMinusSuffix !== this.correctForm()) {
          return false;
        }
        if (this.subnetMask === defaultBits && !this.parsedSubnet) {
          return true;
        }
        return this.parsedSubnet === String(this.subnetMask);
      };
    }
    exports2.isCorrect = isCorrect;
  }
});

// node_modules/ip-address/dist/v4/constants.js
var require_constants5 = __commonJS({
  "node_modules/ip-address/dist/v4/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RE_SUBNET_STRING = exports2.RE_ADDRESS = exports2.GROUPS = exports2.BITS = void 0;
    exports2.BITS = 32;
    exports2.GROUPS = 4;
    exports2.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
    exports2.RE_SUBNET_STRING = /\/\d{1,2}$/;
  }
});

// node_modules/ip-address/dist/address-error.js
var require_address_error = __commonJS({
  "node_modules/ip-address/dist/address-error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AddressError = void 0;
    var AddressError = class extends Error {
      constructor(message, parseMessage) {
        super(message);
        this.name = "AddressError";
        if (parseMessage !== null) {
          this.parseMessage = parseMessage;
        }
      }
    };
    exports2.AddressError = AddressError;
  }
});

// node_modules/jsbn/index.js
var require_jsbn = __commonJS({
  "node_modules/jsbn/index.js"(exports2, module2) {
    (function() {
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        if (a != null)
          if ("number" == typeof a) this.fromNumber(a, b, c);
          else if (b == null && "string" != typeof a) this.fromString(a, 256);
          else this.fromString(a, b);
      }
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this[i++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this[i] & 32767;
          var h = this[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this[i] & 16383;
          var h = this[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w[j++] = l & 268435455;
        }
        return c;
      }
      var inBrowser = typeof navigator !== "undefined";
      if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr, vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
      }
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0) this[0] = x;
        else if (x < -1) this[0] = x + this.DV;
        else this.t = 0;
      }
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      function bnpFromString(s, b) {
        var k;
        if (b == 16) k = 4;
        else if (b == 8) k = 3;
        else if (b == 256) k = 8;
        else if (b == 2) k = 1;
        else if (b == 32) k = 5;
        else if (b == 4) k = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
          var x = k == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-") mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this[this.t++] = x;
          else if (sh + k > this.DB) {
            this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
            this[this.t++] = x >> this.DB - sh;
          } else
            this[this.t - 1] |= x << sh;
          sh += k;
          if (sh >= this.DB) sh -= this.DB;
        }
        if (k == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0) this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi) BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c) --this.t;
      }
      function bnToString(b) {
        if (this.s < 0) return "-" + this.negate().toString(b);
        var k;
        if (b == 16) k = 4;
        else if (b == 8) k = 3;
        else if (b == 2) k = 1;
        else if (b == 32) k = 5;
        else if (b == 4) k = 2;
        else return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) > 0) {
            m = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k) {
              d = (this[i] & (1 << p) - 1) << k - p;
              d |= this[--i] >> (p += this.DB - k);
            } else {
              d = this[i] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0) m = true;
            if (m) r += int2char(d);
          }
        }
        return m ? r : "0";
      }
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0) return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0) return this.s < 0 ? -r : r;
        while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
        return 0;
      }
      function nbits(x) {
        var r = 1, t2;
        if ((t2 = x >>> 16) != 0) {
          x = t2;
          r += 16;
        }
        if ((t2 = x >> 8) != 0) {
          x = t2;
          r += 8;
        }
        if ((t2 = x >> 4) != 0) {
          x = t2;
          r += 4;
        }
        if ((t2 = x >> 2) != 0) {
          x = t2;
          r += 2;
        }
        if ((t2 = x >> 1) != 0) {
          x = t2;
          r += 1;
        }
        return r;
      }
      function bnBitLength() {
        if (this.t <= 0) return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
        for (i = n - 1; i >= 0; --i) r[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i) r[i - n] = this[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r[i + ds + 1] = this[i] >> cbs | c;
          c = (this[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i) r[i] = 0;
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r[i - ds - 1] |= (this[i] & bm) << cbs;
          r[i - ds] = this[i] >> bs;
        }
        if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] - a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1) r[i++] = this.DV + c;
        else if (c > 0) r[i++] = c;
        r.t = i;
        r.clamp();
      }
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0) r[i] = 0;
        for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
      }
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0) r[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x[i], r, 2 * i, 0, 1);
          if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      function bnpDivRemTo(m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0) return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q != null) q.fromInt(0);
          if (r != null) this.copyTo(r);
          return;
        }
        if (r == null) r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0) return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t2 = q == null ? nbi() : q;
        y.dlShiftTo(j, t2);
        if (r.compareTo(t2) >= 0) {
          r[r.t++] = 1;
          r.subTo(t2, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t2);
        t2.subTo(y, y);
        while (y.t < ys) y[y.t++] = 0;
        while (--j >= 0) {
          var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
          if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t2);
            r.subTo(t2, r);
            while (r[i] < --qd) r.subTo(t2, r);
          }
        }
        if (q != null) {
          r.drShiftTo(ys, q);
          if (ts != ms) BigInteger.ZERO.subTo(q, q);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0) r.rShiftTo(nsh, r);
        if (ts < 0) BigInteger.ZERO.subTo(r, r);
      }
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
        return r;
      }
      function Classic(m) {
        this.m = m;
      }
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
        else return x;
      }
      function cRevert(x) {
        return x;
      }
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1) return 0;
        var x = this[0];
        if ((x & 1) == 0) return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m.DB - 15) - 1;
        this.mt2 = 2 * m.t;
      }
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
        return r;
      }
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      function montReduce(x) {
        while (x.t <= this.mt2)
          x[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
      }
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      function bnpExp(e, z2) {
        if (e > 4294967295 || e < 1) return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z2.sqrTo(r, r2);
          if ((e & 1 << i) > 0) z2.mulTo(r2, g, r);
          else {
            var t2 = r;
            r = r2;
            r2 = t2;
          }
        }
        return z2.revert(r);
      }
      function bnModPowInt(e, m) {
        var z2;
        if (e < 256 || m.isEven()) z2 = new Classic(m);
        else z2 = new Montgomery(m);
        return this.exp(e, z2);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1) return this[0] - this.DV;
          else if (this.t == 0) return -1;
        } else if (this.t == 1) return this[0];
        else if (this.t == 0) return 0;
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      function bnSigNum() {
        if (this.s < 0) return -1;
        else if (this.t <= 0 || this.t == 1 && this[0] <= 0) return 0;
        else return 1;
      }
      function bnpToRadix(b) {
        if (b == null) b = 10;
        if (this.signum() == 0 || b < 2 || b > 36) return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
        this.divRemTo(d, y, z2);
        while (y.signum() > 0) {
          r = (a + z2.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z2);
        }
        return z2.intValue().toString(b) + r;
      }
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null) b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi) BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if ("number" == typeof b) {
          if (a < 2) this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven()) this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t2 = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t2 > 0) x[0] &= (1 << t2) - 1;
          else x[0] = 0;
          this.fromString(x, 256);
        }
      }
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this[i] & (1 << p) - 1) << 8 - p;
              d |= this[--i] >> (p += this.DB - 8);
            } else {
              d = this[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0) d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128)) ++k;
            if (k > 0 || d != this.s) r[k++] = d;
          }
        }
        return r;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      function op_and(x, y) {
        return x & y;
      }
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      function op_or(x, y) {
        return x | y;
      }
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      function op_xor(x, y) {
        return x ^ y;
      }
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      function op_andnot(x, y) {
        return x & ~y;
      }
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0) this.rShiftTo(-n, r);
        else this.lShiftTo(n, r);
        return r;
      }
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0) this.lShiftTo(-n, r);
        else this.rShiftTo(n, r);
        return r;
      }
      function lbit(x) {
        if (x == 0) return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0) ++r;
        return r;
      }
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this[i] != 0) return i * this.DB + lbit(this[i]);
        if (this.s < 0) return this.t * this.DB;
        return -1;
      }
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
        return r;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t) return this.s != 0;
        return (this[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] + a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0) r[i++] = c;
        else if (c < -1) r[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      function bnSquare() {
        var r = nbi();
        this.squareTo(r);
        return r;
      }
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      function bnDivideAndRemainder(a) {
        var q = nbi(), r = nbi();
        this.divRemTo(a, q, r);
        return new Array(q, r);
      }
      function bnpDMultiply(n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0) return;
        while (this.t <= w) this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
          this[w] -= this.DV;
          if (++w >= this.t) this[this.t++] = 0;
          ++this[w];
        }
      }
      function NullExp() {
      }
      function nNop(x) {
        return x;
      }
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0) r[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
        r.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0) r[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      function Barrett(m) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
        else if (x.compareTo(this.m) < 0) return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      function barrettRevert(x) {
        return x;
      }
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
      }
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m) {
        var i = e.bitLength(), k, r = nbv(1), z2;
        if (i <= 0) return r;
        else if (i < 18) k = 1;
        else if (i < 48) k = 3;
        else if (i < 144) k = 4;
        else if (i < 768) k = 5;
        else k = 6;
        if (i < 8)
          z2 = new Classic(m);
        else if (m.isEven())
          z2 = new Barrett(m);
        else
          z2 = new Montgomery(m);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z2.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z2.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z2.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
          if (i >= k1) w = e[j] >> i - k1 & km;
          else {
            w = (e[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0) w |= e[j - 1] >> this.DB + i - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z2.sqrTo(r, r2);
              z2.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0) z2.sqrTo(r, r2);
            else {
              t2 = r;
              r = r2;
              r2 = t2;
            }
            z2.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e[j] & 1 << i) == 0) {
            z2.sqrTo(r, r2);
            t2 = r;
            r = r2;
            r2 = t2;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z2.revert(r);
      }
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t2 = x;
          x = y;
          y = t2;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0) return x;
        if (i < g) g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0) y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0) return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0) r = this[0] % n;
          else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
        return r;
      }
      function bnModInverse(m) {
        var ac = m.isEven();
        if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven()) b.subTo(m, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven()) d.subTo(m, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac) a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac) c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
        if (d.compareTo(m) >= 0) return d.subtract(m);
        if (d.signum() < 0) d.addTo(m, d);
        else return d;
        if (d.signum() < 0) return d.add(m);
        else return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t2) {
        var i, x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i]) return true;
          return false;
        }
        if (x.isEven()) return false;
        i = 1;
        while (i < lowprimes.length) {
          var m = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
          m = x.modInt(m);
          while (i < j) if (m % lowprimes[i++] == 0) return false;
        }
        return x.millerRabin(t2);
      }
      function bnpMillerRabin(t2) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0) return false;
        var r = n1.shiftRight(k);
        t2 = t2 + 1 >> 1;
        if (t2 > lowprimes.length) t2 = lowprimes.length;
        var a = nbi();
        for (var i = 0; i < t2; ++i) {
          a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0) return false;
            }
            if (y.compareTo(n1) != 0) return false;
          }
        }
        return true;
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      BigInteger.prototype.Barrett = Barrett;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(x) {
        rng_pool[rng_pptr++] ^= x & 255;
        rng_pool[rng_pptr++] ^= x >> 8 & 255;
        rng_pool[rng_pptr++] ^= x >> 16 & 255;
        rng_pool[rng_pptr++] ^= x >> 24 & 255;
        if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;
      }
      function rng_seed_time() {
        rng_seed_int((/* @__PURE__ */ new Date()).getTime());
      }
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t;
        if (typeof window !== "undefined" && window.crypto) {
          if (window.crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            window.crypto.getRandomValues(ua);
            for (t = 0; t < 32; ++t)
              rng_pool[rng_pptr++] = ua[t];
          } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for (t = 0; t < z.length; ++t)
              rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
          }
        }
        while (rng_pptr < rng_psize) {
          t = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t >>> 8;
          rng_pool[rng_pptr++] = t & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      function rng_get_bytes(ba) {
        var i;
        for (i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
      }
      function SecureRandom() {
      }
      SecureRandom.prototype.nextBytes = rng_get_bytes;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      function ARC4init(key) {
        var i, j, t2;
        for (i = 0; i < 256; ++i)
          this.S[i] = i;
        j = 0;
        for (i = 0; i < 256; ++i) {
          j = j + this.S[i] + key[i % key.length] & 255;
          t2 = this.S[i];
          this.S[i] = this.S[j];
          this.S[j] = t2;
        }
        this.i = 0;
        this.j = 0;
      }
      function ARC4next() {
        var t2;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        t2 = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t2;
        return this.S[t2 + this.S[this.i] & 255];
      }
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      var rng_psize = 256;
      if (typeof exports2 !== "undefined") {
        exports2 = module2.exports = {
          default: BigInteger,
          BigInteger,
          SecureRandom
        };
      } else {
        this.jsbn = {
          BigInteger,
          SecureRandom
        };
      }
    }).call(exports2);
  }
});

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/sprintf-js/src/sprintf.js"(exports2) {
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports2 !== "undefined") {
        exports2["sprintf"] = sprintf;
        exports2["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// node_modules/ip-address/dist/ipv4.js
var require_ipv4 = __commonJS({
  "node_modules/ip-address/dist/ipv4.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Address4 = void 0;
    var common = __importStar(require_common2());
    var constants = __importStar(require_constants5());
    var address_error_1 = require_address_error();
    var jsbn_1 = require_jsbn();
    var sprintf_js_1 = require_sprintf();
    var Address4 = class _Address4 {
      constructor(address) {
        this.groups = constants.GROUPS;
        this.parsedAddress = [];
        this.parsedSubnet = "";
        this.subnet = "/32";
        this.subnetMask = 32;
        this.v4 = true;
        this.isCorrect = common.isCorrect(constants.BITS);
        this.isInSubnet = common.isInSubnet;
        this.address = address;
        const subnet = constants.RE_SUBNET_STRING.exec(address);
        if (subnet) {
          this.parsedSubnet = subnet[0].replace("/", "");
          this.subnetMask = parseInt(this.parsedSubnet, 10);
          this.subnet = `/${this.subnetMask}`;
          if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          address = address.replace(constants.RE_SUBNET_STRING, "");
        }
        this.addressMinusSuffix = address;
        this.parsedAddress = this.parse(address);
      }
      static isValid(address) {
        try {
          new _Address4(address);
          return true;
        } catch (e) {
          return false;
        }
      }
      /*
       * Parses a v4 address
       */
      parse(address) {
        const groups = address.split(".");
        if (!address.match(constants.RE_ADDRESS)) {
          throw new address_error_1.AddressError("Invalid IPv4 address.");
        }
        return groups;
      }
      /**
       * Returns the correct form of an address
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      correctForm() {
        return this.parsedAddress.map((part) => parseInt(part, 10)).join(".");
      }
      /**
       * Converts a hex string to an IPv4 address object
       * @memberof Address4
       * @static
       * @param {string} hex - a hex string to convert
       * @returns {Address4}
       */
      static fromHex(hex) {
        const padded = hex.replace(/:/g, "").padStart(8, "0");
        const groups = [];
        let i;
        for (i = 0; i < 8; i += 2) {
          const h = padded.slice(i, i + 2);
          groups.push(parseInt(h, 16));
        }
        return new _Address4(groups.join("."));
      }
      /**
       * Converts an integer into a IPv4 address object
       * @memberof Address4
       * @static
       * @param {integer} integer - a number to convert
       * @returns {Address4}
       */
      static fromInteger(integer) {
        return _Address4.fromHex(integer.toString(16));
      }
      /**
       * Return an address from in-addr.arpa form
       * @memberof Address4
       * @static
       * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address
       * @returns {Adress4}
       * @example
       * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)
       * address.correctForm(); // '192.0.2.42'
       */
      static fromArpa(arpaFormAddress) {
        const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
        const address = leader.split(".").reverse().join(".");
        return new _Address4(address);
      }
      /**
       * Converts an IPv4 address object to a hex string
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      toHex() {
        return this.parsedAddress.map((part) => (0, sprintf_js_1.sprintf)("%02x", parseInt(part, 10))).join(":");
      }
      /**
       * Converts an IPv4 address object to an array of bytes
       * @memberof Address4
       * @instance
       * @returns {Array}
       */
      toArray() {
        return this.parsedAddress.map((part) => parseInt(part, 10));
      }
      /**
       * Converts an IPv4 address object to an IPv6 address group
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      toGroup6() {
        const output = [];
        let i;
        for (i = 0; i < constants.GROUPS; i += 2) {
          const hex = (0, sprintf_js_1.sprintf)("%02x%02x", parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));
          output.push((0, sprintf_js_1.sprintf)("%x", parseInt(hex, 16)));
        }
        return output.join(":");
      }
      /**
       * Returns the address as a BigInteger
       * @memberof Address4
       * @instance
       * @returns {BigInteger}
       */
      bigInteger() {
        return new jsbn_1.BigInteger(this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)("%02x", parseInt(n, 10))).join(""), 16);
      }
      /**
       * Helper function getting start address.
       * @memberof Address4
       * @instance
       * @returns {BigInteger}
       */
      _startAddress() {
        return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants.BITS - this.subnetMask), 2);
      }
      /**
       * The first address in the range given by this address' subnet.
       * Often referred to as the Network Address.
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      startAddress() {
        return _Address4.fromBigInteger(this._startAddress());
      }
      /**
       * The first host address in the range given by this address's subnet ie
       * the first address after the Network Address
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      startAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return _Address4.fromBigInteger(this._startAddress().add(adjust));
      }
      /**
       * Helper function getting end address.
       * @memberof Address4
       * @instance
       * @returns {BigInteger}
       */
      _endAddress() {
        return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants.BITS - this.subnetMask), 2);
      }
      /**
       * The last address in the range given by this address' subnet
       * Often referred to as the Broadcast
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      endAddress() {
        return _Address4.fromBigInteger(this._endAddress());
      }
      /**
       * The last host address in the range given by this address's subnet ie
       * the last address prior to the Broadcast Address
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      endAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return _Address4.fromBigInteger(this._endAddress().subtract(adjust));
      }
      /**
       * Converts a BigInteger to a v4 address object
       * @memberof Address4
       * @static
       * @param {BigInteger} bigInteger - a BigInteger to convert
       * @returns {Address4}
       */
      static fromBigInteger(bigInteger) {
        return _Address4.fromInteger(parseInt(bigInteger.toString(), 10));
      }
      /**
       * Returns the first n bits of the address, defaulting to the
       * subnet mask
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      mask(mask) {
        if (mask === void 0) {
          mask = this.subnetMask;
        }
        return this.getBitsBase2(0, mask);
      }
      /**
       * Returns the bits in the given range as a base-2 string
       * @memberof Address4
       * @instance
       * @returns {string}
       */
      getBitsBase2(start, end) {
        return this.binaryZeroPad().slice(start, end);
      }
      /**
       * Return the reversed ip6.arpa form of the address
       * @memberof Address4
       * @param {Object} options
       * @param {boolean} options.omitSuffix - omit the "in-addr.arpa" suffix
       * @instance
       * @returns {String}
       */
      reverseForm(options) {
        if (!options) {
          options = {};
        }
        const reversed = this.correctForm().split(".").reverse().join(".");
        if (options.omitSuffix) {
          return reversed;
        }
        return (0, sprintf_js_1.sprintf)("%s.in-addr.arpa.", reversed);
      }
      /**
       * Returns true if the given address is a multicast address
       * @memberof Address4
       * @instance
       * @returns {boolean}
       */
      isMulticast() {
        return this.isInSubnet(new _Address4("224.0.0.0/4"));
      }
      /**
       * Returns a zero-padded base-2 string representation of the address
       * @memberof Address4
       * @instance
       * @returns {string}
       */
      binaryZeroPad() {
        return this.bigInteger().toString(2).padStart(constants.BITS, "0");
      }
      /**
       * Groups an IPv4 address for inclusion at the end of an IPv6 address
       * @returns {String}
       */
      groupForV6() {
        const segments = this.parsedAddress;
        return this.address.replace(constants.RE_ADDRESS, (0, sprintf_js_1.sprintf)('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join("."), segments.slice(2, 4).join(".")));
      }
    };
    exports2.Address4 = Address4;
  }
});

// node_modules/ip-address/dist/v6/constants.js
var require_constants6 = __commonJS({
  "node_modules/ip-address/dist/v6/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RE_URL_WITH_PORT = exports2.RE_URL = exports2.RE_ZONE_STRING = exports2.RE_SUBNET_STRING = exports2.RE_BAD_ADDRESS = exports2.RE_BAD_CHARACTERS = exports2.TYPES = exports2.SCOPES = exports2.GROUPS = exports2.BITS = void 0;
    exports2.BITS = 128;
    exports2.GROUPS = 8;
    exports2.SCOPES = {
      0: "Reserved",
      1: "Interface local",
      2: "Link local",
      4: "Admin local",
      5: "Site local",
      8: "Organization local",
      14: "Global",
      15: "Reserved"
    };
    exports2.TYPES = {
      "ff01::1/128": "Multicast (All nodes on this interface)",
      "ff01::2/128": "Multicast (All routers on this interface)",
      "ff02::1/128": "Multicast (All nodes on this link)",
      "ff02::2/128": "Multicast (All routers on this link)",
      "ff05::2/128": "Multicast (All routers in this site)",
      "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
      "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
      "ff02::9/128": "Multicast (RIP routers)",
      "ff02::a/128": "Multicast (EIGRP routers)",
      "ff02::d/128": "Multicast (PIM routers)",
      "ff02::16/128": "Multicast (MLDv2 reports)",
      "ff01::fb/128": "Multicast (mDNSv6)",
      "ff02::fb/128": "Multicast (mDNSv6)",
      "ff05::fb/128": "Multicast (mDNSv6)",
      "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
      "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
      "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
      "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
      "::/128": "Unspecified",
      "::1/128": "Loopback",
      "ff00::/8": "Multicast",
      "fe80::/10": "Link-local unicast"
    };
    exports2.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
    exports2.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
    exports2.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
    exports2.RE_ZONE_STRING = /%.*$/;
    exports2.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
    exports2.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
  }
});

// node_modules/ip-address/dist/v6/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/ip-address/dist/v6/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.simpleGroup = exports2.spanLeadingZeroes = exports2.spanAll = exports2.spanAllZeroes = void 0;
    var sprintf_js_1 = require_sprintf();
    function spanAllZeroes(s) {
      return s.replace(/(0+)/g, '<span class="zero">$1</span>');
    }
    exports2.spanAllZeroes = spanAllZeroes;
    function spanAll(s, offset = 0) {
      const letters = s.split("");
      return letters.map(
        (n, i) => (0, sprintf_js_1.sprintf)('<span class="digit value-%s position-%d">%s</span>', n, i + offset, spanAllZeroes(n))
        // XXX Use #base-2 .value-0 instead?
      ).join("");
    }
    exports2.spanAll = spanAll;
    function spanLeadingZeroesSimple(group) {
      return group.replace(/^(0+)/, '<span class="zero">$1</span>');
    }
    function spanLeadingZeroes(address) {
      const groups = address.split(":");
      return groups.map((g) => spanLeadingZeroesSimple(g)).join(":");
    }
    exports2.spanLeadingZeroes = spanLeadingZeroes;
    function simpleGroup(addressString, offset = 0) {
      const groups = addressString.split(":");
      return groups.map((g, i) => {
        if (/group-v4/.test(g)) {
          return g;
        }
        return (0, sprintf_js_1.sprintf)('<span class="hover-group group-%d">%s</span>', i + offset, spanLeadingZeroesSimple(g));
      });
    }
    exports2.simpleGroup = simpleGroup;
  }
});

// node_modules/ip-address/dist/v6/regular-expressions.js
var require_regular_expressions = __commonJS({
  "node_modules/ip-address/dist/v6/regular-expressions.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.possibleElisions = exports2.simpleRegularExpression = exports2.ADDRESS_BOUNDARY = exports2.padGroup = exports2.groupPossibilities = void 0;
    var v6 = __importStar(require_constants6());
    var sprintf_js_1 = require_sprintf();
    function groupPossibilities(possibilities) {
      return (0, sprintf_js_1.sprintf)("(%s)", possibilities.join("|"));
    }
    exports2.groupPossibilities = groupPossibilities;
    function padGroup(group) {
      if (group.length < 4) {
        return (0, sprintf_js_1.sprintf)("0{0,%d}%s", 4 - group.length, group);
      }
      return group;
    }
    exports2.padGroup = padGroup;
    exports2.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
    function simpleRegularExpression(groups) {
      const zeroIndexes = [];
      groups.forEach((group, i) => {
        const groupInteger = parseInt(group, 16);
        if (groupInteger === 0) {
          zeroIndexes.push(i);
        }
      });
      const possibilities = zeroIndexes.map((zeroIndex) => groups.map((group, i) => {
        if (i === zeroIndex) {
          const elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
          return groupPossibilities([padGroup(group), elision]);
        }
        return padGroup(group);
      }).join(":"));
      possibilities.push(groups.map(padGroup).join(":"));
      return groupPossibilities(possibilities);
    }
    exports2.simpleRegularExpression = simpleRegularExpression;
    function possibleElisions(elidedGroups, moreLeft, moreRight) {
      const left = moreLeft ? "" : ":";
      const right = moreRight ? "" : ":";
      const possibilities = [];
      if (!moreLeft && !moreRight) {
        possibilities.push("::");
      }
      if (moreLeft && moreRight) {
        possibilities.push("");
      }
      if (moreRight && !moreLeft || !moreRight && moreLeft) {
        possibilities.push(":");
      }
      possibilities.push((0, sprintf_js_1.sprintf)("%s(:0{1,4}){1,%d}", left, elidedGroups - 1));
      possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){1,%d}%s", elidedGroups - 1, right));
      possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){%d}0{1,4}", elidedGroups - 1));
      for (let groups = 1; groups < elidedGroups - 1; groups++) {
        for (let position = 1; position < elidedGroups - groups; position++) {
          possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", position, elidedGroups - position - groups - 1));
        }
      }
      return groupPossibilities(possibilities);
    }
    exports2.possibleElisions = possibleElisions;
  }
});

// node_modules/ip-address/dist/ipv6.js
var require_ipv6 = __commonJS({
  "node_modules/ip-address/dist/ipv6.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Address6 = void 0;
    var common = __importStar(require_common2());
    var constants4 = __importStar(require_constants5());
    var constants6 = __importStar(require_constants6());
    var helpers = __importStar(require_helpers2());
    var ipv4_1 = require_ipv4();
    var regular_expressions_1 = require_regular_expressions();
    var address_error_1 = require_address_error();
    var jsbn_1 = require_jsbn();
    var sprintf_js_1 = require_sprintf();
    function assert(condition) {
      if (!condition) {
        throw new Error("Assertion failed.");
      }
    }
    function addCommas(number) {
      const r = /(\d+)(\d{3})/;
      while (r.test(number)) {
        number = number.replace(r, "$1,$2");
      }
      return number;
    }
    function spanLeadingZeroes4(n) {
      n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
      n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
      return n;
    }
    function compact(address, slice) {
      const s1 = [];
      const s2 = [];
      let i;
      for (i = 0; i < address.length; i++) {
        if (i < slice[0]) {
          s1.push(address[i]);
        } else if (i > slice[1]) {
          s2.push(address[i]);
        }
      }
      return s1.concat(["compact"]).concat(s2);
    }
    function paddedHex(octet) {
      return (0, sprintf_js_1.sprintf)("%04x", parseInt(octet, 16));
    }
    function unsignByte(b) {
      return b & 255;
    }
    var Address6 = class _Address6 {
      constructor(address, optionalGroups) {
        this.addressMinusSuffix = "";
        this.parsedSubnet = "";
        this.subnet = "/128";
        this.subnetMask = 128;
        this.v4 = false;
        this.zone = "";
        this.isInSubnet = common.isInSubnet;
        this.isCorrect = common.isCorrect(constants6.BITS);
        if (optionalGroups === void 0) {
          this.groups = constants6.GROUPS;
        } else {
          this.groups = optionalGroups;
        }
        this.address = address;
        const subnet = constants6.RE_SUBNET_STRING.exec(address);
        if (subnet) {
          this.parsedSubnet = subnet[0].replace("/", "");
          this.subnetMask = parseInt(this.parsedSubnet, 10);
          this.subnet = `/${this.subnetMask}`;
          if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          address = address.replace(constants6.RE_SUBNET_STRING, "");
        } else if (/\//.test(address)) {
          throw new address_error_1.AddressError("Invalid subnet mask.");
        }
        const zone = constants6.RE_ZONE_STRING.exec(address);
        if (zone) {
          this.zone = zone[0];
          address = address.replace(constants6.RE_ZONE_STRING, "");
        }
        this.addressMinusSuffix = address;
        this.parsedAddress = this.parse(this.addressMinusSuffix);
      }
      static isValid(address) {
        try {
          new _Address6(address);
          return true;
        } catch (e) {
          return false;
        }
      }
      /**
       * Convert a BigInteger to a v6 address object
       * @memberof Address6
       * @static
       * @param {BigInteger} bigInteger - a BigInteger to convert
       * @returns {Address6}
       * @example
       * var bigInteger = new BigInteger('1000000000000');
       * var address = Address6.fromBigInteger(bigInteger);
       * address.correctForm(); // '::e8:d4a5:1000'
       */
      static fromBigInteger(bigInteger) {
        const hex = bigInteger.toString(16).padStart(32, "0");
        const groups = [];
        let i;
        for (i = 0; i < constants6.GROUPS; i++) {
          groups.push(hex.slice(i * 4, (i + 1) * 4));
        }
        return new _Address6(groups.join(":"));
      }
      /**
       * Convert a URL (with optional port number) to an address object
       * @memberof Address6
       * @static
       * @param {string} url - a URL with optional port number
       * @example
       * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');
       * addressAndPort.address.correctForm(); // 'ffff::'
       * addressAndPort.port; // 8080
       */
      static fromURL(url) {
        let host;
        let port = null;
        let result;
        if (url.indexOf("[") !== -1 && url.indexOf("]:") !== -1) {
          result = constants6.RE_URL_WITH_PORT.exec(url);
          if (result === null) {
            return {
              error: "failed to parse address with port",
              address: null,
              port: null
            };
          }
          host = result[1];
          port = result[2];
        } else if (url.indexOf("/") !== -1) {
          url = url.replace(/^[a-z0-9]+:\/\//, "");
          result = constants6.RE_URL.exec(url);
          if (result === null) {
            return {
              error: "failed to parse address from URL",
              address: null,
              port: null
            };
          }
          host = result[1];
        } else {
          host = url;
        }
        if (port) {
          port = parseInt(port, 10);
          if (port < 0 || port > 65536) {
            port = null;
          }
        } else {
          port = null;
        }
        return {
          address: new _Address6(host),
          port
        };
      }
      /**
       * Create an IPv6-mapped address given an IPv4 address
       * @memberof Address6
       * @static
       * @param {string} address - An IPv4 address string
       * @returns {Address6}
       * @example
       * var address = Address6.fromAddress4('192.168.0.1');
       * address.correctForm(); // '::ffff:c0a8:1'
       * address.to4in6(); // '::ffff:192.168.0.1'
       */
      static fromAddress4(address) {
        const address4 = new ipv4_1.Address4(address);
        const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
        return new _Address6(`::ffff:${address4.correctForm()}/${mask6}`);
      }
      /**
       * Return an address from ip6.arpa form
       * @memberof Address6
       * @static
       * @param {string} arpaFormAddress - an 'ip6.arpa' form address
       * @returns {Adress6}
       * @example
       * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)
       * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'
       */
      static fromArpa(arpaFormAddress) {
        let address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
        const semicolonAmount = 7;
        if (address.length !== 63) {
          throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
        }
        const parts = address.split(".").reverse();
        for (let i = semicolonAmount; i > 0; i--) {
          const insertIndex = i * 4;
          parts.splice(insertIndex, 0, ":");
        }
        address = parts.join("");
        return new _Address6(address);
      }
      /**
       * Return the Microsoft UNC transcription of the address
       * @memberof Address6
       * @instance
       * @returns {String} the Microsoft UNC transcription of the address
       */
      microsoftTranscription() {
        return (0, sprintf_js_1.sprintf)("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-"));
      }
      /**
       * Return the first n bits of the address, defaulting to the subnet mask
       * @memberof Address6
       * @instance
       * @param {number} [mask=subnet] - the number of bits to mask
       * @returns {String} the first n bits of the address as a string
       */
      mask(mask = this.subnetMask) {
        return this.getBitsBase2(0, mask);
      }
      /**
       * Return the number of possible subnets of a given size in the address
       * @memberof Address6
       * @instance
       * @param {number} [size=128] - the subnet size
       * @returns {String}
       */
      // TODO: probably useful to have a numeric version of this too
      possibleSubnets(subnetSize = 128) {
        const availableBits = constants6.BITS - this.subnetMask;
        const subnetBits = Math.abs(subnetSize - constants6.BITS);
        const subnetPowers = availableBits - subnetBits;
        if (subnetPowers < 0) {
          return "0";
        }
        return addCommas(new jsbn_1.BigInteger("2", 10).pow(subnetPowers).toString(10));
      }
      /**
       * Helper function getting start address.
       * @memberof Address6
       * @instance
       * @returns {BigInteger}
       */
      _startAddress() {
        return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants6.BITS - this.subnetMask), 2);
      }
      /**
       * The first address in the range given by this address' subnet
       * Often referred to as the Network Address.
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      startAddress() {
        return _Address6.fromBigInteger(this._startAddress());
      }
      /**
       * The first host address in the range given by this address's subnet ie
       * the first address after the Network Address
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      startAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return _Address6.fromBigInteger(this._startAddress().add(adjust));
      }
      /**
       * Helper function getting end address.
       * @memberof Address6
       * @instance
       * @returns {BigInteger}
       */
      _endAddress() {
        return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants6.BITS - this.subnetMask), 2);
      }
      /**
       * The last address in the range given by this address' subnet
       * Often referred to as the Broadcast
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      endAddress() {
        return _Address6.fromBigInteger(this._endAddress());
      }
      /**
       * The last host address in the range given by this address's subnet ie
       * the last address prior to the Broadcast Address
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      endAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return _Address6.fromBigInteger(this._endAddress().subtract(adjust));
      }
      /**
       * Return the scope of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getScope() {
        let scope = constants6.SCOPES[this.getBits(12, 16).intValue()];
        if (this.getType() === "Global unicast" && scope !== "Link local") {
          scope = "Global";
        }
        return scope || "Unknown";
      }
      /**
       * Return the type of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getType() {
        for (const subnet of Object.keys(constants6.TYPES)) {
          if (this.isInSubnet(new _Address6(subnet))) {
            return constants6.TYPES[subnet];
          }
        }
        return "Global unicast";
      }
      /**
       * Return the bits in the given range as a BigInteger
       * @memberof Address6
       * @instance
       * @returns {BigInteger}
       */
      getBits(start, end) {
        return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);
      }
      /**
       * Return the bits in the given range as a base-2 string
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getBitsBase2(start, end) {
        return this.binaryZeroPad().slice(start, end);
      }
      /**
       * Return the bits in the given range as a base-16 string
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getBitsBase16(start, end) {
        const length = end - start;
        if (length % 4 !== 0) {
          throw new Error("Length of bits to retrieve must be divisible by four");
        }
        return this.getBits(start, end).toString(16).padStart(length / 4, "0");
      }
      /**
       * Return the bits that are set past the subnet mask length
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getBitsPastSubnet() {
        return this.getBitsBase2(this.subnetMask, constants6.BITS);
      }
      /**
       * Return the reversed ip6.arpa form of the address
       * @memberof Address6
       * @param {Object} options
       * @param {boolean} options.omitSuffix - omit the "ip6.arpa" suffix
       * @instance
       * @returns {String}
       */
      reverseForm(options) {
        if (!options) {
          options = {};
        }
        const characters = Math.floor(this.subnetMask / 4);
        const reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
        if (characters > 0) {
          if (options.omitSuffix) {
            return reversed;
          }
          return (0, sprintf_js_1.sprintf)("%s.ip6.arpa.", reversed);
        }
        if (options.omitSuffix) {
          return "";
        }
        return "ip6.arpa.";
      }
      /**
       * Return the correct form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      correctForm() {
        let i;
        let groups = [];
        let zeroCounter = 0;
        const zeroes = [];
        for (i = 0; i < this.parsedAddress.length; i++) {
          const value = parseInt(this.parsedAddress[i], 16);
          if (value === 0) {
            zeroCounter++;
          }
          if (value !== 0 && zeroCounter > 0) {
            if (zeroCounter > 1) {
              zeroes.push([i - zeroCounter, i - 1]);
            }
            zeroCounter = 0;
          }
        }
        if (zeroCounter > 1) {
          zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
        }
        const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);
        if (zeroes.length > 0) {
          const index = zeroLengths.indexOf(Math.max(...zeroLengths));
          groups = compact(this.parsedAddress, zeroes[index]);
        } else {
          groups = this.parsedAddress;
        }
        for (i = 0; i < groups.length; i++) {
          if (groups[i] !== "compact") {
            groups[i] = parseInt(groups[i], 16).toString(16);
          }
        }
        let correct = groups.join(":");
        correct = correct.replace(/^compact$/, "::");
        correct = correct.replace(/^compact|compact$/, ":");
        correct = correct.replace(/compact/, "");
        return correct;
      }
      /**
       * Return a zero-padded base-2 string representation of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       * @example
       * var address = new Address6('2001:4860:4001:803::1011');
       * address.binaryZeroPad();
       * // '0010000000000001010010000110000001000000000000010000100000000011
       * //  0000000000000000000000000000000000000000000000000001000000010001'
       */
      binaryZeroPad() {
        return this.bigInteger().toString(2).padStart(constants6.BITS, "0");
      }
      // TODO: Improve the semantics of this helper function
      parse4in6(address) {
        const groups = address.split(":");
        const lastGroup = groups.slice(-1)[0];
        const address4 = lastGroup.match(constants4.RE_ADDRESS);
        if (address4) {
          this.parsedAddress4 = address4[0];
          this.address4 = new ipv4_1.Address4(this.parsedAddress4);
          for (let i = 0; i < this.address4.groups; i++) {
            if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
              throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join(".")));
            }
          }
          this.v4 = true;
          groups[groups.length - 1] = this.address4.toGroup6();
          address = groups.join(":");
        }
        return address;
      }
      // TODO: Make private?
      parse(address) {
        address = this.parse4in6(address);
        const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
        if (badCharacters) {
          throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Bad character%s detected in address: %s", badCharacters.length > 1 ? "s" : "", badCharacters.join("")), address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
        }
        const badAddress = address.match(constants6.RE_BAD_ADDRESS);
        if (badAddress) {
          throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Address failed regex: %s", badAddress.join("")), address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
        }
        let groups = [];
        const halves = address.split("::");
        if (halves.length === 2) {
          let first = halves[0].split(":");
          let last = halves[1].split(":");
          if (first.length === 1 && first[0] === "") {
            first = [];
          }
          if (last.length === 1 && last[0] === "") {
            last = [];
          }
          const remaining = this.groups - (first.length + last.length);
          if (!remaining) {
            throw new address_error_1.AddressError("Error parsing groups");
          }
          this.elidedGroups = remaining;
          this.elisionBegin = first.length;
          this.elisionEnd = first.length + this.elidedGroups;
          groups = groups.concat(first);
          for (let i = 0; i < remaining; i++) {
            groups.push("0");
          }
          groups = groups.concat(last);
        } else if (halves.length === 1) {
          groups = address.split(":");
          this.elidedGroups = 0;
        } else {
          throw new address_error_1.AddressError("Too many :: groups found");
        }
        groups = groups.map((group) => (0, sprintf_js_1.sprintf)("%x", parseInt(group, 16)));
        if (groups.length !== this.groups) {
          throw new address_error_1.AddressError("Incorrect number of groups found");
        }
        return groups;
      }
      /**
       * Return the canonical form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      canonicalForm() {
        return this.parsedAddress.map(paddedHex).join(":");
      }
      /**
       * Return the decimal form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      decimal() {
        return this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)("%05d", parseInt(n, 16))).join(":");
      }
      /**
       * Return the address as a BigInteger
       * @memberof Address6
       * @instance
       * @returns {BigInteger}
       */
      bigInteger() {
        return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(""), 16);
      }
      /**
       * Return the last two groups of this address as an IPv4 address string
       * @memberof Address6
       * @instance
       * @returns {Address4}
       * @example
       * var address = new Address6('2001:4860:4001::1825:bf11');
       * address.to4().correctForm(); // '24.37.191.17'
       */
      to4() {
        const binary = this.binaryZeroPad().split("");
        return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary.slice(96, 128).join(""), 2).toString(16));
      }
      /**
       * Return the v4-in-v6 form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      to4in6() {
        const address4 = this.to4();
        const address6 = new _Address6(this.parsedAddress.slice(0, 6).join(":"), 6);
        const correct = address6.correctForm();
        let infix = "";
        if (!/:$/.test(correct)) {
          infix = ":";
        }
        return correct + infix + address4.address;
      }
      /**
       * Return an object containing the Teredo properties of the address
       * @memberof Address6
       * @instance
       * @returns {Object}
       */
      inspectTeredo() {
        const prefix = this.getBitsBase16(0, 32);
        const udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger("ffff", 16)).toString();
        const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
        const client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger("ffffffff", 16)).toString(16));
        const flags = this.getBits(64, 80);
        const flagsBase2 = this.getBitsBase2(64, 80);
        const coneNat = flags.testBit(15);
        const reserved = flags.testBit(14);
        const groupIndividual = flags.testBit(8);
        const universalLocal = flags.testBit(9);
        const nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
        return {
          prefix: (0, sprintf_js_1.sprintf)("%s:%s", prefix.slice(0, 4), prefix.slice(4, 8)),
          server4: server4.address,
          client4: client4.address,
          flags: flagsBase2,
          coneNat,
          microsoft: {
            reserved,
            universalLocal,
            groupIndividual,
            nonce
          },
          udpPort
        };
      }
      /**
       * Return an object containing the 6to4 properties of the address
       * @memberof Address6
       * @instance
       * @returns {Object}
       */
      inspect6to4() {
        const prefix = this.getBitsBase16(0, 16);
        const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
        return {
          prefix: (0, sprintf_js_1.sprintf)("%s", prefix.slice(0, 4)),
          gateway: gateway.address
        };
      }
      /**
       * Return a v6 6to4 address from a v6 v4inv6 address
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      to6to4() {
        if (!this.is4()) {
          return null;
        }
        const addr6to4 = [
          "2002",
          this.getBitsBase16(96, 112),
          this.getBitsBase16(112, 128),
          "",
          "/16"
        ].join(":");
        return new _Address6(addr6to4);
      }
      /**
       * Return a byte array
       * @memberof Address6
       * @instance
       * @returns {Array}
       */
      toByteArray() {
        const byteArray = this.bigInteger().toByteArray();
        if (byteArray.length === 17 && byteArray[0] === 0) {
          return byteArray.slice(1);
        }
        return byteArray;
      }
      /**
       * Return an unsigned byte array
       * @memberof Address6
       * @instance
       * @returns {Array}
       */
      toUnsignedByteArray() {
        return this.toByteArray().map(unsignByte);
      }
      /**
       * Convert a byte array to an Address6 object
       * @memberof Address6
       * @static
       * @returns {Address6}
       */
      static fromByteArray(bytes) {
        return this.fromUnsignedByteArray(bytes.map(unsignByte));
      }
      /**
       * Convert an unsigned byte array to an Address6 object
       * @memberof Address6
       * @static
       * @returns {Address6}
       */
      static fromUnsignedByteArray(bytes) {
        const BYTE_MAX = new jsbn_1.BigInteger("256", 10);
        let result = new jsbn_1.BigInteger("0", 10);
        let multiplier = new jsbn_1.BigInteger("1", 10);
        for (let i = bytes.length - 1; i >= 0; i--) {
          result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes[i].toString(10), 10)));
          multiplier = multiplier.multiply(BYTE_MAX);
        }
        return _Address6.fromBigInteger(result);
      }
      /**
       * Returns true if the address is in the canonical form, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isCanonical() {
        return this.addressMinusSuffix === this.canonicalForm();
      }
      /**
       * Returns true if the address is a link local address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isLinkLocal() {
        if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
          return true;
        }
        return false;
      }
      /**
       * Returns true if the address is a multicast address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isMulticast() {
        return this.getType() === "Multicast";
      }
      /**
       * Returns true if the address is a v4-in-v6 address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      is4() {
        return this.v4;
      }
      /**
       * Returns true if the address is a Teredo address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isTeredo() {
        return this.isInSubnet(new _Address6("2001::/32"));
      }
      /**
       * Returns true if the address is a 6to4 address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      is6to4() {
        return this.isInSubnet(new _Address6("2002::/16"));
      }
      /**
       * Returns true if the address is a loopback address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isLoopback() {
        return this.getType() === "Loopback";
      }
      // #endregion
      // #region HTML
      /**
       * @returns {String} the address in link form with a default port of 80
       */
      href(optionalPort) {
        if (optionalPort === void 0) {
          optionalPort = "";
        } else {
          optionalPort = (0, sprintf_js_1.sprintf)(":%s", optionalPort);
        }
        return (0, sprintf_js_1.sprintf)("http://[%s]%s/", this.correctForm(), optionalPort);
      }
      /**
       * @returns {String} a link suitable for conveying the address via a URL hash
       */
      link(options) {
        if (!options) {
          options = {};
        }
        if (options.className === void 0) {
          options.className = "";
        }
        if (options.prefix === void 0) {
          options.prefix = "/#address=";
        }
        if (options.v4 === void 0) {
          options.v4 = false;
        }
        let formFunction = this.correctForm;
        if (options.v4) {
          formFunction = this.to4in6;
        }
        if (options.className) {
          return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s" class="%3$s">%2$s</a>', options.prefix, formFunction.call(this), options.className);
        }
        return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s">%2$s</a>', options.prefix, formFunction.call(this));
      }
      /**
       * Groups an address
       * @returns {String}
       */
      group() {
        if (this.elidedGroups === 0) {
          return helpers.simpleGroup(this.address).join(":");
        }
        assert(typeof this.elidedGroups === "number");
        assert(typeof this.elisionBegin === "number");
        const output = [];
        const [left, right] = this.address.split("::");
        if (left.length) {
          output.push(...helpers.simpleGroup(left));
        } else {
          output.push("");
        }
        const classes = ["hover-group"];
        for (let i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {
          classes.push((0, sprintf_js_1.sprintf)("group-%d", i));
        }
        output.push((0, sprintf_js_1.sprintf)('<span class="%s"></span>', classes.join(" ")));
        if (right.length) {
          output.push(...helpers.simpleGroup(right, this.elisionEnd));
        } else {
          output.push("");
        }
        if (this.is4()) {
          assert(this.address4 instanceof ipv4_1.Address4);
          output.pop();
          output.push(this.address4.groupForV6());
        }
        return output.join(":");
      }
      // #endregion
      // #region Regular expressions
      /**
       * Generate a regular expression string that can be used to find or validate
       * all variations of this address
       * @memberof Address6
       * @instance
       * @param {boolean} substringSearch
       * @returns {string}
       */
      regularExpressionString(substringSearch = false) {
        let output = [];
        const address6 = new _Address6(this.correctForm());
        if (address6.elidedGroups === 0) {
          output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));
        } else if (address6.elidedGroups === constants6.GROUPS) {
          output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));
        } else {
          const halves = address6.address.split("::");
          if (halves[0].length) {
            output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(":")));
          }
          assert(typeof address6.elidedGroups === "number");
          output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
          if (halves[1].length) {
            output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(":")));
          }
          output = [output.join(":")];
        }
        if (!substringSearch) {
          output = [
            "(?=^|",
            regular_expressions_1.ADDRESS_BOUNDARY,
            "|[^\\w\\:])(",
            ...output,
            ")(?=[^\\w\\:]|",
            regular_expressions_1.ADDRESS_BOUNDARY,
            "|$)"
          ];
        }
        return output.join("");
      }
      /**
       * Generate a regular expression that can be used to find or validate all
       * variations of this address.
       * @memberof Address6
       * @instance
       * @param {boolean} substringSearch
       * @returns {RegExp}
       */
      regularExpression(substringSearch = false) {
        return new RegExp(this.regularExpressionString(substringSearch), "i");
      }
    };
    exports2.Address6 = Address6;
  }
});

// node_modules/ip-address/dist/ip-address.js
var require_ip_address = __commonJS({
  "node_modules/ip-address/dist/ip-address.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.v6 = exports2.AddressError = exports2.Address6 = exports2.Address4 = void 0;
    var ipv4_1 = require_ipv4();
    Object.defineProperty(exports2, "Address4", { enumerable: true, get: function() {
      return ipv4_1.Address4;
    } });
    var ipv6_1 = require_ipv6();
    Object.defineProperty(exports2, "Address6", { enumerable: true, get: function() {
      return ipv6_1.Address6;
    } });
    var address_error_1 = require_address_error();
    Object.defineProperty(exports2, "AddressError", { enumerable: true, get: function() {
      return address_error_1.AddressError;
    } });
    var helpers = __importStar(require_helpers2());
    exports2.v6 = { helpers };
  }
});

// node_modules/socks/build/common/helpers.js
var require_helpers3 = __commonJS({
  "node_modules/socks/build/common/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ipToBuffer = exports2.int32ToIpv4 = exports2.ipv4ToInt32 = exports2.validateSocksClientChainOptions = exports2.validateSocksClientOptions = void 0;
    var util_1 = require_util();
    var constants_1 = require_constants4();
    var stream = require("stream");
    var ip_address_1 = require_ip_address();
    var net = require("net");
    function validateSocksClientOptions(options, acceptedCommands = ["connect", "bind", "associate"]) {
      if (!constants_1.SocksCommand[options.command]) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);
      }
      if (acceptedCommands.indexOf(options.command) === -1) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);
      }
      if (!isValidSocksRemoteHost(options.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
      }
      if (!isValidSocksProxy(options.proxy)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
      }
      validateCustomProxyAuth(options.proxy, options);
      if (options.timeout && !isValidTimeoutValue(options.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
      }
      if (options.existing_socket && !(options.existing_socket instanceof stream.Duplex)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);
      }
    }
    exports2.validateSocksClientOptions = validateSocksClientOptions;
    function validateSocksClientChainOptions(options) {
      if (options.command !== "connect") {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);
      }
      if (!isValidSocksRemoteHost(options.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
      }
      if (!(options.proxies && Array.isArray(options.proxies) && options.proxies.length >= 2)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);
      }
      options.proxies.forEach((proxy) => {
        if (!isValidSocksProxy(proxy)) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
        }
        validateCustomProxyAuth(proxy, options);
      });
      if (options.timeout && !isValidTimeoutValue(options.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
      }
    }
    exports2.validateSocksClientChainOptions = validateSocksClientChainOptions;
    function validateCustomProxyAuth(proxy, options) {
      if (proxy.custom_auth_method !== void 0) {
        if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);
        }
        if (proxy.custom_auth_request_handler === void 0 || typeof proxy.custom_auth_request_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
        if (proxy.custom_auth_response_size === void 0) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
        if (proxy.custom_auth_response_handler === void 0 || typeof proxy.custom_auth_response_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
      }
    }
    function isValidSocksRemoteHost(remoteHost) {
      return remoteHost && typeof remoteHost.host === "string" && typeof remoteHost.port === "number" && remoteHost.port >= 0 && remoteHost.port <= 65535;
    }
    function isValidSocksProxy(proxy) {
      return proxy && (typeof proxy.host === "string" || typeof proxy.ipaddress === "string") && typeof proxy.port === "number" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);
    }
    function isValidTimeoutValue(value) {
      return typeof value === "number" && value > 0;
    }
    function ipv4ToInt32(ip) {
      const address = new ip_address_1.Address4(ip);
      return address.toArray().reduce((acc, part) => (acc << 8) + part, 0);
    }
    exports2.ipv4ToInt32 = ipv4ToInt32;
    function int32ToIpv4(int32) {
      const octet1 = int32 >>> 24 & 255;
      const octet2 = int32 >>> 16 & 255;
      const octet3 = int32 >>> 8 & 255;
      const octet4 = int32 & 255;
      return [octet1, octet2, octet3, octet4].join(".");
    }
    exports2.int32ToIpv4 = int32ToIpv4;
    function ipToBuffer(ip) {
      if (net.isIPv4(ip)) {
        const address = new ip_address_1.Address4(ip);
        return Buffer.from(address.toArray());
      } else if (net.isIPv6(ip)) {
        const address = new ip_address_1.Address6(ip);
        return Buffer.from(address.canonicalForm().split(":").map((segment) => segment.padStart(4, "0")).join(""), "hex");
      } else {
        throw new Error("Invalid IP address format");
      }
    }
    exports2.ipToBuffer = ipToBuffer;
  }
});

// node_modules/socks/build/common/receivebuffer.js
var require_receivebuffer = __commonJS({
  "node_modules/socks/build/common/receivebuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReceiveBuffer = void 0;
    var ReceiveBuffer = class {
      constructor(size = 4096) {
        this.buffer = Buffer.allocUnsafe(size);
        this.offset = 0;
        this.originalSize = size;
      }
      get length() {
        return this.offset;
      }
      append(data) {
        if (!Buffer.isBuffer(data)) {
          throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
        }
        if (this.offset + data.length >= this.buffer.length) {
          const tmp = this.buffer;
          this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));
          tmp.copy(this.buffer);
        }
        data.copy(this.buffer, this.offset);
        return this.offset += data.length;
      }
      peek(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        return this.buffer.slice(0, length);
      }
      get(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        const value = Buffer.allocUnsafe(length);
        this.buffer.slice(0, length).copy(value);
        this.buffer.copyWithin(0, length, length + this.offset - length);
        this.offset -= length;
        return value;
      }
    };
    exports2.ReceiveBuffer = ReceiveBuffer;
  }
});

// node_modules/socks/build/client/socksclient.js
var require_socksclient = __commonJS({
  "node_modules/socks/build/client/socksclient.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SocksClientError = exports2.SocksClient = void 0;
    var events_1 = require("events");
    var net = require("net");
    var smart_buffer_1 = require_smartbuffer();
    var constants_1 = require_constants4();
    var helpers_1 = require_helpers3();
    var receivebuffer_1 = require_receivebuffer();
    var util_1 = require_util();
    Object.defineProperty(exports2, "SocksClientError", { enumerable: true, get: function() {
      return util_1.SocksClientError;
    } });
    var ip_address_1 = require_ip_address();
    var SocksClient = class _SocksClient extends events_1.EventEmitter {
      constructor(options) {
        super();
        this.options = Object.assign({}, options);
        (0, helpers_1.validateSocksClientOptions)(options);
        this.setState(constants_1.SocksClientState.Created);
      }
      /**
       * Creates a new SOCKS connection.
       *
       * Note: Supports callbacks and promises. Only supports the connect command.
       * @param options { SocksClientOptions } Options.
       * @param callback { Function } An optional callback function.
       * @returns { Promise }
       */
      static createConnection(options, callback) {
        return new Promise((resolve, reject) => {
          try {
            (0, helpers_1.validateSocksClientOptions)(options, ["connect"]);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          const client = new _SocksClient(options);
          client.connect(options.existing_socket);
          client.once("established", (info) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(null, info);
              resolve(info);
            } else {
              resolve(info);
            }
          });
          client.once("error", (err) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          });
        });
      }
      /**
       * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.
       *
       * Note: Supports callbacks and promises. Only supports the connect method.
       * Note: Implemented via createConnection() factory function.
       * @param options { SocksClientChainOptions } Options
       * @param callback { Function } An optional callback function.
       * @returns { Promise }
       */
      static createConnectionChain(options, callback) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          try {
            (0, helpers_1.validateSocksClientChainOptions)(options);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          if (options.randomizeChain) {
            (0, util_1.shuffleArray)(options.proxies);
          }
          try {
            let sock;
            for (let i = 0; i < options.proxies.length; i++) {
              const nextProxy = options.proxies[i];
              const nextDestination = i === options.proxies.length - 1 ? options.destination : {
                host: options.proxies[i + 1].host || options.proxies[i + 1].ipaddress,
                port: options.proxies[i + 1].port
              };
              const result = yield _SocksClient.createConnection({
                command: "connect",
                proxy: nextProxy,
                destination: nextDestination,
                existing_socket: sock
              });
              sock = sock || result.socket;
            }
            if (typeof callback === "function") {
              callback(null, { socket: sock });
              resolve({ socket: sock });
            } else {
              resolve({ socket: sock });
            }
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          }
        }));
      }
      /**
       * Creates a SOCKS UDP Frame.
       * @param options
       */
      static createUDPFrame(options) {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt16BE(0);
        buff.writeUInt8(options.frameNumber || 0);
        if (net.isIPv4(options.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeUInt32BE((0, helpers_1.ipv4ToInt32)(options.remoteHost.host));
        } else if (net.isIPv6(options.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(options.remoteHost.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
          buff.writeString(options.remoteHost.host);
        }
        buff.writeUInt16BE(options.remoteHost.port);
        buff.writeBuffer(options.data);
        return buff.toBuffer();
      }
      /**
       * Parses a SOCKS UDP frame.
       * @param data
       */
      static parseUDPFrame(data) {
        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
        buff.readOffset = 2;
        const frameNumber = buff.readUInt8();
        const hostType = buff.readUInt8();
        let remoteHost;
        if (hostType === constants_1.Socks5HostType.IPv4) {
          remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());
        } else if (hostType === constants_1.Socks5HostType.IPv6) {
          remoteHost = ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm();
        } else {
          remoteHost = buff.readString(buff.readUInt8());
        }
        const remotePort = buff.readUInt16BE();
        return {
          frameNumber,
          remoteHost: {
            host: remoteHost,
            port: remotePort
          },
          data: buff.readBuffer()
        };
      }
      /**
       * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.
       */
      setState(newState) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.state = newState;
        }
      }
      /**
       * Starts the connection establishment to the proxy and destination.
       * @param existingSocket Connected socket to use instead of creating a new one (internal use).
       */
      connect(existingSocket) {
        this.onDataReceived = (data) => this.onDataReceivedHandler(data);
        this.onClose = () => this.onCloseHandler();
        this.onError = (err) => this.onErrorHandler(err);
        this.onConnect = () => this.onConnectHandler();
        const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);
        if (timer.unref && typeof timer.unref === "function") {
          timer.unref();
        }
        if (existingSocket) {
          this.socket = existingSocket;
        } else {
          this.socket = new net.Socket();
        }
        this.socket.once("close", this.onClose);
        this.socket.once("error", this.onError);
        this.socket.once("connect", this.onConnect);
        this.socket.on("data", this.onDataReceived);
        this.setState(constants_1.SocksClientState.Connecting);
        this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
        if (existingSocket) {
          this.socket.emit("connect");
        } else {
          this.socket.connect(this.getSocketOptions());
          if (this.options.set_tcp_nodelay !== void 0 && this.options.set_tcp_nodelay !== null) {
            this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
          }
        }
        this.prependOnceListener("established", (info) => {
          setImmediate(() => {
            if (this.receiveBuffer.length > 0) {
              const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
              info.socket.emit("data", excessData);
            }
            info.socket.resume();
          });
        });
      }
      // Socket options (defaults host/port to options.proxy.host/options.proxy.port)
      getSocketOptions() {
        return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
      }
      /**
       * Handles internal Socks timeout callback.
       * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.
       */
      onEstablishedTimeout() {
        if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {
          this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
        }
      }
      /**
       * Handles Socket connect event.
       */
      onConnectHandler() {
        this.setState(constants_1.SocksClientState.Connected);
        if (this.options.proxy.type === 4) {
          this.sendSocks4InitialHandshake();
        } else {
          this.sendSocks5InitialHandshake();
        }
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      /**
       * Handles Socket data event.
       * @param data
       */
      onDataReceivedHandler(data) {
        this.receiveBuffer.append(data);
        this.processData();
      }
      /**
       * Handles processing of the data we have received.
       */
      processData() {
        while (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
          if (this.state === constants_1.SocksClientState.SentInitialHandshake) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4FinalHandshakeResponse();
            } else {
              this.handleInitialSocks5HandshakeResponse();
            }
          } else if (this.state === constants_1.SocksClientState.SentAuthentication) {
            this.handleInitialSocks5AuthenticationHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {
            this.handleSocks5FinalHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4IncomingConnectionResponse();
            } else {
              this.handleSocks5IncomingConnectionResponse();
            }
          } else {
            this.closeSocket(constants_1.ERRORS.InternalError);
            break;
          }
        }
      }
      /**
       * Handles Socket close event.
       * @param had_error
       */
      onCloseHandler() {
        this.closeSocket(constants_1.ERRORS.SocketClosed);
      }
      /**
       * Handles Socket error event.
       * @param err
       */
      onErrorHandler(err) {
        this.closeSocket(err.message);
      }
      /**
       * Removes internal event listeners on the underlying Socket.
       */
      removeInternalSocketHandlers() {
        this.socket.pause();
        this.socket.removeListener("data", this.onDataReceived);
        this.socket.removeListener("close", this.onClose);
        this.socket.removeListener("error", this.onError);
        this.socket.removeListener("connect", this.onConnect);
      }
      /**
       * Closes and destroys the underlying Socket. Emits an error event.
       * @param err { String } An error string to include in error event.
       */
      closeSocket(err) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.setState(constants_1.SocksClientState.Error);
          this.socket.destroy();
          this.removeInternalSocketHandlers();
          this.emit("error", new util_1.SocksClientError(err, this.options));
        }
      }
      /**
       * Sends initial Socks v4 handshake request.
       */
      sendSocks4InitialHandshake() {
        const userId = this.options.proxy.userId || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(4);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt16BE(this.options.destination.port);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
          buff.writeStringNT(userId);
        } else {
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(1);
          buff.writeStringNT(userId);
          buff.writeStringNT(this.options.destination.host);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
        this.socket.write(buff.toBuffer());
      }
      /**
       * Handles Socks v4 handshake response.
       * @param data
       */
      handleSocks4FinalHandshakeResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
            buff.readOffset = 2;
            const remoteHost = {
              port: buff.readUInt16BE(),
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.emit("bound", { remoteHost, socket: this.socket });
          } else {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { socket: this.socket });
          }
        }
      }
      /**
       * Handles Socks v4 incoming connection request (BIND)
       * @param data
       */
      handleSocks4IncomingConnectionResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
          buff.readOffset = 2;
          const remoteHost = {
            port: buff.readUInt16BE(),
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
          };
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      /**
       * Sends initial Socks v5 handshake request.
       */
      sendSocks5InitialHandshake() {
        const buff = new smart_buffer_1.SmartBuffer();
        const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
        if (this.options.proxy.userId || this.options.proxy.password) {
          supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
        }
        if (this.options.proxy.custom_auth_method !== void 0) {
          supportedAuthMethods.push(this.options.proxy.custom_auth_method);
        }
        buff.writeUInt8(5);
        buff.writeUInt8(supportedAuthMethods.length);
        for (const authMethod of supportedAuthMethods) {
          buff.writeUInt8(authMethod);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      /**
       * Handles initial Socks v5 handshake response.
       * @param data
       */
      handleInitialSocks5HandshakeResponse() {
        const data = this.receiveBuffer.get(2);
        if (data[0] !== 5) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
        } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
        } else {
          if (data[1] === constants_1.Socks5Auth.NoAuth) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
            this.sendSocks5CommandRequest();
          } else if (data[1] === constants_1.Socks5Auth.UserPass) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
            this.sendSocks5UserPassAuthentication();
          } else if (data[1] === this.options.proxy.custom_auth_method) {
            this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
            this.sendSocks5CustomAuthentication();
          } else {
            this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
          }
        }
      }
      /**
       * Sends Socks v5 user & password auth handshake.
       *
       * Note: No auth and user/pass are currently supported.
       */
      sendSocks5UserPassAuthentication() {
        const userId = this.options.proxy.userId || "";
        const password = this.options.proxy.password || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(1);
        buff.writeUInt8(Buffer.byteLength(userId));
        buff.writeString(userId);
        buff.writeUInt8(Buffer.byteLength(password));
        buff.writeString(password);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentAuthentication);
      }
      sendSocks5CustomAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
          this.socket.write(yield this.options.proxy.custom_auth_request_handler());
          this.setState(constants_1.SocksClientState.SentAuthentication);
        });
      }
      handleSocks5CustomAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.options.proxy.custom_auth_response_handler(data);
        });
      }
      handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      handleSocks5AuthenticationUserPassHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      /**
       * Handles Socks v5 auth handshake response.
       * @param data
       */
      handleInitialSocks5AuthenticationHandshakeResponse() {
        return __awaiter(this, void 0, void 0, function* () {
          this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);
          let authResult = false;
          if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
            authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {
            authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
            authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
          }
          if (!authResult) {
            this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
          } else {
            this.sendSocks5CommandRequest();
          }
        });
      }
      /**
       * Sends Socks v5 final handshake request.
       */
      sendSocks5CommandRequest() {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(5);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt8(0);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        } else if (net.isIPv6(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(this.options.destination.host.length);
          buff.writeString(this.options.destination.host);
        }
        buff.writeUInt16BE(this.options.destination.port);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentFinalHandshake);
      }
      /**
       * Handles Socks v5 final handshake response.
       * @param data
       */
      handleSocks5FinalHandshakeResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
            this.emit("bound", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", {
              remoteHost,
              socket: this.socket
            });
          }
        }
      }
      /**
       * Handles Socks v5 incoming connection request (BIND).
       */
      handleSocks5IncomingConnectionResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      get socksClientOptions() {
        return Object.assign({}, this.options);
      }
    };
    exports2.SocksClient = SocksClient;
  }
});

// node_modules/socks/build/index.js
var require_build = __commonJS({
  "node_modules/socks/build/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_socksclient(), exports2);
  }
});

// node_modules/socks-proxy-agent/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/socks-proxy-agent/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SocksProxyAgent = void 0;
    var socks_1 = require_build();
    var agent_base_1 = require_dist();
    var debug_1 = __importDefault(require_src());
    var dns = __importStar(require("dns"));
    var net = __importStar(require("net"));
    var tls = __importStar(require("tls"));
    var url_1 = require("url");
    var debug = (0, debug_1.default)("socks-proxy-agent");
    var setServernameFromNonIpHost = (options) => {
      if (options.servername === void 0 && options.host && !net.isIP(options.host)) {
        return {
          ...options,
          servername: options.host
        };
      }
      return options;
    };
    function parseSocksURL(url) {
      let lookup = false;
      let type = 5;
      const host = url.hostname;
      const port = parseInt(url.port, 10) || 1080;
      switch (url.protocol.replace(":", "")) {
        case "socks4":
          lookup = true;
          type = 4;
          break;
        // pass through
        case "socks4a":
          type = 4;
          break;
        case "socks5":
          lookup = true;
          type = 5;
          break;
        // pass through
        case "socks":
          type = 5;
          break;
        case "socks5h":
          type = 5;
          break;
        default:
          throw new TypeError(`A "socks" protocol must be specified! Got: ${String(url.protocol)}`);
      }
      const proxy = {
        host,
        port,
        type
      };
      if (url.username) {
        Object.defineProperty(proxy, "userId", {
          value: decodeURIComponent(url.username),
          enumerable: false
        });
      }
      if (url.password != null) {
        Object.defineProperty(proxy, "password", {
          value: decodeURIComponent(url.password),
          enumerable: false
        });
      }
      return { lookup, proxy };
    }
    var SocksProxyAgent = class extends agent_base_1.Agent {
      constructor(uri, opts) {
        super(opts);
        const url = typeof uri === "string" ? new url_1.URL(uri) : uri;
        const { proxy, lookup } = parseSocksURL(url);
        this.shouldLookup = lookup;
        this.proxy = proxy;
        this.timeout = opts?.timeout ?? null;
        this.socketOptions = opts?.socketOptions ?? null;
      }
      /**
       * Initiates a SOCKS connection to the specified SOCKS proxy server,
       * which in turn connects to the specified remote host and port.
       */
      async connect(req, opts) {
        const { shouldLookup, proxy, timeout } = this;
        if (!opts.host) {
          throw new Error("No `host` defined!");
        }
        let { host } = opts;
        const { port, lookup: lookupFn = dns.lookup } = opts;
        if (shouldLookup) {
          host = await new Promise((resolve, reject) => {
            lookupFn(host, {}, (err, res) => {
              if (err) {
                reject(err);
              } else {
                resolve(res);
              }
            });
          });
        }
        const socksOpts = {
          proxy,
          destination: {
            host,
            port: typeof port === "number" ? port : parseInt(port, 10)
          },
          command: "connect",
          timeout: timeout ?? void 0,
          // @ts-expect-error the type supplied by socks for socket_options is wider
          // than necessary since socks will always override the host and port
          socket_options: this.socketOptions ?? void 0
        };
        const cleanup = (tlsSocket) => {
          req.destroy();
          socket.destroy();
          if (tlsSocket)
            tlsSocket.destroy();
        };
        debug("Creating socks proxy connection: %o", socksOpts);
        const { socket } = await socks_1.SocksClient.createConnection(socksOpts);
        debug("Successfully created socks proxy connection");
        if (timeout !== null) {
          socket.setTimeout(timeout);
          socket.on("timeout", () => cleanup());
        }
        if (opts.secureEndpoint) {
          debug("Upgrading socket connection to TLS");
          const tlsSocket = tls.connect({
            ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
            socket
          });
          tlsSocket.once("error", (error) => {
            debug("Socket TLS error", error.message);
            cleanup(tlsSocket);
          });
          return tlsSocket;
        }
        return socket;
      }
    };
    SocksProxyAgent.protocols = [
      "socks",
      "socks4",
      "socks4a",
      "socks5",
      "socks5h"
    ];
    exports2.SocksProxyAgent = SocksProxyAgent;
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/@npmcli/agent/lib/errors.js
var require_errors5 = __commonJS({
  "node_modules/@npmcli/agent/lib/errors.js"(exports2, module2) {
    "use strict";
    var InvalidProxyProtocolError = class extends Error {
      constructor(url) {
        super(`Invalid protocol \`${url.protocol}\` connecting to proxy \`${url.host}\``);
        this.code = "EINVALIDPROXY";
        this.proxy = url;
      }
    };
    var ConnectionTimeoutError = class extends Error {
      constructor(host) {
        super(`Timeout connecting to host \`${host}\``);
        this.code = "ECONNECTIONTIMEOUT";
        this.host = host;
      }
    };
    var IdleTimeoutError = class extends Error {
      constructor(host) {
        super(`Idle timeout reached for host \`${host}\``);
        this.code = "EIDLETIMEOUT";
        this.host = host;
      }
    };
    var ResponseTimeoutError = class extends Error {
      constructor(request, proxy) {
        let msg = "Response timeout ";
        if (proxy) {
          msg += `from proxy \`${proxy.host}\` `;
        }
        msg += `connecting to host \`${request.host}\``;
        super(msg);
        this.code = "ERESPONSETIMEOUT";
        this.proxy = proxy;
        this.request = request;
      }
    };
    var TransferTimeoutError = class extends Error {
      constructor(request, proxy) {
        let msg = "Transfer timeout ";
        if (proxy) {
          msg += `from proxy \`${proxy.host}\` `;
        }
        msg += `for \`${request.host}\``;
        super(msg);
        this.code = "ETRANSFERTIMEOUT";
        this.proxy = proxy;
        this.request = request;
      }
    };
    module2.exports = {
      InvalidProxyProtocolError,
      ConnectionTimeoutError,
      IdleTimeoutError,
      ResponseTimeoutError,
      TransferTimeoutError
    };
  }
});

// node_modules/@npmcli/agent/lib/proxy.js
var require_proxy = __commonJS({
  "node_modules/@npmcli/agent/lib/proxy.js"(exports2, module2) {
    "use strict";
    var { HttpProxyAgent } = require_dist2();
    var { HttpsProxyAgent } = require_dist3();
    var { SocksProxyAgent } = require_dist4();
    var { LRUCache } = require_commonjs2();
    var { InvalidProxyProtocolError } = require_errors5();
    var PROXY_CACHE = new LRUCache({ max: 20 });
    var SOCKS_PROTOCOLS = new Set(SocksProxyAgent.protocols);
    var PROXY_ENV_KEYS = /* @__PURE__ */ new Set(["https_proxy", "http_proxy", "proxy", "no_proxy"]);
    var PROXY_ENV = Object.entries(process.env).reduce((acc, [key, value]) => {
      key = key.toLowerCase();
      if (PROXY_ENV_KEYS.has(key)) {
        acc[key] = value;
      }
      return acc;
    }, {});
    var getProxyAgent = (url) => {
      url = new URL(url);
      const protocol = url.protocol.slice(0, -1);
      if (SOCKS_PROTOCOLS.has(protocol)) {
        return SocksProxyAgent;
      }
      if (protocol === "https" || protocol === "http") {
        return [HttpProxyAgent, HttpsProxyAgent];
      }
      throw new InvalidProxyProtocolError(url);
    };
    var isNoProxy = (url, noProxy) => {
      if (typeof noProxy === "string") {
        noProxy = noProxy.split(",").map((p) => p.trim()).filter(Boolean);
      }
      if (!noProxy || !noProxy.length) {
        return false;
      }
      const hostSegments = url.hostname.split(".").reverse();
      return noProxy.some((no) => {
        const noSegments = no.split(".").filter(Boolean).reverse();
        if (!noSegments.length) {
          return false;
        }
        for (let i = 0; i < noSegments.length; i++) {
          if (hostSegments[i] !== noSegments[i]) {
            return false;
          }
        }
        return true;
      });
    };
    var getProxy = (url, { proxy, noProxy }) => {
      url = new URL(url);
      if (!proxy) {
        proxy = url.protocol === "https:" ? PROXY_ENV.https_proxy : PROXY_ENV.https_proxy || PROXY_ENV.http_proxy || PROXY_ENV.proxy;
      }
      if (!noProxy) {
        noProxy = PROXY_ENV.no_proxy;
      }
      if (!proxy || isNoProxy(url, noProxy)) {
        return null;
      }
      return new URL(proxy);
    };
    module2.exports = {
      getProxyAgent,
      getProxy,
      proxyCache: PROXY_CACHE
    };
  }
});

// node_modules/@npmcli/agent/lib/agents.js
var require_agents = __commonJS({
  "node_modules/@npmcli/agent/lib/agents.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { once } = require("events");
    var timers = require("timers/promises");
    var { normalizeOptions, cacheOptions } = require_options3();
    var { getProxy, getProxyAgent, proxyCache } = require_proxy();
    var Errors = require_errors5();
    var { Agent: AgentBase } = require_dist();
    module2.exports = class Agent extends AgentBase {
      #options;
      #timeouts;
      #proxy;
      #noProxy;
      #ProxyAgent;
      constructor(options = {}) {
        const { timeouts, proxy, noProxy, ...normalizedOptions } = normalizeOptions(options);
        super(normalizedOptions);
        this.#options = normalizedOptions;
        this.#timeouts = timeouts;
        if (proxy) {
          this.#proxy = new URL(proxy);
          this.#noProxy = noProxy;
          this.#ProxyAgent = getProxyAgent(proxy);
        }
      }
      get proxy() {
        return this.#proxy ? { url: this.#proxy } : {};
      }
      #getProxy(options) {
        if (!this.#proxy) {
          return;
        }
        const proxy = getProxy(`${options.protocol}//${options.host}:${options.port}`, {
          proxy: this.#proxy,
          noProxy: this.#noProxy
        });
        if (!proxy) {
          return;
        }
        const cacheKey = cacheOptions({
          ...options,
          ...this.#options,
          timeouts: this.#timeouts,
          proxy
        });
        if (proxyCache.has(cacheKey)) {
          return proxyCache.get(cacheKey);
        }
        let ProxyAgent = this.#ProxyAgent;
        if (Array.isArray(ProxyAgent)) {
          ProxyAgent = this.isSecureEndpoint(options) ? ProxyAgent[1] : ProxyAgent[0];
        }
        const proxyAgent = new ProxyAgent(proxy, {
          ...this.#options,
          socketOptions: { family: this.#options.family }
        });
        proxyCache.set(cacheKey, proxyAgent);
        return proxyAgent;
      }
      // takes an array of promises and races them against the connection timeout
      // which will throw the necessary error if it is hit. This will return the
      // result of the promise race.
      async #timeoutConnection({ promises, options, timeout }, ac = new AbortController()) {
        if (timeout) {
          const connectionTimeout = timers.setTimeout(timeout, null, { signal: ac.signal }).then(() => {
            throw new Errors.ConnectionTimeoutError(`${options.host}:${options.port}`);
          }).catch((err) => {
            if (err.name === "AbortError") {
              return;
            }
            throw err;
          });
          promises.push(connectionTimeout);
        }
        let result;
        try {
          result = await Promise.race(promises);
          ac.abort();
        } catch (err) {
          ac.abort();
          throw err;
        }
        return result;
      }
      async connect(request, options) {
        options.lookup ??= this.#options.lookup;
        let socket;
        let timeout = this.#timeouts.connection;
        const isSecureEndpoint = this.isSecureEndpoint(options);
        const proxy = this.#getProxy(options);
        if (proxy) {
          const start = Date.now();
          socket = await this.#timeoutConnection({
            options,
            timeout,
            promises: [proxy.connect(request, options)]
          });
          if (timeout) {
            timeout = timeout - (Date.now() - start);
          }
        } else {
          socket = (isSecureEndpoint ? tls : net).connect(options);
        }
        socket.setKeepAlive(this.keepAlive, this.keepAliveMsecs);
        socket.setNoDelay(this.keepAlive);
        const abortController = new AbortController();
        const { signal } = abortController;
        const connectPromise = socket[isSecureEndpoint ? "secureConnecting" : "connecting"] ? once(socket, isSecureEndpoint ? "secureConnect" : "connect", { signal }) : Promise.resolve();
        await this.#timeoutConnection({
          options,
          timeout,
          promises: [
            connectPromise,
            once(socket, "error", { signal }).then((err) => {
              throw err[0];
            })
          ]
        }, abortController);
        if (this.#timeouts.idle) {
          socket.setTimeout(this.#timeouts.idle, () => {
            socket.destroy(new Errors.IdleTimeoutError(`${options.host}:${options.port}`));
          });
        }
        return socket;
      }
      addRequest(request, options) {
        const proxy = this.#getProxy(options);
        if (proxy?.setRequestProps) {
          proxy.setRequestProps(request, options);
        }
        request.setHeader("connection", this.keepAlive ? "keep-alive" : "close");
        if (this.#timeouts.response) {
          let responseTimeout;
          request.once("finish", () => {
            setTimeout(() => {
              request.destroy(new Errors.ResponseTimeoutError(request, this.#proxy));
            }, this.#timeouts.response);
          });
          request.once("response", () => {
            clearTimeout(responseTimeout);
          });
        }
        if (this.#timeouts.transfer) {
          let transferTimeout;
          request.once("response", (res) => {
            setTimeout(() => {
              res.destroy(new Errors.TransferTimeoutError(request, this.#proxy));
            }, this.#timeouts.transfer);
            res.once("close", () => {
              clearTimeout(transferTimeout);
            });
          });
        }
        return super.addRequest(request, options);
      }
    };
  }
});

// node_modules/@npmcli/agent/lib/index.js
var require_lib29 = __commonJS({
  "node_modules/@npmcli/agent/lib/index.js"(exports2, module2) {
    "use strict";
    var { LRUCache } = require_commonjs2();
    var { normalizeOptions, cacheOptions } = require_options3();
    var { getProxy, proxyCache } = require_proxy();
    var dns = require_dns();
    var Agent = require_agents();
    var agentCache = new LRUCache({ max: 20 });
    var getAgent = (url, { agent, proxy, noProxy, ...options } = {}) => {
      if (agent != null) {
        return agent;
      }
      url = new URL(url);
      const proxyForUrl = getProxy(url, { proxy, noProxy });
      const normalizedOptions = {
        ...normalizeOptions(options),
        proxy: proxyForUrl
      };
      const cacheKey = cacheOptions({
        ...normalizedOptions,
        secureEndpoint: url.protocol === "https:"
      });
      if (agentCache.has(cacheKey)) {
        return agentCache.get(cacheKey);
      }
      const newAgent = new Agent(normalizedOptions);
      agentCache.set(cacheKey, newAgent);
      return newAgent;
    };
    module2.exports = {
      getAgent,
      Agent,
      // these are exported for backwards compatability
      HttpAgent: Agent,
      HttpsAgent: Agent,
      cache: {
        proxy: proxyCache,
        agent: agentCache,
        dns: dns.cache,
        clear: () => {
          proxyCache.clear();
          agentCache.clear();
          dns.cache.clear();
        }
      }
    };
  }
});

// node_modules/make-fetch-happen/package.json
var require_package4 = __commonJS({
  "node_modules/make-fetch-happen/package.json"(exports2, module2) {
    module2.exports = {
      name: "make-fetch-happen",
      version: "14.0.3",
      description: "Opinionated, caching, retrying fetch client",
      main: "lib/index.js",
      files: [
        "bin/",
        "lib/"
      ],
      scripts: {
        test: "tap",
        posttest: "npm run lint",
        eslint: 'eslint "**/*.{js,cjs,ts,mjs,jsx,tsx}"',
        lint: "npm run eslint",
        lintfix: "npm run eslint -- --fix",
        postlint: "template-oss-check",
        snap: "tap",
        "template-oss-apply": "template-oss-apply --force"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/npm/make-fetch-happen.git"
      },
      keywords: [
        "http",
        "request",
        "fetch",
        "mean girls",
        "caching",
        "cache",
        "subresource integrity"
      ],
      author: "GitHub Inc.",
      license: "ISC",
      dependencies: {
        "@npmcli/agent": "^3.0.0",
        cacache: "^19.0.1",
        "http-cache-semantics": "^4.1.1",
        minipass: "^7.0.2",
        "minipass-fetch": "^4.0.0",
        "minipass-flush": "^1.0.5",
        "minipass-pipeline": "^1.2.4",
        negotiator: "^1.0.0",
        "proc-log": "^5.0.0",
        "promise-retry": "^2.0.1",
        ssri: "^12.0.0"
      },
      devDependencies: {
        "@npmcli/eslint-config": "^5.0.0",
        "@npmcli/template-oss": "4.23.4",
        nock: "^13.2.4",
        "safe-buffer": "^5.2.1",
        "standard-version": "^9.3.2",
        tap: "^16.0.0"
      },
      engines: {
        node: "^18.17.0 || >=20.5.0"
      },
      tap: {
        color: 1,
        files: "test/*.js",
        "check-coverage": true,
        timeout: 60,
        "nyc-arg": [
          "--exclude",
          "tap-snapshots/**"
        ]
      },
      templateOSS: {
        "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
        version: "4.23.4",
        publish: "true"
      }
    };
  }
});

// node_modules/make-fetch-happen/lib/remote.js
var require_remote = __commonJS({
  "node_modules/make-fetch-happen/lib/remote.js"(exports2, module2) {
    var { Minipass } = require_commonjs3();
    var fetch = require_lib27();
    var promiseRetry = require_promise_retry();
    var ssri = require_lib15();
    var { log } = require_lib4();
    var CachingMinipassPipeline = require_pipeline();
    var { getAgent } = require_lib29();
    var pkg = require_package4();
    var USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`;
    var RETRY_ERRORS = [
      "ECONNRESET",
      // remote socket closed on us
      "ECONNREFUSED",
      // remote host refused to open connection
      "EADDRINUSE",
      // failed to bind to a local port (proxy?)
      "ETIMEDOUT",
      // someone in the transaction is WAY TOO SLOW
      // from @npmcli/agent
      "ECONNECTIONTIMEOUT",
      "EIDLETIMEOUT",
      "ERESPONSETIMEOUT",
      "ETRANSFERTIMEOUT"
      // Known codes we do NOT retry on:
      // ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)
      // EINVALIDPROXY // invalid protocol from @npmcli/agent
      // EINVALIDRESPONSE // invalid status code from @npmcli/agent
    ];
    var RETRY_TYPES = [
      "request-timeout"
    ];
    var remoteFetch = (request, options) => {
      const agent = getAgent(request.url, { ...options, signal: void 0 });
      if (!request.headers.has("connection")) {
        request.headers.set("connection", agent ? "keep-alive" : "close");
      }
      if (!request.headers.has("user-agent")) {
        request.headers.set("user-agent", USER_AGENT);
      }
      const _opts = {
        ...options,
        agent,
        redirect: "manual"
      };
      return promiseRetry(async (retryHandler, attemptNum) => {
        const req = new fetch.Request(request, _opts);
        try {
          let res = await fetch(req, _opts);
          if (_opts.integrity && res.status === 200) {
            const integrityStream = ssri.integrityStream({
              algorithms: _opts.algorithms,
              integrity: _opts.integrity,
              size: _opts.size
            });
            const pipeline = new CachingMinipassPipeline({
              events: ["integrity", "size"]
            }, res.body, integrityStream);
            integrityStream.on("integrity", (i) => pipeline.emit("integrity", i));
            integrityStream.on("size", (s) => pipeline.emit("size", s));
            res = new fetch.Response(pipeline, res);
            res.body.hasIntegrityEmitter = true;
          }
          res.headers.set("x-fetch-attempts", attemptNum);
          const isStream = Minipass.isStream(req.body);
          const isRetriable = req.method !== "POST" && !isStream && ([408, 420, 429].includes(res.status) || res.status >= 500);
          if (isRetriable) {
            if (typeof options.onRetry === "function") {
              options.onRetry(res);
            }
            log.http("fetch", `${req.method} ${req.url} attempt ${attemptNum} failed with ${res.status}`);
            return retryHandler(res);
          }
          return res;
        } catch (err) {
          const code = err.code === "EPROMISERETRY" ? err.retried.code : err.code;
          const isRetryError = err.retried instanceof fetch.Response || RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type);
          if (req.method === "POST" || isRetryError) {
            throw err;
          }
          if (typeof options.onRetry === "function") {
            options.onRetry(err);
          }
          log.http("fetch", `${req.method} ${req.url} attempt ${attemptNum} failed with ${err.code}`);
          return retryHandler(err);
        }
      }, options.retry).catch((err) => {
        if (err.status >= 400 && err.type !== "system") {
          return err;
        }
        throw err;
      });
    };
    module2.exports = remoteFetch;
  }
});

// node_modules/make-fetch-happen/lib/cache/entry.js
var require_entry = __commonJS({
  "node_modules/make-fetch-happen/lib/cache/entry.js"(exports2, module2) {
    var { Request, Response } = require_lib27();
    var { Minipass } = require_commonjs3();
    var MinipassFlush = require_minipass_flush();
    var cacache = require_lib20();
    var url = require("url");
    var CachingMinipassPipeline = require_pipeline();
    var CachePolicy = require_policy();
    var cacheKey = require_key();
    var remote = require_remote();
    var hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    var KEEP_REQUEST_HEADERS = [
      "accept-charset",
      "accept-encoding",
      "accept-language",
      "accept",
      "cache-control"
    ];
    var KEEP_RESPONSE_HEADERS = [
      "cache-control",
      "content-encoding",
      "content-language",
      "content-type",
      "date",
      "etag",
      "expires",
      "last-modified",
      "link",
      "location",
      "pragma",
      "vary"
    ];
    var getMetadata = (request, response, options) => {
      const metadata = {
        time: Date.now(),
        url: request.url,
        reqHeaders: {},
        resHeaders: {},
        // options on which we must match the request and vary the response
        options: {
          compress: options.compress != null ? options.compress : request.compress
        }
      };
      if (response.status !== 200 && response.status !== 304) {
        metadata.status = response.status;
      }
      for (const name of KEEP_REQUEST_HEADERS) {
        if (request.headers.has(name)) {
          metadata.reqHeaders[name] = request.headers.get(name);
        }
      }
      const host = request.headers.get("host");
      const parsedUrl = new url.URL(request.url);
      if (host && parsedUrl.host !== host) {
        metadata.reqHeaders.host = host;
      }
      if (response.headers.has("vary")) {
        const vary = response.headers.get("vary");
        if (vary !== "*") {
          const varyHeaders = vary.trim().toLowerCase().split(/\s*,\s*/);
          for (const name of varyHeaders) {
            if (request.headers.has(name)) {
              metadata.reqHeaders[name] = request.headers.get(name);
            }
          }
        }
      }
      for (const name of KEEP_RESPONSE_HEADERS) {
        if (response.headers.has(name)) {
          metadata.resHeaders[name] = response.headers.get(name);
        }
      }
      for (const name of options.cacheAdditionalHeaders) {
        if (response.headers.has(name)) {
          metadata.resHeaders[name] = response.headers.get(name);
        }
      }
      return metadata;
    };
    var _request = Symbol("request");
    var _response = Symbol("response");
    var _policy = Symbol("policy");
    var CacheEntry = class _CacheEntry {
      constructor({ entry, request, response, options }) {
        if (entry) {
          this.key = entry.key;
          this.entry = entry;
          this.entry.metadata.time = this.entry.metadata.time || this.entry.time;
        } else {
          this.key = cacheKey(request);
        }
        this.options = options;
        this[_request] = request;
        this[_response] = response;
        this[_policy] = null;
      }
      // returns a CacheEntry instance that satisfies the given request
      // or undefined if no existing entry satisfies
      static async find(request, options) {
        try {
          var matches = await cacache.index.compact(options.cachePath, cacheKey(request), (A, B) => {
            const entryA = new _CacheEntry({ entry: A, options });
            const entryB = new _CacheEntry({ entry: B, options });
            return entryA.policy.satisfies(entryB.request);
          }, {
            validateEntry: (entry) => {
              if (entry.metadata && entry.metadata.resHeaders && entry.metadata.resHeaders["content-encoding"] === null) {
                return false;
              }
              if (entry.integrity === null) {
                return !!(entry.metadata && entry.metadata.status);
              }
              return true;
            }
          });
        } catch (err) {
          return;
        }
        if (options.cache === "reload") {
          return;
        }
        let match;
        for (const entry of matches) {
          const _entry = new _CacheEntry({
            entry,
            options
          });
          if (_entry.policy.satisfies(request)) {
            match = _entry;
            break;
          }
        }
        return match;
      }
      // if the user made a PUT/POST/PATCH then we invalidate our
      // cache for the same url by deleting the index entirely
      static async invalidate(request, options) {
        const key = cacheKey(request);
        try {
          await cacache.rm.entry(options.cachePath, key, { removeFully: true });
        } catch (err) {
        }
      }
      get request() {
        if (!this[_request]) {
          this[_request] = new Request(this.entry.metadata.url, {
            method: "GET",
            headers: this.entry.metadata.reqHeaders,
            ...this.entry.metadata.options
          });
        }
        return this[_request];
      }
      get response() {
        if (!this[_response]) {
          this[_response] = new Response(null, {
            url: this.entry.metadata.url,
            counter: this.options.counter,
            status: this.entry.metadata.status || 200,
            headers: {
              ...this.entry.metadata.resHeaders,
              "content-length": this.entry.size
            }
          });
        }
        return this[_response];
      }
      get policy() {
        if (!this[_policy]) {
          this[_policy] = new CachePolicy({
            entry: this.entry,
            request: this.request,
            response: this.response,
            options: this.options
          });
        }
        return this[_policy];
      }
      // wraps the response in a pipeline that stores the data
      // in the cache while the user consumes it
      async store(status) {
        if (this.request.method !== "GET" || ![200, 301, 308].includes(this.response.status) || !this.policy.storable()) {
          this.response.headers.set("x-local-cache-status", "skip");
          return this.response;
        }
        const size = this.response.headers.get("content-length");
        const cacheOpts = {
          algorithms: this.options.algorithms,
          metadata: getMetadata(this.request, this.response, this.options),
          size,
          integrity: this.options.integrity,
          integrityEmitter: this.response.body.hasIntegrityEmitter && this.response.body
        };
        let body = null;
        if (this.response.status === 200) {
          let cacheWriteResolve, cacheWriteReject;
          const cacheWritePromise = new Promise((resolve, reject) => {
            cacheWriteResolve = resolve;
            cacheWriteReject = reject;
          }).catch((err) => {
            body.emit("error", err);
          });
          body = new CachingMinipassPipeline({ events: ["integrity", "size"] }, new MinipassFlush({
            flush() {
              return cacheWritePromise;
            }
          }));
          body.hasIntegrityEmitter = true;
          const onResume = () => {
            const tee = new Minipass();
            const cacheStream = cacache.put.stream(this.options.cachePath, this.key, cacheOpts);
            cacheStream.on("integrity", (i) => body.emit("integrity", i));
            cacheStream.on("size", (s) => body.emit("size", s));
            tee.pipe(cacheStream);
            cacheStream.promise().then(cacheWriteResolve, cacheWriteReject);
            body.unshift(tee);
            body.unshift(this.response.body);
          };
          body.once("resume", onResume);
          body.once("end", () => body.removeListener("resume", onResume));
        } else {
          await cacache.index.insert(this.options.cachePath, this.key, null, cacheOpts);
        }
        this.response.headers.set("x-local-cache", encodeURIComponent(this.options.cachePath));
        this.response.headers.set("x-local-cache-key", encodeURIComponent(this.key));
        this.response.headers.set("x-local-cache-mode", "stream");
        this.response.headers.set("x-local-cache-status", status);
        this.response.headers.set("x-local-cache-time", (/* @__PURE__ */ new Date()).toISOString());
        const newResponse = new Response(body, {
          url: this.response.url,
          status: this.response.status,
          headers: this.response.headers,
          counter: this.options.counter
        });
        return newResponse;
      }
      // use the cached data to create a response and return it
      async respond(method, options, status) {
        let response;
        if (method === "HEAD" || [301, 308].includes(this.response.status)) {
          response = this.response;
        } else {
          const body = new Minipass();
          const headers = { ...this.policy.responseHeaders() };
          const onResume = () => {
            const cacheStream = cacache.get.stream.byDigest(
              this.options.cachePath,
              this.entry.integrity,
              { memoize: this.options.memoize }
            );
            cacheStream.on("error", async (err) => {
              cacheStream.pause();
              if (err.code === "EINTEGRITY") {
                await cacache.rm.content(
                  this.options.cachePath,
                  this.entry.integrity,
                  { memoize: this.options.memoize }
                );
              }
              if (err.code === "ENOENT" || err.code === "EINTEGRITY") {
                await _CacheEntry.invalidate(this.request, this.options);
              }
              body.emit("error", err);
              cacheStream.resume();
            });
            body.emit("integrity", this.entry.integrity);
            body.emit("size", Number(headers["content-length"]));
            cacheStream.pipe(body);
          };
          body.once("resume", onResume);
          body.once("end", () => body.removeListener("resume", onResume));
          response = new Response(body, {
            url: this.entry.metadata.url,
            counter: options.counter,
            status: 200,
            headers
          });
        }
        response.headers.set("x-local-cache", encodeURIComponent(this.options.cachePath));
        response.headers.set("x-local-cache-hash", encodeURIComponent(this.entry.integrity));
        response.headers.set("x-local-cache-key", encodeURIComponent(this.key));
        response.headers.set("x-local-cache-mode", "stream");
        response.headers.set("x-local-cache-status", status);
        response.headers.set("x-local-cache-time", new Date(this.entry.metadata.time).toUTCString());
        return response;
      }
      // use the provided request along with this cache entry to
      // revalidate the stored response. returns a response, either
      // from the cache or from the update
      async revalidate(request, options) {
        const revalidateRequest = new Request(request, {
          headers: this.policy.revalidationHeaders(request)
        });
        try {
          var response = await remote(revalidateRequest, {
            ...options,
            headers: void 0
          });
        } catch (err) {
          if (!this.policy.mustRevalidate) {
            return this.respond(request.method, options, "stale");
          }
          throw err;
        }
        if (this.policy.revalidated(revalidateRequest, response)) {
          const metadata = getMetadata(request, response, options);
          for (const name of KEEP_RESPONSE_HEADERS) {
            if (!hasOwnProperty(metadata.resHeaders, name) && hasOwnProperty(this.entry.metadata.resHeaders, name)) {
              metadata.resHeaders[name] = this.entry.metadata.resHeaders[name];
            }
          }
          for (const name of options.cacheAdditionalHeaders) {
            const inMeta = hasOwnProperty(metadata.resHeaders, name);
            const inEntry = hasOwnProperty(this.entry.metadata.resHeaders, name);
            const inPolicy = hasOwnProperty(this.policy.response.headers, name);
            if (!inMeta && inEntry) {
              metadata.resHeaders[name] = this.entry.metadata.resHeaders[name];
            }
            if (!inPolicy && inMeta) {
              this.policy.response.headers[name] = metadata.resHeaders[name];
            }
          }
          try {
            await cacache.index.insert(options.cachePath, this.key, this.entry.integrity, {
              size: this.entry.size,
              metadata
            });
          } catch (err) {
          }
          return this.respond(request.method, options, "revalidated");
        }
        const newEntry = new _CacheEntry({
          request,
          response,
          options
        });
        return newEntry.store("updated");
      }
    };
    module2.exports = CacheEntry;
  }
});

// node_modules/make-fetch-happen/lib/cache/index.js
var require_cache = __commonJS({
  "node_modules/make-fetch-happen/lib/cache/index.js"(exports2, module2) {
    var { NotCachedError } = require_errors4();
    var CacheEntry = require_entry();
    var remote = require_remote();
    var cacheFetch = async (request, options) => {
      const entry = await CacheEntry.find(request, options);
      if (!entry) {
        if (options.cache === "only-if-cached") {
          throw new NotCachedError(request.url);
        }
        const response = await remote(request, options);
        const newEntry = new CacheEntry({ request, response, options });
        return newEntry.store("miss");
      }
      if (options.cache === "no-cache") {
        return entry.revalidate(request, options);
      }
      const _needsRevalidation = entry.policy.needsRevalidation(request);
      if (options.cache === "force-cache" || options.cache === "only-if-cached" || !_needsRevalidation) {
        return entry.respond(request.method, options, _needsRevalidation ? "stale" : "hit");
      }
      return entry.revalidate(request, options);
    };
    cacheFetch.invalidate = async (request, options) => {
      if (!options.cachePath) {
        return;
      }
      return CacheEntry.invalidate(request, options);
    };
    module2.exports = cacheFetch;
  }
});

// node_modules/make-fetch-happen/lib/fetch.js
var require_fetch = __commonJS({
  "node_modules/make-fetch-happen/lib/fetch.js"(exports2, module2) {
    "use strict";
    var { FetchError, Request, isRedirect } = require_lib27();
    var url = require("url");
    var CachePolicy = require_policy();
    var cache = require_cache();
    var remote = require_remote();
    var canFollowRedirect = (request, response, options) => {
      if (!isRedirect(response.status)) {
        return false;
      }
      if (options.redirect === "manual") {
        return false;
      }
      if (options.redirect === "error") {
        throw new FetchError(
          `redirect mode is set to error: ${request.url}`,
          "no-redirect",
          { code: "ENOREDIRECT" }
        );
      }
      if (!response.headers.has("location")) {
        throw new FetchError(
          `redirect location header missing for: ${request.url}`,
          "no-location",
          { code: "EINVALIDREDIRECT" }
        );
      }
      if (request.counter >= request.follow) {
        throw new FetchError(
          `maximum redirect reached at: ${request.url}`,
          "max-redirect",
          { code: "EMAXREDIRECT" }
        );
      }
      return true;
    };
    var getRedirect = (request, response, options) => {
      const _opts = { ...options };
      const location = response.headers.get("location");
      const redirectUrl = new url.URL(location, /^https?:/.test(location) ? void 0 : request.url);
      if (new url.URL(request.url).hostname !== redirectUrl.hostname) {
        request.headers.delete("authorization");
        request.headers.delete("cookie");
      }
      if (response.status === 303 || request.method === "POST" && [301, 302].includes(response.status)) {
        _opts.method = "GET";
        _opts.body = null;
        request.headers.delete("content-length");
      }
      _opts.headers = {};
      request.headers.forEach((value, key) => {
        _opts.headers[key] = value;
      });
      _opts.counter = ++request.counter;
      const redirectReq = new Request(url.format(redirectUrl), _opts);
      return {
        request: redirectReq,
        options: _opts
      };
    };
    var fetch = async (request, options) => {
      const response = CachePolicy.storable(request, options) ? await cache(request, options) : await remote(request, options);
      if (!["GET", "HEAD"].includes(request.method) && response.status >= 200 && response.status <= 399) {
        await cache.invalidate(request, options);
      }
      if (!canFollowRedirect(request, response, options)) {
        return response;
      }
      const redirect = getRedirect(request, response, options);
      return fetch(redirect.request, redirect.options);
    };
    module2.exports = fetch;
  }
});

// node_modules/make-fetch-happen/lib/index.js
var require_lib30 = __commonJS({
  "node_modules/make-fetch-happen/lib/index.js"(exports2, module2) {
    var { FetchError, Headers, Request, Response } = require_lib27();
    var configureOptions = require_options2();
    var fetch = require_fetch();
    var makeFetchHappen = (url, opts) => {
      const options = configureOptions(opts);
      const request = new Request(url, options);
      return fetch(request, options);
    };
    makeFetchHappen.defaults = (defaultUrl, defaultOptions = {}, wrappedFetch = makeFetchHappen) => {
      if (typeof defaultUrl === "object") {
        defaultOptions = defaultUrl;
        defaultUrl = null;
      }
      const defaultedFetch = (url, options = {}) => {
        const finalUrl = url || defaultUrl;
        const finalOptions = {
          ...defaultOptions,
          ...options,
          headers: {
            ...defaultOptions.headers,
            ...options.headers
          }
        };
        return wrappedFetch(finalUrl, finalOptions);
      };
      defaultedFetch.defaults = (defaultUrl1, defaultOptions1 = {}) => makeFetchHappen.defaults(defaultUrl1, defaultOptions1, defaultedFetch);
      return defaultedFetch;
    };
    module2.exports = makeFetchHappen;
    module2.exports.FetchError = FetchError;
    module2.exports.Headers = Headers;
    module2.exports.Request = Request;
    module2.exports.Response = Response;
  }
});

// node_modules/jsonparse/jsonparse.js
var require_jsonparse = __commonJS({
  "node_modules/jsonparse/jsonparse.js"(exports2, module2) {
    var C = {};
    var LEFT_BRACE = C.LEFT_BRACE = 1;
    var RIGHT_BRACE = C.RIGHT_BRACE = 2;
    var LEFT_BRACKET = C.LEFT_BRACKET = 3;
    var RIGHT_BRACKET = C.RIGHT_BRACKET = 4;
    var COLON = C.COLON = 5;
    var COMMA = C.COMMA = 6;
    var TRUE = C.TRUE = 7;
    var FALSE = C.FALSE = 8;
    var NULL = C.NULL = 9;
    var STRING = C.STRING = 10;
    var NUMBER = C.NUMBER = 11;
    var START = C.START = 17;
    var STOP = C.STOP = 18;
    var TRUE1 = C.TRUE1 = 33;
    var TRUE2 = C.TRUE2 = 34;
    var TRUE3 = C.TRUE3 = 35;
    var FALSE1 = C.FALSE1 = 49;
    var FALSE2 = C.FALSE2 = 50;
    var FALSE3 = C.FALSE3 = 51;
    var FALSE4 = C.FALSE4 = 52;
    var NULL1 = C.NULL1 = 65;
    var NULL2 = C.NULL2 = 66;
    var NULL3 = C.NULL3 = 67;
    var NUMBER1 = C.NUMBER1 = 81;
    var NUMBER3 = C.NUMBER3 = 83;
    var STRING1 = C.STRING1 = 97;
    var STRING2 = C.STRING2 = 98;
    var STRING3 = C.STRING3 = 99;
    var STRING4 = C.STRING4 = 100;
    var STRING5 = C.STRING5 = 101;
    var STRING6 = C.STRING6 = 102;
    var VALUE = C.VALUE = 113;
    var KEY = C.KEY = 114;
    var OBJECT = C.OBJECT = 129;
    var ARRAY = C.ARRAY = 130;
    var BACK_SLASH = "\\".charCodeAt(0);
    var FORWARD_SLASH = "/".charCodeAt(0);
    var BACKSPACE = "\b".charCodeAt(0);
    var FORM_FEED = "\f".charCodeAt(0);
    var NEWLINE = "\n".charCodeAt(0);
    var CARRIAGE_RETURN = "\r".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var STRING_BUFFER_SIZE = 64 * 1024;
    function Parser() {
      this.tState = START;
      this.value = void 0;
      this.string = void 0;
      this.stringBuffer = Buffer.alloc ? Buffer.alloc(STRING_BUFFER_SIZE) : new Buffer(STRING_BUFFER_SIZE);
      this.stringBufferOffset = 0;
      this.unicode = void 0;
      this.highSurrogate = void 0;
      this.key = void 0;
      this.mode = void 0;
      this.stack = [];
      this.state = VALUE;
      this.bytes_remaining = 0;
      this.bytes_in_sequence = 0;
      this.temp_buffs = { "2": new Buffer(2), "3": new Buffer(3), "4": new Buffer(4) };
      this.offset = -1;
    }
    Parser.toknam = function(code) {
      var keys = Object.keys(C);
      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        if (C[key] === code) {
          return key;
        }
      }
      return code && "0x" + code.toString(16);
    };
    var proto = Parser.prototype;
    proto.onError = function(err) {
      throw err;
    };
    proto.charError = function(buffer, i) {
      this.tState = STOP;
      this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + Parser.toknam(this.tState)));
    };
    proto.appendStringChar = function(char) {
      if (this.stringBufferOffset >= STRING_BUFFER_SIZE) {
        this.string += this.stringBuffer.toString("utf8");
        this.stringBufferOffset = 0;
      }
      this.stringBuffer[this.stringBufferOffset++] = char;
    };
    proto.appendStringBuf = function(buf, start, end) {
      var size = buf.length;
      if (typeof start === "number") {
        if (typeof end === "number") {
          if (end < 0) {
            size = buf.length - start + end;
          } else {
            size = end - start;
          }
        } else {
          size = buf.length - start;
        }
      }
      if (size < 0) {
        size = 0;
      }
      if (this.stringBufferOffset + size > STRING_BUFFER_SIZE) {
        this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
        this.stringBufferOffset = 0;
      }
      buf.copy(this.stringBuffer, this.stringBufferOffset, start, end);
      this.stringBufferOffset += size;
    };
    proto.write = function(buffer) {
      if (typeof buffer === "string") buffer = new Buffer(buffer);
      var n;
      for (var i = 0, l = buffer.length; i < l; i++) {
        if (this.tState === START) {
          n = buffer[i];
          this.offset++;
          if (n === 123) {
            this.onToken(LEFT_BRACE, "{");
          } else if (n === 125) {
            this.onToken(RIGHT_BRACE, "}");
          } else if (n === 91) {
            this.onToken(LEFT_BRACKET, "[");
          } else if (n === 93) {
            this.onToken(RIGHT_BRACKET, "]");
          } else if (n === 58) {
            this.onToken(COLON, ":");
          } else if (n === 44) {
            this.onToken(COMMA, ",");
          } else if (n === 116) {
            this.tState = TRUE1;
          } else if (n === 102) {
            this.tState = FALSE1;
          } else if (n === 110) {
            this.tState = NULL1;
          } else if (n === 34) {
            this.string = "";
            this.stringBufferOffset = 0;
            this.tState = STRING1;
          } else if (n === 45) {
            this.string = "-";
            this.tState = NUMBER1;
          } else {
            if (n >= 48 && n < 64) {
              this.string = String.fromCharCode(n);
              this.tState = NUMBER3;
            } else if (n === 32 || n === 9 || n === 10 || n === 13) {
            } else {
              return this.charError(buffer, i);
            }
          }
        } else if (this.tState === STRING1) {
          n = buffer[i];
          if (this.bytes_remaining > 0) {
            for (var j = 0; j < this.bytes_remaining; j++) {
              this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
            }
            this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]);
            this.bytes_in_sequence = this.bytes_remaining = 0;
            i = i + j - 1;
          } else if (this.bytes_remaining === 0 && n >= 128) {
            if (n <= 193 || n > 244) {
              return this.onError(new Error("Invalid UTF-8 character at position " + i + " in state " + Parser.toknam(this.tState)));
            }
            if (n >= 194 && n <= 223) this.bytes_in_sequence = 2;
            if (n >= 224 && n <= 239) this.bytes_in_sequence = 3;
            if (n >= 240 && n <= 244) this.bytes_in_sequence = 4;
            if (this.bytes_in_sequence + i > buffer.length) {
              for (var k = 0; k <= buffer.length - 1 - i; k++) {
                this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k];
              }
              this.bytes_remaining = i + this.bytes_in_sequence - buffer.length;
              i = buffer.length - 1;
            } else {
              this.appendStringBuf(buffer, i, i + this.bytes_in_sequence);
              i = i + this.bytes_in_sequence - 1;
            }
          } else if (n === 34) {
            this.tState = START;
            this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
            this.stringBufferOffset = 0;
            this.onToken(STRING, this.string);
            this.offset += Buffer.byteLength(this.string, "utf8") + 1;
            this.string = void 0;
          } else if (n === 92) {
            this.tState = STRING2;
          } else if (n >= 32) {
            this.appendStringChar(n);
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === STRING2) {
          n = buffer[i];
          if (n === 34) {
            this.appendStringChar(n);
            this.tState = STRING1;
          } else if (n === 92) {
            this.appendStringChar(BACK_SLASH);
            this.tState = STRING1;
          } else if (n === 47) {
            this.appendStringChar(FORWARD_SLASH);
            this.tState = STRING1;
          } else if (n === 98) {
            this.appendStringChar(BACKSPACE);
            this.tState = STRING1;
          } else if (n === 102) {
            this.appendStringChar(FORM_FEED);
            this.tState = STRING1;
          } else if (n === 110) {
            this.appendStringChar(NEWLINE);
            this.tState = STRING1;
          } else if (n === 114) {
            this.appendStringChar(CARRIAGE_RETURN);
            this.tState = STRING1;
          } else if (n === 116) {
            this.appendStringChar(TAB);
            this.tState = STRING1;
          } else if (n === 117) {
            this.unicode = "";
            this.tState = STRING3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6) {
          n = buffer[i];
          if (n >= 48 && n < 64 || n > 64 && n <= 70 || n > 96 && n <= 102) {
            this.unicode += String.fromCharCode(n);
            if (this.tState++ === STRING6) {
              var intVal = parseInt(this.unicode, 16);
              this.unicode = void 0;
              if (this.highSurrogate !== void 0 && intVal >= 56320 && intVal < 57343 + 1) {
                this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate, intVal)));
                this.highSurrogate = void 0;
              } else if (this.highSurrogate === void 0 && intVal >= 55296 && intVal < 56319 + 1) {
                this.highSurrogate = intVal;
              } else {
                if (this.highSurrogate !== void 0) {
                  this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate)));
                  this.highSurrogate = void 0;
                }
                this.appendStringBuf(new Buffer(String.fromCharCode(intVal)));
              }
              this.tState = STRING1;
            }
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {
          n = buffer[i];
          switch (n) {
            case 48:
            // 0
            case 49:
            // 1
            case 50:
            // 2
            case 51:
            // 3
            case 52:
            // 4
            case 53:
            // 5
            case 54:
            // 6
            case 55:
            // 7
            case 56:
            // 8
            case 57:
            // 9
            case 46:
            // .
            case 101:
            // e
            case 69:
            // E
            case 43:
            // +
            case 45:
              this.string += String.fromCharCode(n);
              this.tState = NUMBER3;
              break;
            default:
              this.tState = START;
              var result = Number(this.string);
              if (isNaN(result)) {
                return this.charError(buffer, i);
              }
              if (this.string.match(/[0-9]+/) == this.string && result.toString() != this.string) {
                this.onToken(STRING, this.string);
              } else {
                this.onToken(NUMBER, result);
              }
              this.offset += this.string.length - 1;
              this.string = void 0;
              i--;
              break;
          }
        } else if (this.tState === TRUE1) {
          if (buffer[i] === 114) {
            this.tState = TRUE2;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === TRUE2) {
          if (buffer[i] === 117) {
            this.tState = TRUE3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === TRUE3) {
          if (buffer[i] === 101) {
            this.tState = START;
            this.onToken(TRUE, true);
            this.offset += 3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === FALSE1) {
          if (buffer[i] === 97) {
            this.tState = FALSE2;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === FALSE2) {
          if (buffer[i] === 108) {
            this.tState = FALSE3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === FALSE3) {
          if (buffer[i] === 115) {
            this.tState = FALSE4;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === FALSE4) {
          if (buffer[i] === 101) {
            this.tState = START;
            this.onToken(FALSE, false);
            this.offset += 4;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === NULL1) {
          if (buffer[i] === 117) {
            this.tState = NULL2;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === NULL2) {
          if (buffer[i] === 108) {
            this.tState = NULL3;
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === NULL3) {
          if (buffer[i] === 108) {
            this.tState = START;
            this.onToken(NULL, null);
            this.offset += 3;
          } else {
            return this.charError(buffer, i);
          }
        }
      }
    };
    proto.onToken = function(token, value) {
    };
    proto.parseError = function(token, value) {
      this.tState = STOP;
      this.onError(new Error("Unexpected " + Parser.toknam(token) + (value ? "(" + JSON.stringify(value) + ")" : "") + " in state " + Parser.toknam(this.state)));
    };
    proto.push = function() {
      this.stack.push({ value: this.value, key: this.key, mode: this.mode });
    };
    proto.pop = function() {
      var value = this.value;
      var parent = this.stack.pop();
      this.value = parent.value;
      this.key = parent.key;
      this.mode = parent.mode;
      this.emit(value);
      if (!this.mode) {
        this.state = VALUE;
      }
    };
    proto.emit = function(value) {
      if (this.mode) {
        this.state = COMMA;
      }
      this.onValue(value);
    };
    proto.onValue = function(value) {
    };
    proto.onToken = function(token, value) {
      if (this.state === VALUE) {
        if (token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL) {
          if (this.value) {
            this.value[this.key] = value;
          }
          this.emit(value);
        } else if (token === LEFT_BRACE) {
          this.push();
          if (this.value) {
            this.value = this.value[this.key] = {};
          } else {
            this.value = {};
          }
          this.key = void 0;
          this.state = KEY;
          this.mode = OBJECT;
        } else if (token === LEFT_BRACKET) {
          this.push();
          if (this.value) {
            this.value = this.value[this.key] = [];
          } else {
            this.value = [];
          }
          this.key = 0;
          this.mode = ARRAY;
          this.state = VALUE;
        } else if (token === RIGHT_BRACE) {
          if (this.mode === OBJECT) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else if (token === RIGHT_BRACKET) {
          if (this.mode === ARRAY) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else {
          return this.parseError(token, value);
        }
      } else if (this.state === KEY) {
        if (token === STRING) {
          this.key = value;
          this.state = COLON;
        } else if (token === RIGHT_BRACE) {
          this.pop();
        } else {
          return this.parseError(token, value);
        }
      } else if (this.state === COLON) {
        if (token === COLON) {
          this.state = VALUE;
        } else {
          return this.parseError(token, value);
        }
      } else if (this.state === COMMA) {
        if (token === COMMA) {
          if (this.mode === ARRAY) {
            this.key++;
            this.state = VALUE;
          } else if (this.mode === OBJECT) {
            this.state = KEY;
          }
        } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {
          this.pop();
        } else {
          return this.parseError(token, value);
        }
      } else {
        return this.parseError(token, value);
      }
    };
    Parser.C = C;
    module2.exports = Parser;
  }
});

// node_modules/npm-registry-fetch/lib/json-stream.js
var require_json_stream = __commonJS({
  "node_modules/npm-registry-fetch/lib/json-stream.js"(exports2, module2) {
    var Parser = require_jsonparse();
    var { Minipass } = require_commonjs3();
    var JSONStreamError = class extends Error {
      constructor(err, caller) {
        super(err.message);
        Error.captureStackTrace(this, caller || this.constructor);
      }
      get name() {
        return "JSONStreamError";
      }
    };
    var check = (x, y) => typeof x === "string" ? String(y) === x : x && typeof x.test === "function" ? x.test(y) : typeof x === "boolean" || typeof x === "object" ? x : typeof x === "function" ? x(y) : false;
    var JSONStream = class _JSONStream extends Minipass {
      #count = 0;
      #ending = false;
      #footer = null;
      #header = null;
      #map = null;
      #onTokenOriginal;
      #parser;
      #path = null;
      #root = null;
      constructor(opts) {
        super({
          ...opts,
          objectMode: true
        });
        const parser = this.#parser = new Parser();
        parser.onValue = (value) => this.#onValue(value);
        this.#onTokenOriginal = parser.onToken;
        parser.onToken = (token, value) => this.#onToken(token, value);
        parser.onError = (er) => this.#onError(er);
        this.#path = typeof opts.path === "string" ? opts.path.split(".").map((e) => e === "$*" ? { emitKey: true } : e === "*" ? true : e === "" ? { recurse: true } : e) : Array.isArray(opts.path) && opts.path.length ? opts.path : null;
        if (typeof opts.map === "function") {
          this.#map = opts.map;
        }
      }
      #setHeaderFooter(key, value) {
        if (this.#header !== false) {
          this.#header = this.#header || {};
          this.#header[key] = value;
        }
        if (this.#footer !== false && this.#header === false) {
          this.#footer = this.#footer || {};
          this.#footer[key] = value;
        }
      }
      #onError(er) {
        const caller = this.#ending ? this.end : this.write;
        this.#ending = false;
        return this.emit("error", new JSONStreamError(er, caller));
      }
      #onToken(token, value) {
        const parser = this.#parser;
        this.#onTokenOriginal.call(this.#parser, token, value);
        if (parser.stack.length === 0) {
          if (this.#root) {
            const root = this.#root;
            if (!this.#path) {
              super.write(root);
            }
            this.#root = null;
            this.#count = 0;
          }
        }
      }
      #onValue(value) {
        const parser = this.#parser;
        this.#root = value;
        if (!this.#path) {
          return;
        }
        let i = 0;
        let j = 0;
        let emitKey = false;
        while (i < this.#path.length) {
          const key = this.#path[i];
          j++;
          if (key && !key.recurse) {
            const c = j === parser.stack.length ? parser : parser.stack[j];
            if (!c) {
              return;
            }
            if (!check(key, c.key)) {
              this.#setHeaderFooter(c.key, value);
              return;
            }
            emitKey = !!key.emitKey;
            i++;
          } else {
            i++;
            if (i >= this.#path.length) {
              return;
            }
            const nextKey = this.#path[i];
            if (!nextKey) {
              return;
            }
            while (true) {
              const c = j === parser.stack.length ? parser : parser.stack[j];
              if (!c) {
                return;
              }
              if (check(nextKey, c.key)) {
                i++;
                if (!Object.isFrozen(parser.stack[j])) {
                  parser.stack[j].value = null;
                }
                break;
              } else {
                this.#setHeaderFooter(c.key, value);
              }
              j++;
            }
          }
        }
        if (this.#header) {
          const header = this.#header;
          this.#header = false;
          this.emit("header", header);
        }
        if (j !== parser.stack.length) {
          return;
        }
        this.#count++;
        const actualPath = parser.stack.slice(1).map((e) => e.key).concat([parser.key]);
        if (value !== null && value !== void 0) {
          const data = this.#map ? this.#map(value, actualPath) : value;
          if (data !== null && data !== void 0) {
            const emit = emitKey ? { value: data } : data;
            if (emitKey) {
              emit.key = parser.key;
            }
            super.write(emit);
          }
        }
        if (parser.value) {
          delete parser.value[parser.key];
        }
        for (const k of parser.stack) {
          k.value = null;
        }
      }
      write(chunk, encoding) {
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding);
        } else if (!Buffer.isBuffer(chunk)) {
          return this.emit("error", new TypeError(
            "Can only parse JSON from string or buffer input"
          ));
        }
        this.#parser.write(chunk);
        return this.flowing;
      }
      end(chunk, encoding) {
        this.#ending = true;
        if (chunk) {
          this.write(chunk, encoding);
        }
        const h = this.#header;
        this.#header = null;
        const f = this.#footer;
        this.#footer = null;
        if (h) {
          this.emit("header", h);
        }
        if (f) {
          this.emit("footer", f);
        }
        return super.end();
      }
      static get JSONStreamError() {
        return JSONStreamError;
      }
      static parse(path, map) {
        return new _JSONStream({ path, map });
      }
    };
    module2.exports = JSONStream;
  }
});

// node_modules/npm-registry-fetch/lib/index.js
var require_lib31 = __commonJS({
  "node_modules/npm-registry-fetch/lib/index.js"(exports2, module2) {
    "use strict";
    var { HttpErrorAuthOTP } = require_errors3();
    var checkResponse = require_check_response();
    var getAuth = require_auth();
    var fetch = require_lib30();
    var JSONStream = require_json_stream();
    var npa = require_npa();
    var qs = require("querystring");
    var url = require("url");
    var zlib = require_commonjs6();
    var { Minipass } = require_commonjs3();
    var defaultOpts = require_default_opts();
    var urlIsValid = (u) => {
      try {
        return !!new url.URL(u);
      } catch (_) {
        return false;
      }
    };
    module2.exports = regFetch;
    function regFetch(uri, opts_ = {}) {
      const opts = {
        ...defaultOpts,
        ...opts_
      };
      const uriValid = urlIsValid(uri);
      let registry = opts.registry || defaultOpts.registry;
      if (!uriValid) {
        registry = opts.registry = opts.spec && pickRegistry(opts.spec, opts) || opts.registry || registry;
        uri = `${registry.trim().replace(/\/?$/g, "")}/${uri.trim().replace(/^\//, "")}`;
        new url.URL(uri);
      }
      const method = opts.method || "GET";
      const startTime = Date.now();
      const auth = getAuth(uri, opts);
      const headers = getHeaders(uri, auth, opts);
      let body = opts.body;
      const bodyIsStream = Minipass.isStream(body);
      const bodyIsPromise = body && typeof body === "object" && typeof body.then === "function";
      if (body && !bodyIsStream && !bodyIsPromise && typeof body !== "string" && !Buffer.isBuffer(body)) {
        headers["content-type"] = headers["content-type"] || "application/json";
        body = JSON.stringify(body);
      } else if (body && !headers["content-type"]) {
        headers["content-type"] = "application/octet-stream";
      }
      if (opts.gzip) {
        headers["content-encoding"] = "gzip";
        if (bodyIsStream) {
          const gz = new zlib.Gzip();
          body.on(
            "error",
            /* istanbul ignore next: unlikely and hard to test */
            (err) => gz.emit("error", err)
          );
          body = body.pipe(gz);
        } else if (!bodyIsPromise) {
          body = new zlib.Gzip().end(body).concat();
        }
      }
      const parsed = new url.URL(uri);
      if (opts.query) {
        const q = typeof opts.query === "string" ? qs.parse(opts.query) : opts.query;
        Object.keys(q).forEach((key) => {
          if (q[key] !== void 0) {
            parsed.searchParams.set(key, q[key]);
          }
        });
        uri = url.format(parsed);
      }
      if (parsed.searchParams.get("write") === "true" && method === "GET") {
        opts.offline = false;
        opts.preferOffline = false;
        opts.preferOnline = true;
      }
      const doFetch = async (fetchBody) => {
        const p = fetch(uri, {
          agent: opts.agent,
          algorithms: opts.algorithms,
          body: fetchBody,
          cache: getCacheMode(opts),
          cachePath: opts.cache,
          ca: opts.ca,
          cert: auth.cert || opts.cert,
          headers,
          integrity: opts.integrity,
          key: auth.key || opts.key,
          localAddress: opts.localAddress,
          maxSockets: opts.maxSockets,
          memoize: opts.memoize,
          method,
          noProxy: opts.noProxy,
          proxy: opts.httpsProxy || opts.proxy,
          retry: opts.retry ? opts.retry : {
            retries: opts.fetchRetries,
            factor: opts.fetchRetryFactor,
            minTimeout: opts.fetchRetryMintimeout,
            maxTimeout: opts.fetchRetryMaxtimeout
          },
          strictSSL: opts.strictSSL,
          timeout: opts.timeout || 30 * 1e3
        }).then((res) => checkResponse({
          method,
          uri,
          res,
          registry,
          startTime,
          auth,
          opts
        }));
        if (typeof opts.otpPrompt === "function") {
          return p.catch(async (er) => {
            if (er instanceof HttpErrorAuthOTP) {
              let otp;
              try {
                otp = await opts.otpPrompt();
              } catch (_) {
              }
              if (!otp) {
                throw er;
              }
              return regFetch(uri, { ...opts, otp });
            }
            throw er;
          });
        } else {
          return p;
        }
      };
      return Promise.resolve(body).then(doFetch);
    }
    module2.exports.getAuth = getAuth;
    module2.exports.json = fetchJSON;
    function fetchJSON(uri, opts) {
      return regFetch(uri, opts).then((res) => res.json());
    }
    module2.exports.json.stream = fetchJSONStream;
    function fetchJSONStream(uri, jsonPath, opts_ = {}) {
      const opts = { ...defaultOpts, ...opts_ };
      const parser = JSONStream.parse(jsonPath, opts.mapJSON);
      regFetch(uri, opts).then(
        (res) => res.body.on(
          "error",
          /* istanbul ignore next: unlikely and difficult to test */
          (er) => parser.emit("error", er)
        ).pipe(parser)
      ).catch((er) => parser.emit("error", er));
      return parser;
    }
    module2.exports.pickRegistry = pickRegistry;
    function pickRegistry(spec, opts = {}) {
      spec = npa(spec);
      let registry = spec.scope && opts[spec.scope.replace(/^@?/, "@") + ":registry"];
      if (!registry && opts.scope) {
        registry = opts[opts.scope.replace(/^@?/, "@") + ":registry"];
      }
      if (!registry) {
        registry = opts.registry || defaultOpts.registry;
      }
      return registry;
    }
    function getCacheMode(opts) {
      return opts.offline ? "only-if-cached" : opts.preferOffline ? "force-cache" : opts.preferOnline ? "no-cache" : "default";
    }
    function getHeaders(uri, auth, opts) {
      const headers = Object.assign({
        "user-agent": opts.userAgent
      }, opts.headers || {});
      if (opts.authType) {
        headers["npm-auth-type"] = opts.authType;
      }
      if (opts.scope) {
        headers["npm-scope"] = opts.scope;
      }
      if (opts.npmSession) {
        headers["npm-session"] = opts.npmSession;
      }
      if (opts.npmCommand) {
        headers["npm-command"] = opts.npmCommand;
      }
      if (auth.token) {
        headers.authorization = `Bearer ${auth.token}`;
      } else if (auth.auth) {
        headers.authorization = `Basic ${auth.auth}`;
      }
      if (opts.otp) {
        headers["npm-otp"] = opts.otp;
      }
      return headers;
    }
  }
});

// node_modules/pacote/package.json
var require_package5 = __commonJS({
  "node_modules/pacote/package.json"(exports2, module2) {
    module2.exports = {
      name: "pacote",
      version: "21.0.0",
      description: "JavaScript package downloader",
      author: "GitHub Inc.",
      bin: {
        pacote: "bin/index.js"
      },
      license: "ISC",
      main: "lib/index.js",
      scripts: {
        test: "tap",
        snap: "tap",
        lint: "npm run eslint",
        postlint: "template-oss-check",
        lintfix: "npm run eslint -- --fix",
        posttest: "npm run lint",
        "template-oss-apply": "template-oss-apply --force",
        eslint: 'eslint "**/*.{js,cjs,ts,mjs,jsx,tsx}"'
      },
      tap: {
        timeout: 300,
        "nyc-arg": [
          "--exclude",
          "tap-snapshots/**"
        ]
      },
      devDependencies: {
        "@npmcli/arborist": "^8.0.0",
        "@npmcli/eslint-config": "^5.0.0",
        "@npmcli/template-oss": "4.23.4",
        "hosted-git-info": "^8.0.0",
        "mutate-fs": "^2.1.1",
        nock: "^13.2.4",
        "npm-registry-mock": "^1.3.2",
        rimraf: "^6.0.1",
        tap: "^16.0.1"
      },
      files: [
        "bin/",
        "lib/"
      ],
      keywords: [
        "packages",
        "npm",
        "git"
      ],
      dependencies: {
        "@npmcli/git": "^6.0.0",
        "@npmcli/installed-package-contents": "^3.0.0",
        "@npmcli/package-json": "^6.0.0",
        "@npmcli/promise-spawn": "^8.0.0",
        "@npmcli/run-script": "^9.0.0",
        cacache: "^19.0.0",
        "fs-minipass": "^3.0.0",
        minipass: "^7.0.2",
        "npm-package-arg": "^12.0.0",
        "npm-packlist": "^10.0.0",
        "npm-pick-manifest": "^10.0.0",
        "npm-registry-fetch": "^18.0.0",
        "proc-log": "^5.0.0",
        "promise-retry": "^2.0.1",
        sigstore: "^3.0.0",
        ssri: "^12.0.0",
        tar: "^6.1.11"
      },
      engines: {
        node: "^20.17.0 || >=22.9.0"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/npm/pacote.git"
      },
      templateOSS: {
        "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
        version: "4.23.4",
        windowsCI: false,
        publish: "true"
      }
    };
  }
});

// node_modules/pacote/lib/remote.js
var require_remote2 = __commonJS({
  "node_modules/pacote/lib/remote.js"(exports2, module2) {
    var fetch = require_lib31();
    var { Minipass } = require_commonjs3();
    var Fetcher = require_fetcher2();
    var FileFetcher = require_file();
    var _ = require_protected();
    var pacoteVersion = require_package5().version;
    var RemoteFetcher = class extends Fetcher {
      constructor(spec, opts) {
        super(spec, opts);
        this.resolved = this.spec.fetchSpec;
        const resolvedURL = new URL(this.resolved);
        if (this.replaceRegistryHost !== "never" && (this.replaceRegistryHost === "always" || this.replaceRegistryHost === resolvedURL.host)) {
          this.resolved = new URL(resolvedURL.pathname, this.registry).href;
        }
        const nameat = this.spec.name ? `${this.spec.name}@` : "";
        this.pkgid = opts.pkgid ? opts.pkgid : `remote:${nameat}${this.resolved}`;
      }
      // Don't need to cache tarball fetches in pacote, because make-fetch-happen
      // will write into cacache anyway.
      get [_.cacheFetches]() {
        return false;
      }
      [_.tarballFromResolved]() {
        const stream = new Minipass();
        stream.hasIntegrityEmitter = true;
        const fetchOpts = {
          ...this.opts,
          headers: this.#headers(),
          spec: this.spec,
          integrity: this.integrity,
          algorithms: [this.pickIntegrityAlgorithm()]
        };
        fetch(this.resolved, fetchOpts).then((res) => {
          res.body.on(
            "error",
            /* istanbul ignore next - exceedingly rare and hard to simulate */
            (er) => stream.emit("error", er)
          );
          res.body.on("integrity", (i) => {
            this.integrity = i;
            stream.emit("integrity", i);
          });
          res.body.pipe(stream);
        }).catch((er) => stream.emit("error", er));
        return stream;
      }
      #headers() {
        return {
          // npm will override this, but ensure that we always send *something*
          "user-agent": this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,
          ...this.opts.headers || {},
          "pacote-version": pacoteVersion,
          "pacote-req-type": "tarball",
          "pacote-pkg-id": this.pkgid,
          ...this.integrity ? { "pacote-integrity": String(this.integrity) } : {},
          ...this.opts.headers || {}
        };
      }
      get types() {
        return ["remote"];
      }
      // getting a packument and/or manifest is the same as with a file: spec.
      // unpack the tarball stream, and then read from the package.json file.
      packument() {
        return FileFetcher.prototype.packument.apply(this);
      }
      manifest() {
        return FileFetcher.prototype.manifest.apply(this);
      }
    };
    module2.exports = RemoteFetcher;
  }
});

// node_modules/pacote/lib/util/add-git-sha.js
var require_add_git_sha = __commonJS({
  "node_modules/pacote/lib/util/add-git-sha.js"(exports2, module2) {
    var addGitSha = (spec, sha) => {
      if (spec.hosted) {
        const h = spec.hosted;
        const opt = { noCommittish: true };
        const base = h.https && h.auth ? h.https(opt) : h.shortcut(opt);
        return `${base}#${sha}`;
      } else {
        return spec.rawSpec.replace(/#.*$/, "") + `#${sha}`;
      }
    };
    module2.exports = addGitSha;
  }
});

// node_modules/pacote/lib/util/npm.js
var require_npm = __commonJS({
  "node_modules/pacote/lib/util/npm.js"(exports2, module2) {
    var spawn = require_lib7();
    module2.exports = (npmBin, npmCommand, cwd, env, extra) => {
      const isJS = npmBin.endsWith(".js");
      const cmd = isJS ? process.execPath : npmBin;
      const args = (isJS ? [npmBin] : []).concat(npmCommand);
      return spawn(cmd, args, { cwd, env }, extra);
    };
  }
});

// node_modules/pacote/lib/git.js
var require_git = __commonJS({
  "node_modules/pacote/lib/git.js"(exports2, module2) {
    var cacache = require_lib20();
    var git = require_lib12();
    var npa = require_npa();
    var pickManifest = require_lib11();
    var { Minipass } = require_commonjs3();
    var { log } = require_lib4();
    var DirFetcher = require_dir();
    var Fetcher = require_fetcher2();
    var FileFetcher = require_file();
    var RemoteFetcher = require_remote2();
    var _ = require_protected();
    var addGitSha = require_add_git_sha();
    var npm = require_npm();
    var hashre = /^[a-f0-9]{40}$/;
    var repoUrl = (h, opts) => h.sshurl && !(h.https && h.auth) && addGitPlus(h.sshurl(opts)) || h.https && addGitPlus(h.https(opts));
    var addGitPlus = (url) => url && `git+${url}`.replace(/^(git\+)+/, "git+");
    var GitFetcher = class extends Fetcher {
      constructor(spec, opts) {
        super(spec, opts);
        if (this.opts.integrity) {
          delete this.opts.integrity;
          log.warn(`skipping integrity check for git dependency ${this.spec.fetchSpec}`);
        }
        this.resolvedRef = null;
        if (this.spec.hosted) {
          this.from = this.spec.hosted.shortcut({ noCommittish: false });
        }
        if (this.spec.gitCommittish && hashre.test(this.spec.gitCommittish)) {
          this.resolvedSha = this.spec.gitCommittish;
          this.resolved = this.spec.hosted ? repoUrl(this.spec.hosted, { noCommittish: false }) : this.spec.rawSpec;
        } else {
          this.resolvedSha = "";
        }
        this.Arborist = opts.Arborist || null;
      }
      // just exposed to make it easier to test all the combinations
      static repoUrl(hosted, opts) {
        return repoUrl(hosted, opts);
      }
      get types() {
        return ["git"];
      }
      resolve() {
        if (this.resolved) {
          return super.resolve();
        }
        const h = this.spec.hosted;
        return h ? this.#resolvedFromHosted(h) : this.#resolvedFromRepo(this.spec.fetchSpec);
      }
      // first try https, since that's faster and passphrase-less for
      // public repos, and supports private repos when auth is provided.
      // Fall back to SSH to support private repos
      // NB: we always store the https url in resolved field if auth
      // is present, otherwise ssh if the hosted type provides it
      #resolvedFromHosted(hosted) {
        return this.#resolvedFromRepo(hosted.https && hosted.https()).catch((er) => {
          if (er instanceof git.errors.GitPathspecError) {
            throw er;
          }
          const ssh = hosted.sshurl && hosted.sshurl();
          if (!ssh || hosted.auth) {
            throw er;
          }
          return this.#resolvedFromRepo(ssh);
        });
      }
      #resolvedFromRepo(gitRemote) {
        if (!gitRemote) {
          return Promise.reject(new Error(`No git url for ${this.spec}`));
        }
        const gitRange = this.spec.gitRange;
        const name = this.spec.name;
        return git.revs(gitRemote, this.opts).then((remoteRefs) => {
          return gitRange ? pickManifest({
            versions: remoteRefs.versions,
            "dist-tags": remoteRefs["dist-tags"],
            name
          }, gitRange, this.opts) : this.spec.gitCommittish ? remoteRefs.refs[this.spec.gitCommittish] || remoteRefs.refs[remoteRefs.shas[this.spec.gitCommittish]] : remoteRefs.refs.HEAD;
        }).then((revDoc) => {
          if (!revDoc || !revDoc.sha) {
            return this.#resolvedFromClone();
          }
          this.resolvedRef = revDoc;
          this.resolvedSha = revDoc.sha;
          this.#addGitSha(revDoc.sha);
          return this.resolved;
        });
      }
      #setResolvedWithSha(withSha) {
        this.resolved = !this.spec.hosted ? withSha : repoUrl(npa(withSha).hosted, { noCommittish: false });
      }
      // when we get the git sha, we affix it to our spec to build up
      // either a git url with a hash, or a tarball download URL
      #addGitSha(sha) {
        this.#setResolvedWithSha(addGitSha(this.spec, sha));
      }
      #resolvedFromClone() {
        return this.#clone(() => this.resolved);
      }
      #prepareDir(dir) {
        return this[_.readPackageJson](dir).then((mani) => {
          const scripts = mani.scripts;
          if (!mani.workspaces && (!scripts || !(scripts.postinstall || scripts.build || scripts.preinstall || scripts.install || scripts.prepack || scripts.prepare))) {
            return;
          }
          const noPrepare = !process.env._PACOTE_NO_PREPARE_ ? [] : process.env._PACOTE_NO_PREPARE_.split("\n");
          if (noPrepare.includes(this.resolved)) {
            log.info("prepare", "skip prepare, already seen", this.resolved);
            return;
          }
          noPrepare.push(this.resolved);
          return npm(
            this.npmBin,
            [].concat(this.npmInstallCmd).concat(this.npmCliConfig),
            dir,
            { ...process.env, _PACOTE_NO_PREPARE_: noPrepare.join("\n") },
            { message: "git dep preparation failed" }
          );
        });
      }
      [_.tarballFromResolved]() {
        const stream = new Minipass();
        stream.resolved = this.resolved;
        stream.from = this.from;
        this.#clone((dir) => this.#prepareDir(dir).then(() => new Promise((res, rej) => {
          if (!this.Arborist) {
            throw new Error("GitFetcher requires an Arborist constructor to pack a tarball");
          }
          const df = new DirFetcher(`file:${dir}`, {
            ...this.opts,
            Arborist: this.Arborist,
            resolved: null,
            integrity: null
          });
          const dirStream = df[_.tarballFromResolved]();
          dirStream.on("error", rej);
          dirStream.on("end", res);
          dirStream.pipe(stream);
        }))).catch(
          /* istanbul ignore next: very unlikely and hard to test */
          (er) => stream.emit("error", er)
        );
        return stream;
      }
      // clone a git repo into a temp folder (or fetch and unpack if possible)
      // handler accepts a directory, and returns a promise that resolves
      // when we're done with it, at which point, cacache deletes it
      //
      // TODO: after cloning, create a tarball of the folder, and add to the cache
      // with cacache.put.stream(), using a key that's deterministic based on the
      // spec and repo, so that we don't ever clone the same thing multiple times.
      #clone(handler, tarballOk = true) {
        const o = { tmpPrefix: "git-clone" };
        const ref = this.resolvedSha || this.spec.gitCommittish;
        const h = this.spec.hosted;
        const resolved = this.resolved;
        tarballOk = tarballOk && h && resolved === repoUrl(h, { noCommittish: false }) && h.tarball;
        return cacache.tmp.withTmp(this.cache, o, async (tmp) => {
          if (tarballOk) {
            const nameat = this.spec.name ? `${this.spec.name}@` : "";
            return new RemoteFetcher(h.tarball({ noCommittish: false }), {
              ...this.opts,
              allowGitIgnore: true,
              pkgid: `git:${nameat}${this.resolved}`,
              resolved: this.resolved,
              integrity: null
              // it'll always be different, if we have one
            }).extract(tmp).then(() => handler(tmp), (er) => {
              if (er.constructor.name.match(/^Http/)) {
                return this.#clone(handler, false);
              } else {
                throw er;
              }
            });
          }
          const sha = await (h ? this.#cloneHosted(ref, tmp) : this.#cloneRepo(this.spec.fetchSpec, ref, tmp));
          this.resolvedSha = sha;
          if (!this.resolved) {
            await this.#addGitSha(sha);
          }
          return handler(tmp);
        });
      }
      // first try https, since that's faster and passphrase-less for
      // public repos, and supports private repos when auth is provided.
      // Fall back to SSH to support private repos
      // NB: we always store the https url in resolved field if auth
      // is present, otherwise ssh if the hosted type provides it
      #cloneHosted(ref, tmp) {
        const hosted = this.spec.hosted;
        return this.#cloneRepo(hosted.https({ noCommittish: true }), ref, tmp).catch((er) => {
          if (er instanceof git.errors.GitPathspecError) {
            throw er;
          }
          const ssh = hosted.sshurl && hosted.sshurl({ noCommittish: true });
          if (!ssh || hosted.auth) {
            throw er;
          }
          return this.#cloneRepo(ssh, ref, tmp);
        });
      }
      #cloneRepo(repo, ref, tmp) {
        const { opts, spec } = this;
        return git.clone(repo, ref, tmp, { ...opts, spec });
      }
      manifest() {
        if (this.package) {
          return Promise.resolve(this.package);
        }
        return this.spec.hosted && this.resolved ? FileFetcher.prototype.manifest.apply(this) : this.#clone((dir) => this[_.readPackageJson](dir).then((mani) => this.package = {
          ...mani,
          _resolved: this.resolved,
          _from: this.from
        }));
      }
      packument() {
        return FileFetcher.prototype.packument.apply(this);
      }
    };
    module2.exports = GitFetcher;
  }
});

// node_modules/@sigstore/protobuf-specs/dist/__generated__/envelope.js
var require_envelope = __commonJS({
  "node_modules/@sigstore/protobuf-specs/dist/__generated__/envelope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Signature = exports2.Envelope = void 0;
    exports2.Envelope = {
      fromJSON(object) {
        return {
          payload: isSet(object.payload) ? Buffer.from(bytesFromBase64(object.payload)) : Buffer.alloc(0),
          payloadType: isSet(object.payloadType) ? globalThis.String(object.payloadType) : "",
          signatures: globalThis.Array.isArray(object?.signatures) ? object.signatures.map((e) => exports2.Signature.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.payload.length !== 0) {
          obj.payload = base64FromBytes(message.payload);
        }
        if (message.payloadType !== "") {
          obj.payloadType = message.payloadType;
        }
        if (message.signatures?.length) {
          obj.signatures = message.signatures.map((e) => exports2.Signature.toJSON(e));
        }
        return obj;
      }
    };
    exports2.Signature = {
      fromJSON(object) {
        return {
          sig: isSet(object.sig) ? Buffer.from(bytesFromBase64(object.sig)) : Buffer.alloc(0),
          keyid: isSet(object.keyid) ? globalThis.String(object.keyid) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.sig.length !== 0) {
          obj.sig = base64FromBytes(message.sig);
        }
        if (message.keyid !== "") {
          obj.keyid = message.keyid;
        }
        return obj;
      }
    };
    function bytesFromBase64(b64) {
      return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    function base64FromBytes(arr) {
      return globalThis.Buffer.from(arr).toString("base64");
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@sigstore/protobuf-specs/dist/__generated__/google/protobuf/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/@sigstore/protobuf-specs/dist/__generated__/google/protobuf/timestamp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Timestamp = void 0;
    exports2.Timestamp = {
      fromJSON(object) {
        return {
          seconds: isSet(object.seconds) ? globalThis.String(object.seconds) : "0",
          nanos: isSet(object.nanos) ? globalThis.Number(object.nanos) : 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.seconds !== "0") {
          obj.seconds = message.seconds;
        }
        if (message.nanos !== 0) {
          obj.nanos = Math.round(message.nanos);
        }
        return obj;
      }
    };
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@sigstore/protobuf-specs/dist/__generated__/sigstore_common.js
var require_sigstore_common = __commonJS({
  "node_modules/@sigstore/protobuf-specs/dist/__generated__/sigstore_common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimeRange = exports2.X509CertificateChain = exports2.SubjectAlternativeName = exports2.X509Certificate = exports2.DistinguishedName = exports2.ObjectIdentifierValuePair = exports2.ObjectIdentifier = exports2.PublicKeyIdentifier = exports2.PublicKey = exports2.RFC3161SignedTimestamp = exports2.LogId = exports2.MessageSignature = exports2.HashOutput = exports2.SubjectAlternativeNameType = exports2.PublicKeyDetails = exports2.HashAlgorithm = void 0;
    exports2.hashAlgorithmFromJSON = hashAlgorithmFromJSON;
    exports2.hashAlgorithmToJSON = hashAlgorithmToJSON;
    exports2.publicKeyDetailsFromJSON = publicKeyDetailsFromJSON;
    exports2.publicKeyDetailsToJSON = publicKeyDetailsToJSON;
    exports2.subjectAlternativeNameTypeFromJSON = subjectAlternativeNameTypeFromJSON;
    exports2.subjectAlternativeNameTypeToJSON = subjectAlternativeNameTypeToJSON;
    var timestamp_1 = require_timestamp();
    var HashAlgorithm;
    (function(HashAlgorithm2) {
      HashAlgorithm2[HashAlgorithm2["HASH_ALGORITHM_UNSPECIFIED"] = 0] = "HASH_ALGORITHM_UNSPECIFIED";
      HashAlgorithm2[HashAlgorithm2["SHA2_256"] = 1] = "SHA2_256";
      HashAlgorithm2[HashAlgorithm2["SHA2_384"] = 2] = "SHA2_384";
      HashAlgorithm2[HashAlgorithm2["SHA2_512"] = 3] = "SHA2_512";
      HashAlgorithm2[HashAlgorithm2["SHA3_256"] = 4] = "SHA3_256";
      HashAlgorithm2[HashAlgorithm2["SHA3_384"] = 5] = "SHA3_384";
    })(HashAlgorithm || (exports2.HashAlgorithm = HashAlgorithm = {}));
    function hashAlgorithmFromJSON(object) {
      switch (object) {
        case 0:
        case "HASH_ALGORITHM_UNSPECIFIED":
          return HashAlgorithm.HASH_ALGORITHM_UNSPECIFIED;
        case 1:
        case "SHA2_256":
          return HashAlgorithm.SHA2_256;
        case 2:
        case "SHA2_384":
          return HashAlgorithm.SHA2_384;
        case 3:
        case "SHA2_512":
          return HashAlgorithm.SHA2_512;
        case 4:
        case "SHA3_256":
          return HashAlgorithm.SHA3_256;
        case 5:
        case "SHA3_384":
          return HashAlgorithm.SHA3_384;
        default:
          throw new globalThis.Error("Unrecognized enum value " + object + " for enum HashAlgorithm");
      }
    }
    function hashAlgorithmToJSON(object) {
      switch (object) {
        case HashAlgorithm.HASH_ALGORITHM_UNSPECIFIED:
          return "HASH_ALGORITHM_UNSPECIFIED";
        case HashAlgorithm.SHA2_256:
          return "SHA2_256";
        case HashAlgorithm.SHA2_384:
          return "SHA2_384";
        case HashAlgorithm.SHA2_512:
          return "SHA2_512";
        case HashAlgorithm.SHA3_256:
          return "SHA3_256";
        case HashAlgorithm.SHA3_384:
          return "SHA3_384";
        default:
          throw new globalThis.Error("Unrecognized enum value " + object + " for enum HashAlgorithm");
      }
    }
    var PublicKeyDetails;
    (function(PublicKeyDetails2) {
      PublicKeyDetails2[PublicKeyDetails2["PUBLIC_KEY_DETAILS_UNSPECIFIED"] = 0] = "PUBLIC_KEY_DETAILS_UNSPECIFIED";
      PublicKeyDetails2[PublicKeyDetails2["PKCS1_RSA_PKCS1V5"] = 1] = "PKCS1_RSA_PKCS1V5";
      PublicKeyDetails2[PublicKeyDetails2["PKCS1_RSA_PSS"] = 2] = "PKCS1_RSA_PSS";
      PublicKeyDetails2[PublicKeyDetails2["PKIX_RSA_PKCS1V5"] = 3] = "PKIX_RSA_PKCS1V5";
      PublicKeyDetails2[PublicKeyDetails2["PKIX_RSA_PSS"] = 4] = "PKIX_RSA_PSS";
      PublicKeyDetails2[PublicKeyDetails2["PKIX_RSA_PKCS1V15_2048_SHA256"] = 9] = "PKIX_RSA_PKCS1V15_2048_SHA256";
      PublicKeyDetails2[PublicKeyDetails2["PKIX_RSA_PKCS1V15_3072_SHA256"] = 10] = "PKIX_RSA_PKCS1V15_3072_SHA256";
      PublicKeyDetails2[PublicKeyDetails2["PKIX_RSA_PKCS1V15_4096_SHA256"] = 11] = "PKIX_RSA_PKCS1V15_4096_SHA256";
      PublicKeyDetails2[PublicKeyDetails2["PKIX_RSA_PSS_2048_SHA256"] = 16] = "PKIX_RSA_PSS_2048_SHA256";
      PublicKeyDetails2[PublicKeyDetails2["PKIX_RSA_PSS_3072_SHA256"] = 17] = "PKIX_RSA_PSS_3072_SHA256";
      PublicKeyDetails2[PublicKeyDetails2["PKIX_RSA_PSS_4096_SHA256"] = 18] = "PKIX_RSA_PSS_4096_SHA256";
      PublicKeyDetails2[PublicKeyDetails2["PKIX_ECDSA_P256_HMAC_SHA_256"] = 6] = "PKIX_ECDSA_P256_HMAC_SHA_256";
      PublicKeyDetails2[PublicKeyDetails2["PKIX_ECDSA_P256_SHA_256"] = 5] = "PKIX_ECDSA_P256_SHA_256";
      PublicKeyDetails2[PublicKeyDetails2["PKIX_ECDSA_P384_SHA_384"] = 12] = "PKIX_ECDSA_P384_SHA_384";
      PublicKeyDetails2[PublicKeyDetails2["PKIX_ECDSA_P521_SHA_512"] = 13] = "PKIX_ECDSA_P521_SHA_512";
      PublicKeyDetails2[PublicKeyDetails2["PKIX_ED25519"] = 7] = "PKIX_ED25519";
      PublicKeyDetails2[PublicKeyDetails2["PKIX_ED25519_PH"] = 8] = "PKIX_ED25519_PH";
      PublicKeyDetails2[PublicKeyDetails2["LMS_SHA256"] = 14] = "LMS_SHA256";
      PublicKeyDetails2[PublicKeyDetails2["LMOTS_SHA256"] = 15] = "LMOTS_SHA256";
    })(PublicKeyDetails || (exports2.PublicKeyDetails = PublicKeyDetails = {}));
    function publicKeyDetailsFromJSON(object) {
      switch (object) {
        case 0:
        case "PUBLIC_KEY_DETAILS_UNSPECIFIED":
          return PublicKeyDetails.PUBLIC_KEY_DETAILS_UNSPECIFIED;
        case 1:
        case "PKCS1_RSA_PKCS1V5":
          return PublicKeyDetails.PKCS1_RSA_PKCS1V5;
        case 2:
        case "PKCS1_RSA_PSS":
          return PublicKeyDetails.PKCS1_RSA_PSS;
        case 3:
        case "PKIX_RSA_PKCS1V5":
          return PublicKeyDetails.PKIX_RSA_PKCS1V5;
        case 4:
        case "PKIX_RSA_PSS":
          return PublicKeyDetails.PKIX_RSA_PSS;
        case 9:
        case "PKIX_RSA_PKCS1V15_2048_SHA256":
          return PublicKeyDetails.PKIX_RSA_PKCS1V15_2048_SHA256;
        case 10:
        case "PKIX_RSA_PKCS1V15_3072_SHA256":
          return PublicKeyDetails.PKIX_RSA_PKCS1V15_3072_SHA256;
        case 11:
        case "PKIX_RSA_PKCS1V15_4096_SHA256":
          return PublicKeyDetails.PKIX_RSA_PKCS1V15_4096_SHA256;
        case 16:
        case "PKIX_RSA_PSS_2048_SHA256":
          return PublicKeyDetails.PKIX_RSA_PSS_2048_SHA256;
        case 17:
        case "PKIX_RSA_PSS_3072_SHA256":
          return PublicKeyDetails.PKIX_RSA_PSS_3072_SHA256;
        case 18:
        case "PKIX_RSA_PSS_4096_SHA256":
          return PublicKeyDetails.PKIX_RSA_PSS_4096_SHA256;
        case 6:
        case "PKIX_ECDSA_P256_HMAC_SHA_256":
          return PublicKeyDetails.PKIX_ECDSA_P256_HMAC_SHA_256;
        case 5:
        case "PKIX_ECDSA_P256_SHA_256":
          return PublicKeyDetails.PKIX_ECDSA_P256_SHA_256;
        case 12:
        case "PKIX_ECDSA_P384_SHA_384":
          return PublicKeyDetails.PKIX_ECDSA_P384_SHA_384;
        case 13:
        case "PKIX_ECDSA_P521_SHA_512":
          return PublicKeyDetails.PKIX_ECDSA_P521_SHA_512;
        case 7:
        case "PKIX_ED25519":
          return PublicKeyDetails.PKIX_ED25519;
        case 8:
        case "PKIX_ED25519_PH":
          return PublicKeyDetails.PKIX_ED25519_PH;
        case 14:
        case "LMS_SHA256":
          return PublicKeyDetails.LMS_SHA256;
        case 15:
        case "LMOTS_SHA256":
          return PublicKeyDetails.LMOTS_SHA256;
        default:
          throw new globalThis.Error("Unrecognized enum value " + object + " for enum PublicKeyDetails");
      }
    }
    function publicKeyDetailsToJSON(object) {
      switch (object) {
        case PublicKeyDetails.PUBLIC_KEY_DETAILS_UNSPECIFIED:
          return "PUBLIC_KEY_DETAILS_UNSPECIFIED";
        case PublicKeyDetails.PKCS1_RSA_PKCS1V5:
          return "PKCS1_RSA_PKCS1V5";
        case PublicKeyDetails.PKCS1_RSA_PSS:
          return "PKCS1_RSA_PSS";
        case PublicKeyDetails.PKIX_RSA_PKCS1V5:
          return "PKIX_RSA_PKCS1V5";
        case PublicKeyDetails.PKIX_RSA_PSS:
          return "PKIX_RSA_PSS";
        case PublicKeyDetails.PKIX_RSA_PKCS1V15_2048_SHA256:
          return "PKIX_RSA_PKCS1V15_2048_SHA256";
        case PublicKeyDetails.PKIX_RSA_PKCS1V15_3072_SHA256:
          return "PKIX_RSA_PKCS1V15_3072_SHA256";
        case PublicKeyDetails.PKIX_RSA_PKCS1V15_4096_SHA256:
          return "PKIX_RSA_PKCS1V15_4096_SHA256";
        case PublicKeyDetails.PKIX_RSA_PSS_2048_SHA256:
          return "PKIX_RSA_PSS_2048_SHA256";
        case PublicKeyDetails.PKIX_RSA_PSS_3072_SHA256:
          return "PKIX_RSA_PSS_3072_SHA256";
        case PublicKeyDetails.PKIX_RSA_PSS_4096_SHA256:
          return "PKIX_RSA_PSS_4096_SHA256";
        case PublicKeyDetails.PKIX_ECDSA_P256_HMAC_SHA_256:
          return "PKIX_ECDSA_P256_HMAC_SHA_256";
        case PublicKeyDetails.PKIX_ECDSA_P256_SHA_256:
          return "PKIX_ECDSA_P256_SHA_256";
        case PublicKeyDetails.PKIX_ECDSA_P384_SHA_384:
          return "PKIX_ECDSA_P384_SHA_384";
        case PublicKeyDetails.PKIX_ECDSA_P521_SHA_512:
          return "PKIX_ECDSA_P521_SHA_512";
        case PublicKeyDetails.PKIX_ED25519:
          return "PKIX_ED25519";
        case PublicKeyDetails.PKIX_ED25519_PH:
          return "PKIX_ED25519_PH";
        case PublicKeyDetails.LMS_SHA256:
          return "LMS_SHA256";
        case PublicKeyDetails.LMOTS_SHA256:
          return "LMOTS_SHA256";
        default:
          throw new globalThis.Error("Unrecognized enum value " + object + " for enum PublicKeyDetails");
      }
    }
    var SubjectAlternativeNameType;
    (function(SubjectAlternativeNameType2) {
      SubjectAlternativeNameType2[SubjectAlternativeNameType2["SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED"] = 0] = "SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED";
      SubjectAlternativeNameType2[SubjectAlternativeNameType2["EMAIL"] = 1] = "EMAIL";
      SubjectAlternativeNameType2[SubjectAlternativeNameType2["URI"] = 2] = "URI";
      SubjectAlternativeNameType2[SubjectAlternativeNameType2["OTHER_NAME"] = 3] = "OTHER_NAME";
    })(SubjectAlternativeNameType || (exports2.SubjectAlternativeNameType = SubjectAlternativeNameType = {}));
    function subjectAlternativeNameTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED":
          return SubjectAlternativeNameType.SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED;
        case 1:
        case "EMAIL":
          return SubjectAlternativeNameType.EMAIL;
        case 2:
        case "URI":
          return SubjectAlternativeNameType.URI;
        case 3:
        case "OTHER_NAME":
          return SubjectAlternativeNameType.OTHER_NAME;
        default:
          throw new globalThis.Error("Unrecognized enum value " + object + " for enum SubjectAlternativeNameType");
      }
    }
    function subjectAlternativeNameTypeToJSON(object) {
      switch (object) {
        case SubjectAlternativeNameType.SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED:
          return "SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED";
        case SubjectAlternativeNameType.EMAIL:
          return "EMAIL";
        case SubjectAlternativeNameType.URI:
          return "URI";
        case SubjectAlternativeNameType.OTHER_NAME:
          return "OTHER_NAME";
        default:
          throw new globalThis.Error("Unrecognized enum value " + object + " for enum SubjectAlternativeNameType");
      }
    }
    exports2.HashOutput = {
      fromJSON(object) {
        return {
          algorithm: isSet(object.algorithm) ? hashAlgorithmFromJSON(object.algorithm) : 0,
          digest: isSet(object.digest) ? Buffer.from(bytesFromBase64(object.digest)) : Buffer.alloc(0)
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.algorithm !== 0) {
          obj.algorithm = hashAlgorithmToJSON(message.algorithm);
        }
        if (message.digest.length !== 0) {
          obj.digest = base64FromBytes(message.digest);
        }
        return obj;
      }
    };
    exports2.MessageSignature = {
      fromJSON(object) {
        return {
          messageDigest: isSet(object.messageDigest) ? exports2.HashOutput.fromJSON(object.messageDigest) : void 0,
          signature: isSet(object.signature) ? Buffer.from(bytesFromBase64(object.signature)) : Buffer.alloc(0)
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.messageDigest !== void 0) {
          obj.messageDigest = exports2.HashOutput.toJSON(message.messageDigest);
        }
        if (message.signature.length !== 0) {
          obj.signature = base64FromBytes(message.signature);
        }
        return obj;
      }
    };
    exports2.LogId = {
      fromJSON(object) {
        return { keyId: isSet(object.keyId) ? Buffer.from(bytesFromBase64(object.keyId)) : Buffer.alloc(0) };
      },
      toJSON(message) {
        const obj = {};
        if (message.keyId.length !== 0) {
          obj.keyId = base64FromBytes(message.keyId);
        }
        return obj;
      }
    };
    exports2.RFC3161SignedTimestamp = {
      fromJSON(object) {
        return {
          signedTimestamp: isSet(object.signedTimestamp) ? Buffer.from(bytesFromBase64(object.signedTimestamp)) : Buffer.alloc(0)
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.signedTimestamp.length !== 0) {
          obj.signedTimestamp = base64FromBytes(message.signedTimestamp);
        }
        return obj;
      }
    };
    exports2.PublicKey = {
      fromJSON(object) {
        return {
          rawBytes: isSet(object.rawBytes) ? Buffer.from(bytesFromBase64(object.rawBytes)) : void 0,
          keyDetails: isSet(object.keyDetails) ? publicKeyDetailsFromJSON(object.keyDetails) : 0,
          validFor: isSet(object.validFor) ? exports2.TimeRange.fromJSON(object.validFor) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.rawBytes !== void 0) {
          obj.rawBytes = base64FromBytes(message.rawBytes);
        }
        if (message.keyDetails !== 0) {
          obj.keyDetails = publicKeyDetailsToJSON(message.keyDetails);
        }
        if (message.validFor !== void 0) {
          obj.validFor = exports2.TimeRange.toJSON(message.validFor);
        }
        return obj;
      }
    };
    exports2.PublicKeyIdentifier = {
      fromJSON(object) {
        return { hint: isSet(object.hint) ? globalThis.String(object.hint) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.hint !== "") {
          obj.hint = message.hint;
        }
        return obj;
      }
    };
    exports2.ObjectIdentifier = {
      fromJSON(object) {
        return { id: globalThis.Array.isArray(object?.id) ? object.id.map((e) => globalThis.Number(e)) : [] };
      },
      toJSON(message) {
        const obj = {};
        if (message.id?.length) {
          obj.id = message.id.map((e) => Math.round(e));
        }
        return obj;
      }
    };
    exports2.ObjectIdentifierValuePair = {
      fromJSON(object) {
        return {
          oid: isSet(object.oid) ? exports2.ObjectIdentifier.fromJSON(object.oid) : void 0,
          value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0)
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.oid !== void 0) {
          obj.oid = exports2.ObjectIdentifier.toJSON(message.oid);
        }
        if (message.value.length !== 0) {
          obj.value = base64FromBytes(message.value);
        }
        return obj;
      }
    };
    exports2.DistinguishedName = {
      fromJSON(object) {
        return {
          organization: isSet(object.organization) ? globalThis.String(object.organization) : "",
          commonName: isSet(object.commonName) ? globalThis.String(object.commonName) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.organization !== "") {
          obj.organization = message.organization;
        }
        if (message.commonName !== "") {
          obj.commonName = message.commonName;
        }
        return obj;
      }
    };
    exports2.X509Certificate = {
      fromJSON(object) {
        return { rawBytes: isSet(object.rawBytes) ? Buffer.from(bytesFromBase64(object.rawBytes)) : Buffer.alloc(0) };
      },
      toJSON(message) {
        const obj = {};
        if (message.rawBytes.length !== 0) {
          obj.rawBytes = base64FromBytes(message.rawBytes);
        }
        return obj;
      }
    };
    exports2.SubjectAlternativeName = {
      fromJSON(object) {
        return {
          type: isSet(object.type) ? subjectAlternativeNameTypeFromJSON(object.type) : 0,
          identity: isSet(object.regexp) ? { $case: "regexp", regexp: globalThis.String(object.regexp) } : isSet(object.value) ? { $case: "value", value: globalThis.String(object.value) } : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
          obj.type = subjectAlternativeNameTypeToJSON(message.type);
        }
        if (message.identity?.$case === "regexp") {
          obj.regexp = message.identity.regexp;
        } else if (message.identity?.$case === "value") {
          obj.value = message.identity.value;
        }
        return obj;
      }
    };
    exports2.X509CertificateChain = {
      fromJSON(object) {
        return {
          certificates: globalThis.Array.isArray(object?.certificates) ? object.certificates.map((e) => exports2.X509Certificate.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.certificates?.length) {
          obj.certificates = message.certificates.map((e) => exports2.X509Certificate.toJSON(e));
        }
        return obj;
      }
    };
    exports2.TimeRange = {
      fromJSON(object) {
        return {
          start: isSet(object.start) ? fromJsonTimestamp(object.start) : void 0,
          end: isSet(object.end) ? fromJsonTimestamp(object.end) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.start !== void 0) {
          obj.start = message.start.toISOString();
        }
        if (message.end !== void 0) {
          obj.end = message.end.toISOString();
        }
        return obj;
      }
    };
    function bytesFromBase64(b64) {
      return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    function base64FromBytes(arr) {
      return globalThis.Buffer.from(arr).toString("base64");
    }
    function fromTimestamp(t) {
      let millis = (globalThis.Number(t.seconds) || 0) * 1e3;
      millis += (t.nanos || 0) / 1e6;
      return new globalThis.Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof globalThis.Date) {
        return o;
      } else if (typeof o === "string") {
        return new globalThis.Date(o);
      } else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
      }
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@sigstore/protobuf-specs/dist/__generated__/sigstore_rekor.js
var require_sigstore_rekor = __commonJS({
  "node_modules/@sigstore/protobuf-specs/dist/__generated__/sigstore_rekor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransparencyLogEntry = exports2.InclusionPromise = exports2.InclusionProof = exports2.Checkpoint = exports2.KindVersion = void 0;
    var sigstore_common_1 = require_sigstore_common();
    exports2.KindVersion = {
      fromJSON(object) {
        return {
          kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
          version: isSet(object.version) ? globalThis.String(object.version) : ""
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.kind !== "") {
          obj.kind = message.kind;
        }
        if (message.version !== "") {
          obj.version = message.version;
        }
        return obj;
      }
    };
    exports2.Checkpoint = {
      fromJSON(object) {
        return { envelope: isSet(object.envelope) ? globalThis.String(object.envelope) : "" };
      },
      toJSON(message) {
        const obj = {};
        if (message.envelope !== "") {
          obj.envelope = message.envelope;
        }
        return obj;
      }
    };
    exports2.InclusionProof = {
      fromJSON(object) {
        return {
          logIndex: isSet(object.logIndex) ? globalThis.String(object.logIndex) : "0",
          rootHash: isSet(object.rootHash) ? Buffer.from(bytesFromBase64(object.rootHash)) : Buffer.alloc(0),
          treeSize: isSet(object.treeSize) ? globalThis.String(object.treeSize) : "0",
          hashes: globalThis.Array.isArray(object?.hashes) ? object.hashes.map((e) => Buffer.from(bytesFromBase64(e))) : [],
          checkpoint: isSet(object.checkpoint) ? exports2.Checkpoint.fromJSON(object.checkpoint) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.logIndex !== "0") {
          obj.logIndex = message.logIndex;
        }
        if (message.rootHash.length !== 0) {
          obj.rootHash = base64FromBytes(message.rootHash);
        }
        if (message.treeSize !== "0") {
          obj.treeSize = message.treeSize;
        }
        if (message.hashes?.length) {
          obj.hashes = message.hashes.map((e) => base64FromBytes(e));
        }
        if (message.checkpoint !== void 0) {
          obj.checkpoint = exports2.Checkpoint.toJSON(message.checkpoint);
        }
        return obj;
      }
    };
    exports2.InclusionPromise = {
      fromJSON(object) {
        return {
          signedEntryTimestamp: isSet(object.signedEntryTimestamp) ? Buffer.from(bytesFromBase64(object.signedEntryTimestamp)) : Buffer.alloc(0)
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.signedEntryTimestamp.length !== 0) {
          obj.signedEntryTimestamp = base64FromBytes(message.signedEntryTimestamp);
        }
        return obj;
      }
    };
    exports2.TransparencyLogEntry = {
      fromJSON(object) {
        return {
          logIndex: isSet(object.logIndex) ? globalThis.String(object.logIndex) : "0",
          logId: isSet(object.logId) ? sigstore_common_1.LogId.fromJSON(object.logId) : void 0,
          kindVersion: isSet(object.kindVersion) ? exports2.KindVersion.fromJSON(object.kindVersion) : void 0,
          integratedTime: isSet(object.integratedTime) ? globalThis.String(object.integratedTime) : "0",
          inclusionPromise: isSet(object.inclusionPromise) ? exports2.InclusionPromise.fromJSON(object.inclusionPromise) : void 0,
          inclusionProof: isSet(object.inclusionProof) ? exports2.InclusionProof.fromJSON(object.inclusionProof) : void 0,
          canonicalizedBody: isSet(object.canonicalizedBody) ? Buffer.from(bytesFromBase64(object.canonicalizedBody)) : Buffer.alloc(0)
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.logIndex !== "0") {
          obj.logIndex = message.logIndex;
        }
        if (message.logId !== void 0) {
          obj.logId = sigstore_common_1.LogId.toJSON(message.logId);
        }
        if (message.kindVersion !== void 0) {
          obj.kindVersion = exports2.KindVersion.toJSON(message.kindVersion);
        }
        if (message.integratedTime !== "0") {
          obj.integratedTime = message.integratedTime;
        }
        if (message.inclusionPromise !== void 0) {
          obj.inclusionPromise = exports2.InclusionPromise.toJSON(message.inclusionPromise);
        }
        if (message.inclusionProof !== void 0) {
          obj.inclusionProof = exports2.InclusionProof.toJSON(message.inclusionProof);
        }
        if (message.canonicalizedBody.length !== 0) {
          obj.canonicalizedBody = base64FromBytes(message.canonicalizedBody);
        }
        return obj;
      }
    };
    function bytesFromBase64(b64) {
      return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    function base64FromBytes(arr) {
      return globalThis.Buffer.from(arr).toString("base64");
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@sigstore/protobuf-specs/dist/__generated__/sigstore_bundle.js
var require_sigstore_bundle = __commonJS({
  "node_modules/@sigstore/protobuf-specs/dist/__generated__/sigstore_bundle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Bundle = exports2.VerificationMaterial = exports2.TimestampVerificationData = void 0;
    var envelope_1 = require_envelope();
    var sigstore_common_1 = require_sigstore_common();
    var sigstore_rekor_1 = require_sigstore_rekor();
    exports2.TimestampVerificationData = {
      fromJSON(object) {
        return {
          rfc3161Timestamps: globalThis.Array.isArray(object?.rfc3161Timestamps) ? object.rfc3161Timestamps.map((e) => sigstore_common_1.RFC3161SignedTimestamp.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.rfc3161Timestamps?.length) {
          obj.rfc3161Timestamps = message.rfc3161Timestamps.map((e) => sigstore_common_1.RFC3161SignedTimestamp.toJSON(e));
        }
        return obj;
      }
    };
    exports2.VerificationMaterial = {
      fromJSON(object) {
        return {
          content: isSet(object.publicKey) ? { $case: "publicKey", publicKey: sigstore_common_1.PublicKeyIdentifier.fromJSON(object.publicKey) } : isSet(object.x509CertificateChain) ? {
            $case: "x509CertificateChain",
            x509CertificateChain: sigstore_common_1.X509CertificateChain.fromJSON(object.x509CertificateChain)
          } : isSet(object.certificate) ? { $case: "certificate", certificate: sigstore_common_1.X509Certificate.fromJSON(object.certificate) } : void 0,
          tlogEntries: globalThis.Array.isArray(object?.tlogEntries) ? object.tlogEntries.map((e) => sigstore_rekor_1.TransparencyLogEntry.fromJSON(e)) : [],
          timestampVerificationData: isSet(object.timestampVerificationData) ? exports2.TimestampVerificationData.fromJSON(object.timestampVerificationData) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.content?.$case === "publicKey") {
          obj.publicKey = sigstore_common_1.PublicKeyIdentifier.toJSON(message.content.publicKey);
        } else if (message.content?.$case === "x509CertificateChain") {
          obj.x509CertificateChain = sigstore_common_1.X509CertificateChain.toJSON(message.content.x509CertificateChain);
        } else if (message.content?.$case === "certificate") {
          obj.certificate = sigstore_common_1.X509Certificate.toJSON(message.content.certificate);
        }
        if (message.tlogEntries?.length) {
          obj.tlogEntries = message.tlogEntries.map((e) => sigstore_rekor_1.TransparencyLogEntry.toJSON(e));
        }
        if (message.timestampVerificationData !== void 0) {
          obj.timestampVerificationData = exports2.TimestampVerificationData.toJSON(message.timestampVerificationData);
        }
        return obj;
      }
    };
    exports2.Bundle = {
      fromJSON(object) {
        return {
          mediaType: isSet(object.mediaType) ? globalThis.String(object.mediaType) : "",
          verificationMaterial: isSet(object.verificationMaterial) ? exports2.VerificationMaterial.fromJSON(object.verificationMaterial) : void 0,
          content: isSet(object.messageSignature) ? { $case: "messageSignature", messageSignature: sigstore_common_1.MessageSignature.fromJSON(object.messageSignature) } : isSet(object.dsseEnvelope) ? { $case: "dsseEnvelope", dsseEnvelope: envelope_1.Envelope.fromJSON(object.dsseEnvelope) } : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.mediaType !== "") {
          obj.mediaType = message.mediaType;
        }
        if (message.verificationMaterial !== void 0) {
          obj.verificationMaterial = exports2.VerificationMaterial.toJSON(message.verificationMaterial);
        }
        if (message.content?.$case === "messageSignature") {
          obj.messageSignature = sigstore_common_1.MessageSignature.toJSON(message.content.messageSignature);
        } else if (message.content?.$case === "dsseEnvelope") {
          obj.dsseEnvelope = envelope_1.Envelope.toJSON(message.content.dsseEnvelope);
        }
        return obj;
      }
    };
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@sigstore/protobuf-specs/dist/__generated__/sigstore_trustroot.js
var require_sigstore_trustroot = __commonJS({
  "node_modules/@sigstore/protobuf-specs/dist/__generated__/sigstore_trustroot.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientTrustConfig = exports2.SigningConfig = exports2.TrustedRoot = exports2.CertificateAuthority = exports2.TransparencyLogInstance = void 0;
    var sigstore_common_1 = require_sigstore_common();
    exports2.TransparencyLogInstance = {
      fromJSON(object) {
        return {
          baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : "",
          hashAlgorithm: isSet(object.hashAlgorithm) ? (0, sigstore_common_1.hashAlgorithmFromJSON)(object.hashAlgorithm) : 0,
          publicKey: isSet(object.publicKey) ? sigstore_common_1.PublicKey.fromJSON(object.publicKey) : void 0,
          logId: isSet(object.logId) ? sigstore_common_1.LogId.fromJSON(object.logId) : void 0,
          checkpointKeyId: isSet(object.checkpointKeyId) ? sigstore_common_1.LogId.fromJSON(object.checkpointKeyId) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.baseUrl !== "") {
          obj.baseUrl = message.baseUrl;
        }
        if (message.hashAlgorithm !== 0) {
          obj.hashAlgorithm = (0, sigstore_common_1.hashAlgorithmToJSON)(message.hashAlgorithm);
        }
        if (message.publicKey !== void 0) {
          obj.publicKey = sigstore_common_1.PublicKey.toJSON(message.publicKey);
        }
        if (message.logId !== void 0) {
          obj.logId = sigstore_common_1.LogId.toJSON(message.logId);
        }
        if (message.checkpointKeyId !== void 0) {
          obj.checkpointKeyId = sigstore_common_1.LogId.toJSON(message.checkpointKeyId);
        }
        return obj;
      }
    };
    exports2.CertificateAuthority = {
      fromJSON(object) {
        return {
          subject: isSet(object.subject) ? sigstore_common_1.DistinguishedName.fromJSON(object.subject) : void 0,
          uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
          certChain: isSet(object.certChain) ? sigstore_common_1.X509CertificateChain.fromJSON(object.certChain) : void 0,
          validFor: isSet(object.validFor) ? sigstore_common_1.TimeRange.fromJSON(object.validFor) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.subject !== void 0) {
          obj.subject = sigstore_common_1.DistinguishedName.toJSON(message.subject);
        }
        if (message.uri !== "") {
          obj.uri = message.uri;
        }
        if (message.certChain !== void 0) {
          obj.certChain = sigstore_common_1.X509CertificateChain.toJSON(message.certChain);
        }
        if (message.validFor !== void 0) {
          obj.validFor = sigstore_common_1.TimeRange.toJSON(message.validFor);
        }
        return obj;
      }
    };
    exports2.TrustedRoot = {
      fromJSON(object) {
        return {
          mediaType: isSet(object.mediaType) ? globalThis.String(object.mediaType) : "",
          tlogs: globalThis.Array.isArray(object?.tlogs) ? object.tlogs.map((e) => exports2.TransparencyLogInstance.fromJSON(e)) : [],
          certificateAuthorities: globalThis.Array.isArray(object?.certificateAuthorities) ? object.certificateAuthorities.map((e) => exports2.CertificateAuthority.fromJSON(e)) : [],
          ctlogs: globalThis.Array.isArray(object?.ctlogs) ? object.ctlogs.map((e) => exports2.TransparencyLogInstance.fromJSON(e)) : [],
          timestampAuthorities: globalThis.Array.isArray(object?.timestampAuthorities) ? object.timestampAuthorities.map((e) => exports2.CertificateAuthority.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.mediaType !== "") {
          obj.mediaType = message.mediaType;
        }
        if (message.tlogs?.length) {
          obj.tlogs = message.tlogs.map((e) => exports2.TransparencyLogInstance.toJSON(e));
        }
        if (message.certificateAuthorities?.length) {
          obj.certificateAuthorities = message.certificateAuthorities.map((e) => exports2.CertificateAuthority.toJSON(e));
        }
        if (message.ctlogs?.length) {
          obj.ctlogs = message.ctlogs.map((e) => exports2.TransparencyLogInstance.toJSON(e));
        }
        if (message.timestampAuthorities?.length) {
          obj.timestampAuthorities = message.timestampAuthorities.map((e) => exports2.CertificateAuthority.toJSON(e));
        }
        return obj;
      }
    };
    exports2.SigningConfig = {
      fromJSON(object) {
        return {
          mediaType: isSet(object.mediaType) ? globalThis.String(object.mediaType) : "",
          caUrl: isSet(object.caUrl) ? globalThis.String(object.caUrl) : "",
          oidcUrl: isSet(object.oidcUrl) ? globalThis.String(object.oidcUrl) : "",
          tlogUrls: globalThis.Array.isArray(object?.tlogUrls) ? object.tlogUrls.map((e) => globalThis.String(e)) : [],
          tsaUrls: globalThis.Array.isArray(object?.tsaUrls) ? object.tsaUrls.map((e) => globalThis.String(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.mediaType !== "") {
          obj.mediaType = message.mediaType;
        }
        if (message.caUrl !== "") {
          obj.caUrl = message.caUrl;
        }
        if (message.oidcUrl !== "") {
          obj.oidcUrl = message.oidcUrl;
        }
        if (message.tlogUrls?.length) {
          obj.tlogUrls = message.tlogUrls;
        }
        if (message.tsaUrls?.length) {
          obj.tsaUrls = message.tsaUrls;
        }
        return obj;
      }
    };
    exports2.ClientTrustConfig = {
      fromJSON(object) {
        return {
          mediaType: isSet(object.mediaType) ? globalThis.String(object.mediaType) : "",
          trustedRoot: isSet(object.trustedRoot) ? exports2.TrustedRoot.fromJSON(object.trustedRoot) : void 0,
          signingConfig: isSet(object.signingConfig) ? exports2.SigningConfig.fromJSON(object.signingConfig) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.mediaType !== "") {
          obj.mediaType = message.mediaType;
        }
        if (message.trustedRoot !== void 0) {
          obj.trustedRoot = exports2.TrustedRoot.toJSON(message.trustedRoot);
        }
        if (message.signingConfig !== void 0) {
          obj.signingConfig = exports2.SigningConfig.toJSON(message.signingConfig);
        }
        return obj;
      }
    };
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@sigstore/protobuf-specs/dist/__generated__/sigstore_verification.js
var require_sigstore_verification = __commonJS({
  "node_modules/@sigstore/protobuf-specs/dist/__generated__/sigstore_verification.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Input = exports2.Artifact = exports2.ArtifactVerificationOptions_ObserverTimestampOptions = exports2.ArtifactVerificationOptions_TlogIntegratedTimestampOptions = exports2.ArtifactVerificationOptions_TimestampAuthorityOptions = exports2.ArtifactVerificationOptions_CtlogOptions = exports2.ArtifactVerificationOptions_TlogOptions = exports2.ArtifactVerificationOptions = exports2.PublicKeyIdentities = exports2.CertificateIdentities = exports2.CertificateIdentity = void 0;
    var sigstore_bundle_1 = require_sigstore_bundle();
    var sigstore_common_1 = require_sigstore_common();
    var sigstore_trustroot_1 = require_sigstore_trustroot();
    exports2.CertificateIdentity = {
      fromJSON(object) {
        return {
          issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
          san: isSet(object.san) ? sigstore_common_1.SubjectAlternativeName.fromJSON(object.san) : void 0,
          oids: globalThis.Array.isArray(object?.oids) ? object.oids.map((e) => sigstore_common_1.ObjectIdentifierValuePair.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.issuer !== "") {
          obj.issuer = message.issuer;
        }
        if (message.san !== void 0) {
          obj.san = sigstore_common_1.SubjectAlternativeName.toJSON(message.san);
        }
        if (message.oids?.length) {
          obj.oids = message.oids.map((e) => sigstore_common_1.ObjectIdentifierValuePair.toJSON(e));
        }
        return obj;
      }
    };
    exports2.CertificateIdentities = {
      fromJSON(object) {
        return {
          identities: globalThis.Array.isArray(object?.identities) ? object.identities.map((e) => exports2.CertificateIdentity.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.identities?.length) {
          obj.identities = message.identities.map((e) => exports2.CertificateIdentity.toJSON(e));
        }
        return obj;
      }
    };
    exports2.PublicKeyIdentities = {
      fromJSON(object) {
        return {
          publicKeys: globalThis.Array.isArray(object?.publicKeys) ? object.publicKeys.map((e) => sigstore_common_1.PublicKey.fromJSON(e)) : []
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.publicKeys?.length) {
          obj.publicKeys = message.publicKeys.map((e) => sigstore_common_1.PublicKey.toJSON(e));
        }
        return obj;
      }
    };
    exports2.ArtifactVerificationOptions = {
      fromJSON(object) {
        return {
          signers: isSet(object.certificateIdentities) ? {
            $case: "certificateIdentities",
            certificateIdentities: exports2.CertificateIdentities.fromJSON(object.certificateIdentities)
          } : isSet(object.publicKeys) ? { $case: "publicKeys", publicKeys: exports2.PublicKeyIdentities.fromJSON(object.publicKeys) } : void 0,
          tlogOptions: isSet(object.tlogOptions) ? exports2.ArtifactVerificationOptions_TlogOptions.fromJSON(object.tlogOptions) : void 0,
          ctlogOptions: isSet(object.ctlogOptions) ? exports2.ArtifactVerificationOptions_CtlogOptions.fromJSON(object.ctlogOptions) : void 0,
          tsaOptions: isSet(object.tsaOptions) ? exports2.ArtifactVerificationOptions_TimestampAuthorityOptions.fromJSON(object.tsaOptions) : void 0,
          integratedTsOptions: isSet(object.integratedTsOptions) ? exports2.ArtifactVerificationOptions_TlogIntegratedTimestampOptions.fromJSON(object.integratedTsOptions) : void 0,
          observerOptions: isSet(object.observerOptions) ? exports2.ArtifactVerificationOptions_ObserverTimestampOptions.fromJSON(object.observerOptions) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.signers?.$case === "certificateIdentities") {
          obj.certificateIdentities = exports2.CertificateIdentities.toJSON(message.signers.certificateIdentities);
        } else if (message.signers?.$case === "publicKeys") {
          obj.publicKeys = exports2.PublicKeyIdentities.toJSON(message.signers.publicKeys);
        }
        if (message.tlogOptions !== void 0) {
          obj.tlogOptions = exports2.ArtifactVerificationOptions_TlogOptions.toJSON(message.tlogOptions);
        }
        if (message.ctlogOptions !== void 0) {
          obj.ctlogOptions = exports2.ArtifactVerificationOptions_CtlogOptions.toJSON(message.ctlogOptions);
        }
        if (message.tsaOptions !== void 0) {
          obj.tsaOptions = exports2.ArtifactVerificationOptions_TimestampAuthorityOptions.toJSON(message.tsaOptions);
        }
        if (message.integratedTsOptions !== void 0) {
          obj.integratedTsOptions = exports2.ArtifactVerificationOptions_TlogIntegratedTimestampOptions.toJSON(message.integratedTsOptions);
        }
        if (message.observerOptions !== void 0) {
          obj.observerOptions = exports2.ArtifactVerificationOptions_ObserverTimestampOptions.toJSON(message.observerOptions);
        }
        return obj;
      }
    };
    exports2.ArtifactVerificationOptions_TlogOptions = {
      fromJSON(object) {
        return {
          threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
          performOnlineVerification: isSet(object.performOnlineVerification) ? globalThis.Boolean(object.performOnlineVerification) : false,
          disable: isSet(object.disable) ? globalThis.Boolean(object.disable) : false
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.threshold !== 0) {
          obj.threshold = Math.round(message.threshold);
        }
        if (message.performOnlineVerification !== false) {
          obj.performOnlineVerification = message.performOnlineVerification;
        }
        if (message.disable !== false) {
          obj.disable = message.disable;
        }
        return obj;
      }
    };
    exports2.ArtifactVerificationOptions_CtlogOptions = {
      fromJSON(object) {
        return {
          threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
          disable: isSet(object.disable) ? globalThis.Boolean(object.disable) : false
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.threshold !== 0) {
          obj.threshold = Math.round(message.threshold);
        }
        if (message.disable !== false) {
          obj.disable = message.disable;
        }
        return obj;
      }
    };
    exports2.ArtifactVerificationOptions_TimestampAuthorityOptions = {
      fromJSON(object) {
        return {
          threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
          disable: isSet(object.disable) ? globalThis.Boolean(object.disable) : false
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.threshold !== 0) {
          obj.threshold = Math.round(message.threshold);
        }
        if (message.disable !== false) {
          obj.disable = message.disable;
        }
        return obj;
      }
    };
    exports2.ArtifactVerificationOptions_TlogIntegratedTimestampOptions = {
      fromJSON(object) {
        return {
          threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
          disable: isSet(object.disable) ? globalThis.Boolean(object.disable) : false
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.threshold !== 0) {
          obj.threshold = Math.round(message.threshold);
        }
        if (message.disable !== false) {
          obj.disable = message.disable;
        }
        return obj;
      }
    };
    exports2.ArtifactVerificationOptions_ObserverTimestampOptions = {
      fromJSON(object) {
        return {
          threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
          disable: isSet(object.disable) ? globalThis.Boolean(object.disable) : false
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.threshold !== 0) {
          obj.threshold = Math.round(message.threshold);
        }
        if (message.disable !== false) {
          obj.disable = message.disable;
        }
        return obj;
      }
    };
    exports2.Artifact = {
      fromJSON(object) {
        return {
          data: isSet(object.artifactUri) ? { $case: "artifactUri", artifactUri: globalThis.String(object.artifactUri) } : isSet(object.artifact) ? { $case: "artifact", artifact: Buffer.from(bytesFromBase64(object.artifact)) } : isSet(object.artifactDigest) ? { $case: "artifactDigest", artifactDigest: sigstore_common_1.HashOutput.fromJSON(object.artifactDigest) } : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.data?.$case === "artifactUri") {
          obj.artifactUri = message.data.artifactUri;
        } else if (message.data?.$case === "artifact") {
          obj.artifact = base64FromBytes(message.data.artifact);
        } else if (message.data?.$case === "artifactDigest") {
          obj.artifactDigest = sigstore_common_1.HashOutput.toJSON(message.data.artifactDigest);
        }
        return obj;
      }
    };
    exports2.Input = {
      fromJSON(object) {
        return {
          artifactTrustRoot: isSet(object.artifactTrustRoot) ? sigstore_trustroot_1.TrustedRoot.fromJSON(object.artifactTrustRoot) : void 0,
          artifactVerificationOptions: isSet(object.artifactVerificationOptions) ? exports2.ArtifactVerificationOptions.fromJSON(object.artifactVerificationOptions) : void 0,
          bundle: isSet(object.bundle) ? sigstore_bundle_1.Bundle.fromJSON(object.bundle) : void 0,
          artifact: isSet(object.artifact) ? exports2.Artifact.fromJSON(object.artifact) : void 0
        };
      },
      toJSON(message) {
        const obj = {};
        if (message.artifactTrustRoot !== void 0) {
          obj.artifactTrustRoot = sigstore_trustroot_1.TrustedRoot.toJSON(message.artifactTrustRoot);
        }
        if (message.artifactVerificationOptions !== void 0) {
          obj.artifactVerificationOptions = exports2.ArtifactVerificationOptions.toJSON(message.artifactVerificationOptions);
        }
        if (message.bundle !== void 0) {
          obj.bundle = sigstore_bundle_1.Bundle.toJSON(message.bundle);
        }
        if (message.artifact !== void 0) {
          obj.artifact = exports2.Artifact.toJSON(message.artifact);
        }
        return obj;
      }
    };
    function bytesFromBase64(b64) {
      return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    function base64FromBytes(arr) {
      return globalThis.Buffer.from(arr).toString("base64");
    }
    function isSet(value) {
      return value !== null && value !== void 0;
    }
  }
});

// node_modules/@sigstore/protobuf-specs/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@sigstore/protobuf-specs/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_envelope(), exports2);
    __exportStar(require_sigstore_bundle(), exports2);
    __exportStar(require_sigstore_common(), exports2);
    __exportStar(require_sigstore_rekor(), exports2);
    __exportStar(require_sigstore_trustroot(), exports2);
    __exportStar(require_sigstore_verification(), exports2);
  }
});

// node_modules/@sigstore/bundle/dist/bundle.js
var require_bundle = __commonJS({
  "node_modules/@sigstore/bundle/dist/bundle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BUNDLE_V03_MEDIA_TYPE = exports2.BUNDLE_V03_LEGACY_MEDIA_TYPE = exports2.BUNDLE_V02_MEDIA_TYPE = exports2.BUNDLE_V01_MEDIA_TYPE = void 0;
    exports2.isBundleWithCertificateChain = isBundleWithCertificateChain;
    exports2.isBundleWithPublicKey = isBundleWithPublicKey;
    exports2.isBundleWithMessageSignature = isBundleWithMessageSignature;
    exports2.isBundleWithDsseEnvelope = isBundleWithDsseEnvelope;
    exports2.BUNDLE_V01_MEDIA_TYPE = "application/vnd.dev.sigstore.bundle+json;version=0.1";
    exports2.BUNDLE_V02_MEDIA_TYPE = "application/vnd.dev.sigstore.bundle+json;version=0.2";
    exports2.BUNDLE_V03_LEGACY_MEDIA_TYPE = "application/vnd.dev.sigstore.bundle+json;version=0.3";
    exports2.BUNDLE_V03_MEDIA_TYPE = "application/vnd.dev.sigstore.bundle.v0.3+json";
    function isBundleWithCertificateChain(b) {
      return b.verificationMaterial.content.$case === "x509CertificateChain";
    }
    function isBundleWithPublicKey(b) {
      return b.verificationMaterial.content.$case === "publicKey";
    }
    function isBundleWithMessageSignature(b) {
      return b.content.$case === "messageSignature";
    }
    function isBundleWithDsseEnvelope(b) {
      return b.content.$case === "dsseEnvelope";
    }
  }
});

// node_modules/@sigstore/bundle/dist/build.js
var require_build2 = __commonJS({
  "node_modules/@sigstore/bundle/dist/build.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toMessageSignatureBundle = toMessageSignatureBundle;
    exports2.toDSSEBundle = toDSSEBundle;
    var protobuf_specs_1 = require_dist5();
    var bundle_1 = require_bundle();
    function toMessageSignatureBundle(options) {
      return {
        mediaType: options.certificateChain ? bundle_1.BUNDLE_V02_MEDIA_TYPE : bundle_1.BUNDLE_V03_MEDIA_TYPE,
        content: {
          $case: "messageSignature",
          messageSignature: {
            messageDigest: {
              algorithm: protobuf_specs_1.HashAlgorithm.SHA2_256,
              digest: options.digest
            },
            signature: options.signature
          }
        },
        verificationMaterial: toVerificationMaterial(options)
      };
    }
    function toDSSEBundle(options) {
      return {
        mediaType: options.certificateChain ? bundle_1.BUNDLE_V02_MEDIA_TYPE : bundle_1.BUNDLE_V03_MEDIA_TYPE,
        content: {
          $case: "dsseEnvelope",
          dsseEnvelope: toEnvelope(options)
        },
        verificationMaterial: toVerificationMaterial(options)
      };
    }
    function toEnvelope(options) {
      return {
        payloadType: options.artifactType,
        payload: options.artifact,
        signatures: [toSignature(options)]
      };
    }
    function toSignature(options) {
      return {
        keyid: options.keyHint || "",
        sig: options.signature
      };
    }
    function toVerificationMaterial(options) {
      return {
        content: toKeyContent(options),
        tlogEntries: [],
        timestampVerificationData: { rfc3161Timestamps: [] }
      };
    }
    function toKeyContent(options) {
      if (options.certificate) {
        if (options.certificateChain) {
          return {
            $case: "x509CertificateChain",
            x509CertificateChain: {
              certificates: [{ rawBytes: options.certificate }]
            }
          };
        } else {
          return {
            $case: "certificate",
            certificate: { rawBytes: options.certificate }
          };
        }
      } else {
        return {
          $case: "publicKey",
          publicKey: {
            hint: options.keyHint || ""
          }
        };
      }
    }
  }
});

// node_modules/@sigstore/bundle/dist/error.js
var require_error = __commonJS({
  "node_modules/@sigstore/bundle/dist/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidationError = void 0;
    var ValidationError = class extends Error {
      constructor(message, fields) {
        super(message);
        this.fields = fields;
      }
    };
    exports2.ValidationError = ValidationError;
  }
});

// node_modules/@sigstore/bundle/dist/validate.js
var require_validate = __commonJS({
  "node_modules/@sigstore/bundle/dist/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertBundle = assertBundle;
    exports2.assertBundleV01 = assertBundleV01;
    exports2.isBundleV01 = isBundleV01;
    exports2.assertBundleV02 = assertBundleV02;
    exports2.assertBundleLatest = assertBundleLatest;
    var error_1 = require_error();
    function assertBundle(b) {
      const invalidValues = validateBundleBase(b);
      if (invalidValues.length > 0) {
        throw new error_1.ValidationError("invalid bundle", invalidValues);
      }
    }
    function assertBundleV01(b) {
      const invalidValues = [];
      invalidValues.push(...validateBundleBase(b));
      invalidValues.push(...validateInclusionPromise(b));
      if (invalidValues.length > 0) {
        throw new error_1.ValidationError("invalid v0.1 bundle", invalidValues);
      }
    }
    function isBundleV01(b) {
      try {
        assertBundleV01(b);
        return true;
      } catch (e) {
        return false;
      }
    }
    function assertBundleV02(b) {
      const invalidValues = [];
      invalidValues.push(...validateBundleBase(b));
      invalidValues.push(...validateInclusionProof(b));
      if (invalidValues.length > 0) {
        throw new error_1.ValidationError("invalid v0.2 bundle", invalidValues);
      }
    }
    function assertBundleLatest(b) {
      const invalidValues = [];
      invalidValues.push(...validateBundleBase(b));
      invalidValues.push(...validateInclusionProof(b));
      invalidValues.push(...validateNoCertificateChain(b));
      if (invalidValues.length > 0) {
        throw new error_1.ValidationError("invalid bundle", invalidValues);
      }
    }
    function validateBundleBase(b) {
      const invalidValues = [];
      if (b.mediaType === void 0 || !b.mediaType.match(/^application\/vnd\.dev\.sigstore\.bundle\+json;version=\d\.\d/) && !b.mediaType.match(/^application\/vnd\.dev\.sigstore\.bundle\.v\d\.\d\+json/)) {
        invalidValues.push("mediaType");
      }
      if (b.content === void 0) {
        invalidValues.push("content");
      } else {
        switch (b.content.$case) {
          case "messageSignature":
            if (b.content.messageSignature.messageDigest === void 0) {
              invalidValues.push("content.messageSignature.messageDigest");
            } else {
              if (b.content.messageSignature.messageDigest.digest.length === 0) {
                invalidValues.push("content.messageSignature.messageDigest.digest");
              }
            }
            if (b.content.messageSignature.signature.length === 0) {
              invalidValues.push("content.messageSignature.signature");
            }
            break;
          case "dsseEnvelope":
            if (b.content.dsseEnvelope.payload.length === 0) {
              invalidValues.push("content.dsseEnvelope.payload");
            }
            if (b.content.dsseEnvelope.signatures.length !== 1) {
              invalidValues.push("content.dsseEnvelope.signatures");
            } else {
              if (b.content.dsseEnvelope.signatures[0].sig.length === 0) {
                invalidValues.push("content.dsseEnvelope.signatures[0].sig");
              }
            }
            break;
        }
      }
      if (b.verificationMaterial === void 0) {
        invalidValues.push("verificationMaterial");
      } else {
        if (b.verificationMaterial.content === void 0) {
          invalidValues.push("verificationMaterial.content");
        } else {
          switch (b.verificationMaterial.content.$case) {
            case "x509CertificateChain":
              if (b.verificationMaterial.content.x509CertificateChain.certificates.length === 0) {
                invalidValues.push("verificationMaterial.content.x509CertificateChain.certificates");
              }
              b.verificationMaterial.content.x509CertificateChain.certificates.forEach((cert, i) => {
                if (cert.rawBytes.length === 0) {
                  invalidValues.push(`verificationMaterial.content.x509CertificateChain.certificates[${i}].rawBytes`);
                }
              });
              break;
            case "certificate":
              if (b.verificationMaterial.content.certificate.rawBytes.length === 0) {
                invalidValues.push("verificationMaterial.content.certificate.rawBytes");
              }
              break;
          }
        }
        if (b.verificationMaterial.tlogEntries === void 0) {
          invalidValues.push("verificationMaterial.tlogEntries");
        } else {
          if (b.verificationMaterial.tlogEntries.length > 0) {
            b.verificationMaterial.tlogEntries.forEach((entry, i) => {
              if (entry.logId === void 0) {
                invalidValues.push(`verificationMaterial.tlogEntries[${i}].logId`);
              }
              if (entry.kindVersion === void 0) {
                invalidValues.push(`verificationMaterial.tlogEntries[${i}].kindVersion`);
              }
            });
          }
        }
      }
      return invalidValues;
    }
    function validateInclusionPromise(b) {
      const invalidValues = [];
      if (b.verificationMaterial && b.verificationMaterial.tlogEntries?.length > 0) {
        b.verificationMaterial.tlogEntries.forEach((entry, i) => {
          if (entry.inclusionPromise === void 0) {
            invalidValues.push(`verificationMaterial.tlogEntries[${i}].inclusionPromise`);
          }
        });
      }
      return invalidValues;
    }
    function validateInclusionProof(b) {
      const invalidValues = [];
      if (b.verificationMaterial && b.verificationMaterial.tlogEntries?.length > 0) {
        b.verificationMaterial.tlogEntries.forEach((entry, i) => {
          if (entry.inclusionProof === void 0) {
            invalidValues.push(`verificationMaterial.tlogEntries[${i}].inclusionProof`);
          } else {
            if (entry.inclusionProof.checkpoint === void 0) {
              invalidValues.push(`verificationMaterial.tlogEntries[${i}].inclusionProof.checkpoint`);
            }
          }
        });
      }
      return invalidValues;
    }
    function validateNoCertificateChain(b) {
      const invalidValues = [];
      if (b.verificationMaterial?.content?.$case === "x509CertificateChain") {
        invalidValues.push("verificationMaterial.content.$case");
      }
      return invalidValues;
    }
  }
});

// node_modules/@sigstore/bundle/dist/serialized.js
var require_serialized = __commonJS({
  "node_modules/@sigstore/bundle/dist/serialized.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.envelopeToJSON = exports2.envelopeFromJSON = exports2.bundleToJSON = exports2.bundleFromJSON = void 0;
    var protobuf_specs_1 = require_dist5();
    var bundle_1 = require_bundle();
    var validate_1 = require_validate();
    var bundleFromJSON = (obj) => {
      const bundle = protobuf_specs_1.Bundle.fromJSON(obj);
      switch (bundle.mediaType) {
        case bundle_1.BUNDLE_V01_MEDIA_TYPE:
          (0, validate_1.assertBundleV01)(bundle);
          break;
        case bundle_1.BUNDLE_V02_MEDIA_TYPE:
          (0, validate_1.assertBundleV02)(bundle);
          break;
        default:
          (0, validate_1.assertBundleLatest)(bundle);
          break;
      }
      return bundle;
    };
    exports2.bundleFromJSON = bundleFromJSON;
    var bundleToJSON = (bundle) => {
      return protobuf_specs_1.Bundle.toJSON(bundle);
    };
    exports2.bundleToJSON = bundleToJSON;
    var envelopeFromJSON = (obj) => {
      return protobuf_specs_1.Envelope.fromJSON(obj);
    };
    exports2.envelopeFromJSON = envelopeFromJSON;
    var envelopeToJSON = (envelope) => {
      return protobuf_specs_1.Envelope.toJSON(envelope);
    };
    exports2.envelopeToJSON = envelopeToJSON;
  }
});

// node_modules/@sigstore/bundle/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@sigstore/bundle/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBundleV01 = exports2.assertBundleV02 = exports2.assertBundleV01 = exports2.assertBundleLatest = exports2.assertBundle = exports2.envelopeToJSON = exports2.envelopeFromJSON = exports2.bundleToJSON = exports2.bundleFromJSON = exports2.ValidationError = exports2.isBundleWithPublicKey = exports2.isBundleWithMessageSignature = exports2.isBundleWithDsseEnvelope = exports2.isBundleWithCertificateChain = exports2.BUNDLE_V03_MEDIA_TYPE = exports2.BUNDLE_V03_LEGACY_MEDIA_TYPE = exports2.BUNDLE_V02_MEDIA_TYPE = exports2.BUNDLE_V01_MEDIA_TYPE = exports2.toMessageSignatureBundle = exports2.toDSSEBundle = void 0;
    var build_1 = require_build2();
    Object.defineProperty(exports2, "toDSSEBundle", { enumerable: true, get: function() {
      return build_1.toDSSEBundle;
    } });
    Object.defineProperty(exports2, "toMessageSignatureBundle", { enumerable: true, get: function() {
      return build_1.toMessageSignatureBundle;
    } });
    var bundle_1 = require_bundle();
    Object.defineProperty(exports2, "BUNDLE_V01_MEDIA_TYPE", { enumerable: true, get: function() {
      return bundle_1.BUNDLE_V01_MEDIA_TYPE;
    } });
    Object.defineProperty(exports2, "BUNDLE_V02_MEDIA_TYPE", { enumerable: true, get: function() {
      return bundle_1.BUNDLE_V02_MEDIA_TYPE;
    } });
    Object.defineProperty(exports2, "BUNDLE_V03_LEGACY_MEDIA_TYPE", { enumerable: true, get: function() {
      return bundle_1.BUNDLE_V03_LEGACY_MEDIA_TYPE;
    } });
    Object.defineProperty(exports2, "BUNDLE_V03_MEDIA_TYPE", { enumerable: true, get: function() {
      return bundle_1.BUNDLE_V03_MEDIA_TYPE;
    } });
    Object.defineProperty(exports2, "isBundleWithCertificateChain", { enumerable: true, get: function() {
      return bundle_1.isBundleWithCertificateChain;
    } });
    Object.defineProperty(exports2, "isBundleWithDsseEnvelope", { enumerable: true, get: function() {
      return bundle_1.isBundleWithDsseEnvelope;
    } });
    Object.defineProperty(exports2, "isBundleWithMessageSignature", { enumerable: true, get: function() {
      return bundle_1.isBundleWithMessageSignature;
    } });
    Object.defineProperty(exports2, "isBundleWithPublicKey", { enumerable: true, get: function() {
      return bundle_1.isBundleWithPublicKey;
    } });
    var error_1 = require_error();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return error_1.ValidationError;
    } });
    var serialized_1 = require_serialized();
    Object.defineProperty(exports2, "bundleFromJSON", { enumerable: true, get: function() {
      return serialized_1.bundleFromJSON;
    } });
    Object.defineProperty(exports2, "bundleToJSON", { enumerable: true, get: function() {
      return serialized_1.bundleToJSON;
    } });
    Object.defineProperty(exports2, "envelopeFromJSON", { enumerable: true, get: function() {
      return serialized_1.envelopeFromJSON;
    } });
    Object.defineProperty(exports2, "envelopeToJSON", { enumerable: true, get: function() {
      return serialized_1.envelopeToJSON;
    } });
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "assertBundle", { enumerable: true, get: function() {
      return validate_1.assertBundle;
    } });
    Object.defineProperty(exports2, "assertBundleLatest", { enumerable: true, get: function() {
      return validate_1.assertBundleLatest;
    } });
    Object.defineProperty(exports2, "assertBundleV01", { enumerable: true, get: function() {
      return validate_1.assertBundleV01;
    } });
    Object.defineProperty(exports2, "assertBundleV02", { enumerable: true, get: function() {
      return validate_1.assertBundleV02;
    } });
    Object.defineProperty(exports2, "isBundleV01", { enumerable: true, get: function() {
      return validate_1.isBundleV01;
    } });
  }
});

// node_modules/@sigstore/core/dist/stream.js
var require_stream = __commonJS({
  "node_modules/@sigstore/core/dist/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ByteStream = void 0;
    var StreamError = class extends Error {
    };
    var ByteStream = class _ByteStream {
      constructor(buffer) {
        this.start = 0;
        if (buffer) {
          this.buf = buffer;
          this.view = Buffer.from(buffer);
        } else {
          this.buf = new ArrayBuffer(0);
          this.view = Buffer.from(this.buf);
        }
      }
      get buffer() {
        return this.view.subarray(0, this.start);
      }
      get length() {
        return this.view.byteLength;
      }
      get position() {
        return this.start;
      }
      seek(position) {
        this.start = position;
      }
      // Returns a Buffer containing the specified number of bytes starting at the
      // given start position.
      slice(start, len) {
        const end = start + len;
        if (end > this.length) {
          throw new StreamError("request past end of buffer");
        }
        return this.view.subarray(start, end);
      }
      appendChar(char) {
        this.ensureCapacity(1);
        this.view[this.start] = char;
        this.start += 1;
      }
      appendUint16(num) {
        this.ensureCapacity(2);
        const value = new Uint16Array([num]);
        const view = new Uint8Array(value.buffer);
        this.view[this.start] = view[1];
        this.view[this.start + 1] = view[0];
        this.start += 2;
      }
      appendUint24(num) {
        this.ensureCapacity(3);
        const value = new Uint32Array([num]);
        const view = new Uint8Array(value.buffer);
        this.view[this.start] = view[2];
        this.view[this.start + 1] = view[1];
        this.view[this.start + 2] = view[0];
        this.start += 3;
      }
      appendView(view) {
        this.ensureCapacity(view.length);
        this.view.set(view, this.start);
        this.start += view.length;
      }
      getBlock(size) {
        if (size <= 0) {
          return Buffer.alloc(0);
        }
        if (this.start + size > this.view.length) {
          throw new Error("request past end of buffer");
        }
        const result = this.view.subarray(this.start, this.start + size);
        this.start += size;
        return result;
      }
      getUint8() {
        return this.getBlock(1)[0];
      }
      getUint16() {
        const block = this.getBlock(2);
        return block[0] << 8 | block[1];
      }
      ensureCapacity(size) {
        if (this.start + size > this.view.byteLength) {
          const blockSize = _ByteStream.BLOCK_SIZE + (size > _ByteStream.BLOCK_SIZE ? size : 0);
          this.realloc(this.view.byteLength + blockSize);
        }
      }
      realloc(size) {
        const newArray = new ArrayBuffer(size);
        const newView = Buffer.from(newArray);
        newView.set(this.view);
        this.buf = newArray;
        this.view = newView;
      }
    };
    exports2.ByteStream = ByteStream;
    ByteStream.BLOCK_SIZE = 1024;
  }
});

// node_modules/@sigstore/core/dist/asn1/error.js
var require_error2 = __commonJS({
  "node_modules/@sigstore/core/dist/asn1/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ASN1TypeError = exports2.ASN1ParseError = void 0;
    var ASN1ParseError = class extends Error {
    };
    exports2.ASN1ParseError = ASN1ParseError;
    var ASN1TypeError = class extends Error {
    };
    exports2.ASN1TypeError = ASN1TypeError;
  }
});

// node_modules/@sigstore/core/dist/asn1/length.js
var require_length = __commonJS({
  "node_modules/@sigstore/core/dist/asn1/length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeLength = decodeLength;
    exports2.encodeLength = encodeLength;
    var error_1 = require_error2();
    function decodeLength(stream) {
      const buf = stream.getUint8();
      if ((buf & 128) === 0) {
        return buf;
      }
      const byteCount = buf & 127;
      if (byteCount > 6) {
        throw new error_1.ASN1ParseError("length exceeds 6 byte limit");
      }
      let len = 0;
      for (let i = 0; i < byteCount; i++) {
        len = len * 256 + stream.getUint8();
      }
      if (len === 0) {
        throw new error_1.ASN1ParseError("indefinite length encoding not supported");
      }
      return len;
    }
    function encodeLength(len) {
      if (len < 128) {
        return Buffer.from([len]);
      }
      let val = BigInt(len);
      const bytes = [];
      while (val > 0n) {
        bytes.unshift(Number(val & 255n));
        val = val >> 8n;
      }
      return Buffer.from([128 | bytes.length, ...bytes]);
    }
  }
});

// node_modules/@sigstore/core/dist/asn1/parse.js
var require_parse4 = __commonJS({
  "node_modules/@sigstore/core/dist/asn1/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseInteger = parseInteger;
    exports2.parseStringASCII = parseStringASCII;
    exports2.parseTime = parseTime;
    exports2.parseOID = parseOID;
    exports2.parseBoolean = parseBoolean;
    exports2.parseBitString = parseBitString;
    var RE_TIME_SHORT_YEAR = /^(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\.\d{3})?Z$/;
    var RE_TIME_LONG_YEAR = /^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\.\d{3})?Z$/;
    function parseInteger(buf) {
      let pos = 0;
      const end = buf.length;
      let val = buf[pos];
      const neg = val > 127;
      const pad = neg ? 255 : 0;
      while (val == pad && ++pos < end) {
        val = buf[pos];
      }
      const len = end - pos;
      if (len === 0)
        return BigInt(neg ? -1 : 0);
      val = neg ? val - 256 : val;
      let n = BigInt(val);
      for (let i = pos + 1; i < end; ++i) {
        n = n * BigInt(256) + BigInt(buf[i]);
      }
      return n;
    }
    function parseStringASCII(buf) {
      return buf.toString("ascii");
    }
    function parseTime(buf, shortYear) {
      const timeStr = parseStringASCII(buf);
      const m = shortYear ? RE_TIME_SHORT_YEAR.exec(timeStr) : RE_TIME_LONG_YEAR.exec(timeStr);
      if (!m) {
        throw new Error("invalid time");
      }
      if (shortYear) {
        let year = Number(m[1]);
        year += year >= 50 ? 1900 : 2e3;
        m[1] = year.toString();
      }
      return /* @__PURE__ */ new Date(`${m[1]}-${m[2]}-${m[3]}T${m[4]}:${m[5]}:${m[6]}Z`);
    }
    function parseOID(buf) {
      let pos = 0;
      const end = buf.length;
      let n = buf[pos++];
      const first = Math.floor(n / 40);
      const second = n % 40;
      let oid = `${first}.${second}`;
      let val = 0;
      for (; pos < end; ++pos) {
        n = buf[pos];
        val = (val << 7) + (n & 127);
        if ((n & 128) === 0) {
          oid += `.${val}`;
          val = 0;
        }
      }
      return oid;
    }
    function parseBoolean(buf) {
      return buf[0] !== 0;
    }
    function parseBitString(buf) {
      const unused = buf[0];
      const start = 1;
      const end = buf.length;
      const bits = [];
      for (let i = start; i < end; ++i) {
        const byte = buf[i];
        const skip = i === end - 1 ? unused : 0;
        for (let j = 7; j >= skip; --j) {
          bits.push(byte >> j & 1);
        }
      }
      return bits;
    }
  }
});

// node_modules/@sigstore/core/dist/asn1/tag.js
var require_tag = __commonJS({
  "node_modules/@sigstore/core/dist/asn1/tag.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ASN1Tag = void 0;
    var error_1 = require_error2();
    var UNIVERSAL_TAG = {
      BOOLEAN: 1,
      INTEGER: 2,
      BIT_STRING: 3,
      OCTET_STRING: 4,
      OBJECT_IDENTIFIER: 6,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLE_STRING: 19,
      UTC_TIME: 23,
      GENERALIZED_TIME: 24
    };
    var TAG_CLASS = {
      UNIVERSAL: 0,
      APPLICATION: 1,
      CONTEXT_SPECIFIC: 2,
      PRIVATE: 3
    };
    var ASN1Tag = class {
      constructor(enc) {
        this.number = enc & 31;
        this.constructed = (enc & 32) === 32;
        this.class = enc >> 6;
        if (this.number === 31) {
          throw new error_1.ASN1ParseError("long form tags not supported");
        }
        if (this.class === TAG_CLASS.UNIVERSAL && this.number === 0) {
          throw new error_1.ASN1ParseError("unsupported tag 0x00");
        }
      }
      isUniversal() {
        return this.class === TAG_CLASS.UNIVERSAL;
      }
      isContextSpecific(num) {
        const res = this.class === TAG_CLASS.CONTEXT_SPECIFIC;
        return num !== void 0 ? res && this.number === num : res;
      }
      isBoolean() {
        return this.isUniversal() && this.number === UNIVERSAL_TAG.BOOLEAN;
      }
      isInteger() {
        return this.isUniversal() && this.number === UNIVERSAL_TAG.INTEGER;
      }
      isBitString() {
        return this.isUniversal() && this.number === UNIVERSAL_TAG.BIT_STRING;
      }
      isOctetString() {
        return this.isUniversal() && this.number === UNIVERSAL_TAG.OCTET_STRING;
      }
      isOID() {
        return this.isUniversal() && this.number === UNIVERSAL_TAG.OBJECT_IDENTIFIER;
      }
      isUTCTime() {
        return this.isUniversal() && this.number === UNIVERSAL_TAG.UTC_TIME;
      }
      isGeneralizedTime() {
        return this.isUniversal() && this.number === UNIVERSAL_TAG.GENERALIZED_TIME;
      }
      toDER() {
        return this.number | (this.constructed ? 32 : 0) | this.class << 6;
      }
    };
    exports2.ASN1Tag = ASN1Tag;
  }
});

// node_modules/@sigstore/core/dist/asn1/obj.js
var require_obj = __commonJS({
  "node_modules/@sigstore/core/dist/asn1/obj.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ASN1Obj = void 0;
    var stream_1 = require_stream();
    var error_1 = require_error2();
    var length_1 = require_length();
    var parse_1 = require_parse4();
    var tag_1 = require_tag();
    var ASN1Obj = class {
      constructor(tag, value, subs) {
        this.tag = tag;
        this.value = value;
        this.subs = subs;
      }
      // Constructs an ASN.1 object from a Buffer of DER-encoded bytes.
      static parseBuffer(buf) {
        return parseStream(new stream_1.ByteStream(buf));
      }
      toDER() {
        const valueStream = new stream_1.ByteStream();
        if (this.subs.length > 0) {
          for (const sub of this.subs) {
            valueStream.appendView(sub.toDER());
          }
        } else {
          valueStream.appendView(this.value);
        }
        const value = valueStream.buffer;
        const obj = new stream_1.ByteStream();
        obj.appendChar(this.tag.toDER());
        obj.appendView((0, length_1.encodeLength)(value.length));
        obj.appendView(value);
        return obj.buffer;
      }
      /////////////////////////////////////////////////////////////////////////////
      // Convenience methods for parsing ASN.1 primitives into JS types
      // Returns the ASN.1 object's value as a boolean. Throws an error if the
      // object is not a boolean.
      toBoolean() {
        if (!this.tag.isBoolean()) {
          throw new error_1.ASN1TypeError("not a boolean");
        }
        return (0, parse_1.parseBoolean)(this.value);
      }
      // Returns the ASN.1 object's value as a BigInt. Throws an error if the
      // object is not an integer.
      toInteger() {
        if (!this.tag.isInteger()) {
          throw new error_1.ASN1TypeError("not an integer");
        }
        return (0, parse_1.parseInteger)(this.value);
      }
      // Returns the ASN.1 object's value as an OID string. Throws an error if the
      // object is not an OID.
      toOID() {
        if (!this.tag.isOID()) {
          throw new error_1.ASN1TypeError("not an OID");
        }
        return (0, parse_1.parseOID)(this.value);
      }
      // Returns the ASN.1 object's value as a Date. Throws an error if the object
      // is not either a UTCTime or a GeneralizedTime.
      toDate() {
        switch (true) {
          case this.tag.isUTCTime():
            return (0, parse_1.parseTime)(this.value, true);
          case this.tag.isGeneralizedTime():
            return (0, parse_1.parseTime)(this.value, false);
          default:
            throw new error_1.ASN1TypeError("not a date");
        }
      }
      // Returns the ASN.1 object's value as a number[] where each number is the
      // value of a bit in the bit string. Throws an error if the object is not a
      // bit string.
      toBitString() {
        if (!this.tag.isBitString()) {
          throw new error_1.ASN1TypeError("not a bit string");
        }
        return (0, parse_1.parseBitString)(this.value);
      }
    };
    exports2.ASN1Obj = ASN1Obj;
    function parseStream(stream) {
      const tag = new tag_1.ASN1Tag(stream.getUint8());
      const len = (0, length_1.decodeLength)(stream);
      const value = stream.slice(stream.position, len);
      const start = stream.position;
      let subs = [];
      if (tag.constructed) {
        subs = collectSubs(stream, len);
      } else if (tag.isOctetString()) {
        try {
          subs = collectSubs(stream, len);
        } catch (e) {
        }
      }
      if (subs.length === 0) {
        stream.seek(start + len);
      }
      return new ASN1Obj(tag, value, subs);
    }
    function collectSubs(stream, len) {
      const end = stream.position + len;
      if (end > stream.length) {
        throw new error_1.ASN1ParseError("invalid length");
      }
      const subs = [];
      while (stream.position < end) {
        subs.push(parseStream(stream));
      }
      if (stream.position !== end) {
        throw new error_1.ASN1ParseError("invalid length");
      }
      return subs;
    }
  }
});

// node_modules/@sigstore/core/dist/asn1/index.js
var require_asn1 = __commonJS({
  "node_modules/@sigstore/core/dist/asn1/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ASN1Obj = void 0;
    var obj_1 = require_obj();
    Object.defineProperty(exports2, "ASN1Obj", { enumerable: true, get: function() {
      return obj_1.ASN1Obj;
    } });
  }
});

// node_modules/@sigstore/core/dist/crypto.js
var require_crypto = __commonJS({
  "node_modules/@sigstore/core/dist/crypto.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPublicKey = createPublicKey;
    exports2.digest = digest;
    exports2.verify = verify;
    exports2.bufferEqual = bufferEqual;
    var crypto_1 = __importDefault(require("crypto"));
    function createPublicKey(key, type = "spki") {
      if (typeof key === "string") {
        return crypto_1.default.createPublicKey(key);
      } else {
        return crypto_1.default.createPublicKey({ key, format: "der", type });
      }
    }
    function digest(algorithm, ...data) {
      const hash = crypto_1.default.createHash(algorithm);
      for (const d of data) {
        hash.update(d);
      }
      return hash.digest();
    }
    function verify(data, key, signature, algorithm) {
      try {
        return crypto_1.default.verify(algorithm, data, key, signature);
      } catch (e) {
        return false;
      }
    }
    function bufferEqual(a, b) {
      try {
        return crypto_1.default.timingSafeEqual(a, b);
      } catch {
        return false;
      }
    }
  }
});

// node_modules/@sigstore/core/dist/dsse.js
var require_dsse = __commonJS({
  "node_modules/@sigstore/core/dist/dsse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.preAuthEncoding = preAuthEncoding;
    var PAE_PREFIX = "DSSEv1";
    function preAuthEncoding(payloadType, payload) {
      const prefix = [
        PAE_PREFIX,
        payloadType.length,
        payloadType,
        payload.length,
        ""
      ].join(" ");
      return Buffer.concat([Buffer.from(prefix, "ascii"), payload]);
    }
  }
});

// node_modules/@sigstore/core/dist/encoding.js
var require_encoding3 = __commonJS({
  "node_modules/@sigstore/core/dist/encoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.base64Encode = base64Encode;
    exports2.base64Decode = base64Decode;
    var BASE64_ENCODING = "base64";
    var UTF8_ENCODING = "utf-8";
    function base64Encode(str) {
      return Buffer.from(str, UTF8_ENCODING).toString(BASE64_ENCODING);
    }
    function base64Decode(str) {
      return Buffer.from(str, BASE64_ENCODING).toString(UTF8_ENCODING);
    }
  }
});

// node_modules/@sigstore/core/dist/json.js
var require_json = __commonJS({
  "node_modules/@sigstore/core/dist/json.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.canonicalize = canonicalize;
    function canonicalize(object) {
      let buffer = "";
      if (object === null || typeof object !== "object" || object.toJSON != null) {
        buffer += JSON.stringify(object);
      } else if (Array.isArray(object)) {
        buffer += "[";
        let first = true;
        object.forEach((element) => {
          if (!first) {
            buffer += ",";
          }
          first = false;
          buffer += canonicalize(element);
        });
        buffer += "]";
      } else {
        buffer += "{";
        let first = true;
        Object.keys(object).sort().forEach((property) => {
          if (!first) {
            buffer += ",";
          }
          first = false;
          buffer += JSON.stringify(property);
          buffer += ":";
          buffer += canonicalize(object[property]);
        });
        buffer += "}";
      }
      return buffer;
    }
  }
});

// node_modules/@sigstore/core/dist/pem.js
var require_pem = __commonJS({
  "node_modules/@sigstore/core/dist/pem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toDER = toDER;
    exports2.fromDER = fromDER;
    var PEM_HEADER = /-----BEGIN (.*)-----/;
    var PEM_FOOTER = /-----END (.*)-----/;
    function toDER(certificate) {
      let der = "";
      certificate.split("\n").forEach((line) => {
        if (line.match(PEM_HEADER) || line.match(PEM_FOOTER)) {
          return;
        }
        der += line;
      });
      return Buffer.from(der, "base64");
    }
    function fromDER(certificate, type = "CERTIFICATE") {
      const der = certificate.toString("base64");
      const lines = der.match(/.{1,64}/g) || "";
      return [`-----BEGIN ${type}-----`, ...lines, `-----END ${type}-----`].join("\n").concat("\n");
    }
  }
});

// node_modules/@sigstore/core/dist/oid.js
var require_oid = __commonJS({
  "node_modules/@sigstore/core/dist/oid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SHA2_HASH_ALGOS = exports2.ECDSA_SIGNATURE_ALGOS = void 0;
    exports2.ECDSA_SIGNATURE_ALGOS = {
      "1.2.840.10045.4.3.1": "sha224",
      "1.2.840.10045.4.3.2": "sha256",
      "1.2.840.10045.4.3.3": "sha384",
      "1.2.840.10045.4.3.4": "sha512"
    };
    exports2.SHA2_HASH_ALGOS = {
      "2.16.840.1.101.3.4.2.1": "sha256",
      "2.16.840.1.101.3.4.2.2": "sha384",
      "2.16.840.1.101.3.4.2.3": "sha512"
    };
  }
});

// node_modules/@sigstore/core/dist/rfc3161/error.js
var require_error3 = __commonJS({
  "node_modules/@sigstore/core/dist/rfc3161/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RFC3161TimestampVerificationError = void 0;
    var RFC3161TimestampVerificationError = class extends Error {
    };
    exports2.RFC3161TimestampVerificationError = RFC3161TimestampVerificationError;
  }
});

// node_modules/@sigstore/core/dist/rfc3161/tstinfo.js
var require_tstinfo = __commonJS({
  "node_modules/@sigstore/core/dist/rfc3161/tstinfo.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TSTInfo = void 0;
    var crypto = __importStar(require_crypto());
    var oid_1 = require_oid();
    var error_1 = require_error3();
    var TSTInfo = class {
      constructor(asn1) {
        this.root = asn1;
      }
      get version() {
        return this.root.subs[0].toInteger();
      }
      get genTime() {
        return this.root.subs[4].toDate();
      }
      get messageImprintHashAlgorithm() {
        const oid = this.messageImprintObj.subs[0].subs[0].toOID();
        return oid_1.SHA2_HASH_ALGOS[oid];
      }
      get messageImprintHashedMessage() {
        return this.messageImprintObj.subs[1].value;
      }
      get raw() {
        return this.root.toDER();
      }
      verify(data) {
        const digest = crypto.digest(this.messageImprintHashAlgorithm, data);
        if (!crypto.bufferEqual(digest, this.messageImprintHashedMessage)) {
          throw new error_1.RFC3161TimestampVerificationError("message imprint does not match artifact");
        }
      }
      // https://www.rfc-editor.org/rfc/rfc3161#section-2.4.2
      get messageImprintObj() {
        return this.root.subs[2];
      }
    };
    exports2.TSTInfo = TSTInfo;
  }
});

// node_modules/@sigstore/core/dist/rfc3161/timestamp.js
var require_timestamp2 = __commonJS({
  "node_modules/@sigstore/core/dist/rfc3161/timestamp.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RFC3161Timestamp = void 0;
    var asn1_1 = require_asn1();
    var crypto = __importStar(require_crypto());
    var oid_1 = require_oid();
    var error_1 = require_error3();
    var tstinfo_1 = require_tstinfo();
    var OID_PKCS9_CONTENT_TYPE_SIGNED_DATA = "1.2.840.113549.1.7.2";
    var OID_PKCS9_CONTENT_TYPE_TSTINFO = "1.2.840.113549.1.9.16.1.4";
    var OID_PKCS9_MESSAGE_DIGEST_KEY = "1.2.840.113549.1.9.4";
    var RFC3161Timestamp = class _RFC3161Timestamp {
      constructor(asn1) {
        this.root = asn1;
      }
      static parse(der) {
        const asn1 = asn1_1.ASN1Obj.parseBuffer(der);
        return new _RFC3161Timestamp(asn1);
      }
      get status() {
        return this.pkiStatusInfoObj.subs[0].toInteger();
      }
      get contentType() {
        return this.contentTypeObj.toOID();
      }
      get eContentType() {
        return this.eContentTypeObj.toOID();
      }
      get signingTime() {
        return this.tstInfo.genTime;
      }
      get signerIssuer() {
        return this.signerSidObj.subs[0].value;
      }
      get signerSerialNumber() {
        return this.signerSidObj.subs[1].value;
      }
      get signerDigestAlgorithm() {
        const oid = this.signerDigestAlgorithmObj.subs[0].toOID();
        return oid_1.SHA2_HASH_ALGOS[oid];
      }
      get signatureAlgorithm() {
        const oid = this.signatureAlgorithmObj.subs[0].toOID();
        return oid_1.ECDSA_SIGNATURE_ALGOS[oid];
      }
      get signatureValue() {
        return this.signatureValueObj.value;
      }
      get tstInfo() {
        return new tstinfo_1.TSTInfo(this.eContentObj.subs[0].subs[0]);
      }
      verify(data, publicKey) {
        if (!this.timeStampTokenObj) {
          throw new error_1.RFC3161TimestampVerificationError("timeStampToken is missing");
        }
        if (this.contentType !== OID_PKCS9_CONTENT_TYPE_SIGNED_DATA) {
          throw new error_1.RFC3161TimestampVerificationError(`incorrect content type: ${this.contentType}`);
        }
        if (this.eContentType !== OID_PKCS9_CONTENT_TYPE_TSTINFO) {
          throw new error_1.RFC3161TimestampVerificationError(`incorrect encapsulated content type: ${this.eContentType}`);
        }
        this.tstInfo.verify(data);
        this.verifyMessageDigest();
        this.verifySignature(publicKey);
      }
      verifyMessageDigest() {
        const tstInfoDigest = crypto.digest(this.signerDigestAlgorithm, this.tstInfo.raw);
        const expectedDigest = this.messageDigestAttributeObj.subs[1].subs[0].value;
        if (!crypto.bufferEqual(tstInfoDigest, expectedDigest)) {
          throw new error_1.RFC3161TimestampVerificationError("signed data does not match tstInfo");
        }
      }
      verifySignature(key) {
        const signedAttrs = this.signedAttrsObj.toDER();
        signedAttrs[0] = 49;
        const verified = crypto.verify(signedAttrs, key, this.signatureValue, this.signatureAlgorithm);
        if (!verified) {
          throw new error_1.RFC3161TimestampVerificationError("signature verification failed");
        }
      }
      // https://www.rfc-editor.org/rfc/rfc3161#section-2.4.2
      get pkiStatusInfoObj() {
        return this.root.subs[0];
      }
      // https://www.rfc-editor.org/rfc/rfc3161#section-2.4.2
      get timeStampTokenObj() {
        return this.root.subs[1];
      }
      // https://datatracker.ietf.org/doc/html/rfc5652#section-3
      get contentTypeObj() {
        return this.timeStampTokenObj.subs[0];
      }
      // https://www.rfc-editor.org/rfc/rfc5652#section-3
      get signedDataObj() {
        const obj = this.timeStampTokenObj.subs.find((sub) => sub.tag.isContextSpecific(0));
        return obj.subs[0];
      }
      // https://datatracker.ietf.org/doc/html/rfc5652#section-5.1
      get encapContentInfoObj() {
        return this.signedDataObj.subs[2];
      }
      // https://datatracker.ietf.org/doc/html/rfc5652#section-5.1
      get signerInfosObj() {
        const sd = this.signedDataObj;
        return sd.subs[sd.subs.length - 1];
      }
      // https://www.rfc-editor.org/rfc/rfc5652#section-5.1
      get signerInfoObj() {
        return this.signerInfosObj.subs[0];
      }
      // https://datatracker.ietf.org/doc/html/rfc5652#section-5.2
      get eContentTypeObj() {
        return this.encapContentInfoObj.subs[0];
      }
      // https://datatracker.ietf.org/doc/html/rfc5652#section-5.2
      get eContentObj() {
        return this.encapContentInfoObj.subs[1];
      }
      // https://datatracker.ietf.org/doc/html/rfc5652#section-5.3
      get signedAttrsObj() {
        const signedAttrs = this.signerInfoObj.subs.find((sub) => sub.tag.isContextSpecific(0));
        return signedAttrs;
      }
      // https://datatracker.ietf.org/doc/html/rfc5652#section-5.3
      get messageDigestAttributeObj() {
        const messageDigest = this.signedAttrsObj.subs.find((sub) => sub.subs[0].tag.isOID() && sub.subs[0].toOID() === OID_PKCS9_MESSAGE_DIGEST_KEY);
        return messageDigest;
      }
      // https://datatracker.ietf.org/doc/html/rfc5652#section-5.3
      get signerSidObj() {
        return this.signerInfoObj.subs[1];
      }
      // https://datatracker.ietf.org/doc/html/rfc5652#section-5.3
      get signerDigestAlgorithmObj() {
        return this.signerInfoObj.subs[2];
      }
      // https://datatracker.ietf.org/doc/html/rfc5652#section-5.3
      get signatureAlgorithmObj() {
        return this.signerInfoObj.subs[4];
      }
      // https://datatracker.ietf.org/doc/html/rfc5652#section-5.3
      get signatureValueObj() {
        return this.signerInfoObj.subs[5];
      }
    };
    exports2.RFC3161Timestamp = RFC3161Timestamp;
  }
});

// node_modules/@sigstore/core/dist/rfc3161/index.js
var require_rfc3161 = __commonJS({
  "node_modules/@sigstore/core/dist/rfc3161/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RFC3161Timestamp = void 0;
    var timestamp_1 = require_timestamp2();
    Object.defineProperty(exports2, "RFC3161Timestamp", { enumerable: true, get: function() {
      return timestamp_1.RFC3161Timestamp;
    } });
  }
});

// node_modules/@sigstore/core/dist/x509/sct.js
var require_sct = __commonJS({
  "node_modules/@sigstore/core/dist/x509/sct.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SignedCertificateTimestamp = void 0;
    var crypto = __importStar(require_crypto());
    var stream_1 = require_stream();
    var SignedCertificateTimestamp = class _SignedCertificateTimestamp {
      constructor(options) {
        this.version = options.version;
        this.logID = options.logID;
        this.timestamp = options.timestamp;
        this.extensions = options.extensions;
        this.hashAlgorithm = options.hashAlgorithm;
        this.signatureAlgorithm = options.signatureAlgorithm;
        this.signature = options.signature;
      }
      get datetime() {
        return new Date(Number(this.timestamp.readBigInt64BE()));
      }
      // Returns the hash algorithm used to generate the SCT's signature.
      // https://www.rfc-editor.org/rfc/rfc5246#section-7.4.1.4.1
      get algorithm() {
        switch (this.hashAlgorithm) {
          /* istanbul ignore next */
          case 0:
            return "none";
          /* istanbul ignore next */
          case 1:
            return "md5";
          /* istanbul ignore next */
          case 2:
            return "sha1";
          /* istanbul ignore next */
          case 3:
            return "sha224";
          case 4:
            return "sha256";
          /* istanbul ignore next */
          case 5:
            return "sha384";
          /* istanbul ignore next */
          case 6:
            return "sha512";
          /* istanbul ignore next */
          default:
            return "unknown";
        }
      }
      verify(preCert, key) {
        const stream = new stream_1.ByteStream();
        stream.appendChar(this.version);
        stream.appendChar(0);
        stream.appendView(this.timestamp);
        stream.appendUint16(1);
        stream.appendView(preCert);
        stream.appendUint16(this.extensions.byteLength);
        if (this.extensions.byteLength > 0) {
          stream.appendView(this.extensions);
        }
        return crypto.verify(stream.buffer, key, this.signature, this.algorithm);
      }
      // Parses a SignedCertificateTimestamp from a buffer. SCTs are encoded using
      // TLS encoding which means the fields and lengths of most fields are
      // specified as part of the SCT and TLS specs.
      // https://www.rfc-editor.org/rfc/rfc6962#section-3.2
      // https://www.rfc-editor.org/rfc/rfc5246#section-7.4.1.4.1
      static parse(buf) {
        const stream = new stream_1.ByteStream(buf);
        const version = stream.getUint8();
        const logID = stream.getBlock(32);
        const timestamp = stream.getBlock(8);
        const extenstionLength = stream.getUint16();
        const extensions = stream.getBlock(extenstionLength);
        const hashAlgorithm = stream.getUint8();
        const signatureAlgorithm = stream.getUint8();
        const sigLength = stream.getUint16();
        const signature = stream.getBlock(sigLength);
        if (stream.position !== buf.length) {
          throw new Error("SCT buffer length mismatch");
        }
        return new _SignedCertificateTimestamp({
          version,
          logID,
          timestamp,
          extensions,
          hashAlgorithm,
          signatureAlgorithm,
          signature
        });
      }
    };
    exports2.SignedCertificateTimestamp = SignedCertificateTimestamp;
  }
});

// node_modules/@sigstore/core/dist/x509/ext.js
var require_ext = __commonJS({
  "node_modules/@sigstore/core/dist/x509/ext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.X509SCTExtension = exports2.X509SubjectKeyIDExtension = exports2.X509AuthorityKeyIDExtension = exports2.X509SubjectAlternativeNameExtension = exports2.X509KeyUsageExtension = exports2.X509BasicConstraintsExtension = exports2.X509Extension = void 0;
    var stream_1 = require_stream();
    var sct_1 = require_sct();
    var X509Extension = class {
      constructor(asn1) {
        this.root = asn1;
      }
      get oid() {
        return this.root.subs[0].toOID();
      }
      get critical() {
        return this.root.subs.length === 3 ? this.root.subs[1].toBoolean() : false;
      }
      get value() {
        return this.extnValueObj.value;
      }
      get valueObj() {
        return this.extnValueObj;
      }
      get extnValueObj() {
        return this.root.subs[this.root.subs.length - 1];
      }
    };
    exports2.X509Extension = X509Extension;
    var X509BasicConstraintsExtension = class extends X509Extension {
      get isCA() {
        return this.sequence.subs[0]?.toBoolean() ?? false;
      }
      get pathLenConstraint() {
        return this.sequence.subs.length > 1 ? this.sequence.subs[1].toInteger() : void 0;
      }
      // The extnValue field contains a single sequence wrapping the isCA and
      // pathLenConstraint.
      get sequence() {
        return this.extnValueObj.subs[0];
      }
    };
    exports2.X509BasicConstraintsExtension = X509BasicConstraintsExtension;
    var X509KeyUsageExtension = class extends X509Extension {
      get digitalSignature() {
        return this.bitString[0] === 1;
      }
      get keyCertSign() {
        return this.bitString[5] === 1;
      }
      get crlSign() {
        return this.bitString[6] === 1;
      }
      // The extnValue field contains a single bit string which is a bit mask
      // indicating which key usages are enabled.
      get bitString() {
        return this.extnValueObj.subs[0].toBitString();
      }
    };
    exports2.X509KeyUsageExtension = X509KeyUsageExtension;
    var X509SubjectAlternativeNameExtension = class extends X509Extension {
      get rfc822Name() {
        return this.findGeneralName(1)?.value.toString("ascii");
      }
      get uri() {
        return this.findGeneralName(6)?.value.toString("ascii");
      }
      // Retrieve the value of an otherName with the given OID.
      otherName(oid) {
        const otherName = this.findGeneralName(0);
        if (otherName === void 0) {
          return void 0;
        }
        const otherNameOID = otherName.subs[0].toOID();
        if (otherNameOID !== oid) {
          return void 0;
        }
        const otherNameValue = otherName.subs[1];
        return otherNameValue.subs[0].value.toString("ascii");
      }
      findGeneralName(tag) {
        return this.generalNames.find((gn) => gn.tag.isContextSpecific(tag));
      }
      // The extnValue field contains a sequence of GeneralNames.
      get generalNames() {
        return this.extnValueObj.subs[0].subs;
      }
    };
    exports2.X509SubjectAlternativeNameExtension = X509SubjectAlternativeNameExtension;
    var X509AuthorityKeyIDExtension = class extends X509Extension {
      get keyIdentifier() {
        return this.findSequenceMember(0)?.value;
      }
      findSequenceMember(tag) {
        return this.sequence.subs.find((el) => el.tag.isContextSpecific(tag));
      }
      // The extnValue field contains a single sequence wrapping the keyIdentifier
      get sequence() {
        return this.extnValueObj.subs[0];
      }
    };
    exports2.X509AuthorityKeyIDExtension = X509AuthorityKeyIDExtension;
    var X509SubjectKeyIDExtension = class extends X509Extension {
      get keyIdentifier() {
        return this.extnValueObj.subs[0].value;
      }
    };
    exports2.X509SubjectKeyIDExtension = X509SubjectKeyIDExtension;
    var X509SCTExtension = class extends X509Extension {
      constructor(asn1) {
        super(asn1);
      }
      get signedCertificateTimestamps() {
        const buf = this.extnValueObj.subs[0].value;
        const stream = new stream_1.ByteStream(buf);
        const end = stream.getUint16() + 2;
        const sctList = [];
        while (stream.position < end) {
          const sctLength = stream.getUint16();
          const sct = stream.getBlock(sctLength);
          sctList.push(sct_1.SignedCertificateTimestamp.parse(sct));
        }
        if (stream.position !== end) {
          throw new Error("SCT list length does not match actual length");
        }
        return sctList;
      }
    };
    exports2.X509SCTExtension = X509SCTExtension;
  }
});

// node_modules/@sigstore/core/dist/x509/cert.js
var require_cert = __commonJS({
  "node_modules/@sigstore/core/dist/x509/cert.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.X509Certificate = exports2.EXTENSION_OID_SCT = void 0;
    var asn1_1 = require_asn1();
    var crypto = __importStar(require_crypto());
    var oid_1 = require_oid();
    var pem = __importStar(require_pem());
    var ext_1 = require_ext();
    var EXTENSION_OID_SUBJECT_KEY_ID = "2.5.29.14";
    var EXTENSION_OID_KEY_USAGE = "2.5.29.15";
    var EXTENSION_OID_SUBJECT_ALT_NAME = "2.5.29.17";
    var EXTENSION_OID_BASIC_CONSTRAINTS = "2.5.29.19";
    var EXTENSION_OID_AUTHORITY_KEY_ID = "2.5.29.35";
    exports2.EXTENSION_OID_SCT = "1.3.6.1.4.1.11129.2.4.2";
    var X509Certificate = class _X509Certificate {
      constructor(asn1) {
        this.root = asn1;
      }
      static parse(cert) {
        const der = typeof cert === "string" ? pem.toDER(cert) : cert;
        const asn1 = asn1_1.ASN1Obj.parseBuffer(der);
        return new _X509Certificate(asn1);
      }
      get tbsCertificate() {
        return this.tbsCertificateObj;
      }
      get version() {
        const ver = this.versionObj.subs[0].toInteger();
        return `v${(ver + BigInt(1)).toString()}`;
      }
      get serialNumber() {
        return this.serialNumberObj.value;
      }
      get notBefore() {
        return this.validityObj.subs[0].toDate();
      }
      get notAfter() {
        return this.validityObj.subs[1].toDate();
      }
      get issuer() {
        return this.issuerObj.value;
      }
      get subject() {
        return this.subjectObj.value;
      }
      get publicKey() {
        return this.subjectPublicKeyInfoObj.toDER();
      }
      get signatureAlgorithm() {
        const oid = this.signatureAlgorithmObj.subs[0].toOID();
        return oid_1.ECDSA_SIGNATURE_ALGOS[oid];
      }
      get signatureValue() {
        return this.signatureValueObj.value.subarray(1);
      }
      get subjectAltName() {
        const ext = this.extSubjectAltName;
        return ext?.uri || /* istanbul ignore next */
        ext?.rfc822Name;
      }
      get extensions() {
        const extSeq = this.extensionsObj?.subs[0];
        return extSeq?.subs || [];
      }
      get extKeyUsage() {
        const ext = this.findExtension(EXTENSION_OID_KEY_USAGE);
        return ext ? new ext_1.X509KeyUsageExtension(ext) : void 0;
      }
      get extBasicConstraints() {
        const ext = this.findExtension(EXTENSION_OID_BASIC_CONSTRAINTS);
        return ext ? new ext_1.X509BasicConstraintsExtension(ext) : void 0;
      }
      get extSubjectAltName() {
        const ext = this.findExtension(EXTENSION_OID_SUBJECT_ALT_NAME);
        return ext ? new ext_1.X509SubjectAlternativeNameExtension(ext) : void 0;
      }
      get extAuthorityKeyID() {
        const ext = this.findExtension(EXTENSION_OID_AUTHORITY_KEY_ID);
        return ext ? new ext_1.X509AuthorityKeyIDExtension(ext) : void 0;
      }
      get extSubjectKeyID() {
        const ext = this.findExtension(EXTENSION_OID_SUBJECT_KEY_ID);
        return ext ? new ext_1.X509SubjectKeyIDExtension(ext) : (
          /* istanbul ignore next */
          void 0
        );
      }
      get extSCT() {
        const ext = this.findExtension(exports2.EXTENSION_OID_SCT);
        return ext ? new ext_1.X509SCTExtension(ext) : void 0;
      }
      get isCA() {
        const ca = this.extBasicConstraints?.isCA || false;
        if (this.extKeyUsage) {
          return ca && this.extKeyUsage.keyCertSign;
        }
        return ca;
      }
      extension(oid) {
        const ext = this.findExtension(oid);
        return ext ? new ext_1.X509Extension(ext) : void 0;
      }
      verify(issuerCertificate) {
        const publicKey = issuerCertificate?.publicKey || this.publicKey;
        const key = crypto.createPublicKey(publicKey);
        return crypto.verify(this.tbsCertificate.toDER(), key, this.signatureValue, this.signatureAlgorithm);
      }
      validForDate(date) {
        return this.notBefore <= date && date <= this.notAfter;
      }
      equals(other) {
        return this.root.toDER().equals(other.root.toDER());
      }
      // Creates a copy of the certificate with a new buffer
      clone() {
        const der = this.root.toDER();
        const clone = Buffer.alloc(der.length);
        der.copy(clone);
        return _X509Certificate.parse(clone);
      }
      findExtension(oid) {
        return this.extensions.find((ext) => ext.subs[0].toOID() === oid);
      }
      /////////////////////////////////////////////////////////////////////////////
      // The following properties use the documented x509 structure to locate the
      // desired ASN.1 object
      // https://www.rfc-editor.org/rfc/rfc5280#section-4.1
      // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.1.1
      get tbsCertificateObj() {
        return this.root.subs[0];
      }
      // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.1.2
      get signatureAlgorithmObj() {
        return this.root.subs[1];
      }
      // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.1.3
      get signatureValueObj() {
        return this.root.subs[2];
      }
      // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.1
      get versionObj() {
        return this.tbsCertificateObj.subs[0];
      }
      // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.2
      get serialNumberObj() {
        return this.tbsCertificateObj.subs[1];
      }
      // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.4
      get issuerObj() {
        return this.tbsCertificateObj.subs[3];
      }
      // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.5
      get validityObj() {
        return this.tbsCertificateObj.subs[4];
      }
      // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.6
      get subjectObj() {
        return this.tbsCertificateObj.subs[5];
      }
      // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.7
      get subjectPublicKeyInfoObj() {
        return this.tbsCertificateObj.subs[6];
      }
      // Extensions can't be located by index because their position varies. Instead,
      // we need to find the extensions context specific tag
      // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.9
      get extensionsObj() {
        return this.tbsCertificateObj.subs.find((sub) => sub.tag.isContextSpecific(3));
      }
    };
    exports2.X509Certificate = X509Certificate;
  }
});

// node_modules/@sigstore/core/dist/x509/index.js
var require_x509 = __commonJS({
  "node_modules/@sigstore/core/dist/x509/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.X509SCTExtension = exports2.X509Certificate = exports2.EXTENSION_OID_SCT = void 0;
    var cert_1 = require_cert();
    Object.defineProperty(exports2, "EXTENSION_OID_SCT", { enumerable: true, get: function() {
      return cert_1.EXTENSION_OID_SCT;
    } });
    Object.defineProperty(exports2, "X509Certificate", { enumerable: true, get: function() {
      return cert_1.X509Certificate;
    } });
    var ext_1 = require_ext();
    Object.defineProperty(exports2, "X509SCTExtension", { enumerable: true, get: function() {
      return ext_1.X509SCTExtension;
    } });
  }
});

// node_modules/@sigstore/core/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/@sigstore/core/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.X509SCTExtension = exports2.X509Certificate = exports2.EXTENSION_OID_SCT = exports2.ByteStream = exports2.RFC3161Timestamp = exports2.pem = exports2.json = exports2.encoding = exports2.dsse = exports2.crypto = exports2.ASN1Obj = void 0;
    var asn1_1 = require_asn1();
    Object.defineProperty(exports2, "ASN1Obj", { enumerable: true, get: function() {
      return asn1_1.ASN1Obj;
    } });
    exports2.crypto = __importStar(require_crypto());
    exports2.dsse = __importStar(require_dsse());
    exports2.encoding = __importStar(require_encoding3());
    exports2.json = __importStar(require_json());
    exports2.pem = __importStar(require_pem());
    var rfc3161_1 = require_rfc3161();
    Object.defineProperty(exports2, "RFC3161Timestamp", { enumerable: true, get: function() {
      return rfc3161_1.RFC3161Timestamp;
    } });
    var stream_1 = require_stream();
    Object.defineProperty(exports2, "ByteStream", { enumerable: true, get: function() {
      return stream_1.ByteStream;
    } });
    var x509_1 = require_x509();
    Object.defineProperty(exports2, "EXTENSION_OID_SCT", { enumerable: true, get: function() {
      return x509_1.EXTENSION_OID_SCT;
    } });
    Object.defineProperty(exports2, "X509Certificate", { enumerable: true, get: function() {
      return x509_1.X509Certificate;
    } });
    Object.defineProperty(exports2, "X509SCTExtension", { enumerable: true, get: function() {
      return x509_1.X509SCTExtension;
    } });
  }
});

// node_modules/@sigstore/sign/dist/util/oidc.js
var require_oidc = __commonJS({
  "node_modules/@sigstore/sign/dist/util/oidc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractJWTSubject = extractJWTSubject;
    var core_1 = require_dist7();
    function extractJWTSubject(jwt) {
      const parts = jwt.split(".", 3);
      const payload = JSON.parse(core_1.encoding.base64Decode(parts[1]));
      switch (payload.iss) {
        case "https://accounts.google.com":
        case "https://oauth2.sigstore.dev/auth":
          return payload.email;
        default:
          return payload.sub;
      }
    }
  }
});

// node_modules/@sigstore/sign/package.json
var require_package6 = __commonJS({
  "node_modules/@sigstore/sign/package.json"(exports2, module2) {
    module2.exports = {
      name: "@sigstore/sign",
      version: "3.1.0",
      description: "Sigstore signing library",
      main: "dist/index.js",
      types: "dist/index.d.ts",
      scripts: {
        clean: "shx rm -rf dist *.tsbuildinfo",
        build: "tsc --build",
        test: "jest"
      },
      files: [
        "dist"
      ],
      author: "bdehamer@github.com",
      license: "Apache-2.0",
      repository: {
        type: "git",
        url: "git+https://github.com/sigstore/sigstore-js.git"
      },
      bugs: {
        url: "https://github.com/sigstore/sigstore-js/issues"
      },
      homepage: "https://github.com/sigstore/sigstore-js/tree/main/packages/sign#readme",
      publishConfig: {
        provenance: true
      },
      devDependencies: {
        "@sigstore/jest": "^0.0.0",
        "@sigstore/mock": "^0.10.0",
        "@sigstore/rekor-types": "^3.0.0",
        "@types/make-fetch-happen": "^10.0.4",
        "@types/promise-retry": "^1.1.6"
      },
      dependencies: {
        "@sigstore/bundle": "^3.1.0",
        "@sigstore/core": "^2.0.0",
        "@sigstore/protobuf-specs": "^0.4.0",
        "make-fetch-happen": "^14.0.2",
        "proc-log": "^5.0.0",
        "promise-retry": "^2.0.1"
      },
      engines: {
        node: "^18.17.0 || >=20.5.0"
      }
    };
  }
});

// node_modules/@sigstore/sign/dist/util/ua.js
var require_ua = __commonJS({
  "node_modules/@sigstore/sign/dist/util/ua.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getUserAgent = void 0;
    var os_1 = __importDefault(require("os"));
    var getUserAgent = () => {
      const packageVersion = require_package6().version;
      const nodeVersion = process.version;
      const platformName = os_1.default.platform();
      const archName = os_1.default.arch();
      return `sigstore-js/${packageVersion} (Node ${nodeVersion}) (${platformName}/${archName})`;
    };
    exports2.getUserAgent = getUserAgent;
  }
});

// node_modules/@sigstore/sign/dist/util/index.js
var require_util2 = __commonJS({
  "node_modules/@sigstore/sign/dist/util/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ua = exports2.oidc = exports2.pem = exports2.json = exports2.encoding = exports2.dsse = exports2.crypto = void 0;
    var core_1 = require_dist7();
    Object.defineProperty(exports2, "crypto", { enumerable: true, get: function() {
      return core_1.crypto;
    } });
    Object.defineProperty(exports2, "dsse", { enumerable: true, get: function() {
      return core_1.dsse;
    } });
    Object.defineProperty(exports2, "encoding", { enumerable: true, get: function() {
      return core_1.encoding;
    } });
    Object.defineProperty(exports2, "json", { enumerable: true, get: function() {
      return core_1.json;
    } });
    Object.defineProperty(exports2, "pem", { enumerable: true, get: function() {
      return core_1.pem;
    } });
    exports2.oidc = __importStar(require_oidc());
    exports2.ua = __importStar(require_ua());
  }
});

// node_modules/@sigstore/sign/dist/bundler/base.js
var require_base = __commonJS({
  "node_modules/@sigstore/sign/dist/bundler/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseBundleBuilder = void 0;
    var BaseBundleBuilder = class {
      constructor(options) {
        this.signer = options.signer;
        this.witnesses = options.witnesses;
      }
      // Executes the signing/witnessing process for the given artifact.
      async create(artifact) {
        const signature = await this.prepare(artifact).then((blob) => this.signer.sign(blob));
        const bundle = await this.package(artifact, signature);
        const verificationMaterials = await Promise.all(this.witnesses.map((witness) => witness.testify(bundle.content, publicKey(signature.key))));
        const tlogEntryList = [];
        const timestampList = [];
        verificationMaterials.forEach(({ tlogEntries, rfc3161Timestamps }) => {
          tlogEntryList.push(...tlogEntries ?? []);
          timestampList.push(...rfc3161Timestamps ?? []);
        });
        bundle.verificationMaterial.tlogEntries = tlogEntryList;
        bundle.verificationMaterial.timestampVerificationData = {
          rfc3161Timestamps: timestampList
        };
        return bundle;
      }
      // Override this function to apply any pre-signing transformations to the
      // artifact. The returned buffer will be signed by the signer. The default
      // implementation simply returns the artifact data.
      async prepare(artifact) {
        return artifact.data;
      }
    };
    exports2.BaseBundleBuilder = BaseBundleBuilder;
    function publicKey(key) {
      switch (key.$case) {
        case "publicKey":
          return key.publicKey;
        case "x509Certificate":
          return key.certificate;
      }
    }
  }
});

// node_modules/@sigstore/sign/dist/bundler/bundle.js
var require_bundle2 = __commonJS({
  "node_modules/@sigstore/sign/dist/bundler/bundle.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toMessageSignatureBundle = toMessageSignatureBundle;
    exports2.toDSSEBundle = toDSSEBundle;
    var sigstore = __importStar(require_dist6());
    var util_1 = require_util2();
    function toMessageSignatureBundle(artifact, signature) {
      const digest = util_1.crypto.digest("sha256", artifact.data);
      return sigstore.toMessageSignatureBundle({
        digest,
        signature: signature.signature,
        certificate: signature.key.$case === "x509Certificate" ? util_1.pem.toDER(signature.key.certificate) : void 0,
        keyHint: signature.key.$case === "publicKey" ? signature.key.hint : void 0,
        certificateChain: true
      });
    }
    function toDSSEBundle(artifact, signature, certificateChain) {
      return sigstore.toDSSEBundle({
        artifact: artifact.data,
        artifactType: artifact.type,
        signature: signature.signature,
        certificate: signature.key.$case === "x509Certificate" ? util_1.pem.toDER(signature.key.certificate) : void 0,
        keyHint: signature.key.$case === "publicKey" ? signature.key.hint : void 0,
        certificateChain
      });
    }
  }
});

// node_modules/@sigstore/sign/dist/bundler/dsse.js
var require_dsse2 = __commonJS({
  "node_modules/@sigstore/sign/dist/bundler/dsse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DSSEBundleBuilder = void 0;
    var util_1 = require_util2();
    var base_1 = require_base();
    var bundle_1 = require_bundle2();
    var DSSEBundleBuilder = class extends base_1.BaseBundleBuilder {
      constructor(options) {
        super(options);
        this.certificateChain = options.certificateChain ?? false;
      }
      // DSSE requires the artifact to be pre-encoded with the payload type
      // before the signature is generated.
      async prepare(artifact) {
        const a = artifactDefaults(artifact);
        return util_1.dsse.preAuthEncoding(a.type, a.data);
      }
      // Packages the artifact and signature into a DSSE bundle
      async package(artifact, signature) {
        return (0, bundle_1.toDSSEBundle)(artifactDefaults(artifact), signature, this.certificateChain);
      }
    };
    exports2.DSSEBundleBuilder = DSSEBundleBuilder;
    function artifactDefaults(artifact) {
      return {
        ...artifact,
        type: artifact.type ?? ""
      };
    }
  }
});

// node_modules/@sigstore/sign/dist/bundler/message.js
var require_message = __commonJS({
  "node_modules/@sigstore/sign/dist/bundler/message.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MessageSignatureBundleBuilder = void 0;
    var base_1 = require_base();
    var bundle_1 = require_bundle2();
    var MessageSignatureBundleBuilder = class extends base_1.BaseBundleBuilder {
      constructor(options) {
        super(options);
      }
      async package(artifact, signature) {
        return (0, bundle_1.toMessageSignatureBundle)(artifact, signature);
      }
    };
    exports2.MessageSignatureBundleBuilder = MessageSignatureBundleBuilder;
  }
});

// node_modules/@sigstore/sign/dist/bundler/index.js
var require_bundler = __commonJS({
  "node_modules/@sigstore/sign/dist/bundler/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MessageSignatureBundleBuilder = exports2.DSSEBundleBuilder = void 0;
    var dsse_1 = require_dsse2();
    Object.defineProperty(exports2, "DSSEBundleBuilder", { enumerable: true, get: function() {
      return dsse_1.DSSEBundleBuilder;
    } });
    var message_1 = require_message();
    Object.defineProperty(exports2, "MessageSignatureBundleBuilder", { enumerable: true, get: function() {
      return message_1.MessageSignatureBundleBuilder;
    } });
  }
});

// node_modules/@sigstore/sign/dist/external/error.js
var require_error4 = __commonJS({
  "node_modules/@sigstore/sign/dist/external/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HTTPError = void 0;
    var HTTPError = class extends Error {
      constructor({ status, message, location }) {
        super(`(${status}) ${message}`);
        this.statusCode = status;
        this.location = location;
      }
    };
    exports2.HTTPError = HTTPError;
  }
});

// node_modules/@sigstore/sign/dist/error.js
var require_error5 = __commonJS({
  "node_modules/@sigstore/sign/dist/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InternalError = void 0;
    exports2.internalError = internalError;
    var error_1 = require_error4();
    var InternalError = class extends Error {
      constructor({ code, message, cause }) {
        super(message);
        this.name = this.constructor.name;
        this.cause = cause;
        this.code = code;
      }
    };
    exports2.InternalError = InternalError;
    function internalError(err, code, message) {
      if (err instanceof error_1.HTTPError) {
        message += ` - ${err.message}`;
      }
      throw new InternalError({
        code,
        message,
        cause: err
      });
    }
  }
});

// node_modules/@sigstore/sign/dist/identity/ci.js
var require_ci = __commonJS({
  "node_modules/@sigstore/sign/dist/identity/ci.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CIContextProvider = void 0;
    var make_fetch_happen_1 = __importDefault(require_lib30());
    var providers = [getGHAToken, getEnv];
    var CIContextProvider = class {
      /* istanbul ignore next */
      constructor(audience = "sigstore") {
        this.audience = audience;
      }
      // Invoke all registered ProviderFuncs and return the value of whichever one
      // resolves first.
      async getToken() {
        return Promise.any(providers.map((getToken) => getToken(this.audience))).catch(() => Promise.reject("CI: no tokens available"));
      }
    };
    exports2.CIContextProvider = CIContextProvider;
    async function getGHAToken(audience) {
      if (!process.env.ACTIONS_ID_TOKEN_REQUEST_URL || !process.env.ACTIONS_ID_TOKEN_REQUEST_TOKEN) {
        return Promise.reject("no token available");
      }
      const url = new URL(process.env.ACTIONS_ID_TOKEN_REQUEST_URL);
      url.searchParams.append("audience", audience);
      const response = await (0, make_fetch_happen_1.default)(url.href, {
        retry: 2,
        headers: {
          Accept: "application/json",
          Authorization: `Bearer ${process.env.ACTIONS_ID_TOKEN_REQUEST_TOKEN}`
        }
      });
      return response.json().then((data) => data.value);
    }
    async function getEnv() {
      if (!process.env.SIGSTORE_ID_TOKEN) {
        return Promise.reject("no token available");
      }
      return process.env.SIGSTORE_ID_TOKEN;
    }
  }
});

// node_modules/@sigstore/sign/dist/identity/index.js
var require_identity = __commonJS({
  "node_modules/@sigstore/sign/dist/identity/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CIContextProvider = void 0;
    var ci_1 = require_ci();
    Object.defineProperty(exports2, "CIContextProvider", { enumerable: true, get: function() {
      return ci_1.CIContextProvider;
    } });
  }
});

// node_modules/@sigstore/sign/dist/external/fetch.js
var require_fetch2 = __commonJS({
  "node_modules/@sigstore/sign/dist/external/fetch.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchWithRetry = fetchWithRetry;
    var http2_1 = require("http2");
    var make_fetch_happen_1 = __importDefault(require_lib30());
    var proc_log_1 = require_lib4();
    var promise_retry_1 = __importDefault(require_promise_retry());
    var util_1 = require_util2();
    var error_1 = require_error4();
    var { HTTP2_HEADER_LOCATION, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_USER_AGENT, HTTP_STATUS_INTERNAL_SERVER_ERROR, HTTP_STATUS_TOO_MANY_REQUESTS, HTTP_STATUS_REQUEST_TIMEOUT } = http2_1.constants;
    async function fetchWithRetry(url, options) {
      return (0, promise_retry_1.default)(async (retry, attemptNum) => {
        const method = options.method || "POST";
        const headers = {
          [HTTP2_HEADER_USER_AGENT]: util_1.ua.getUserAgent(),
          ...options.headers
        };
        const response = await (0, make_fetch_happen_1.default)(url, {
          method,
          headers,
          body: options.body,
          timeout: options.timeout,
          retry: false
          // We're handling retries ourselves
        }).catch((reason) => {
          proc_log_1.log.http("fetch", `${method} ${url} attempt ${attemptNum} failed with ${reason}`);
          return retry(reason);
        });
        if (response.ok) {
          return response;
        } else {
          const error = await errorFromResponse(response);
          proc_log_1.log.http("fetch", `${method} ${url} attempt ${attemptNum} failed with ${response.status}`);
          if (retryable(response.status)) {
            return retry(error);
          } else {
            throw error;
          }
        }
      }, retryOpts(options.retry));
    }
    var errorFromResponse = async (response) => {
      let message = response.statusText;
      const location = response.headers.get(HTTP2_HEADER_LOCATION) || void 0;
      const contentType = response.headers.get(HTTP2_HEADER_CONTENT_TYPE);
      if (contentType?.includes("application/json")) {
        try {
          const body = await response.json();
          message = body.message || message;
        } catch (e) {
        }
      }
      return new error_1.HTTPError({
        status: response.status,
        message,
        location
      });
    };
    var retryable = (status) => [HTTP_STATUS_REQUEST_TIMEOUT, HTTP_STATUS_TOO_MANY_REQUESTS].includes(status) || status >= HTTP_STATUS_INTERNAL_SERVER_ERROR;
    var retryOpts = (retry) => {
      if (typeof retry === "boolean") {
        return { retries: retry ? 1 : 0 };
      } else if (typeof retry === "number") {
        return { retries: retry };
      } else {
        return { retries: 0, ...retry };
      }
    };
  }
});

// node_modules/@sigstore/sign/dist/external/fulcio.js
var require_fulcio = __commonJS({
  "node_modules/@sigstore/sign/dist/external/fulcio.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Fulcio = void 0;
    var fetch_1 = require_fetch2();
    var Fulcio = class {
      constructor(options) {
        this.options = options;
      }
      async createSigningCertificate(request) {
        const { baseURL, retry, timeout } = this.options;
        const url = `${baseURL}/api/v2/signingCert`;
        const response = await (0, fetch_1.fetchWithRetry)(url, {
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(request),
          timeout,
          retry
        });
        return response.json();
      }
    };
    exports2.Fulcio = Fulcio;
  }
});

// node_modules/@sigstore/sign/dist/signer/fulcio/ca.js
var require_ca = __commonJS({
  "node_modules/@sigstore/sign/dist/signer/fulcio/ca.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CAClient = void 0;
    var error_1 = require_error5();
    var fulcio_1 = require_fulcio();
    var CAClient = class {
      constructor(options) {
        this.fulcio = new fulcio_1.Fulcio({
          baseURL: options.fulcioBaseURL,
          retry: options.retry,
          timeout: options.timeout
        });
      }
      async createSigningCertificate(identityToken, publicKey, challenge) {
        const request = toCertificateRequest(identityToken, publicKey, challenge);
        try {
          const resp = await this.fulcio.createSigningCertificate(request);
          const cert = resp.signedCertificateEmbeddedSct ? resp.signedCertificateEmbeddedSct : resp.signedCertificateDetachedSct;
          return cert.chain.certificates;
        } catch (err) {
          (0, error_1.internalError)(err, "CA_CREATE_SIGNING_CERTIFICATE_ERROR", "error creating signing certificate");
        }
      }
    };
    exports2.CAClient = CAClient;
    function toCertificateRequest(identityToken, publicKey, challenge) {
      return {
        credentials: {
          oidcIdentityToken: identityToken
        },
        publicKeyRequest: {
          publicKey: {
            algorithm: "ECDSA",
            content: publicKey
          },
          proofOfPossession: challenge.toString("base64")
        }
      };
    }
  }
});

// node_modules/@sigstore/sign/dist/signer/fulcio/ephemeral.js
var require_ephemeral = __commonJS({
  "node_modules/@sigstore/sign/dist/signer/fulcio/ephemeral.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EphemeralSigner = void 0;
    var crypto_1 = __importDefault(require("crypto"));
    var EC_KEYPAIR_TYPE = "ec";
    var P256_CURVE = "P-256";
    var EphemeralSigner = class {
      constructor() {
        this.keypair = crypto_1.default.generateKeyPairSync(EC_KEYPAIR_TYPE, {
          namedCurve: P256_CURVE
        });
      }
      async sign(data) {
        const signature = crypto_1.default.sign(null, data, this.keypair.privateKey);
        const publicKey = this.keypair.publicKey.export({ format: "pem", type: "spki" }).toString("ascii");
        return {
          signature,
          key: { $case: "publicKey", publicKey }
        };
      }
    };
    exports2.EphemeralSigner = EphemeralSigner;
  }
});

// node_modules/@sigstore/sign/dist/signer/fulcio/index.js
var require_fulcio2 = __commonJS({
  "node_modules/@sigstore/sign/dist/signer/fulcio/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FulcioSigner = exports2.DEFAULT_FULCIO_URL = void 0;
    var error_1 = require_error5();
    var util_1 = require_util2();
    var ca_1 = require_ca();
    var ephemeral_1 = require_ephemeral();
    exports2.DEFAULT_FULCIO_URL = "https://fulcio.sigstore.dev";
    var FulcioSigner = class {
      constructor(options) {
        this.ca = new ca_1.CAClient({
          ...options,
          fulcioBaseURL: options.fulcioBaseURL || /* istanbul ignore next */
          exports2.DEFAULT_FULCIO_URL
        });
        this.identityProvider = options.identityProvider;
        this.keyHolder = options.keyHolder || new ephemeral_1.EphemeralSigner();
      }
      async sign(data) {
        const identityToken = await this.getIdentityToken();
        let subject;
        try {
          subject = util_1.oidc.extractJWTSubject(identityToken);
        } catch (err) {
          throw new error_1.InternalError({
            code: "IDENTITY_TOKEN_PARSE_ERROR",
            message: `invalid identity token: ${identityToken}`,
            cause: err
          });
        }
        const challenge = await this.keyHolder.sign(Buffer.from(subject));
        if (challenge.key.$case !== "publicKey") {
          throw new error_1.InternalError({
            code: "CA_CREATE_SIGNING_CERTIFICATE_ERROR",
            message: "unexpected format for signing key"
          });
        }
        const certificates = await this.ca.createSigningCertificate(identityToken, challenge.key.publicKey, challenge.signature);
        const signature = await this.keyHolder.sign(data);
        return {
          signature: signature.signature,
          key: {
            $case: "x509Certificate",
            certificate: certificates[0]
          }
        };
      }
      async getIdentityToken() {
        try {
          return await this.identityProvider.getToken();
        } catch (err) {
          throw new error_1.InternalError({
            code: "IDENTITY_TOKEN_READ_ERROR",
            message: "error retrieving identity token",
            cause: err
          });
        }
      }
    };
    exports2.FulcioSigner = FulcioSigner;
  }
});

// node_modules/@sigstore/sign/dist/signer/index.js
var require_signer = __commonJS({
  "node_modules/@sigstore/sign/dist/signer/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FulcioSigner = exports2.DEFAULT_FULCIO_URL = void 0;
    var fulcio_1 = require_fulcio2();
    Object.defineProperty(exports2, "DEFAULT_FULCIO_URL", { enumerable: true, get: function() {
      return fulcio_1.DEFAULT_FULCIO_URL;
    } });
    Object.defineProperty(exports2, "FulcioSigner", { enumerable: true, get: function() {
      return fulcio_1.FulcioSigner;
    } });
  }
});

// node_modules/@sigstore/sign/dist/external/rekor.js
var require_rekor = __commonJS({
  "node_modules/@sigstore/sign/dist/external/rekor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Rekor = void 0;
    var fetch_1 = require_fetch2();
    var Rekor = class {
      constructor(options) {
        this.options = options;
      }
      /**
       * Create a new entry in the Rekor log.
       * @param propsedEntry {ProposedEntry} Data to create a new entry
       * @returns {Promise<Entry>} The created entry
       */
      async createEntry(propsedEntry) {
        const { baseURL, timeout, retry } = this.options;
        const url = `${baseURL}/api/v1/log/entries`;
        const response = await (0, fetch_1.fetchWithRetry)(url, {
          headers: {
            "Content-Type": "application/json",
            Accept: "application/json"
          },
          body: JSON.stringify(propsedEntry),
          timeout,
          retry
        });
        const data = await response.json();
        return entryFromResponse(data);
      }
      /**
       * Get an entry from the Rekor log.
       * @param uuid {string} The UUID of the entry to retrieve
       * @returns {Promise<Entry>} The retrieved entry
       */
      async getEntry(uuid) {
        const { baseURL, timeout, retry } = this.options;
        const url = `${baseURL}/api/v1/log/entries/${uuid}`;
        const response = await (0, fetch_1.fetchWithRetry)(url, {
          method: "GET",
          headers: {
            Accept: "application/json"
          },
          timeout,
          retry
        });
        const data = await response.json();
        return entryFromResponse(data);
      }
    };
    exports2.Rekor = Rekor;
    function entryFromResponse(data) {
      const entries = Object.entries(data);
      if (entries.length != 1) {
        throw new Error("Received multiple entries in Rekor response");
      }
      const [uuid, entry] = entries[0];
      return {
        ...entry,
        uuid
      };
    }
  }
});

// node_modules/@sigstore/sign/dist/witness/tlog/client.js
var require_client = __commonJS({
  "node_modules/@sigstore/sign/dist/witness/tlog/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TLogClient = void 0;
    var error_1 = require_error5();
    var error_2 = require_error4();
    var rekor_1 = require_rekor();
    var TLogClient = class {
      constructor(options) {
        this.fetchOnConflict = options.fetchOnConflict ?? false;
        this.rekor = new rekor_1.Rekor({
          baseURL: options.rekorBaseURL,
          retry: options.retry,
          timeout: options.timeout
        });
      }
      async createEntry(proposedEntry) {
        let entry;
        try {
          entry = await this.rekor.createEntry(proposedEntry);
        } catch (err) {
          if (entryExistsError(err) && this.fetchOnConflict) {
            const uuid = err.location.split("/").pop() || "";
            try {
              entry = await this.rekor.getEntry(uuid);
            } catch (err2) {
              (0, error_1.internalError)(err2, "TLOG_FETCH_ENTRY_ERROR", "error fetching tlog entry");
            }
          } else {
            (0, error_1.internalError)(err, "TLOG_CREATE_ENTRY_ERROR", "error creating tlog entry");
          }
        }
        return entry;
      }
    };
    exports2.TLogClient = TLogClient;
    function entryExistsError(value) {
      return value instanceof error_2.HTTPError && value.statusCode === 409 && value.location !== void 0;
    }
  }
});

// node_modules/@sigstore/sign/dist/witness/tlog/entry.js
var require_entry2 = __commonJS({
  "node_modules/@sigstore/sign/dist/witness/tlog/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toProposedEntry = toProposedEntry;
    var bundle_1 = require_dist6();
    var util_1 = require_util2();
    var SHA256_ALGORITHM = "sha256";
    function toProposedEntry(content, publicKey, entryType = "dsse") {
      switch (content.$case) {
        case "dsseEnvelope":
          if (entryType === "intoto") {
            return toProposedIntotoEntry(content.dsseEnvelope, publicKey);
          }
          return toProposedDSSEEntry(content.dsseEnvelope, publicKey);
        case "messageSignature":
          return toProposedHashedRekordEntry(content.messageSignature, publicKey);
      }
    }
    function toProposedHashedRekordEntry(messageSignature, publicKey) {
      const hexDigest = messageSignature.messageDigest.digest.toString("hex");
      const b64Signature = messageSignature.signature.toString("base64");
      const b64Key = util_1.encoding.base64Encode(publicKey);
      return {
        apiVersion: "0.0.1",
        kind: "hashedrekord",
        spec: {
          data: {
            hash: {
              algorithm: SHA256_ALGORITHM,
              value: hexDigest
            }
          },
          signature: {
            content: b64Signature,
            publicKey: {
              content: b64Key
            }
          }
        }
      };
    }
    function toProposedDSSEEntry(envelope, publicKey) {
      const envelopeJSON = JSON.stringify((0, bundle_1.envelopeToJSON)(envelope));
      const encodedKey = util_1.encoding.base64Encode(publicKey);
      return {
        apiVersion: "0.0.1",
        kind: "dsse",
        spec: {
          proposedContent: {
            envelope: envelopeJSON,
            verifiers: [encodedKey]
          }
        }
      };
    }
    function toProposedIntotoEntry(envelope, publicKey) {
      const payloadHash = util_1.crypto.digest(SHA256_ALGORITHM, envelope.payload).toString("hex");
      const envelopeHash = calculateDSSEHash(envelope, publicKey);
      const payload = util_1.encoding.base64Encode(envelope.payload.toString("base64"));
      const sig = util_1.encoding.base64Encode(envelope.signatures[0].sig.toString("base64"));
      const keyid = envelope.signatures[0].keyid;
      const encodedKey = util_1.encoding.base64Encode(publicKey);
      const dsse = {
        payloadType: envelope.payloadType,
        payload,
        signatures: [{ sig, publicKey: encodedKey }]
      };
      if (keyid.length > 0) {
        dsse.signatures[0].keyid = keyid;
      }
      return {
        apiVersion: "0.0.2",
        kind: "intoto",
        spec: {
          content: {
            envelope: dsse,
            hash: { algorithm: SHA256_ALGORITHM, value: envelopeHash },
            payloadHash: { algorithm: SHA256_ALGORITHM, value: payloadHash }
          }
        }
      };
    }
    function calculateDSSEHash(envelope, publicKey) {
      const dsse = {
        payloadType: envelope.payloadType,
        payload: envelope.payload.toString("base64"),
        signatures: [
          { sig: envelope.signatures[0].sig.toString("base64"), publicKey }
        ]
      };
      if (envelope.signatures[0].keyid.length > 0) {
        dsse.signatures[0].keyid = envelope.signatures[0].keyid;
      }
      return util_1.crypto.digest(SHA256_ALGORITHM, util_1.json.canonicalize(dsse)).toString("hex");
    }
  }
});

// node_modules/@sigstore/sign/dist/witness/tlog/index.js
var require_tlog = __commonJS({
  "node_modules/@sigstore/sign/dist/witness/tlog/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RekorWitness = exports2.DEFAULT_REKOR_URL = void 0;
    var util_1 = require_util2();
    var client_1 = require_client();
    var entry_1 = require_entry2();
    exports2.DEFAULT_REKOR_URL = "https://rekor.sigstore.dev";
    var RekorWitness = class {
      constructor(options) {
        this.entryType = options.entryType;
        this.tlog = new client_1.TLogClient({
          ...options,
          rekorBaseURL: options.rekorBaseURL || /* istanbul ignore next */
          exports2.DEFAULT_REKOR_URL
        });
      }
      async testify(content, publicKey) {
        const proposedEntry = (0, entry_1.toProposedEntry)(content, publicKey, this.entryType);
        const entry = await this.tlog.createEntry(proposedEntry);
        return toTransparencyLogEntry(entry);
      }
    };
    exports2.RekorWitness = RekorWitness;
    function toTransparencyLogEntry(entry) {
      const logID = Buffer.from(entry.logID, "hex");
      const bodyJSON = util_1.encoding.base64Decode(entry.body);
      const entryBody = JSON.parse(bodyJSON);
      const promise = entry?.verification?.signedEntryTimestamp ? inclusionPromise(entry.verification.signedEntryTimestamp) : void 0;
      const proof = entry?.verification?.inclusionProof ? inclusionProof(entry.verification.inclusionProof) : void 0;
      const tlogEntry = {
        logIndex: entry.logIndex.toString(),
        logId: {
          keyId: logID
        },
        integratedTime: entry.integratedTime.toString(),
        kindVersion: {
          kind: entryBody.kind,
          version: entryBody.apiVersion
        },
        inclusionPromise: promise,
        inclusionProof: proof,
        canonicalizedBody: Buffer.from(entry.body, "base64")
      };
      return {
        tlogEntries: [tlogEntry]
      };
    }
    function inclusionPromise(promise) {
      return {
        signedEntryTimestamp: Buffer.from(promise, "base64")
      };
    }
    function inclusionProof(proof) {
      return {
        logIndex: proof.logIndex.toString(),
        treeSize: proof.treeSize.toString(),
        rootHash: Buffer.from(proof.rootHash, "hex"),
        hashes: proof.hashes.map((h) => Buffer.from(h, "hex")),
        checkpoint: {
          envelope: proof.checkpoint
        }
      };
    }
  }
});

// node_modules/@sigstore/sign/dist/external/tsa.js
var require_tsa = __commonJS({
  "node_modules/@sigstore/sign/dist/external/tsa.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimestampAuthority = void 0;
    var fetch_1 = require_fetch2();
    var TimestampAuthority = class {
      constructor(options) {
        this.options = options;
      }
      async createTimestamp(request) {
        const { baseURL, timeout, retry } = this.options;
        const url = `${baseURL}/api/v1/timestamp`;
        const response = await (0, fetch_1.fetchWithRetry)(url, {
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(request),
          timeout,
          retry
        });
        return response.buffer();
      }
    };
    exports2.TimestampAuthority = TimestampAuthority;
  }
});

// node_modules/@sigstore/sign/dist/witness/tsa/client.js
var require_client2 = __commonJS({
  "node_modules/@sigstore/sign/dist/witness/tsa/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TSAClient = void 0;
    var error_1 = require_error5();
    var tsa_1 = require_tsa();
    var util_1 = require_util2();
    var SHA256_ALGORITHM = "sha256";
    var TSAClient = class {
      constructor(options) {
        this.tsa = new tsa_1.TimestampAuthority({
          baseURL: options.tsaBaseURL,
          retry: options.retry,
          timeout: options.timeout
        });
      }
      async createTimestamp(signature) {
        const request = {
          artifactHash: util_1.crypto.digest(SHA256_ALGORITHM, signature).toString("base64"),
          hashAlgorithm: SHA256_ALGORITHM
        };
        try {
          return await this.tsa.createTimestamp(request);
        } catch (err) {
          (0, error_1.internalError)(err, "TSA_CREATE_TIMESTAMP_ERROR", "error creating timestamp");
        }
      }
    };
    exports2.TSAClient = TSAClient;
  }
});

// node_modules/@sigstore/sign/dist/witness/tsa/index.js
var require_tsa2 = __commonJS({
  "node_modules/@sigstore/sign/dist/witness/tsa/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TSAWitness = void 0;
    var client_1 = require_client2();
    var TSAWitness = class {
      constructor(options) {
        this.tsa = new client_1.TSAClient({
          tsaBaseURL: options.tsaBaseURL,
          retry: options.retry,
          timeout: options.timeout
        });
      }
      async testify(content) {
        const signature = extractSignature(content);
        const timestamp = await this.tsa.createTimestamp(signature);
        return {
          rfc3161Timestamps: [{ signedTimestamp: timestamp }]
        };
      }
    };
    exports2.TSAWitness = TSAWitness;
    function extractSignature(content) {
      switch (content.$case) {
        case "dsseEnvelope":
          return content.dsseEnvelope.signatures[0].sig;
        case "messageSignature":
          return content.messageSignature.signature;
      }
    }
  }
});

// node_modules/@sigstore/sign/dist/witness/index.js
var require_witness = __commonJS({
  "node_modules/@sigstore/sign/dist/witness/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TSAWitness = exports2.RekorWitness = exports2.DEFAULT_REKOR_URL = void 0;
    var tlog_1 = require_tlog();
    Object.defineProperty(exports2, "DEFAULT_REKOR_URL", { enumerable: true, get: function() {
      return tlog_1.DEFAULT_REKOR_URL;
    } });
    Object.defineProperty(exports2, "RekorWitness", { enumerable: true, get: function() {
      return tlog_1.RekorWitness;
    } });
    var tsa_1 = require_tsa2();
    Object.defineProperty(exports2, "TSAWitness", { enumerable: true, get: function() {
      return tsa_1.TSAWitness;
    } });
  }
});

// node_modules/@sigstore/sign/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/@sigstore/sign/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TSAWitness = exports2.RekorWitness = exports2.DEFAULT_REKOR_URL = exports2.FulcioSigner = exports2.DEFAULT_FULCIO_URL = exports2.CIContextProvider = exports2.InternalError = exports2.MessageSignatureBundleBuilder = exports2.DSSEBundleBuilder = void 0;
    var bundler_1 = require_bundler();
    Object.defineProperty(exports2, "DSSEBundleBuilder", { enumerable: true, get: function() {
      return bundler_1.DSSEBundleBuilder;
    } });
    Object.defineProperty(exports2, "MessageSignatureBundleBuilder", { enumerable: true, get: function() {
      return bundler_1.MessageSignatureBundleBuilder;
    } });
    var error_1 = require_error5();
    Object.defineProperty(exports2, "InternalError", { enumerable: true, get: function() {
      return error_1.InternalError;
    } });
    var identity_1 = require_identity();
    Object.defineProperty(exports2, "CIContextProvider", { enumerable: true, get: function() {
      return identity_1.CIContextProvider;
    } });
    var signer_1 = require_signer();
    Object.defineProperty(exports2, "DEFAULT_FULCIO_URL", { enumerable: true, get: function() {
      return signer_1.DEFAULT_FULCIO_URL;
    } });
    Object.defineProperty(exports2, "FulcioSigner", { enumerable: true, get: function() {
      return signer_1.FulcioSigner;
    } });
    var witness_1 = require_witness();
    Object.defineProperty(exports2, "DEFAULT_REKOR_URL", { enumerable: true, get: function() {
      return witness_1.DEFAULT_REKOR_URL;
    } });
    Object.defineProperty(exports2, "RekorWitness", { enumerable: true, get: function() {
      return witness_1.RekorWitness;
    } });
    Object.defineProperty(exports2, "TSAWitness", { enumerable: true, get: function() {
      return witness_1.TSAWitness;
    } });
  }
});

// node_modules/@sigstore/tuf/dist/appdata.js
var require_appdata = __commonJS({
  "node_modules/@sigstore/tuf/dist/appdata.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.appDataPath = appDataPath;
    var os_1 = __importDefault(require("os"));
    var path_1 = __importDefault(require("path"));
    function appDataPath(name) {
      const homedir = os_1.default.homedir();
      switch (process.platform) {
        /* istanbul ignore next */
        case "darwin": {
          const appSupport = path_1.default.join(homedir, "Library", "Application Support");
          return path_1.default.join(appSupport, name);
        }
        /* istanbul ignore next */
        case "win32": {
          const localAppData = process.env.LOCALAPPDATA || path_1.default.join(homedir, "AppData", "Local");
          return path_1.default.join(localAppData, name, "Data");
        }
        /* istanbul ignore next */
        default: {
          const localData = process.env.XDG_DATA_HOME || path_1.default.join(homedir, ".local", "share");
          return path_1.default.join(localData, name);
        }
      }
    }
  }
});

// node_modules/@tufjs/models/dist/error.js
var require_error6 = __commonJS({
  "node_modules/@tufjs/models/dist/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnsupportedAlgorithmError = exports2.CryptoError = exports2.LengthOrHashMismatchError = exports2.UnsignedMetadataError = exports2.RepositoryError = exports2.ValueError = void 0;
    var ValueError = class extends Error {
    };
    exports2.ValueError = ValueError;
    var RepositoryError = class extends Error {
    };
    exports2.RepositoryError = RepositoryError;
    var UnsignedMetadataError = class extends RepositoryError {
    };
    exports2.UnsignedMetadataError = UnsignedMetadataError;
    var LengthOrHashMismatchError = class extends RepositoryError {
    };
    exports2.LengthOrHashMismatchError = LengthOrHashMismatchError;
    var CryptoError = class extends Error {
    };
    exports2.CryptoError = CryptoError;
    var UnsupportedAlgorithmError = class extends CryptoError {
    };
    exports2.UnsupportedAlgorithmError = UnsupportedAlgorithmError;
  }
});

// node_modules/@tufjs/models/dist/utils/guard.js
var require_guard = __commonJS({
  "node_modules/@tufjs/models/dist/utils/guard.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDefined = isDefined;
    exports2.isObject = isObject;
    exports2.isStringArray = isStringArray;
    exports2.isObjectArray = isObjectArray;
    exports2.isStringRecord = isStringRecord;
    exports2.isObjectRecord = isObjectRecord;
    function isDefined(val) {
      return val !== void 0;
    }
    function isObject(value) {
      return typeof value === "object" && value !== null;
    }
    function isStringArray(value) {
      return Array.isArray(value) && value.every((v) => typeof v === "string");
    }
    function isObjectArray(value) {
      return Array.isArray(value) && value.every(isObject);
    }
    function isStringRecord(value) {
      return typeof value === "object" && value !== null && Object.keys(value).every((k) => typeof k === "string") && Object.values(value).every((v) => typeof v === "string");
    }
    function isObjectRecord(value) {
      return typeof value === "object" && value !== null && Object.keys(value).every((k) => typeof k === "string") && Object.values(value).every((v) => typeof v === "object" && v !== null);
    }
  }
});

// node_modules/@tufjs/canonical-json/lib/index.js
var require_lib32 = __commonJS({
  "node_modules/@tufjs/canonical-json/lib/index.js"(exports2, module2) {
    var COMMA = ",";
    var COLON = ":";
    var LEFT_SQUARE_BRACKET = "[";
    var RIGHT_SQUARE_BRACKET = "]";
    var LEFT_CURLY_BRACKET = "{";
    var RIGHT_CURLY_BRACKET = "}";
    function canonicalize(object) {
      const buffer = [];
      if (typeof object === "string") {
        buffer.push(canonicalizeString(object));
      } else if (typeof object === "boolean") {
        buffer.push(JSON.stringify(object));
      } else if (Number.isInteger(object)) {
        buffer.push(JSON.stringify(object));
      } else if (object === null) {
        buffer.push(JSON.stringify(object));
      } else if (Array.isArray(object)) {
        buffer.push(LEFT_SQUARE_BRACKET);
        let first = true;
        object.forEach((element) => {
          if (!first) {
            buffer.push(COMMA);
          }
          first = false;
          buffer.push(canonicalize(element));
        });
        buffer.push(RIGHT_SQUARE_BRACKET);
      } else if (typeof object === "object") {
        buffer.push(LEFT_CURLY_BRACKET);
        let first = true;
        Object.keys(object).sort().forEach((property) => {
          if (!first) {
            buffer.push(COMMA);
          }
          first = false;
          buffer.push(canonicalizeString(property));
          buffer.push(COLON);
          buffer.push(canonicalize(object[property]));
        });
        buffer.push(RIGHT_CURLY_BRACKET);
      } else {
        throw new TypeError("cannot encode " + object.toString());
      }
      return buffer.join("");
    }
    function canonicalizeString(string) {
      const escapedString = string.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      return '"' + escapedString + '"';
    }
    module2.exports = {
      canonicalize
    };
  }
});

// node_modules/@tufjs/models/dist/utils/verify.js
var require_verify2 = __commonJS({
  "node_modules/@tufjs/models/dist/utils/verify.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifySignature = void 0;
    var canonical_json_1 = require_lib32();
    var crypto_1 = __importDefault(require("crypto"));
    var verifySignature = (metaDataSignedData, key, signature) => {
      const canonicalData = Buffer.from((0, canonical_json_1.canonicalize)(metaDataSignedData));
      return crypto_1.default.verify(void 0, canonicalData, key, Buffer.from(signature, "hex"));
    };
    exports2.verifySignature = verifySignature;
  }
});

// node_modules/@tufjs/models/dist/utils/index.js
var require_utils4 = __commonJS({
  "node_modules/@tufjs/models/dist/utils/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = exports2.guard = void 0;
    exports2.guard = __importStar(require_guard());
    exports2.crypto = __importStar(require_verify2());
  }
});

// node_modules/@tufjs/models/dist/base.js
var require_base2 = __commonJS({
  "node_modules/@tufjs/models/dist/base.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Signed = exports2.MetadataKind = void 0;
    exports2.isMetadataKind = isMetadataKind;
    var util_1 = __importDefault(require("util"));
    var error_1 = require_error6();
    var utils_1 = require_utils4();
    var SPECIFICATION_VERSION = ["1", "0", "31"];
    var MetadataKind;
    (function(MetadataKind2) {
      MetadataKind2["Root"] = "root";
      MetadataKind2["Timestamp"] = "timestamp";
      MetadataKind2["Snapshot"] = "snapshot";
      MetadataKind2["Targets"] = "targets";
    })(MetadataKind || (exports2.MetadataKind = MetadataKind = {}));
    function isMetadataKind(value) {
      return typeof value === "string" && Object.values(MetadataKind).includes(value);
    }
    var Signed = class _Signed {
      constructor(options) {
        this.specVersion = options.specVersion || SPECIFICATION_VERSION.join(".");
        const specList = this.specVersion.split(".");
        if (!(specList.length === 2 || specList.length === 3) || !specList.every((item) => isNumeric(item))) {
          throw new error_1.ValueError("Failed to parse specVersion");
        }
        if (specList[0] != SPECIFICATION_VERSION[0]) {
          throw new error_1.ValueError("Unsupported specVersion");
        }
        this.expires = options.expires;
        this.version = options.version;
        this.unrecognizedFields = options.unrecognizedFields || {};
      }
      equals(other) {
        if (!(other instanceof _Signed)) {
          return false;
        }
        return this.specVersion === other.specVersion && this.expires === other.expires && this.version === other.version && util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields);
      }
      isExpired(referenceTime) {
        if (!referenceTime) {
          referenceTime = /* @__PURE__ */ new Date();
        }
        return referenceTime >= new Date(this.expires);
      }
      static commonFieldsFromJSON(data) {
        const { spec_version, expires, version, ...rest } = data;
        if (!utils_1.guard.isDefined(spec_version)) {
          throw new error_1.ValueError("spec_version is not defined");
        } else if (typeof spec_version !== "string") {
          throw new TypeError("spec_version must be a string");
        }
        if (!utils_1.guard.isDefined(expires)) {
          throw new error_1.ValueError("expires is not defined");
        } else if (!(typeof expires === "string")) {
          throw new TypeError("expires must be a string");
        }
        if (!utils_1.guard.isDefined(version)) {
          throw new error_1.ValueError("version is not defined");
        } else if (!(typeof version === "number")) {
          throw new TypeError("version must be a number");
        }
        return {
          specVersion: spec_version,
          expires,
          version,
          unrecognizedFields: rest
        };
      }
    };
    exports2.Signed = Signed;
    function isNumeric(str) {
      return !isNaN(Number(str));
    }
  }
});

// node_modules/@tufjs/models/dist/file.js
var require_file2 = __commonJS({
  "node_modules/@tufjs/models/dist/file.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TargetFile = exports2.MetaFile = void 0;
    var crypto_1 = __importDefault(require("crypto"));
    var util_1 = __importDefault(require("util"));
    var error_1 = require_error6();
    var utils_1 = require_utils4();
    var MetaFile = class _MetaFile {
      constructor(opts) {
        if (opts.version <= 0) {
          throw new error_1.ValueError("Metafile version must be at least 1");
        }
        if (opts.length !== void 0) {
          validateLength(opts.length);
        }
        this.version = opts.version;
        this.length = opts.length;
        this.hashes = opts.hashes;
        this.unrecognizedFields = opts.unrecognizedFields || {};
      }
      equals(other) {
        if (!(other instanceof _MetaFile)) {
          return false;
        }
        return this.version === other.version && this.length === other.length && util_1.default.isDeepStrictEqual(this.hashes, other.hashes) && util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields);
      }
      verify(data) {
        if (this.length !== void 0) {
          if (data.length !== this.length) {
            throw new error_1.LengthOrHashMismatchError(`Expected length ${this.length} but got ${data.length}`);
          }
        }
        if (this.hashes) {
          Object.entries(this.hashes).forEach(([key, value]) => {
            let hash;
            try {
              hash = crypto_1.default.createHash(key);
            } catch (e) {
              throw new error_1.LengthOrHashMismatchError(`Hash algorithm ${key} not supported`);
            }
            const observedHash = hash.update(data).digest("hex");
            if (observedHash !== value) {
              throw new error_1.LengthOrHashMismatchError(`Expected hash ${value} but got ${observedHash}`);
            }
          });
        }
      }
      toJSON() {
        const json = {
          version: this.version,
          ...this.unrecognizedFields
        };
        if (this.length !== void 0) {
          json.length = this.length;
        }
        if (this.hashes) {
          json.hashes = this.hashes;
        }
        return json;
      }
      static fromJSON(data) {
        const { version, length, hashes, ...rest } = data;
        if (typeof version !== "number") {
          throw new TypeError("version must be a number");
        }
        if (utils_1.guard.isDefined(length) && typeof length !== "number") {
          throw new TypeError("length must be a number");
        }
        if (utils_1.guard.isDefined(hashes) && !utils_1.guard.isStringRecord(hashes)) {
          throw new TypeError("hashes must be string keys and values");
        }
        return new _MetaFile({
          version,
          length,
          hashes,
          unrecognizedFields: rest
        });
      }
    };
    exports2.MetaFile = MetaFile;
    var TargetFile = class _TargetFile {
      constructor(opts) {
        validateLength(opts.length);
        this.length = opts.length;
        this.path = opts.path;
        this.hashes = opts.hashes;
        this.unrecognizedFields = opts.unrecognizedFields || {};
      }
      get custom() {
        const custom = this.unrecognizedFields["custom"];
        if (!custom || Array.isArray(custom) || !(typeof custom === "object")) {
          return {};
        }
        return custom;
      }
      equals(other) {
        if (!(other instanceof _TargetFile)) {
          return false;
        }
        return this.length === other.length && this.path === other.path && util_1.default.isDeepStrictEqual(this.hashes, other.hashes) && util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields);
      }
      async verify(stream) {
        let observedLength = 0;
        const digests = Object.keys(this.hashes).reduce((acc, key) => {
          try {
            acc[key] = crypto_1.default.createHash(key);
          } catch (e) {
            throw new error_1.LengthOrHashMismatchError(`Hash algorithm ${key} not supported`);
          }
          return acc;
        }, {});
        for await (const chunk of stream) {
          observedLength += chunk.length;
          Object.values(digests).forEach((digest) => {
            digest.update(chunk);
          });
        }
        if (observedLength !== this.length) {
          throw new error_1.LengthOrHashMismatchError(`Expected length ${this.length} but got ${observedLength}`);
        }
        Object.entries(digests).forEach(([key, value]) => {
          const expected = this.hashes[key];
          const actual = value.digest("hex");
          if (actual !== expected) {
            throw new error_1.LengthOrHashMismatchError(`Expected hash ${expected} but got ${actual}`);
          }
        });
      }
      toJSON() {
        return {
          length: this.length,
          hashes: this.hashes,
          ...this.unrecognizedFields
        };
      }
      static fromJSON(path, data) {
        const { length, hashes, ...rest } = data;
        if (typeof length !== "number") {
          throw new TypeError("length must be a number");
        }
        if (!utils_1.guard.isStringRecord(hashes)) {
          throw new TypeError("hashes must have string keys and values");
        }
        return new _TargetFile({
          length,
          path,
          hashes,
          unrecognizedFields: rest
        });
      }
    };
    exports2.TargetFile = TargetFile;
    function validateLength(length) {
      if (length < 0) {
        throw new error_1.ValueError("Length must be at least 0");
      }
    }
  }
});

// node_modules/@tufjs/models/dist/utils/oid.js
var require_oid2 = __commonJS({
  "node_modules/@tufjs/models/dist/utils/oid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeOIDString = encodeOIDString;
    var ANS1_TAG_OID = 6;
    function encodeOIDString(oid) {
      const parts = oid.split(".");
      const first = parseInt(parts[0], 10) * 40 + parseInt(parts[1], 10);
      const rest = [];
      parts.slice(2).forEach((part) => {
        const bytes = encodeVariableLengthInteger(parseInt(part, 10));
        rest.push(...bytes);
      });
      const der = Buffer.from([first, ...rest]);
      return Buffer.from([ANS1_TAG_OID, der.length, ...der]);
    }
    function encodeVariableLengthInteger(value) {
      const bytes = [];
      let mask = 0;
      while (value > 0) {
        bytes.unshift(value & 127 | mask);
        value >>= 7;
        mask = 128;
      }
      return bytes;
    }
  }
});

// node_modules/@tufjs/models/dist/utils/key.js
var require_key2 = __commonJS({
  "node_modules/@tufjs/models/dist/utils/key.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getPublicKey = getPublicKey;
    var crypto_1 = __importDefault(require("crypto"));
    var error_1 = require_error6();
    var oid_1 = require_oid2();
    var ASN1_TAG_SEQUENCE = 48;
    var ANS1_TAG_BIT_STRING = 3;
    var NULL_BYTE = 0;
    var OID_EDDSA = "1.3.101.112";
    var OID_EC_PUBLIC_KEY = "1.2.840.10045.2.1";
    var OID_EC_CURVE_P256V1 = "1.2.840.10045.3.1.7";
    var PEM_HEADER = "-----BEGIN PUBLIC KEY-----";
    function getPublicKey(keyInfo) {
      switch (keyInfo.keyType) {
        case "rsa":
          return getRSAPublicKey(keyInfo);
        case "ed25519":
          return getED25519PublicKey(keyInfo);
        case "ecdsa":
        case "ecdsa-sha2-nistp256":
        case "ecdsa-sha2-nistp384":
          return getECDCSAPublicKey(keyInfo);
        default:
          throw new error_1.UnsupportedAlgorithmError(`Unsupported key type: ${keyInfo.keyType}`);
      }
    }
    function getRSAPublicKey(keyInfo) {
      if (!keyInfo.keyVal.startsWith(PEM_HEADER)) {
        throw new error_1.CryptoError("Invalid key format");
      }
      const key = crypto_1.default.createPublicKey(keyInfo.keyVal);
      switch (keyInfo.scheme) {
        case "rsassa-pss-sha256":
          return {
            key,
            padding: crypto_1.default.constants.RSA_PKCS1_PSS_PADDING
          };
        default:
          throw new error_1.UnsupportedAlgorithmError(`Unsupported RSA scheme: ${keyInfo.scheme}`);
      }
    }
    function getED25519PublicKey(keyInfo) {
      let key;
      if (keyInfo.keyVal.startsWith(PEM_HEADER)) {
        key = crypto_1.default.createPublicKey(keyInfo.keyVal);
      } else {
        if (!isHex(keyInfo.keyVal)) {
          throw new error_1.CryptoError("Invalid key format");
        }
        key = crypto_1.default.createPublicKey({
          key: ed25519.hexToDER(keyInfo.keyVal),
          format: "der",
          type: "spki"
        });
      }
      return { key };
    }
    function getECDCSAPublicKey(keyInfo) {
      let key;
      if (keyInfo.keyVal.startsWith(PEM_HEADER)) {
        key = crypto_1.default.createPublicKey(keyInfo.keyVal);
      } else {
        if (!isHex(keyInfo.keyVal)) {
          throw new error_1.CryptoError("Invalid key format");
        }
        key = crypto_1.default.createPublicKey({
          key: ecdsa.hexToDER(keyInfo.keyVal),
          format: "der",
          type: "spki"
        });
      }
      return { key };
    }
    var ed25519 = {
      // Translates a hex key into a crypto KeyObject
      // https://keygen.sh/blog/how-to-use-hexadecimal-ed25519-keys-in-node/
      hexToDER: (hex) => {
        const key = Buffer.from(hex, "hex");
        const oid = (0, oid_1.encodeOIDString)(OID_EDDSA);
        const elements = Buffer.concat([
          Buffer.concat([
            Buffer.from([ASN1_TAG_SEQUENCE]),
            Buffer.from([oid.length]),
            oid
          ]),
          Buffer.concat([
            Buffer.from([ANS1_TAG_BIT_STRING]),
            Buffer.from([key.length + 1]),
            Buffer.from([NULL_BYTE]),
            key
          ])
        ]);
        const der = Buffer.concat([
          Buffer.from([ASN1_TAG_SEQUENCE]),
          Buffer.from([elements.length]),
          elements
        ]);
        return der;
      }
    };
    var ecdsa = {
      hexToDER: (hex) => {
        const key = Buffer.from(hex, "hex");
        const bitString = Buffer.concat([
          Buffer.from([ANS1_TAG_BIT_STRING]),
          Buffer.from([key.length + 1]),
          Buffer.from([NULL_BYTE]),
          key
        ]);
        const oids = Buffer.concat([
          (0, oid_1.encodeOIDString)(OID_EC_PUBLIC_KEY),
          (0, oid_1.encodeOIDString)(OID_EC_CURVE_P256V1)
        ]);
        const oidSequence = Buffer.concat([
          Buffer.from([ASN1_TAG_SEQUENCE]),
          Buffer.from([oids.length]),
          oids
        ]);
        const der = Buffer.concat([
          Buffer.from([ASN1_TAG_SEQUENCE]),
          Buffer.from([oidSequence.length + bitString.length]),
          oidSequence,
          bitString
        ]);
        return der;
      }
    };
    var isHex = (key) => /^[0-9a-fA-F]+$/.test(key);
  }
});

// node_modules/@tufjs/models/dist/key.js
var require_key3 = __commonJS({
  "node_modules/@tufjs/models/dist/key.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Key = void 0;
    var util_1 = __importDefault(require("util"));
    var error_1 = require_error6();
    var utils_1 = require_utils4();
    var key_1 = require_key2();
    var Key = class _Key {
      constructor(options) {
        const { keyID, keyType, scheme, keyVal, unrecognizedFields } = options;
        this.keyID = keyID;
        this.keyType = keyType;
        this.scheme = scheme;
        this.keyVal = keyVal;
        this.unrecognizedFields = unrecognizedFields || {};
      }
      // Verifies the that the metadata.signatures contains a signature made with
      // this key and is correctly signed.
      verifySignature(metadata) {
        const signature = metadata.signatures[this.keyID];
        if (!signature)
          throw new error_1.UnsignedMetadataError("no signature for key found in metadata");
        if (!this.keyVal.public)
          throw new error_1.UnsignedMetadataError("no public key found");
        const publicKey = (0, key_1.getPublicKey)({
          keyType: this.keyType,
          scheme: this.scheme,
          keyVal: this.keyVal.public
        });
        const signedData = metadata.signed.toJSON();
        try {
          if (!utils_1.crypto.verifySignature(signedData, publicKey, signature.sig)) {
            throw new error_1.UnsignedMetadataError(`failed to verify ${this.keyID} signature`);
          }
        } catch (error) {
          if (error instanceof error_1.UnsignedMetadataError) {
            throw error;
          }
          throw new error_1.UnsignedMetadataError(`failed to verify ${this.keyID} signature`);
        }
      }
      equals(other) {
        if (!(other instanceof _Key)) {
          return false;
        }
        return this.keyID === other.keyID && this.keyType === other.keyType && this.scheme === other.scheme && util_1.default.isDeepStrictEqual(this.keyVal, other.keyVal) && util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields);
      }
      toJSON() {
        return {
          keytype: this.keyType,
          scheme: this.scheme,
          keyval: this.keyVal,
          ...this.unrecognizedFields
        };
      }
      static fromJSON(keyID, data) {
        const { keytype, scheme, keyval, ...rest } = data;
        if (typeof keytype !== "string") {
          throw new TypeError("keytype must be a string");
        }
        if (typeof scheme !== "string") {
          throw new TypeError("scheme must be a string");
        }
        if (!utils_1.guard.isStringRecord(keyval)) {
          throw new TypeError("keyval must be a string record");
        }
        return new _Key({
          keyID,
          keyType: keytype,
          scheme,
          keyVal: keyval,
          unrecognizedFields: rest
        });
      }
    };
    exports2.Key = Key;
  }
});

// node_modules/@tufjs/models/dist/role.js
var require_role = __commonJS({
  "node_modules/@tufjs/models/dist/role.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SuccinctRoles = exports2.DelegatedRole = exports2.Role = exports2.TOP_LEVEL_ROLE_NAMES = void 0;
    var crypto_1 = __importDefault(require("crypto"));
    var minimatch_1 = require_commonjs();
    var util_1 = __importDefault(require("util"));
    var error_1 = require_error6();
    var utils_1 = require_utils4();
    exports2.TOP_LEVEL_ROLE_NAMES = [
      "root",
      "targets",
      "snapshot",
      "timestamp"
    ];
    var Role = class _Role {
      constructor(options) {
        const { keyIDs, threshold, unrecognizedFields } = options;
        if (hasDuplicates(keyIDs)) {
          throw new error_1.ValueError("duplicate key IDs found");
        }
        if (threshold < 1) {
          throw new error_1.ValueError("threshold must be at least 1");
        }
        this.keyIDs = keyIDs;
        this.threshold = threshold;
        this.unrecognizedFields = unrecognizedFields || {};
      }
      equals(other) {
        if (!(other instanceof _Role)) {
          return false;
        }
        return this.threshold === other.threshold && util_1.default.isDeepStrictEqual(this.keyIDs, other.keyIDs) && util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields);
      }
      toJSON() {
        return {
          keyids: this.keyIDs,
          threshold: this.threshold,
          ...this.unrecognizedFields
        };
      }
      static fromJSON(data) {
        const { keyids, threshold, ...rest } = data;
        if (!utils_1.guard.isStringArray(keyids)) {
          throw new TypeError("keyids must be an array");
        }
        if (typeof threshold !== "number") {
          throw new TypeError("threshold must be a number");
        }
        return new _Role({
          keyIDs: keyids,
          threshold,
          unrecognizedFields: rest
        });
      }
    };
    exports2.Role = Role;
    function hasDuplicates(array) {
      return new Set(array).size !== array.length;
    }
    var DelegatedRole = class _DelegatedRole extends Role {
      constructor(opts) {
        super(opts);
        const { name, terminating, paths, pathHashPrefixes } = opts;
        this.name = name;
        this.terminating = terminating;
        if (opts.paths && opts.pathHashPrefixes) {
          throw new error_1.ValueError("paths and pathHashPrefixes are mutually exclusive");
        }
        this.paths = paths;
        this.pathHashPrefixes = pathHashPrefixes;
      }
      equals(other) {
        if (!(other instanceof _DelegatedRole)) {
          return false;
        }
        return super.equals(other) && this.name === other.name && this.terminating === other.terminating && util_1.default.isDeepStrictEqual(this.paths, other.paths) && util_1.default.isDeepStrictEqual(this.pathHashPrefixes, other.pathHashPrefixes);
      }
      isDelegatedPath(targetFilepath) {
        if (this.paths) {
          return this.paths.some((pathPattern) => isTargetInPathPattern(targetFilepath, pathPattern));
        }
        if (this.pathHashPrefixes) {
          const hasher = crypto_1.default.createHash("sha256");
          const pathHash = hasher.update(targetFilepath).digest("hex");
          return this.pathHashPrefixes.some((pathHashPrefix) => pathHash.startsWith(pathHashPrefix));
        }
        return false;
      }
      toJSON() {
        const json = {
          ...super.toJSON(),
          name: this.name,
          terminating: this.terminating
        };
        if (this.paths) {
          json.paths = this.paths;
        }
        if (this.pathHashPrefixes) {
          json.path_hash_prefixes = this.pathHashPrefixes;
        }
        return json;
      }
      static fromJSON(data) {
        const { keyids, threshold, name, terminating, paths, path_hash_prefixes, ...rest } = data;
        if (!utils_1.guard.isStringArray(keyids)) {
          throw new TypeError("keyids must be an array of strings");
        }
        if (typeof threshold !== "number") {
          throw new TypeError("threshold must be a number");
        }
        if (typeof name !== "string") {
          throw new TypeError("name must be a string");
        }
        if (typeof terminating !== "boolean") {
          throw new TypeError("terminating must be a boolean");
        }
        if (utils_1.guard.isDefined(paths) && !utils_1.guard.isStringArray(paths)) {
          throw new TypeError("paths must be an array of strings");
        }
        if (utils_1.guard.isDefined(path_hash_prefixes) && !utils_1.guard.isStringArray(path_hash_prefixes)) {
          throw new TypeError("path_hash_prefixes must be an array of strings");
        }
        return new _DelegatedRole({
          keyIDs: keyids,
          threshold,
          name,
          terminating,
          paths,
          pathHashPrefixes: path_hash_prefixes,
          unrecognizedFields: rest
        });
      }
    };
    exports2.DelegatedRole = DelegatedRole;
    var zip = (a, b) => a.map((k, i) => [k, b[i]]);
    function isTargetInPathPattern(target, pattern) {
      const targetParts = target.split("/");
      const patternParts = pattern.split("/");
      if (patternParts.length != targetParts.length) {
        return false;
      }
      return zip(targetParts, patternParts).every(([targetPart, patternPart]) => (0, minimatch_1.minimatch)(targetPart, patternPart));
    }
    var SuccinctRoles = class _SuccinctRoles extends Role {
      constructor(opts) {
        super(opts);
        const { bitLength, namePrefix } = opts;
        if (bitLength <= 0 || bitLength > 32) {
          throw new error_1.ValueError("bitLength must be between 1 and 32");
        }
        this.bitLength = bitLength;
        this.namePrefix = namePrefix;
        this.numberOfBins = Math.pow(2, bitLength);
        this.suffixLen = (this.numberOfBins - 1).toString(16).length;
      }
      equals(other) {
        if (!(other instanceof _SuccinctRoles)) {
          return false;
        }
        return super.equals(other) && this.bitLength === other.bitLength && this.namePrefix === other.namePrefix;
      }
      /***
       * Calculates the name of the delegated role responsible for 'target_filepath'.
       *
       * The target at path ''target_filepath' is assigned to a bin by casting
       * the left-most 'bit_length' of bits of the file path hash digest to
       * int, using it as bin index between 0 and '2**bit_length - 1'.
       *
       * Args:
       *  target_filepath: URL path to a target file, relative to a base
       *  targets URL.
       */
      getRoleForTarget(targetFilepath) {
        const hasher = crypto_1.default.createHash("sha256");
        const hasherBuffer = hasher.update(targetFilepath).digest();
        const hashBytes = hasherBuffer.subarray(0, 4);
        const shiftValue = 32 - this.bitLength;
        const binNumber = hashBytes.readUInt32BE() >>> shiftValue;
        const suffix = binNumber.toString(16).padStart(this.suffixLen, "0");
        return `${this.namePrefix}-${suffix}`;
      }
      *getRoles() {
        for (let i = 0; i < this.numberOfBins; i++) {
          const suffix = i.toString(16).padStart(this.suffixLen, "0");
          yield `${this.namePrefix}-${suffix}`;
        }
      }
      /***
       * Determines whether the given ``role_name`` is in one of
       * the delegated roles that ``SuccinctRoles`` represents.
       *
       * Args:
       *  role_name: The name of the role to check against.
       */
      isDelegatedRole(roleName) {
        const desiredPrefix = this.namePrefix + "-";
        if (!roleName.startsWith(desiredPrefix)) {
          return false;
        }
        const suffix = roleName.slice(desiredPrefix.length, roleName.length);
        if (suffix.length != this.suffixLen) {
          return false;
        }
        if (!suffix.match(/^[0-9a-fA-F]+$/)) {
          return false;
        }
        const num = parseInt(suffix, 16);
        return 0 <= num && num < this.numberOfBins;
      }
      toJSON() {
        const json = {
          ...super.toJSON(),
          bit_length: this.bitLength,
          name_prefix: this.namePrefix
        };
        return json;
      }
      static fromJSON(data) {
        const { keyids, threshold, bit_length, name_prefix, ...rest } = data;
        if (!utils_1.guard.isStringArray(keyids)) {
          throw new TypeError("keyids must be an array of strings");
        }
        if (typeof threshold !== "number") {
          throw new TypeError("threshold must be a number");
        }
        if (typeof bit_length !== "number") {
          throw new TypeError("bit_length must be a number");
        }
        if (typeof name_prefix !== "string") {
          throw new TypeError("name_prefix must be a string");
        }
        return new _SuccinctRoles({
          keyIDs: keyids,
          threshold,
          bitLength: bit_length,
          namePrefix: name_prefix,
          unrecognizedFields: rest
        });
      }
    };
    exports2.SuccinctRoles = SuccinctRoles;
  }
});

// node_modules/@tufjs/models/dist/root.js
var require_root = __commonJS({
  "node_modules/@tufjs/models/dist/root.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Root = void 0;
    var util_1 = __importDefault(require("util"));
    var base_1 = require_base2();
    var error_1 = require_error6();
    var key_1 = require_key3();
    var role_1 = require_role();
    var utils_1 = require_utils4();
    var Root = class _Root extends base_1.Signed {
      constructor(options) {
        super(options);
        this.type = base_1.MetadataKind.Root;
        this.keys = options.keys || {};
        this.consistentSnapshot = options.consistentSnapshot ?? true;
        if (!options.roles) {
          this.roles = role_1.TOP_LEVEL_ROLE_NAMES.reduce((acc, role) => ({
            ...acc,
            [role]: new role_1.Role({ keyIDs: [], threshold: 1 })
          }), {});
        } else {
          const roleNames = new Set(Object.keys(options.roles));
          if (!role_1.TOP_LEVEL_ROLE_NAMES.every((role) => roleNames.has(role))) {
            throw new error_1.ValueError("missing top-level role");
          }
          this.roles = options.roles;
        }
      }
      addKey(key, role) {
        if (!this.roles[role]) {
          throw new error_1.ValueError(`role ${role} does not exist`);
        }
        if (!this.roles[role].keyIDs.includes(key.keyID)) {
          this.roles[role].keyIDs.push(key.keyID);
        }
        this.keys[key.keyID] = key;
      }
      equals(other) {
        if (!(other instanceof _Root)) {
          return false;
        }
        return super.equals(other) && this.consistentSnapshot === other.consistentSnapshot && util_1.default.isDeepStrictEqual(this.keys, other.keys) && util_1.default.isDeepStrictEqual(this.roles, other.roles);
      }
      toJSON() {
        return {
          _type: this.type,
          spec_version: this.specVersion,
          version: this.version,
          expires: this.expires,
          keys: keysToJSON(this.keys),
          roles: rolesToJSON(this.roles),
          consistent_snapshot: this.consistentSnapshot,
          ...this.unrecognizedFields
        };
      }
      static fromJSON(data) {
        const { unrecognizedFields, ...commonFields } = base_1.Signed.commonFieldsFromJSON(data);
        const { keys, roles, consistent_snapshot, ...rest } = unrecognizedFields;
        if (typeof consistent_snapshot !== "boolean") {
          throw new TypeError("consistent_snapshot must be a boolean");
        }
        return new _Root({
          ...commonFields,
          keys: keysFromJSON(keys),
          roles: rolesFromJSON(roles),
          consistentSnapshot: consistent_snapshot,
          unrecognizedFields: rest
        });
      }
    };
    exports2.Root = Root;
    function keysToJSON(keys) {
      return Object.entries(keys).reduce((acc, [keyID, key]) => ({ ...acc, [keyID]: key.toJSON() }), {});
    }
    function rolesToJSON(roles) {
      return Object.entries(roles).reduce((acc, [roleName, role]) => ({ ...acc, [roleName]: role.toJSON() }), {});
    }
    function keysFromJSON(data) {
      let keys;
      if (utils_1.guard.isDefined(data)) {
        if (!utils_1.guard.isObjectRecord(data)) {
          throw new TypeError("keys must be an object");
        }
        keys = Object.entries(data).reduce((acc, [keyID, keyData]) => ({
          ...acc,
          [keyID]: key_1.Key.fromJSON(keyID, keyData)
        }), {});
      }
      return keys;
    }
    function rolesFromJSON(data) {
      let roles;
      if (utils_1.guard.isDefined(data)) {
        if (!utils_1.guard.isObjectRecord(data)) {
          throw new TypeError("roles must be an object");
        }
        roles = Object.entries(data).reduce((acc, [roleName, roleData]) => ({
          ...acc,
          [roleName]: role_1.Role.fromJSON(roleData)
        }), {});
      }
      return roles;
    }
  }
});

// node_modules/@tufjs/models/dist/signature.js
var require_signature = __commonJS({
  "node_modules/@tufjs/models/dist/signature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Signature = void 0;
    var Signature = class _Signature {
      constructor(options) {
        const { keyID, sig } = options;
        this.keyID = keyID;
        this.sig = sig;
      }
      toJSON() {
        return {
          keyid: this.keyID,
          sig: this.sig
        };
      }
      static fromJSON(data) {
        const { keyid, sig } = data;
        if (typeof keyid !== "string") {
          throw new TypeError("keyid must be a string");
        }
        if (typeof sig !== "string") {
          throw new TypeError("sig must be a string");
        }
        return new _Signature({
          keyID: keyid,
          sig
        });
      }
    };
    exports2.Signature = Signature;
  }
});

// node_modules/@tufjs/models/dist/snapshot.js
var require_snapshot = __commonJS({
  "node_modules/@tufjs/models/dist/snapshot.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Snapshot = void 0;
    var util_1 = __importDefault(require("util"));
    var base_1 = require_base2();
    var file_1 = require_file2();
    var utils_1 = require_utils4();
    var Snapshot = class _Snapshot extends base_1.Signed {
      constructor(opts) {
        super(opts);
        this.type = base_1.MetadataKind.Snapshot;
        this.meta = opts.meta || { "targets.json": new file_1.MetaFile({ version: 1 }) };
      }
      equals(other) {
        if (!(other instanceof _Snapshot)) {
          return false;
        }
        return super.equals(other) && util_1.default.isDeepStrictEqual(this.meta, other.meta);
      }
      toJSON() {
        return {
          _type: this.type,
          meta: metaToJSON(this.meta),
          spec_version: this.specVersion,
          version: this.version,
          expires: this.expires,
          ...this.unrecognizedFields
        };
      }
      static fromJSON(data) {
        const { unrecognizedFields, ...commonFields } = base_1.Signed.commonFieldsFromJSON(data);
        const { meta, ...rest } = unrecognizedFields;
        return new _Snapshot({
          ...commonFields,
          meta: metaFromJSON(meta),
          unrecognizedFields: rest
        });
      }
    };
    exports2.Snapshot = Snapshot;
    function metaToJSON(meta) {
      return Object.entries(meta).reduce((acc, [path, metadata]) => ({
        ...acc,
        [path]: metadata.toJSON()
      }), {});
    }
    function metaFromJSON(data) {
      let meta;
      if (utils_1.guard.isDefined(data)) {
        if (!utils_1.guard.isObjectRecord(data)) {
          throw new TypeError("meta field is malformed");
        } else {
          meta = Object.entries(data).reduce((acc, [path, metadata]) => ({
            ...acc,
            [path]: file_1.MetaFile.fromJSON(metadata)
          }), {});
        }
      }
      return meta;
    }
  }
});

// node_modules/@tufjs/models/dist/delegations.js
var require_delegations = __commonJS({
  "node_modules/@tufjs/models/dist/delegations.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Delegations = void 0;
    var util_1 = __importDefault(require("util"));
    var error_1 = require_error6();
    var key_1 = require_key3();
    var role_1 = require_role();
    var utils_1 = require_utils4();
    var Delegations = class _Delegations {
      constructor(options) {
        this.keys = options.keys;
        this.unrecognizedFields = options.unrecognizedFields || {};
        if (options.roles) {
          if (Object.keys(options.roles).some((roleName) => role_1.TOP_LEVEL_ROLE_NAMES.includes(roleName))) {
            throw new error_1.ValueError("Delegated role name conflicts with top-level role name");
          }
        }
        this.succinctRoles = options.succinctRoles;
        this.roles = options.roles;
      }
      equals(other) {
        if (!(other instanceof _Delegations)) {
          return false;
        }
        return util_1.default.isDeepStrictEqual(this.keys, other.keys) && util_1.default.isDeepStrictEqual(this.roles, other.roles) && util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields) && util_1.default.isDeepStrictEqual(this.succinctRoles, other.succinctRoles);
      }
      *rolesForTarget(targetPath) {
        if (this.roles) {
          for (const role of Object.values(this.roles)) {
            if (role.isDelegatedPath(targetPath)) {
              yield { role: role.name, terminating: role.terminating };
            }
          }
        } else if (this.succinctRoles) {
          yield {
            role: this.succinctRoles.getRoleForTarget(targetPath),
            terminating: true
          };
        }
      }
      toJSON() {
        const json = {
          keys: keysToJSON(this.keys),
          ...this.unrecognizedFields
        };
        if (this.roles) {
          json.roles = rolesToJSON(this.roles);
        } else if (this.succinctRoles) {
          json.succinct_roles = this.succinctRoles.toJSON();
        }
        return json;
      }
      static fromJSON(data) {
        const { keys, roles, succinct_roles, ...unrecognizedFields } = data;
        let succinctRoles;
        if (utils_1.guard.isObject(succinct_roles)) {
          succinctRoles = role_1.SuccinctRoles.fromJSON(succinct_roles);
        }
        return new _Delegations({
          keys: keysFromJSON(keys),
          roles: rolesFromJSON(roles),
          unrecognizedFields,
          succinctRoles
        });
      }
    };
    exports2.Delegations = Delegations;
    function keysToJSON(keys) {
      return Object.entries(keys).reduce((acc, [keyId, key]) => ({
        ...acc,
        [keyId]: key.toJSON()
      }), {});
    }
    function rolesToJSON(roles) {
      return Object.values(roles).map((role) => role.toJSON());
    }
    function keysFromJSON(data) {
      if (!utils_1.guard.isObjectRecord(data)) {
        throw new TypeError("keys is malformed");
      }
      return Object.entries(data).reduce((acc, [keyID, keyData]) => ({
        ...acc,
        [keyID]: key_1.Key.fromJSON(keyID, keyData)
      }), {});
    }
    function rolesFromJSON(data) {
      let roleMap;
      if (utils_1.guard.isDefined(data)) {
        if (!utils_1.guard.isObjectArray(data)) {
          throw new TypeError("roles is malformed");
        }
        roleMap = data.reduce((acc, role) => {
          const delegatedRole = role_1.DelegatedRole.fromJSON(role);
          return {
            ...acc,
            [delegatedRole.name]: delegatedRole
          };
        }, {});
      }
      return roleMap;
    }
  }
});

// node_modules/@tufjs/models/dist/targets.js
var require_targets = __commonJS({
  "node_modules/@tufjs/models/dist/targets.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Targets = void 0;
    var util_1 = __importDefault(require("util"));
    var base_1 = require_base2();
    var delegations_1 = require_delegations();
    var file_1 = require_file2();
    var utils_1 = require_utils4();
    var Targets = class _Targets extends base_1.Signed {
      constructor(options) {
        super(options);
        this.type = base_1.MetadataKind.Targets;
        this.targets = options.targets || {};
        this.delegations = options.delegations;
      }
      addTarget(target) {
        this.targets[target.path] = target;
      }
      equals(other) {
        if (!(other instanceof _Targets)) {
          return false;
        }
        return super.equals(other) && util_1.default.isDeepStrictEqual(this.targets, other.targets) && util_1.default.isDeepStrictEqual(this.delegations, other.delegations);
      }
      toJSON() {
        const json = {
          _type: this.type,
          spec_version: this.specVersion,
          version: this.version,
          expires: this.expires,
          targets: targetsToJSON(this.targets),
          ...this.unrecognizedFields
        };
        if (this.delegations) {
          json.delegations = this.delegations.toJSON();
        }
        return json;
      }
      static fromJSON(data) {
        const { unrecognizedFields, ...commonFields } = base_1.Signed.commonFieldsFromJSON(data);
        const { targets, delegations, ...rest } = unrecognizedFields;
        return new _Targets({
          ...commonFields,
          targets: targetsFromJSON(targets),
          delegations: delegationsFromJSON(delegations),
          unrecognizedFields: rest
        });
      }
    };
    exports2.Targets = Targets;
    function targetsToJSON(targets) {
      return Object.entries(targets).reduce((acc, [path, target]) => ({
        ...acc,
        [path]: target.toJSON()
      }), {});
    }
    function targetsFromJSON(data) {
      let targets;
      if (utils_1.guard.isDefined(data)) {
        if (!utils_1.guard.isObjectRecord(data)) {
          throw new TypeError("targets must be an object");
        } else {
          targets = Object.entries(data).reduce((acc, [path, target]) => ({
            ...acc,
            [path]: file_1.TargetFile.fromJSON(path, target)
          }), {});
        }
      }
      return targets;
    }
    function delegationsFromJSON(data) {
      let delegations;
      if (utils_1.guard.isDefined(data)) {
        if (!utils_1.guard.isObject(data)) {
          throw new TypeError("delegations must be an object");
        } else {
          delegations = delegations_1.Delegations.fromJSON(data);
        }
      }
      return delegations;
    }
  }
});

// node_modules/@tufjs/models/dist/timestamp.js
var require_timestamp3 = __commonJS({
  "node_modules/@tufjs/models/dist/timestamp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Timestamp = void 0;
    var base_1 = require_base2();
    var file_1 = require_file2();
    var utils_1 = require_utils4();
    var Timestamp = class _Timestamp extends base_1.Signed {
      constructor(options) {
        super(options);
        this.type = base_1.MetadataKind.Timestamp;
        this.snapshotMeta = options.snapshotMeta || new file_1.MetaFile({ version: 1 });
      }
      equals(other) {
        if (!(other instanceof _Timestamp)) {
          return false;
        }
        return super.equals(other) && this.snapshotMeta.equals(other.snapshotMeta);
      }
      toJSON() {
        return {
          _type: this.type,
          spec_version: this.specVersion,
          version: this.version,
          expires: this.expires,
          meta: { "snapshot.json": this.snapshotMeta.toJSON() },
          ...this.unrecognizedFields
        };
      }
      static fromJSON(data) {
        const { unrecognizedFields, ...commonFields } = base_1.Signed.commonFieldsFromJSON(data);
        const { meta, ...rest } = unrecognizedFields;
        return new _Timestamp({
          ...commonFields,
          snapshotMeta: snapshotMetaFromJSON(meta),
          unrecognizedFields: rest
        });
      }
    };
    exports2.Timestamp = Timestamp;
    function snapshotMetaFromJSON(data) {
      let snapshotMeta;
      if (utils_1.guard.isDefined(data)) {
        const snapshotData = data["snapshot.json"];
        if (!utils_1.guard.isDefined(snapshotData) || !utils_1.guard.isObject(snapshotData)) {
          throw new TypeError("missing snapshot.json in meta");
        } else {
          snapshotMeta = file_1.MetaFile.fromJSON(snapshotData);
        }
      }
      return snapshotMeta;
    }
  }
});

// node_modules/@tufjs/models/dist/metadata.js
var require_metadata = __commonJS({
  "node_modules/@tufjs/models/dist/metadata.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Metadata = void 0;
    var canonical_json_1 = require_lib32();
    var util_1 = __importDefault(require("util"));
    var base_1 = require_base2();
    var error_1 = require_error6();
    var root_1 = require_root();
    var signature_1 = require_signature();
    var snapshot_1 = require_snapshot();
    var targets_1 = require_targets();
    var timestamp_1 = require_timestamp3();
    var utils_1 = require_utils4();
    var Metadata = class _Metadata {
      constructor(signed, signatures, unrecognizedFields) {
        this.signed = signed;
        this.signatures = signatures || {};
        this.unrecognizedFields = unrecognizedFields || {};
      }
      sign(signer, append = true) {
        const bytes = Buffer.from((0, canonical_json_1.canonicalize)(this.signed.toJSON()));
        const signature = signer(bytes);
        if (!append) {
          this.signatures = {};
        }
        this.signatures[signature.keyID] = signature;
      }
      verifyDelegate(delegatedRole, delegatedMetadata) {
        let role;
        let keys = {};
        switch (this.signed.type) {
          case base_1.MetadataKind.Root:
            keys = this.signed.keys;
            role = this.signed.roles[delegatedRole];
            break;
          case base_1.MetadataKind.Targets:
            if (!this.signed.delegations) {
              throw new error_1.ValueError(`No delegations found for ${delegatedRole}`);
            }
            keys = this.signed.delegations.keys;
            if (this.signed.delegations.roles) {
              role = this.signed.delegations.roles[delegatedRole];
            } else if (this.signed.delegations.succinctRoles) {
              if (this.signed.delegations.succinctRoles.isDelegatedRole(delegatedRole)) {
                role = this.signed.delegations.succinctRoles;
              }
            }
            break;
          default:
            throw new TypeError("invalid metadata type");
        }
        if (!role) {
          throw new error_1.ValueError(`no delegation found for ${delegatedRole}`);
        }
        const signingKeys = /* @__PURE__ */ new Set();
        role.keyIDs.forEach((keyID) => {
          const key = keys[keyID];
          if (!key) {
            return;
          }
          try {
            key.verifySignature(delegatedMetadata);
            signingKeys.add(key.keyID);
          } catch (error) {
          }
        });
        if (signingKeys.size < role.threshold) {
          throw new error_1.UnsignedMetadataError(`${delegatedRole} was signed by ${signingKeys.size}/${role.threshold} keys`);
        }
      }
      equals(other) {
        if (!(other instanceof _Metadata)) {
          return false;
        }
        return this.signed.equals(other.signed) && util_1.default.isDeepStrictEqual(this.signatures, other.signatures) && util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields);
      }
      toJSON() {
        const signatures = Object.values(this.signatures).map((signature) => {
          return signature.toJSON();
        });
        return {
          signatures,
          signed: this.signed.toJSON(),
          ...this.unrecognizedFields
        };
      }
      static fromJSON(type, data) {
        const { signed, signatures, ...rest } = data;
        if (!utils_1.guard.isDefined(signed) || !utils_1.guard.isObject(signed)) {
          throw new TypeError("signed is not defined");
        }
        if (type !== signed._type) {
          throw new error_1.ValueError(`expected '${type}', got ${signed["_type"]}`);
        }
        if (!utils_1.guard.isObjectArray(signatures)) {
          throw new TypeError("signatures is not an array");
        }
        let signedObj;
        switch (type) {
          case base_1.MetadataKind.Root:
            signedObj = root_1.Root.fromJSON(signed);
            break;
          case base_1.MetadataKind.Timestamp:
            signedObj = timestamp_1.Timestamp.fromJSON(signed);
            break;
          case base_1.MetadataKind.Snapshot:
            signedObj = snapshot_1.Snapshot.fromJSON(signed);
            break;
          case base_1.MetadataKind.Targets:
            signedObj = targets_1.Targets.fromJSON(signed);
            break;
          default:
            throw new TypeError("invalid metadata type");
        }
        const sigMap = {};
        signatures.forEach((sigData) => {
          const sig = signature_1.Signature.fromJSON(sigData);
          if (sigMap[sig.keyID]) {
            throw new error_1.ValueError(`multiple signatures found for keyid: ${sig.keyID}`);
          }
          sigMap[sig.keyID] = sig;
        });
        return new _Metadata(signedObj, sigMap, rest);
      }
    };
    exports2.Metadata = Metadata;
  }
});

// node_modules/@tufjs/models/dist/index.js
var require_dist9 = __commonJS({
  "node_modules/@tufjs/models/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Timestamp = exports2.Targets = exports2.Snapshot = exports2.Signature = exports2.Root = exports2.Metadata = exports2.Key = exports2.TargetFile = exports2.MetaFile = exports2.ValueError = exports2.MetadataKind = void 0;
    var base_1 = require_base2();
    Object.defineProperty(exports2, "MetadataKind", { enumerable: true, get: function() {
      return base_1.MetadataKind;
    } });
    var error_1 = require_error6();
    Object.defineProperty(exports2, "ValueError", { enumerable: true, get: function() {
      return error_1.ValueError;
    } });
    var file_1 = require_file2();
    Object.defineProperty(exports2, "MetaFile", { enumerable: true, get: function() {
      return file_1.MetaFile;
    } });
    Object.defineProperty(exports2, "TargetFile", { enumerable: true, get: function() {
      return file_1.TargetFile;
    } });
    var key_1 = require_key3();
    Object.defineProperty(exports2, "Key", { enumerable: true, get: function() {
      return key_1.Key;
    } });
    var metadata_1 = require_metadata();
    Object.defineProperty(exports2, "Metadata", { enumerable: true, get: function() {
      return metadata_1.Metadata;
    } });
    var root_1 = require_root();
    Object.defineProperty(exports2, "Root", { enumerable: true, get: function() {
      return root_1.Root;
    } });
    var signature_1 = require_signature();
    Object.defineProperty(exports2, "Signature", { enumerable: true, get: function() {
      return signature_1.Signature;
    } });
    var snapshot_1 = require_snapshot();
    Object.defineProperty(exports2, "Snapshot", { enumerable: true, get: function() {
      return snapshot_1.Snapshot;
    } });
    var targets_1 = require_targets();
    Object.defineProperty(exports2, "Targets", { enumerable: true, get: function() {
      return targets_1.Targets;
    } });
    var timestamp_1 = require_timestamp3();
    Object.defineProperty(exports2, "Timestamp", { enumerable: true, get: function() {
      return timestamp_1.Timestamp;
    } });
  }
});

// node_modules/tuf-js/dist/error.js
var require_error7 = __commonJS({
  "node_modules/tuf-js/dist/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DownloadHTTPError = exports2.DownloadLengthMismatchError = exports2.DownloadError = exports2.ExpiredMetadataError = exports2.EqualVersionError = exports2.BadVersionError = exports2.RepositoryError = exports2.PersistError = exports2.RuntimeError = exports2.ValueError = void 0;
    var ValueError = class extends Error {
    };
    exports2.ValueError = ValueError;
    var RuntimeError = class extends Error {
    };
    exports2.RuntimeError = RuntimeError;
    var PersistError = class extends Error {
    };
    exports2.PersistError = PersistError;
    var RepositoryError = class extends Error {
    };
    exports2.RepositoryError = RepositoryError;
    var BadVersionError = class extends RepositoryError {
    };
    exports2.BadVersionError = BadVersionError;
    var EqualVersionError = class extends BadVersionError {
    };
    exports2.EqualVersionError = EqualVersionError;
    var ExpiredMetadataError = class extends RepositoryError {
    };
    exports2.ExpiredMetadataError = ExpiredMetadataError;
    var DownloadError = class extends Error {
    };
    exports2.DownloadError = DownloadError;
    var DownloadLengthMismatchError = class extends DownloadError {
    };
    exports2.DownloadLengthMismatchError = DownloadLengthMismatchError;
    var DownloadHTTPError = class extends DownloadError {
      constructor(message, statusCode) {
        super(message);
        this.statusCode = statusCode;
      }
    };
    exports2.DownloadHTTPError = DownloadHTTPError;
  }
});

// node_modules/tuf-js/dist/utils/tmpfile.js
var require_tmpfile = __commonJS({
  "node_modules/tuf-js/dist/utils/tmpfile.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withTempFile = void 0;
    var promises_1 = __importDefault(require("fs/promises"));
    var os_1 = __importDefault(require("os"));
    var path_1 = __importDefault(require("path"));
    var withTempFile = async (handler) => withTempDir(async (dir) => handler(path_1.default.join(dir, "tempfile")));
    exports2.withTempFile = withTempFile;
    var withTempDir = async (handler) => {
      const tmpDir = await promises_1.default.realpath(os_1.default.tmpdir());
      const dir = await promises_1.default.mkdtemp(tmpDir + path_1.default.sep);
      try {
        return await handler(dir);
      } finally {
        await promises_1.default.rm(dir, { force: true, recursive: true, maxRetries: 3 });
      }
    };
  }
});

// node_modules/tuf-js/dist/fetcher.js
var require_fetcher = __commonJS({
  "node_modules/tuf-js/dist/fetcher.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultFetcher = exports2.BaseFetcher = void 0;
    var debug_1 = __importDefault(require_src());
    var fs_1 = __importDefault(require("fs"));
    var make_fetch_happen_1 = __importDefault(require_lib30());
    var util_1 = __importDefault(require("util"));
    var error_1 = require_error7();
    var tmpfile_1 = require_tmpfile();
    var log = (0, debug_1.default)("tuf:fetch");
    var BaseFetcher = class {
      // Download file from given URL. The file is downloaded to a temporary
      // location and then passed to the given handler. The handler is responsible
      // for moving the file to its final location. The temporary file is deleted
      // after the handler returns.
      async downloadFile(url, maxLength, handler) {
        return (0, tmpfile_1.withTempFile)(async (tmpFile) => {
          const reader = await this.fetch(url);
          let numberOfBytesReceived = 0;
          const fileStream = fs_1.default.createWriteStream(tmpFile);
          try {
            for await (const chunk of reader) {
              const bufferChunk = Buffer.from(chunk);
              numberOfBytesReceived += bufferChunk.length;
              if (numberOfBytesReceived > maxLength) {
                throw new error_1.DownloadLengthMismatchError("Max length reached");
              }
              await writeBufferToStream(fileStream, bufferChunk);
            }
          } finally {
            await util_1.default.promisify(fileStream.close).bind(fileStream)();
          }
          return handler(tmpFile);
        });
      }
      // Download bytes from given URL.
      async downloadBytes(url, maxLength) {
        return this.downloadFile(url, maxLength, async (file) => {
          const stream = fs_1.default.createReadStream(file);
          const chunks = [];
          for await (const chunk of stream) {
            chunks.push(chunk);
          }
          return Buffer.concat(chunks);
        });
      }
    };
    exports2.BaseFetcher = BaseFetcher;
    var DefaultFetcher = class extends BaseFetcher {
      constructor(options = {}) {
        super();
        this.timeout = options.timeout;
        this.retry = options.retry;
      }
      async fetch(url) {
        log("GET %s", url);
        const response = await (0, make_fetch_happen_1.default)(url, {
          timeout: this.timeout,
          retry: this.retry
        });
        if (!response.ok || !response?.body) {
          throw new error_1.DownloadHTTPError("Failed to download", response.status);
        }
        return response.body;
      }
    };
    exports2.DefaultFetcher = DefaultFetcher;
    var writeBufferToStream = async (stream, buffer) => {
      return new Promise((resolve, reject) => {
        stream.write(buffer, (err) => {
          if (err) {
            reject(err);
          }
          resolve(true);
        });
      });
    };
  }
});

// node_modules/tuf-js/dist/config.js
var require_config = __commonJS({
  "node_modules/tuf-js/dist/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultConfig = void 0;
    exports2.defaultConfig = {
      maxRootRotations: 256,
      maxDelegations: 32,
      rootMaxLength: 512e3,
      //bytes
      timestampMaxLength: 16384,
      // bytes
      snapshotMaxLength: 2e6,
      // bytes
      targetsMaxLength: 5e6,
      // bytes
      prefixTargetsWithHash: true,
      fetchTimeout: 1e5,
      // milliseconds
      fetchRetries: void 0,
      fetchRetry: 2
    };
  }
});

// node_modules/tuf-js/dist/store.js
var require_store = __commonJS({
  "node_modules/tuf-js/dist/store.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TrustedMetadataStore = void 0;
    var models_1 = require_dist9();
    var error_1 = require_error7();
    var TrustedMetadataStore = class {
      constructor(rootData) {
        this.trustedSet = {};
        this.referenceTime = /* @__PURE__ */ new Date();
        this.loadTrustedRoot(rootData);
      }
      get root() {
        if (!this.trustedSet.root) {
          throw new ReferenceError("No trusted root metadata");
        }
        return this.trustedSet.root;
      }
      get timestamp() {
        return this.trustedSet.timestamp;
      }
      get snapshot() {
        return this.trustedSet.snapshot;
      }
      get targets() {
        return this.trustedSet.targets;
      }
      getRole(name) {
        return this.trustedSet[name];
      }
      updateRoot(bytesBuffer) {
        const data = JSON.parse(bytesBuffer.toString("utf8"));
        const newRoot = models_1.Metadata.fromJSON(models_1.MetadataKind.Root, data);
        if (newRoot.signed.type != models_1.MetadataKind.Root) {
          throw new error_1.RepositoryError(`Expected 'root', got ${newRoot.signed.type}`);
        }
        this.root.verifyDelegate(models_1.MetadataKind.Root, newRoot);
        if (newRoot.signed.version != this.root.signed.version + 1) {
          throw new error_1.BadVersionError(`Expected version ${this.root.signed.version + 1}, got ${newRoot.signed.version}`);
        }
        newRoot.verifyDelegate(models_1.MetadataKind.Root, newRoot);
        this.trustedSet.root = newRoot;
        return newRoot;
      }
      updateTimestamp(bytesBuffer) {
        if (this.snapshot) {
          throw new error_1.RuntimeError("Cannot update timestamp after snapshot");
        }
        if (this.root.signed.isExpired(this.referenceTime)) {
          throw new error_1.ExpiredMetadataError("Final root.json is expired");
        }
        const data = JSON.parse(bytesBuffer.toString("utf8"));
        const newTimestamp = models_1.Metadata.fromJSON(models_1.MetadataKind.Timestamp, data);
        if (newTimestamp.signed.type != models_1.MetadataKind.Timestamp) {
          throw new error_1.RepositoryError(`Expected 'timestamp', got ${newTimestamp.signed.type}`);
        }
        this.root.verifyDelegate(models_1.MetadataKind.Timestamp, newTimestamp);
        if (this.timestamp) {
          if (newTimestamp.signed.version < this.timestamp.signed.version) {
            throw new error_1.BadVersionError(`New timestamp version ${newTimestamp.signed.version} is less than current version ${this.timestamp.signed.version}`);
          }
          if (newTimestamp.signed.version === this.timestamp.signed.version) {
            throw new error_1.EqualVersionError(`New timestamp version ${newTimestamp.signed.version} is equal to current version ${this.timestamp.signed.version}`);
          }
          const snapshotMeta = this.timestamp.signed.snapshotMeta;
          const newSnapshotMeta = newTimestamp.signed.snapshotMeta;
          if (newSnapshotMeta.version < snapshotMeta.version) {
            throw new error_1.BadVersionError(`New snapshot version ${newSnapshotMeta.version} is less than current version ${snapshotMeta.version}`);
          }
        }
        this.trustedSet.timestamp = newTimestamp;
        this.checkFinalTimestamp();
        return newTimestamp;
      }
      updateSnapshot(bytesBuffer, trusted = false) {
        if (!this.timestamp) {
          throw new error_1.RuntimeError("Cannot update snapshot before timestamp");
        }
        if (this.targets) {
          throw new error_1.RuntimeError("Cannot update snapshot after targets");
        }
        this.checkFinalTimestamp();
        const snapshotMeta = this.timestamp.signed.snapshotMeta;
        if (!trusted) {
          snapshotMeta.verify(bytesBuffer);
        }
        const data = JSON.parse(bytesBuffer.toString("utf8"));
        const newSnapshot = models_1.Metadata.fromJSON(models_1.MetadataKind.Snapshot, data);
        if (newSnapshot.signed.type != models_1.MetadataKind.Snapshot) {
          throw new error_1.RepositoryError(`Expected 'snapshot', got ${newSnapshot.signed.type}`);
        }
        this.root.verifyDelegate(models_1.MetadataKind.Snapshot, newSnapshot);
        if (this.snapshot) {
          Object.entries(this.snapshot.signed.meta).forEach(([fileName, fileInfo]) => {
            const newFileInfo = newSnapshot.signed.meta[fileName];
            if (!newFileInfo) {
              throw new error_1.RepositoryError(`Missing file ${fileName} in new snapshot`);
            }
            if (newFileInfo.version < fileInfo.version) {
              throw new error_1.BadVersionError(`New version ${newFileInfo.version} of ${fileName} is less than current version ${fileInfo.version}`);
            }
          });
        }
        this.trustedSet.snapshot = newSnapshot;
        this.checkFinalSnapsnot();
        return newSnapshot;
      }
      updateDelegatedTargets(bytesBuffer, roleName, delegatorName) {
        if (!this.snapshot) {
          throw new error_1.RuntimeError("Cannot update delegated targets before snapshot");
        }
        this.checkFinalSnapsnot();
        const delegator = this.trustedSet[delegatorName];
        if (!delegator) {
          throw new error_1.RuntimeError(`No trusted ${delegatorName} metadata`);
        }
        const meta = this.snapshot.signed.meta?.[`${roleName}.json`];
        if (!meta) {
          throw new error_1.RepositoryError(`Missing ${roleName}.json in snapshot`);
        }
        meta.verify(bytesBuffer);
        const data = JSON.parse(bytesBuffer.toString("utf8"));
        const newDelegate = models_1.Metadata.fromJSON(models_1.MetadataKind.Targets, data);
        if (newDelegate.signed.type != models_1.MetadataKind.Targets) {
          throw new error_1.RepositoryError(`Expected 'targets', got ${newDelegate.signed.type}`);
        }
        delegator.verifyDelegate(roleName, newDelegate);
        const version = newDelegate.signed.version;
        if (version != meta.version) {
          throw new error_1.BadVersionError(`Version ${version} of ${roleName} does not match snapshot version ${meta.version}`);
        }
        if (newDelegate.signed.isExpired(this.referenceTime)) {
          throw new error_1.ExpiredMetadataError(`${roleName}.json is expired`);
        }
        this.trustedSet[roleName] = newDelegate;
      }
      // Verifies and loads data as trusted root metadata.
      // Note that an expired initial root is still considered valid.
      loadTrustedRoot(bytesBuffer) {
        const data = JSON.parse(bytesBuffer.toString("utf8"));
        const root = models_1.Metadata.fromJSON(models_1.MetadataKind.Root, data);
        if (root.signed.type != models_1.MetadataKind.Root) {
          throw new error_1.RepositoryError(`Expected 'root', got ${root.signed.type}`);
        }
        root.verifyDelegate(models_1.MetadataKind.Root, root);
        this.trustedSet["root"] = root;
      }
      checkFinalTimestamp() {
        if (!this.timestamp) {
          throw new ReferenceError("No trusted timestamp metadata");
        }
        if (this.timestamp.signed.isExpired(this.referenceTime)) {
          throw new error_1.ExpiredMetadataError("Final timestamp.json is expired");
        }
      }
      checkFinalSnapsnot() {
        if (!this.snapshot) {
          throw new ReferenceError("No trusted snapshot metadata");
        }
        if (!this.timestamp) {
          throw new ReferenceError("No trusted timestamp metadata");
        }
        if (this.snapshot.signed.isExpired(this.referenceTime)) {
          throw new error_1.ExpiredMetadataError("snapshot.json is expired");
        }
        const snapshotMeta = this.timestamp.signed.snapshotMeta;
        if (this.snapshot.signed.version !== snapshotMeta.version) {
          throw new error_1.BadVersionError("Snapshot version doesn't match timestamp");
        }
      }
    };
    exports2.TrustedMetadataStore = TrustedMetadataStore;
  }
});

// node_modules/tuf-js/dist/utils/url.js
var require_url = __commonJS({
  "node_modules/tuf-js/dist/utils/url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.join = join;
    var url_1 = require("url");
    function join(base, path) {
      return new url_1.URL(ensureTrailingSlash(base) + removeLeadingSlash(path)).toString();
    }
    function ensureTrailingSlash(path) {
      return path.endsWith("/") ? path : path + "/";
    }
    function removeLeadingSlash(path) {
      return path.startsWith("/") ? path.slice(1) : path;
    }
  }
});

// node_modules/tuf-js/dist/updater.js
var require_updater = __commonJS({
  "node_modules/tuf-js/dist/updater.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Updater = void 0;
    var models_1 = require_dist9();
    var debug_1 = __importDefault(require_src());
    var fs2 = __importStar(require("fs"));
    var path = __importStar(require("path"));
    var config_1 = require_config();
    var error_1 = require_error7();
    var fetcher_1 = require_fetcher();
    var store_1 = require_store();
    var url = __importStar(require_url());
    var log = (0, debug_1.default)("tuf:cache");
    var Updater = class {
      constructor(options) {
        const { metadataDir, metadataBaseUrl, targetDir, targetBaseUrl, fetcher, config } = options;
        this.dir = metadataDir;
        this.metadataBaseUrl = metadataBaseUrl;
        this.targetDir = targetDir;
        this.targetBaseUrl = targetBaseUrl;
        this.forceCache = options.forceCache ?? false;
        const data = this.loadLocalMetadata(models_1.MetadataKind.Root);
        this.trustedSet = new store_1.TrustedMetadataStore(data);
        this.config = { ...config_1.defaultConfig, ...config };
        this.fetcher = fetcher || new fetcher_1.DefaultFetcher({
          timeout: this.config.fetchTimeout,
          retry: this.config.fetchRetries ?? this.config.fetchRetry
        });
      }
      // refresh and load the metadata before downloading the target
      // refresh should be called once after the client is initialized
      async refresh() {
        if (this.forceCache) {
          try {
            await this.loadTimestamp({ checkRemote: false });
          } catch (error) {
            await this.loadRoot();
            await this.loadTimestamp();
          }
        } else {
          await this.loadRoot();
          await this.loadTimestamp();
        }
        await this.loadSnapshot();
        await this.loadTargets(models_1.MetadataKind.Targets, models_1.MetadataKind.Root);
      }
      // Returns the TargetFile instance with information for the given target path.
      //
      // Implicitly calls refresh if it hasn't already been called.
      async getTargetInfo(targetPath) {
        if (!this.trustedSet.targets) {
          await this.refresh();
        }
        return this.preorderDepthFirstWalk(targetPath);
      }
      async downloadTarget(targetInfo, filePath, targetBaseUrl) {
        const targetPath = filePath || this.generateTargetPath(targetInfo);
        if (!targetBaseUrl) {
          if (!this.targetBaseUrl) {
            throw new error_1.ValueError("Target base URL not set");
          }
          targetBaseUrl = this.targetBaseUrl;
        }
        let targetFilePath = targetInfo.path;
        const consistentSnapshot = this.trustedSet.root.signed.consistentSnapshot;
        if (consistentSnapshot && this.config.prefixTargetsWithHash) {
          const hashes = Object.values(targetInfo.hashes);
          const { dir, base } = path.parse(targetFilePath);
          const filename = `${hashes[0]}.${base}`;
          targetFilePath = dir ? `${dir}/${filename}` : filename;
        }
        const targetUrl = url.join(targetBaseUrl, targetFilePath);
        await this.fetcher.downloadFile(targetUrl, targetInfo.length, async (fileName) => {
          await targetInfo.verify(fs2.createReadStream(fileName));
          log("WRITE %s", targetPath);
          fs2.copyFileSync(fileName, targetPath);
        });
        return targetPath;
      }
      async findCachedTarget(targetInfo, filePath) {
        if (!filePath) {
          filePath = this.generateTargetPath(targetInfo);
        }
        try {
          if (fs2.existsSync(filePath)) {
            await targetInfo.verify(fs2.createReadStream(filePath));
            return filePath;
          }
        } catch (error) {
          return;
        }
        return;
      }
      loadLocalMetadata(fileName) {
        const filePath = path.join(this.dir, `${fileName}.json`);
        log("READ %s", filePath);
        return fs2.readFileSync(filePath);
      }
      // Sequentially load and persist on local disk every newer root metadata
      // version available on the remote.
      // Client workflow 5.3: update root role
      async loadRoot() {
        const rootVersion = this.trustedSet.root.signed.version;
        const lowerBound = rootVersion + 1;
        const upperBound = lowerBound + this.config.maxRootRotations;
        for (let version = lowerBound; version < upperBound; version++) {
          const rootUrl = url.join(this.metadataBaseUrl, `${version}.root.json`);
          try {
            const bytesData = await this.fetcher.downloadBytes(rootUrl, this.config.rootMaxLength);
            this.trustedSet.updateRoot(bytesData);
            this.persistMetadata(models_1.MetadataKind.Root, bytesData);
          } catch (error) {
            if (error instanceof error_1.DownloadHTTPError) {
              if ([403, 404].includes(error.statusCode)) {
                break;
              }
            }
            throw error;
          }
        }
      }
      // Load local and remote timestamp metadata.
      // Client workflow 5.4: update timestamp role
      async loadTimestamp({ checkRemote } = { checkRemote: true }) {
        try {
          const data = this.loadLocalMetadata(models_1.MetadataKind.Timestamp);
          this.trustedSet.updateTimestamp(data);
          if (!checkRemote) {
            return;
          }
        } catch (error) {
        }
        const timestampUrl = url.join(this.metadataBaseUrl, "timestamp.json");
        const bytesData = await this.fetcher.downloadBytes(timestampUrl, this.config.timestampMaxLength);
        try {
          this.trustedSet.updateTimestamp(bytesData);
        } catch (error) {
          if (error instanceof error_1.EqualVersionError) {
            return;
          }
          throw error;
        }
        this.persistMetadata(models_1.MetadataKind.Timestamp, bytesData);
      }
      // Load local and remote snapshot metadata.
      // Client workflow 5.5: update snapshot role
      async loadSnapshot() {
        try {
          const data = this.loadLocalMetadata(models_1.MetadataKind.Snapshot);
          this.trustedSet.updateSnapshot(data, true);
        } catch (error) {
          if (!this.trustedSet.timestamp) {
            throw new ReferenceError("No timestamp metadata");
          }
          const snapshotMeta = this.trustedSet.timestamp.signed.snapshotMeta;
          const maxLength = snapshotMeta.length || this.config.snapshotMaxLength;
          const version = this.trustedSet.root.signed.consistentSnapshot ? snapshotMeta.version : void 0;
          const snapshotUrl = url.join(this.metadataBaseUrl, version ? `${version}.snapshot.json` : "snapshot.json");
          try {
            const bytesData = await this.fetcher.downloadBytes(snapshotUrl, maxLength);
            this.trustedSet.updateSnapshot(bytesData);
            this.persistMetadata(models_1.MetadataKind.Snapshot, bytesData);
          } catch (error2) {
            throw new error_1.RuntimeError(`Unable to load snapshot metadata error ${error2}`);
          }
        }
      }
      // Load local and remote targets metadata.
      // Client workflow 5.6: update targets role
      async loadTargets(role, parentRole) {
        if (this.trustedSet.getRole(role)) {
          return this.trustedSet.getRole(role);
        }
        try {
          const buffer = this.loadLocalMetadata(role);
          this.trustedSet.updateDelegatedTargets(buffer, role, parentRole);
        } catch (error) {
          if (!this.trustedSet.snapshot) {
            throw new ReferenceError("No snapshot metadata");
          }
          const metaInfo = this.trustedSet.snapshot.signed.meta[`${role}.json`];
          const maxLength = metaInfo.length || this.config.targetsMaxLength;
          const version = this.trustedSet.root.signed.consistentSnapshot ? metaInfo.version : void 0;
          const encodedRole = encodeURIComponent(role);
          const metadataUrl = url.join(this.metadataBaseUrl, version ? `${version}.${encodedRole}.json` : `${encodedRole}.json`);
          try {
            const bytesData = await this.fetcher.downloadBytes(metadataUrl, maxLength);
            this.trustedSet.updateDelegatedTargets(bytesData, role, parentRole);
            this.persistMetadata(role, bytesData);
          } catch (error2) {
            throw new error_1.RuntimeError(`Unable to load targets error ${error2}`);
          }
        }
        return this.trustedSet.getRole(role);
      }
      async preorderDepthFirstWalk(targetPath) {
        const delegationsToVisit = [
          {
            roleName: models_1.MetadataKind.Targets,
            parentRoleName: models_1.MetadataKind.Root
          }
        ];
        const visitedRoleNames = /* @__PURE__ */ new Set();
        while (visitedRoleNames.size <= this.config.maxDelegations && delegationsToVisit.length > 0) {
          const { roleName, parentRoleName } = delegationsToVisit.pop();
          if (visitedRoleNames.has(roleName)) {
            continue;
          }
          const targets = (await this.loadTargets(roleName, parentRoleName))?.signed;
          if (!targets) {
            continue;
          }
          const target = targets.targets?.[targetPath];
          if (target) {
            return target;
          }
          visitedRoleNames.add(roleName);
          if (targets.delegations) {
            const childRolesToVisit = [];
            const rolesForTarget = targets.delegations.rolesForTarget(targetPath);
            for (const { role: childName, terminating } of rolesForTarget) {
              childRolesToVisit.push({
                roleName: childName,
                parentRoleName: roleName
              });
              if (terminating) {
                delegationsToVisit.splice(0);
                break;
              }
            }
            childRolesToVisit.reverse();
            delegationsToVisit.push(...childRolesToVisit);
          }
        }
        return;
      }
      generateTargetPath(targetInfo) {
        if (!this.targetDir) {
          throw new error_1.ValueError("Target directory not set");
        }
        const filePath = encodeURIComponent(targetInfo.path);
        return path.join(this.targetDir, filePath);
      }
      persistMetadata(metaDataName, bytesData) {
        const encodedName = encodeURIComponent(metaDataName);
        try {
          const filePath = path.join(this.dir, `${encodedName}.json`);
          log("WRITE %s", filePath);
          fs2.writeFileSync(filePath, bytesData.toString("utf8"));
        } catch (error) {
          throw new error_1.PersistError(`Failed to persist metadata ${encodedName} error: ${error}`);
        }
      }
    };
    exports2.Updater = Updater;
  }
});

// node_modules/tuf-js/dist/index.js
var require_dist10 = __commonJS({
  "node_modules/tuf-js/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Updater = exports2.BaseFetcher = exports2.TargetFile = void 0;
    var models_1 = require_dist9();
    Object.defineProperty(exports2, "TargetFile", { enumerable: true, get: function() {
      return models_1.TargetFile;
    } });
    var fetcher_1 = require_fetcher();
    Object.defineProperty(exports2, "BaseFetcher", { enumerable: true, get: function() {
      return fetcher_1.BaseFetcher;
    } });
    var updater_1 = require_updater();
    Object.defineProperty(exports2, "Updater", { enumerable: true, get: function() {
      return updater_1.Updater;
    } });
  }
});

// node_modules/@sigstore/tuf/dist/error.js
var require_error8 = __commonJS({
  "node_modules/@sigstore/tuf/dist/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TUFError = void 0;
    var TUFError = class extends Error {
      constructor({ code, message, cause }) {
        super(message);
        this.code = code;
        this.cause = cause;
        this.name = this.constructor.name;
      }
    };
    exports2.TUFError = TUFError;
  }
});

// node_modules/@sigstore/tuf/dist/target.js
var require_target = __commonJS({
  "node_modules/@sigstore/tuf/dist/target.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readTarget = readTarget;
    var fs_1 = __importDefault(require("fs"));
    var error_1 = require_error8();
    async function readTarget(tuf, targetPath) {
      const path = await getTargetPath(tuf, targetPath);
      return new Promise((resolve, reject) => {
        fs_1.default.readFile(path, "utf-8", (err, data) => {
          if (err) {
            reject(new error_1.TUFError({
              code: "TUF_READ_TARGET_ERROR",
              message: `error reading target ${path}`,
              cause: err
            }));
          } else {
            resolve(data);
          }
        });
      });
    }
    async function getTargetPath(tuf, target) {
      let targetInfo;
      try {
        targetInfo = await tuf.getTargetInfo(target);
      } catch (err) {
        throw new error_1.TUFError({
          code: "TUF_REFRESH_METADATA_ERROR",
          message: "error refreshing TUF metadata",
          cause: err
        });
      }
      if (!targetInfo) {
        throw new error_1.TUFError({
          code: "TUF_FIND_TARGET_ERROR",
          message: `target ${target} not found`
        });
      }
      let path = await tuf.findCachedTarget(targetInfo);
      if (!path) {
        try {
          path = await tuf.downloadTarget(targetInfo);
        } catch (err) {
          throw new error_1.TUFError({
            code: "TUF_DOWNLOAD_TARGET_ERROR",
            message: `error downloading target ${path}`,
            cause: err
          });
        }
      }
      return path;
    }
  }
});

// node_modules/@sigstore/tuf/seeds.json
var require_seeds = __commonJS({
  "node_modules/@sigstore/tuf/seeds.json"(exports2, module2) {
    module2.exports = { "https://tuf-repo-cdn.sigstore.dev": { "root.json": "ewogInNpZ25hdHVyZXMiOiBbCiAgewogICAia2V5aWQiOiAiNmYyNjAwODlkNTkyM2RhZjIwMTY2Y2E2NTdjNTQzYWY2MTgzNDZhYjk3MTg4NGE5OTk2MmIwMTk4OGJiZTBjMyIsCiAgICJzaWciOiAiMzA0NjAyMjEwMDhhYjFmNmYxN2Q0ZjllNmQ3ZGNmMWM4ODkxMmI2YjUzY2MxMDM4ODY0NGFlMWYwOWJjMzdhMDgyY2QwNjAwM2UwMjIxMDBlMTQ1ZWY0YzdiNzgyZDRlODEwN2I1MzQzN2U2NjlkMDQ3Njg5MmNlOTk5OTAzYWUzM2QxNDQ0ODM2Njk5NmU3IgogIH0sCiAgewogICAia2V5aWQiOiAiZTcxYTU0ZDU0MzgzNWJhODZhZGFkOTQ2MDM3OWM3NjQxZmI4NzI2ZDE2NGVhNzY2ODAxYTFjNTIyYWJhN2VhMiIsCiAgICJzaWciOiAiMzA0NTAyMjEwMGM3NjhiMmY4NmRhOTk1NjkwMTljMTYwYTA4MWRhNTRhZTM2YzM0YzBhMzEyMGQzY2I2OWI1M2I3ZDExMzc1OGUwMjIwNGY2NzE1MThmNjE3YjIwZDQ2NTM3ZmFlNmMzYjYzYmFlODkxM2Y0ZjE5NjIxNTYxMDVjYzRmMDE5YWMzNWM2YSIKICB9LAogIHsKICAgImtleWlkIjogIjIyZjRjYWVjNmQ4ZTZmOTU1NWFmNjZiM2Q0YzNjYjA2YTNiYjIzZmRjN2UzOWM5MTZjNjFmNDYyZTZmNTJiMDYiLAogICAic2lnIjogIjMwNDUwMjIxMDBiNDQzNGU2OTk1ZDM2OGQyM2U3NDc1OWFjZDBjYjkwMTNjODNhNWQzNTExZjBmOTk3ZWM1NGM0NTZhZTQzNTBhMDIyMDE1YjBlMjY1ZDE4MmQyYjYxZGM3NGUxNTVkOThiM2MzZmJlNTY0YmEwNTI4NmFhMTRjOGRmMDJjOWI3NTY1MTYiCiAgfSwKICB7CiAgICJrZXlpZCI6ICI2MTY0MzgzODEyNWI0NDBiNDBkYjY5NDJmNWNiNWEzMWMwZGMwNDM2ODMxNmViMmFhYTU4Yjk1OTA0YTU4MjIyIiwKICAgInNpZyI6ICIzMDQ1MDIyMTAwODJjNTg0MTFkOTg5ZWI5Zjg2MTQxMDg1N2Q0MjM4MTU5MGVjOTQyNGRiZGFhNTFlNzhlZDEzNTE1NDMxOTA0ZTAyMjAxMTgxODVkYTZhNmMyOTQ3MTMxYzE3Nzk3ZTJiYjc2MjBjZTI2ZTVmMzAxZDFjZWFjNWYyYTdlNThmOWRjZjJlIgogIH0sCiAgewogICAia2V5aWQiOiAiYTY4N2U1YmY0ZmFiODJiMGVlNThkNDZlMDVjOTUzNTE0NWEyYzlhZmI0NThmNDNkNDJiNDVjYTBmZGNlMmE3MCIsCiAgICJzaWciOiAiMzA0NjAyMjEwMGM3ODUxMzg1NGNhZTljMzJlYWE2Yjg4ZTE4OTEyZjQ4MDA2YzI3NTdhMjU4ZjkxNzMxMmNhYmE3NTk0OGViOWUwMjIxMDBkOWUxYjRjZTBhZGZlOWZkMmUyMTQ4ZDdmYTI3YTJmNDBiYTExMjJiZDY5ZGE3NjEyZDhkMTc3NmIwMTNjOTFkIgogIH0sCiAgewogICAia2V5aWQiOiAiZmRmYTgzYTA3YjVhODM1ODliODdkZWQ0MWY3N2YzOWQyMzJhZDkxZjdjY2U1Mjg2OGRhY2QwNmJhMDg5ODQ5ZiIsCiAgICJzaWciOiAiMzA0NTAyMjA1NjQ4M2EyZDVkOWVhOWNlYzZlMTFlYWRmYjMzYzQ4NGI2MTQyOThmYWNhMTVhY2YxYzQzMWIxMWVkN2Y3MzRjMDIyMTAwZDBjMWQ3MjZhZjkyYTg3ZTRlNjY0NTljYTVhZGYzOGEwNWI0NGUxZjk0MzE4NDIzZjk1NGJhZThiY2E1YmIyZSIKICB9LAogIHsKICAgImtleWlkIjogImUyZjU5YWNiOTQ4ODUxOTQwN2UxOGNiZmM5MzI5NTEwYmUwM2MwNGFjYTk5MjlkMmYwMzAxMzQzZmVjODU1MjMiLAogICAic2lnIjogIjMwNDYwMjIxMDBkMDA0ZGU4ODAyNGMzMmRjNTY1M2E5ZjQ4NDNjZmM1MjE1NDI3MDQ4YWQ5NjAwZDJjZjljOTY5ZTZlZGZmM2QyMDIyMTAwZDllYmI3OThmNWZjNjZhZjEwODk5ZGVjZTAxNGE4NjI4Y2NmM2M1NDAyY2Q0YTQyNzAyMDc0NzJmOGY2ZTcxMiIKICB9LAogIHsKICAgImtleWlkIjogIjNjMzQ0YWEwNjhmZDRjYzRlODdkYzUwYjYxMmMwMjQzMWZiYzc3MWU5NTAwMzk5MzY4M2EyYjBiZjI2MGNmMGUiLAogICAic2lnIjogIjMwNDYwMjIxMDBiN2IwOTk5NmM0NWNhMmQ0YjA1NjAzZTU2YmFlZmEyOTcxOGEwYjcxMTQ3Y2Y4YzZlNjYzNDliYWE2MTQ3N2RmMDIyMTAwYzRkYTgwYzcxN2I0ZmE3YmJhMGZkNWM3MmRhOGEwNDk5MzU4YjAxMzU4YjIzMDlmNDFkMTQ1NmVhMWU3ZTFkOSIKICB9LAogIHsKICAgImtleWlkIjogImVjODE2Njk3MzRlMDE3OTk2YzViODVmM2QwMmMzZGUxZGQ0NjM3YTE1MjAxOWZlMWFmMTI1ZDJmOTM2OGI5NWUiLAogICAic2lnIjogIjMwNDYwMjIxMDBiZTk3ODJjMzA3NDRlNDExYTgyZmE4NWI1MTM4ZDYwMWNlMTQ4YmMxOTI1OGFlYzY0ZTdlYzI0NDc4ZjM4ODEyMDIyMTAwY2FlZjYzZGNhZjFhNGI5YTUwMGQzYmQwZTNmMTY0ZWMxOGYxYjYzZDdhOTQ2MGQ5YWNhYjEwNjZkYjBmMDE2ZCIKICB9LAogIHsKICAgImtleWlkIjogIjFlMWQ2NWNlOThiMTBhZGRhZDQ3NjRmZWJmN2RkYTJkMDQzNmIzZDNhMzg5MzU3OWMwZGRkYWVhMjBlNTQ4NDkiLAogICAic2lnIjogIjMwNDUwMjIwNzQ2ZWMzZjg1MzRjZTU1NTMxZDBkMDFmZjY0OTY0ZWY0NDBkMWU3ZDJjNGMxNDI0MDliOGU5NzY5ZjFhZGE2ZjAyMjEwMGUzYjkyOWZjZDkzZWExOGZlYWEwODI1ODg3YTcyMTA0ODk4NzlhNjY3ODBjMDdhODNmNGJkNDZlMmYwOWFiM2IiCiAgfQogXSwKICJzaWduZWQiOiB7CiAgIl90eXBlIjogInJvb3QiLAogICJjb25zaXN0ZW50X3NuYXBzaG90IjogdHJ1ZSwKICAiZXhwaXJlcyI6ICIyMDI1LTAyLTE5VDA4OjA0OjMyWiIsCiAgImtleXMiOiB7CiAgICIyMmY0Y2FlYzZkOGU2Zjk1NTVhZjY2YjNkNGMzY2IwNmEzYmIyM2ZkYzdlMzljOTE2YzYxZjQ2MmU2ZjUyYjA2IjogewogICAgImtleWlkX2hhc2hfYWxnb3JpdGhtcyI6IFsKICAgICAic2hhMjU2IiwKICAgICAic2hhNTEyIgogICAgXSwKICAgICJrZXl0eXBlIjogImVjZHNhIiwKICAgICJrZXl2YWwiOiB7CiAgICAgInB1YmxpYyI6ICItLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxuTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFekJ6Vk9tSENQb2pNVkxTSTM2NFdpaVY4TlByRFxuNklnUnhWbGlza3ovdit5M0pFUjVtY1ZHY09ObGlEY1dNQzVKMmxmSG1qUE5QaGI0SDd4bThMemZTQT09XG4tLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1cbiIKICAgIH0sCiAgICAic2NoZW1lIjogImVjZHNhLXNoYTItbmlzdHAyNTYiLAogICAgIngtdHVmLW9uLWNpLWtleW93bmVyIjogIkBzYW50aWFnb3RvcnJlcyIKICAgfSwKICAgIjYxNjQzODM4MTI1YjQ0MGI0MGRiNjk0MmY1Y2I1YTMxYzBkYzA0MzY4MzE2ZWIyYWFhNThiOTU5MDRhNTgyMjIiOiB7CiAgICAia2V5aWRfaGFzaF9hbGdvcml0aG1zIjogWwogICAgICJzaGEyNTYiLAogICAgICJzaGE1MTIiCiAgICBdLAogICAgImtleXR5cGUiOiAiZWNkc2EiLAogICAgImtleXZhbCI6IHsKICAgICAicHVibGljIjogIi0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXG5NRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVpbmlrU3NBUW1Za05lSDVlWXEvQ25JekxhYWNPXG54bFNhYXdRRE93cUt5L3RDcXhxNXh4UFNKYzIxSzRXSWhzOUd5T2tLZnp1ZVkzR0lMemNNSlo0Y1d3PT1cbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLVxuIgogICAgfSwKICAgICJzY2hlbWUiOiAiZWNkc2Etc2hhMi1uaXN0cDI1NiIsCiAgICAieC10dWYtb24tY2kta2V5b3duZXIiOiAiQGJvYmNhbGxhd2F5IgogICB9LAogICAiNmYyNjAwODlkNTkyM2RhZjIwMTY2Y2E2NTdjNTQzYWY2MTgzNDZhYjk3MTg4NGE5OTk2MmIwMTk4OGJiZTBjMyI6IHsKICAgICJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCiAgICAgInNoYTI1NiIsCiAgICAgInNoYTUxMiIKICAgIF0sCiAgICAia2V5dHlwZSI6ICJlY2RzYSIsCiAgICAia2V5dmFsIjogewogICAgICJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRXk4WEtzbWhCWURJOEpjMEd3ekJ4ZUtheDBjbTVcblNUS0VVNjVIUEZ1blVuNDFzVDhwaTBGak00SWtIei9ZVW13bUxVTzBXdDdseGhqNkJrTElLNHFZQXc9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCiAgICB9LAogICAgInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKICAgICJ4LXR1Zi1vbi1jaS1rZXlvd25lciI6ICJAZGxvcmVuYyIKICAgfSwKICAgIjcyNDdmMGRiYWQ4NWIxNDdlMTg2M2JhZGU3NjEyNDNjYzc4NWRjYjdhYTQxMGU3MTA1ZGQzZDJiNjFhMzZkMmMiOiB7CiAgICAia2V5aWRfaGFzaF9hbGdvcml0aG1zIjogWwogICAgICJzaGEyNTYiLAogICAgICJzaGE1MTIiCiAgICBdLAogICAgImtleXR5cGUiOiAiZWNkc2EiLAogICAgImtleXZhbCI6IHsKICAgICAicHVibGljIjogIi0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXG5NRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUVXUmlHcjUraiszSjVTc0grWnRyNW5FMkgyd083XG5CVituTzNzOTNnTGNhMThxVE96SFkxb1d5QUdEeWtNU3NHVFVCU3Q5RCtBbjBLZktzRDJtZlNNNDJRPT1cbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLVxuIgogICAgfSwKICAgICJzY2hlbWUiOiAiZWNkc2Etc2hhMi1uaXN0cDI1NiIsCiAgICAieC10dWYtb24tY2ktb25saW5lLXVyaSI6ICJnY3BrbXM6Ly9wcm9qZWN0cy9zaWdzdG9yZS1yb290LXNpZ25pbmcvbG9jYXRpb25zL2dsb2JhbC9rZXlSaW5ncy9yb290L2NyeXB0b0tleXMvdGltZXN0YW1wIgogICB9LAogICAiYTY4N2U1YmY0ZmFiODJiMGVlNThkNDZlMDVjOTUzNTE0NWEyYzlhZmI0NThmNDNkNDJiNDVjYTBmZGNlMmE3MCI6IHsKICAgICJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCiAgICAgInNoYTI1NiIsCiAgICAgInNoYTUxMiIKICAgIF0sCiAgICAia2V5dHlwZSI6ICJlY2RzYSIsCiAgICAia2V5dmFsIjogewogICAgICJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRTBnaHJoOTJMdzFZcjNpZEdWNVdxQ3RNREI4Q3hcbitEOGhkQzR3MlpMTklwbFZSb1ZHTHNrWWEzZ2hlTXlPamlKOGtQaTE1YVEyLy83UCtvajdVdkpQR3c9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCiAgICB9LAogICAgInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKICAgICJ4LXR1Zi1vbi1jaS1rZXlvd25lciI6ICJAam9zaHVhZ2wiCiAgIH0sCiAgICJlNzFhNTRkNTQzODM1YmE4NmFkYWQ5NDYwMzc5Yzc2NDFmYjg3MjZkMTY0ZWE3NjY4MDFhMWM1MjJhYmE3ZWEyIjogewogICAgImtleWlkX2hhc2hfYWxnb3JpdGhtcyI6IFsKICAgICAic2hhMjU2IiwKICAgICAic2hhNTEyIgogICAgXSwKICAgICJrZXl0eXBlIjogImVjZHNhIiwKICAgICJrZXl2YWwiOiB7CiAgICAgInB1YmxpYyI6ICItLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxuTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFRVhzejNTWlhGYjhqTVY0Mmo2cEpseWpialI4S1xuTjNCd29jZXhxNkxNSWI1cXNXS09RdkxOMTZOVWVmTGM0SHN3T291bVJzVlZhYWpTcFFTNmZvYmtSdz09XG4tLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1cbiIKICAgIH0sCiAgICAic2NoZW1lIjogImVjZHNhLXNoYTItbmlzdHAyNTYiLAogICAgIngtdHVmLW9uLWNpLWtleW93bmVyIjogIkBtbm02NzgiCiAgIH0KICB9LAogICJyb2xlcyI6IHsKICAgInJvb3QiOiB7CiAgICAia2V5aWRzIjogWwogICAgICI2ZjI2MDA4OWQ1OTIzZGFmMjAxNjZjYTY1N2M1NDNhZjYxODM0NmFiOTcxODg0YTk5OTYyYjAxOTg4YmJlMGMzIiwKICAgICAiZTcxYTU0ZDU0MzgzNWJhODZhZGFkOTQ2MDM3OWM3NjQxZmI4NzI2ZDE2NGVhNzY2ODAxYTFjNTIyYWJhN2VhMiIsCiAgICAgIjIyZjRjYWVjNmQ4ZTZmOTU1NWFmNjZiM2Q0YzNjYjA2YTNiYjIzZmRjN2UzOWM5MTZjNjFmNDYyZTZmNTJiMDYiLAogICAgICI2MTY0MzgzODEyNWI0NDBiNDBkYjY5NDJmNWNiNWEzMWMwZGMwNDM2ODMxNmViMmFhYTU4Yjk1OTA0YTU4MjIyIiwKICAgICAiYTY4N2U1YmY0ZmFiODJiMGVlNThkNDZlMDVjOTUzNTE0NWEyYzlhZmI0NThmNDNkNDJiNDVjYTBmZGNlMmE3MCIKICAgIF0sCiAgICAidGhyZXNob2xkIjogMwogICB9LAogICAic25hcHNob3QiOiB7CiAgICAia2V5aWRzIjogWwogICAgICI3MjQ3ZjBkYmFkODViMTQ3ZTE4NjNiYWRlNzYxMjQzY2M3ODVkY2I3YWE0MTBlNzEwNWRkM2QyYjYxYTM2ZDJjIgogICAgXSwKICAgICJ0aHJlc2hvbGQiOiAxLAogICAgIngtdHVmLW9uLWNpLWV4cGlyeS1wZXJpb2QiOiAzNjUwLAogICAgIngtdHVmLW9uLWNpLXNpZ25pbmctcGVyaW9kIjogMzY1CiAgIH0sCiAgICJ0YXJnZXRzIjogewogICAgImtleWlkcyI6IFsKICAgICAiNmYyNjAwODlkNTkyM2RhZjIwMTY2Y2E2NTdjNTQzYWY2MTgzNDZhYjk3MTg4NGE5OTk2MmIwMTk4OGJiZTBjMyIsCiAgICAgImU3MWE1NGQ1NDM4MzViYTg2YWRhZDk0NjAzNzljNzY0MWZiODcyNmQxNjRlYTc2NjgwMWExYzUyMmFiYTdlYTIiLAogICAgICIyMmY0Y2FlYzZkOGU2Zjk1NTVhZjY2YjNkNGMzY2IwNmEzYmIyM2ZkYzdlMzljOTE2YzYxZjQ2MmU2ZjUyYjA2IiwKICAgICAiNjE2NDM4MzgxMjViNDQwYjQwZGI2OTQyZjVjYjVhMzFjMGRjMDQzNjgzMTZlYjJhYWE1OGI5NTkwNGE1ODIyMiIsCiAgICAgImE2ODdlNWJmNGZhYjgyYjBlZTU4ZDQ2ZTA1Yzk1MzUxNDVhMmM5YWZiNDU4ZjQzZDQyYjQ1Y2EwZmRjZTJhNzAiCiAgICBdLAogICAgInRocmVzaG9sZCI6IDMKICAgfSwKICAgInRpbWVzdGFtcCI6IHsKICAgICJrZXlpZHMiOiBbCiAgICAgIjcyNDdmMGRiYWQ4NWIxNDdlMTg2M2JhZGU3NjEyNDNjYzc4NWRjYjdhYTQxMGU3MTA1ZGQzZDJiNjFhMzZkMmMiCiAgICBdLAogICAgInRocmVzaG9sZCI6IDEsCiAgICAieC10dWYtb24tY2ktZXhwaXJ5LXBlcmlvZCI6IDcsCiAgICAieC10dWYtb24tY2ktc2lnbmluZy1wZXJpb2QiOiA0CiAgIH0KICB9LAogICJzcGVjX3ZlcnNpb24iOiAiMS4wIiwKICAidmVyc2lvbiI6IDEwLAogICJ4LXR1Zi1vbi1jaS1leHBpcnktcGVyaW9kIjogMTgyLAogICJ4LXR1Zi1vbi1jaS1zaWduaW5nLXBlcmlvZCI6IDMxCiB9Cn0=", targets: { "trusted_root.json": "ewogICJtZWRpYVR5cGUiOiAiYXBwbGljYXRpb24vdm5kLmRldi5zaWdzdG9yZS50cnVzdGVkcm9vdCtqc29uO3ZlcnNpb249MC4xIiwKICAidGxvZ3MiOiBbCiAgICB7CiAgICAgICJiYXNlVXJsIjogImh0dHBzOi8vcmVrb3Iuc2lnc3RvcmUuZGV2IiwKICAgICAgImhhc2hBbGdvcml0aG0iOiAiU0hBMl8yNTYiLAogICAgICAicHVibGljS2V5IjogewogICAgICAgICJyYXdCeXRlcyI6ICJNRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUUyRzJZKzJ0YWJkVFY1QmNHaUJJeDBhOWZBRndya0JibUxTR3RrczRMM3FYNnlZWTB6dWZCbmhDOFVyL2l5NTVHaFdQLzlBL2JZMkxoQzMwTTkrUll0dz09IiwKICAgICAgICAia2V5RGV0YWlscyI6ICJQS0lYX0VDRFNBX1AyNTZfU0hBXzI1NiIsCiAgICAgICAgInZhbGlkRm9yIjogewogICAgICAgICAgInN0YXJ0IjogIjIwMjEtMDEtMTJUMTE6NTM6MjcuMDAwWiIKICAgICAgICB9CiAgICAgIH0sCiAgICAgICJsb2dJZCI6IHsKICAgICAgICAia2V5SWQiOiAid05JOWF0UUdseitWV2ZPNkxSeWdINFFVZlkvOFc0UkZ3aVQ1aTVXUmdCMD0iCiAgICAgIH0KICAgIH0KICBdLAogICJjZXJ0aWZpY2F0ZUF1dGhvcml0aWVzIjogWwogICAgewogICAgICAic3ViamVjdCI6IHsKICAgICAgICAib3JnYW5pemF0aW9uIjogInNpZ3N0b3JlLmRldiIsCiAgICAgICAgImNvbW1vbk5hbWUiOiAic2lnc3RvcmUiCiAgICAgIH0sCiAgICAgICJ1cmkiOiAiaHR0cHM6Ly9mdWxjaW8uc2lnc3RvcmUuZGV2IiwKICAgICAgImNlcnRDaGFpbiI6IHsKICAgICAgICAiY2VydGlmaWNhdGVzIjogWwogICAgICAgICAgewogICAgICAgICAgICAicmF3Qnl0ZXMiOiAiTUlJQitEQ0NBWDZnQXdJQkFnSVROVmtEWm9DaW9mUERzeTdkZm02Z2VMYnVoekFLQmdncWhrak9QUVFEQXpBcU1SVXdFd1lEVlFRS0V3eHphV2R6ZEc5eVpTNWtaWFl4RVRBUEJnTlZCQU1UQ0hOcFozTjBiM0psTUI0WERUSXhNRE13TnpBek1qQXlPVm9YRFRNeE1ESXlNekF6TWpBeU9Wb3dLakVWTUJNR0ExVUVDaE1NYzJsbmMzUnZjbVV1WkdWMk1SRXdEd1lEVlFRREV3aHphV2R6ZEc5eVpUQjJNQkFHQnlxR1NNNDlBZ0VHQlN1QkJBQWlBMklBQkxTeUE3SWk1aytwTk84WkVXWTB5bGVtV0Rvd09rTmEza0wrR1pFNVo1R1dlaEw5L0E5YlJOQTNSYnJzWjVpMEpjYXN0YVJMN1NwNWZwL2pENWR4cWMvVWRUVm5sdlMxNmFuKzJZZnN3ZS9RdUxvbFJVQ3JjT0UyKzJpQTUrdHpkNk5tTUdRd0RnWURWUjBQQVFIL0JBUURBZ0VHTUJJR0ExVWRFd0VCL3dRSU1BWUJBZjhDQVFFd0hRWURWUjBPQkJZRUZNakZIUUJCbWlRcE1sRWs2dzJ1U3UxS0J0UHNNQjhHQTFVZEl3UVlNQmFBRk1qRkhRQkJtaVFwTWxFazZ3MnVTdTFLQnRQc01Bb0dDQ3FHU000OUJBTURBMmdBTUdVQ01IOGxpV0pmTXVpNnZYWEJoakRnWTRNd3NsbU4vVEp4VmUvODNXckZvbXdtTmYwNTZ5MVg0OEY5YzRtM2Ezb3pYQUl4QUtqUmF5NS9hai9qc0tLR0lrbVFhdGpJOHV1cEhyLytDeEZ2YUpXbXBZcU5rTERHUlUrOW9yemg1aEkyUnJjdWFRPT0iCiAgICAgICAgICB9CiAgICAgICAgXQogICAgICB9LAogICAgICAidmFsaWRGb3IiOiB7CiAgICAgICAgInN0YXJ0IjogIjIwMjEtMDMtMDdUMDM6MjA6MjkuMDAwWiIsCiAgICAgICAgImVuZCI6ICIyMDIyLTEyLTMxVDIzOjU5OjU5Ljk5OVoiCiAgICAgIH0KICAgIH0sCiAgICB7CiAgICAgICJzdWJqZWN0IjogewogICAgICAgICJvcmdhbml6YXRpb24iOiAic2lnc3RvcmUuZGV2IiwKICAgICAgICAiY29tbW9uTmFtZSI6ICJzaWdzdG9yZSIKICAgICAgfSwKICAgICAgInVyaSI6ICJodHRwczovL2Z1bGNpby5zaWdzdG9yZS5kZXYiLAogICAgICAiY2VydENoYWluIjogewogICAgICAgICJjZXJ0aWZpY2F0ZXMiOiBbCiAgICAgICAgICB7CiAgICAgICAgICAgICJyYXdCeXRlcyI6ICJNSUlDR2pDQ0FhR2dBd0lCQWdJVUFMblZpVmZuVTBickphc21Sa0hybi9VbmZhUXdDZ1lJS29aSXpqMEVBd013S2pFVk1CTUdBMVVFQ2hNTWMybG5jM1J2Y21VdVpHVjJNUkV3RHdZRFZRUURFd2h6YVdkemRHOXlaVEFlRncweU1qQTBNVE15TURBMk1UVmFGdzB6TVRFd01EVXhNelUyTlRoYU1EY3hGVEFUQmdOVkJBb1RESE5wWjNOMGIzSmxMbVJsZGpFZU1Cd0dBMVVFQXhNVmMybG5jM1J2Y21VdGFXNTBaWEp0WldScFlYUmxNSFl3RUFZSEtvWkl6ajBDQVFZRks0RUVBQ0lEWWdBRThSVlMveXNIK05PdnVEWnlQSVp0aWxnVUY5TmxhcllwQWQ5SFAxdkJCSDFVNUNWNzdMU1M3czBaaUg0bkU3SHY3cHRTNkx2dlIvU1RrNzk4TFZnTXpMbEo0SGVJZkYzdEhTYWV4TGNZcFNBU3Ixa1MwTi9SZ0JKei85aldDaVhubzNzd2VUQU9CZ05WSFE4QkFmOEVCQU1DQVFZd0V3WURWUjBsQkF3d0NnWUlLd1lCQlFVSEF3TXdFZ1lEVlIwVEFRSC9CQWd3QmdFQi93SUJBREFkQmdOVkhRNEVGZ1FVMzlQcHoxWWtFWmI1cU5qcEtGV2l4aTRZWkQ4d0h3WURWUjBqQkJnd0ZvQVVXTUFlWDVGRnBXYXBlc3lRb1pNaTBDckZ4Zm93Q2dZSUtvWkl6ajBFQXdNRFp3QXdaQUl3UENzUUs0RFlpWllEUElhRGk1SEZLbmZ4WHg2QVNTVm1FUmZzeW5ZQmlYMlg2U0pSblpVODQvOURaZG5GdnZ4bUFqQk90NlFwQmxjNEovMER4dmtUQ3FwY2x2emlMNkJDQ1BuamRsSUIzUHUzQnhzUG15Z1VZN0lpMnpiZENkbGlpb3c9IgogICAgICAgICAgfSwKICAgICAgICAgIHsKICAgICAgICAgICAgInJhd0J5dGVzIjogIk1JSUI5ekNDQVh5Z0F3SUJBZ0lVQUxaTkFQRmR4SFB3amVEbG9Ed3lZQ2hBTy80d0NnWUlLb1pJemowRUF3TXdLakVWTUJNR0ExVUVDaE1NYzJsbmMzUnZjbVV1WkdWMk1SRXdEd1lEVlFRREV3aHphV2R6ZEc5eVpUQWVGdzB5TVRFd01EY3hNelUyTlRsYUZ3MHpNVEV3TURVeE16VTJOVGhhTUNveEZUQVRCZ05WQkFvVERITnBaM04wYjNKbExtUmxkakVSTUE4R0ExVUVBeE1JYzJsbmMzUnZjbVV3ZGpBUUJnY3Foa2pPUFFJQkJnVXJnUVFBSWdOaUFBVDdYZUZUNHJiM1BRR3dTNElhanRMazMvT2xucGdhbmdhQmNsWXBzWUJyNWkrNHluQjA3Y2ViM0xQME9JT1pkeGV4WDY5YzVpVnV5SlJRK0h6MDV5aStVRjN1QldBbEhwaVM1c2gwK0gyR0hFN1NYcmsxRUM1bTFUcjE5TDlnZzkyall6QmhNQTRHQTFVZER3RUIvd1FFQXdJQkJqQVBCZ05WSFJNQkFmOEVCVEFEQVFIL01CMEdBMVVkRGdRV0JCUll3QjVma1VXbFpxbDZ6SkNoa3lMUUtzWEYrakFmQmdOVkhTTUVHREFXZ0JSWXdCNWZrVVdsWnFsNnpKQ2hreUxRS3NYRitqQUtCZ2dxaGtqT1BRUURBd05wQURCbUFqRUFqMW5IZVhacCsxM05XQk5hK0VEc0RQOEcxV1dnMXRDTVdQL1dIUHFwYVZvMGpoc3dlTkZaZ1NzMGVFN3dZSTRxQWpFQTJXQjlvdDk4c0lrb0YzdlpZZGQzL1Z0V0I1YjlUTk1lYTdJeC9zdEo1VGZjTExlQUJMRTRCTkpPc1E0dm5CSEoiCiAgICAgICAgICB9CiAgICAgICAgXQogICAgICB9LAogICAgICAidmFsaWRGb3IiOiB7CiAgICAgICAgInN0YXJ0IjogIjIwMjItMDQtMTNUMjA6MDY6MTUuMDAwWiIKICAgICAgfQogICAgfQogIF0sCiAgImN0bG9ncyI6IFsKICAgIHsKICAgICAgImJhc2VVcmwiOiAiaHR0cHM6Ly9jdGZlLnNpZ3N0b3JlLmRldi90ZXN0IiwKICAgICAgImhhc2hBbGdvcml0aG0iOiAiU0hBMl8yNTYiLAogICAgICAicHVibGljS2V5IjogewogICAgICAgICJyYXdCeXRlcyI6ICJNRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUViZndSK1JKdWRYc2NnUkJScEtYMVhGRHkzUHl1ZER4ei9TZm5SaTFmVDhla3BmQmQyTzF1b3o3anIzWjhuS3p4QTY5RVVRK2VGQ0ZJM3pldWJQV1U3dz09IiwKICAgICAgICAia2V5RGV0YWlscyI6ICJQS0lYX0VDRFNBX1AyNTZfU0hBXzI1NiIsCiAgICAgICAgInZhbGlkRm9yIjogewogICAgICAgICAgInN0YXJ0IjogIjIwMjEtMDMtMTRUMDA6MDA6MDAuMDAwWiIsCiAgICAgICAgICAiZW5kIjogIjIwMjItMTAtMzFUMjM6NTk6NTkuOTk5WiIKICAgICAgICB9CiAgICAgIH0sCiAgICAgICJsb2dJZCI6IHsKICAgICAgICAia2V5SWQiOiAiQ0dDUzhDaFMvMmhGMGRGcko0U2NSV2NZckJZOXd6alNiZWE4SWdZMmIzST0iCiAgICAgIH0KICAgIH0sCiAgICB7CiAgICAgICJiYXNlVXJsIjogImh0dHBzOi8vY3RmZS5zaWdzdG9yZS5kZXYvMjAyMiIsCiAgICAgICJoYXNoQWxnb3JpdGhtIjogIlNIQTJfMjU2IiwKICAgICAgInB1YmxpY0tleSI6IHsKICAgICAgICAicmF3Qnl0ZXMiOiAiTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFaVBTbEZpMENtRlRmRWpDVXFGOUh1Q0VjWVhOS0FhWWFsSUptQlo4eXllelBqVHFoeHJLQnBNbmFvY1Z0TEpCSTFlTTN1WG5RelFHQUpkSjRnczlGeXc9PSIsCiAgICAgICAgImtleURldGFpbHMiOiAiUEtJWF9FQ0RTQV9QMjU2X1NIQV8yNTYiLAogICAgICAgICJ2YWxpZEZvciI6IHsKICAgICAgICAgICJzdGFydCI6ICIyMDIyLTEwLTIwVDAwOjAwOjAwLjAwMFoiCiAgICAgICAgfQogICAgICB9LAogICAgICAibG9nSWQiOiB7CiAgICAgICAgImtleUlkIjogIjNUMHdhc2JIRVRKakdSNGNtV2MzQXFKS1hyamVQSzMvaDRweWdDOHA3bzQ9IgogICAgICB9CiAgICB9CiAgXSwKICAidGltZXN0YW1wQXV0aG9yaXRpZXMiOiBbCiAgICB7CiAgICAgICJzdWJqZWN0IjogewogICAgICAgICJvcmdhbml6YXRpb24iOiAiR2l0SHViLCBJbmMuIiwKICAgICAgICAiY29tbW9uTmFtZSI6ICJJbnRlcm5hbCBTZXJ2aWNlcyBSb290IgogICAgICB9LAogICAgICAiY2VydENoYWluIjogewogICAgICAgICJjZXJ0aWZpY2F0ZXMiOiBbCiAgICAgICAgICB7CiAgICAgICAgICAgICJyYXdCeXRlcyI6ICJNSUlCM0RDQ0FXS2dBd0lCQWdJVWNoa05zSDM2WGEwNGIxTHFJYytxcjlEVmVjTXdDZ1lJS29aSXpqMEVBd013TWpFVk1CTUdBMVVFQ2hNTVIybDBTSFZpTENCSmJtTXVNUmt3RndZRFZRUURFeEJVVTBFZ2FXNTBaWEp0WldScFlYUmxNQjRYRFRJek1EUXhOREF3TURBd01Gb1hEVEkwTURReE16QXdNREF3TUZvd01qRVZNQk1HQTFVRUNoTU1SMmwwU0hWaUxDQkpibU11TVJrd0Z3WURWUVFERXhCVVUwRWdWR2x0WlhOMFlXMXdhVzVuTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFVUQ1Wk5iU3FZTWQ2cjhxcE9PRVg5aWJHblpUOUdzdVhPaHIvZjhVOUZKdWdCR0V4S1lwNDBPVUxTMGVyalpXN3hWOXhWNTJObkpmNU9lRHE0ZTVaS3FOV01GUXdEZ1lEVlIwUEFRSC9CQVFEQWdlQU1CTUdBMVVkSlFRTU1Bb0dDQ3NHQVFVRkJ3TUlNQXdHQTFVZEV3RUIvd1FDTUFBd0h3WURWUjBqQkJnd0ZvQVVhVzFSdWRPZ1Z0MGxlcVkwV0tZYnVQcjQ3d0F3Q2dZSUtvWkl6ajBFQXdNRGFBQXdaUUl3YlVIOUh2RDRlakNaSk9XUW5xQWxrcVVSbGx2dTlNOCtWcUxiaVJLK3pTZlpDWndzaWxqUm44TVFRUlNrWEVFNUFqRUFnK1Z4cXRvamZWZnU4RGh6emhDeDlHS0VUYkpIYjE5aVY3Mm1NS1ViREFGbXpaNmJROGI1NFpiOHRpZHk1YVdlIgogICAgICAgICAgfSwKICAgICAgICAgIHsKICAgICAgICAgICAgInJhd0J5dGVzIjogIk1JSUNFRENDQVpXZ0F3SUJBZ0lVWDhaTzVRWFA3dk40ZE1RNWU5c1UzbnViOE9nd0NnWUlLb1pJemowRUF3TXdPREVWTUJNR0ExVUVDaE1NUjJsMFNIVmlMQ0JKYm1NdU1SOHdIUVlEVlFRREV4WkpiblJsY201aGJDQlRaWEoyYVdObGN5QlNiMjkwTUI0WERUSXpNRFF4TkRBd01EQXdNRm9YRFRJNE1EUXhNakF3TURBd01Gb3dNakVWTUJNR0ExVUVDaE1NUjJsMFNIVmlMQ0JKYm1NdU1Sa3dGd1lEVlFRREV4QlVVMEVnYVc1MFpYSnRaV1JwWVhSbE1IWXdFQVlIS29aSXpqMENBUVlGSzRFRUFDSURZZ0FFdk1MWS9kVFZidklKWUFOQXVzekV3Sm5RRTFsbGZ0eW55TUtJTWhoNDhIbXFiVnI1eWd5YnpzTFJMVktiQldPZFoyMWFlSnorZ1ppeXRaZXRxY3lGOVdsRVI1TkVNZjZKVjdaTm9qUXB4SHE0UkhHb0dTY2VRdi9xdlRpWnhFREtvMll3WkRBT0JnTlZIUThCQWY4RUJBTUNBUVl3RWdZRFZSMFRBUUgvQkFnd0JnRUIvd0lCQURBZEJnTlZIUTRFRmdRVWFXMVJ1ZE9nVnQwbGVxWTBXS1lidVByNDd3QXdId1lEVlIwakJCZ3dGb0FVOU5ZWWxvYm5BRzRjMC9xanh5SC9scS93eitRd0NnWUlLb1pJemowRUF3TURhUUF3WmdJeEFLMUIxODV5Z0NySVlGbElzM0dqc3dqbndTTUc2TFk4d29MVmRha0tEWnhWYThmOGNxTXMxRGhjeEowKzA5dzk1UUl4QU8rdEJ6Wms3dmpVSjlpSmdENFI2WldUeFFXS3FObTc0ak85OW8rbzlzdjRGSS9TWlRaVEZ5TW4wSUpFSGRObXlBPT0iCiAgICAgICAgICB9LAogICAgICAgICAgewogICAgICAgICAgICAicmF3Qnl0ZXMiOiAiTUlJQjlEQ0NBWHFnQXdJQkFnSVVhL0pBa2RVaks0SlV3c3F0YWlSSkdXaHFMU293Q2dZSUtvWkl6ajBFQXdNd09ERVZNQk1HQTFVRUNoTU1SMmwwU0hWaUxDQkpibU11TVI4d0hRWURWUVFERXhaSmJuUmxjbTVoYkNCVFpYSjJhV05sY3lCU2IyOTBNQjRYRFRJek1EUXhOREF3TURBd01Gb1hEVE16TURReE1UQXdNREF3TUZvd09ERVZNQk1HQTFVRUNoTU1SMmwwU0hWaUxDQkpibU11TVI4d0hRWURWUVFERXhaSmJuUmxjbTVoYkNCVFpYSjJhV05sY3lCU2IyOTBNSFl3RUFZSEtvWkl6ajBDQVFZRks0RUVBQ0lEWWdBRWY5akZBWHh6NGt4NjhBSFJNT2tGQmhmbERjTVR2emFYejR4L0ZDY1hqSi8xcUVLb24vcVBJR25hVVJza0R0eU5iTkRPcGVKVERERnF0NDhpTVBybnpweDZJWndxZW1mVUpONHhCRVpmemErcFl0L2l5b2QrOXRacjIwUlJXU3YvbzBVd1F6QU9CZ05WSFE4QkFmOEVCQU1DQVFZd0VnWURWUjBUQVFIL0JBZ3dCZ0VCL3dJQkFqQWRCZ05WSFE0RUZnUVU5TllZbG9ibkFHNGMwL3FqeHlIL2xxL3d6K1F3Q2dZSUtvWkl6ajBFQXdNRGFBQXdaUUl4QUxaTFo4QmdSWHpLeExNTU45VklsTytlNGhyQm5OQmdGN3R6N0hucm93djJOZXRaRXJJQUNLRnltQmx2V0R2dE1BSXdaTytraTZzc1ExYnNabzk4TzhtRUFmMk5aN2lpQ2dERFUwVndqZWNvNnp5ZWgwekJUczkvN2dWNkFITlE1M3hEIgogICAgICAgICAgfQogICAgICAgIF0KICAgICAgfSwKICAgICAgInZhbGlkRm9yIjogewogICAgICAgICJzdGFydCI6ICIyMDIzLTA0LTE0VDAwOjAwOjAwLjAwMFoiCiAgICAgIH0KICAgIH0KICBdCn0K", "registry.npmjs.org%2Fkeys.json": "ewogICAgImtleXMiOiBbCiAgICAgICAgewogICAgICAgICAgICAia2V5SWQiOiAiU0hBMjU2OmpsM2J3c3d1ODBQampva0NnaDBvMnc1YzJVNExoUUFFNTdnajljejFrekEiLAogICAgICAgICAgICAia2V5VXNhZ2UiOiAibnBtOnNpZ25hdHVyZXMiLAogICAgICAgICAgICAicHVibGljS2V5IjogewogICAgICAgICAgICAgICAgInJhd0J5dGVzIjogIk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRTFPbGIzek1BRkZ4WEtIaUlrUU81Y0ozWWhsNWk2VVBwK0lodXRlQkpidUhjQTVVb2dLbzBFV3RsV3dXNktTYUtvVE5FWUw3SmxDUWlWbmtoQmt0VWdnPT0iLAogICAgICAgICAgICAgICAgImtleURldGFpbHMiOiAiUEtJWF9FQ0RTQV9QMjU2X1NIQV8yNTYiLAogICAgICAgICAgICAgICAgInZhbGlkRm9yIjogewogICAgICAgICAgICAgICAgICAgICJzdGFydCI6ICIxOTk5LTAxLTAxVDAwOjAwOjAwLjAwMFoiLAogICAgICAgICAgICAgICAgICAgICJlbmQiOiAiMjAyNS0wMS0yOVQwMDowMDowMC4wMDBaIgogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAgICJrZXlJZCI6ICJTSEEyNTY6amwzYndzd3U4MFBqam9rQ2doMG8ydzVjMlU0TGhRQUU1N2dqOWN6MWt6QSIsCiAgICAgICAgICAgICJrZXlVc2FnZSI6ICJucG06YXR0ZXN0YXRpb25zIiwKICAgICAgICAgICAgInB1YmxpY0tleSI6IHsKICAgICAgICAgICAgICAgICJyYXdCeXRlcyI6ICJNRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUUxT2xiM3pNQUZGeFhLSGlJa1FPNWNKM1lobDVpNlVQcCtJaHV0ZUJKYnVIY0E1VW9nS28wRVd0bFd3VzZLU2FLb1RORVlMN0psQ1FpVm5raEJrdFVnZz09IiwKICAgICAgICAgICAgICAgICJrZXlEZXRhaWxzIjogIlBLSVhfRUNEU0FfUDI1Nl9TSEFfMjU2IiwKICAgICAgICAgICAgICAgICJ2YWxpZEZvciI6IHsKICAgICAgICAgICAgICAgICAgICAic3RhcnQiOiAiMjAyMi0xMi0wMVQwMDowMDowMC4wMDBaIiwKICAgICAgICAgICAgICAgICAgICAiZW5kIjogIjIwMjUtMDEtMjlUMDA6MDA6MDAuMDAwWiIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgICAia2V5SWQiOiAiU0hBMjU2OkRoUTh3UjVBUEJ2RkhMRi8rVGMrQVl2UE9kVHBjSURxT2h4c0JIUndDN1UiLAogICAgICAgICAgICAia2V5VXNhZ2UiOiAibnBtOnNpZ25hdHVyZXMiLAogICAgICAgICAgICAicHVibGljS2V5IjogewogICAgICAgICAgICAgICAgInJhd0J5dGVzIjogIk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRVk2WWE3VysrN2FVUHp2TVRyZXpINlljeDNjK0hPS1lDY05HeWJKWlNDSnEvZmQ3UWE4dXVBS3RkSWtVUXRRaUVLRVJoQW1FNWxNTUpoUDhPa0RPYTJnPT0iLAogICAgICAgICAgICAgICAgImtleURldGFpbHMiOiAiUEtJWF9FQ0RTQV9QMjU2X1NIQV8yNTYiLAogICAgICAgICAgICAgICAgInZhbGlkRm9yIjogewogICAgICAgICAgICAgICAgICAgICJzdGFydCI6ICIyMDI1LTAxLTEzVDAwOjAwOjAwLjAwMFoiCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICAgImtleUlkIjogIlNIQTI1NjpEaFE4d1I1QVBCdkZITEYvK1RjK0FZdlBPZFRwY0lEcU9oeHNCSFJ3QzdVIiwKICAgICAgICAgICAgImtleVVzYWdlIjogIm5wbTphdHRlc3RhdGlvbnMiLAogICAgICAgICAgICAicHVibGljS2V5IjogewogICAgICAgICAgICAgICAgInJhd0J5dGVzIjogIk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRVk2WWE3VysrN2FVUHp2TVRyZXpINlljeDNjK0hPS1lDY05HeWJKWlNDSnEvZmQ3UWE4dXVBS3RkSWtVUXRRaUVLRVJoQW1FNWxNTUpoUDhPa0RPYTJnPT0iLAogICAgICAgICAgICAgICAgImtleURldGFpbHMiOiAiUEtJWF9FQ0RTQV9QMjU2X1NIQV8yNTYiLAogICAgICAgICAgICAgICAgInZhbGlkRm9yIjogewogICAgICAgICAgICAgICAgICAgICJzdGFydCI6ICIyMDI1LTAxLTEzVDAwOjAwOjAwLjAwMFoiCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICBdCn0K" } } };
  }
});

// node_modules/@sigstore/tuf/dist/client.js
var require_client3 = __commonJS({
  "node_modules/@sigstore/tuf/dist/client.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TUFClient = void 0;
    var fs_1 = __importDefault(require("fs"));
    var path_1 = __importDefault(require("path"));
    var tuf_js_1 = require_dist10();
    var _1 = require_dist11();
    var target_1 = require_target();
    var TARGETS_DIR_NAME = "targets";
    var TUFClient = class {
      constructor(options) {
        const url = new URL(options.mirrorURL);
        const repoName = encodeURIComponent(url.host + url.pathname.replace(/\/$/, ""));
        const cachePath = path_1.default.join(options.cachePath, repoName);
        initTufCache(cachePath);
        seedCache({
          cachePath,
          mirrorURL: options.mirrorURL,
          tufRootPath: options.rootPath,
          forceInit: options.forceInit
        });
        this.updater = initClient({
          mirrorURL: options.mirrorURL,
          cachePath,
          forceCache: options.forceCache,
          retry: options.retry,
          timeout: options.timeout
        });
      }
      async refresh() {
        return this.updater.refresh();
      }
      getTarget(targetName) {
        return (0, target_1.readTarget)(this.updater, targetName);
      }
    };
    exports2.TUFClient = TUFClient;
    function initTufCache(cachePath) {
      const targetsPath = path_1.default.join(cachePath, TARGETS_DIR_NAME);
      if (!fs_1.default.existsSync(cachePath)) {
        fs_1.default.mkdirSync(cachePath, { recursive: true });
      }
      if (!fs_1.default.existsSync(targetsPath)) {
        fs_1.default.mkdirSync(targetsPath);
      }
    }
    function seedCache({ cachePath, mirrorURL, tufRootPath, forceInit }) {
      const cachedRootPath = path_1.default.join(cachePath, "root.json");
      if (!fs_1.default.existsSync(cachedRootPath) || forceInit) {
        if (tufRootPath) {
          fs_1.default.copyFileSync(tufRootPath, cachedRootPath);
        } else {
          const seeds = require_seeds();
          const repoSeed = seeds[mirrorURL];
          if (!repoSeed) {
            throw new _1.TUFError({
              code: "TUF_INIT_CACHE_ERROR",
              message: `No root.json found for mirror: ${mirrorURL}`
            });
          }
          fs_1.default.writeFileSync(cachedRootPath, Buffer.from(repoSeed["root.json"], "base64"));
          Object.entries(repoSeed.targets).forEach(([targetName, target]) => {
            fs_1.default.writeFileSync(path_1.default.join(cachePath, TARGETS_DIR_NAME, targetName), Buffer.from(target, "base64"));
          });
        }
      }
    }
    function initClient(options) {
      const config = {
        fetchTimeout: options.timeout,
        fetchRetry: options.retry
      };
      return new tuf_js_1.Updater({
        metadataBaseUrl: options.mirrorURL,
        targetBaseUrl: `${options.mirrorURL}/targets`,
        metadataDir: options.cachePath,
        targetDir: path_1.default.join(options.cachePath, TARGETS_DIR_NAME),
        forceCache: options.forceCache,
        config
      });
    }
  }
});

// node_modules/@sigstore/tuf/dist/index.js
var require_dist11 = __commonJS({
  "node_modules/@sigstore/tuf/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TUFError = exports2.DEFAULT_MIRROR_URL = void 0;
    exports2.getTrustedRoot = getTrustedRoot;
    exports2.initTUF = initTUF;
    var protobuf_specs_1 = require_dist5();
    var appdata_1 = require_appdata();
    var client_1 = require_client3();
    exports2.DEFAULT_MIRROR_URL = "https://tuf-repo-cdn.sigstore.dev";
    var DEFAULT_CACHE_DIR = "sigstore-js";
    var DEFAULT_RETRY = { retries: 2 };
    var DEFAULT_TIMEOUT = 5e3;
    var TRUSTED_ROOT_TARGET = "trusted_root.json";
    async function getTrustedRoot(options = {}) {
      const client = createClient(options);
      const trustedRoot = await client.getTarget(TRUSTED_ROOT_TARGET);
      return protobuf_specs_1.TrustedRoot.fromJSON(JSON.parse(trustedRoot));
    }
    async function initTUF(options = {}) {
      const client = createClient(options);
      return client.refresh().then(() => client);
    }
    function createClient(options) {
      return new client_1.TUFClient({
        cachePath: options.cachePath || (0, appdata_1.appDataPath)(DEFAULT_CACHE_DIR),
        rootPath: options.rootPath,
        mirrorURL: options.mirrorURL || exports2.DEFAULT_MIRROR_URL,
        retry: options.retry ?? DEFAULT_RETRY,
        timeout: options.timeout ?? DEFAULT_TIMEOUT,
        forceCache: options.forceCache ?? false,
        forceInit: options.forceInit ?? options.force ?? false
      });
    }
    var error_1 = require_error8();
    Object.defineProperty(exports2, "TUFError", { enumerable: true, get: function() {
      return error_1.TUFError;
    } });
  }
});

// node_modules/@sigstore/verify/dist/bundle/dsse.js
var require_dsse3 = __commonJS({
  "node_modules/@sigstore/verify/dist/bundle/dsse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DSSESignatureContent = void 0;
    var core_1 = require_dist7();
    var DSSESignatureContent = class {
      constructor(env) {
        this.env = env;
      }
      compareDigest(digest) {
        return core_1.crypto.bufferEqual(digest, core_1.crypto.digest("sha256", this.env.payload));
      }
      compareSignature(signature) {
        return core_1.crypto.bufferEqual(signature, this.signature);
      }
      verifySignature(key) {
        return core_1.crypto.verify(this.preAuthEncoding, key, this.signature);
      }
      get signature() {
        return this.env.signatures.length > 0 ? this.env.signatures[0].sig : Buffer.from("");
      }
      // DSSE Pre-Authentication Encoding
      get preAuthEncoding() {
        return core_1.dsse.preAuthEncoding(this.env.payloadType, this.env.payload);
      }
    };
    exports2.DSSESignatureContent = DSSESignatureContent;
  }
});

// node_modules/@sigstore/verify/dist/bundle/message.js
var require_message2 = __commonJS({
  "node_modules/@sigstore/verify/dist/bundle/message.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MessageSignatureContent = void 0;
    var core_1 = require_dist7();
    var MessageSignatureContent = class {
      constructor(messageSignature, artifact) {
        this.signature = messageSignature.signature;
        this.messageDigest = messageSignature.messageDigest.digest;
        this.artifact = artifact;
      }
      compareSignature(signature) {
        return core_1.crypto.bufferEqual(signature, this.signature);
      }
      compareDigest(digest) {
        return core_1.crypto.bufferEqual(digest, this.messageDigest);
      }
      verifySignature(key) {
        return core_1.crypto.verify(this.artifact, key, this.signature);
      }
    };
    exports2.MessageSignatureContent = MessageSignatureContent;
  }
});

// node_modules/@sigstore/verify/dist/bundle/index.js
var require_bundle3 = __commonJS({
  "node_modules/@sigstore/verify/dist/bundle/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toSignedEntity = toSignedEntity;
    exports2.signatureContent = signatureContent;
    var core_1 = require_dist7();
    var dsse_1 = require_dsse3();
    var message_1 = require_message2();
    function toSignedEntity(bundle, artifact) {
      const { tlogEntries, timestampVerificationData } = bundle.verificationMaterial;
      const timestamps = [];
      for (const entry of tlogEntries) {
        timestamps.push({
          $case: "transparency-log",
          tlogEntry: entry
        });
      }
      for (const ts of timestampVerificationData?.rfc3161Timestamps ?? []) {
        timestamps.push({
          $case: "timestamp-authority",
          timestamp: core_1.RFC3161Timestamp.parse(ts.signedTimestamp)
        });
      }
      return {
        signature: signatureContent(bundle, artifact),
        key: key(bundle),
        tlogEntries,
        timestamps
      };
    }
    function signatureContent(bundle, artifact) {
      switch (bundle.content.$case) {
        case "dsseEnvelope":
          return new dsse_1.DSSESignatureContent(bundle.content.dsseEnvelope);
        case "messageSignature":
          return new message_1.MessageSignatureContent(bundle.content.messageSignature, artifact);
      }
    }
    function key(bundle) {
      switch (bundle.verificationMaterial.content.$case) {
        case "publicKey":
          return {
            $case: "public-key",
            hint: bundle.verificationMaterial.content.publicKey.hint
          };
        case "x509CertificateChain":
          return {
            $case: "certificate",
            certificate: core_1.X509Certificate.parse(bundle.verificationMaterial.content.x509CertificateChain.certificates[0].rawBytes)
          };
        case "certificate":
          return {
            $case: "certificate",
            certificate: core_1.X509Certificate.parse(bundle.verificationMaterial.content.certificate.rawBytes)
          };
      }
    }
  }
});

// node_modules/@sigstore/verify/dist/error.js
var require_error9 = __commonJS({
  "node_modules/@sigstore/verify/dist/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PolicyError = exports2.VerificationError = void 0;
    var BaseError = class extends Error {
      constructor({ code, message, cause }) {
        super(message);
        this.code = code;
        this.cause = cause;
        this.name = this.constructor.name;
      }
    };
    var VerificationError = class extends BaseError {
    };
    exports2.VerificationError = VerificationError;
    var PolicyError = class extends BaseError {
    };
    exports2.PolicyError = PolicyError;
  }
});

// node_modules/@sigstore/verify/dist/trust/filter.js
var require_filter = __commonJS({
  "node_modules/@sigstore/verify/dist/trust/filter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filterCertAuthorities = filterCertAuthorities;
    exports2.filterTLogAuthorities = filterTLogAuthorities;
    function filterCertAuthorities(certAuthorities, criteria) {
      return certAuthorities.filter((ca) => {
        return ca.validFor.start <= criteria.start && ca.validFor.end >= criteria.end;
      });
    }
    function filterTLogAuthorities(tlogAuthorities, criteria) {
      return tlogAuthorities.filter((tlog) => {
        if (criteria.logID && !tlog.logID.equals(criteria.logID)) {
          return false;
        }
        return tlog.validFor.start <= criteria.targetDate && criteria.targetDate <= tlog.validFor.end;
      });
    }
  }
});

// node_modules/@sigstore/verify/dist/trust/index.js
var require_trust = __commonJS({
  "node_modules/@sigstore/verify/dist/trust/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filterTLogAuthorities = exports2.filterCertAuthorities = void 0;
    exports2.toTrustMaterial = toTrustMaterial;
    var core_1 = require_dist7();
    var protobuf_specs_1 = require_dist5();
    var error_1 = require_error9();
    var BEGINNING_OF_TIME = /* @__PURE__ */ new Date(0);
    var END_OF_TIME = /* @__PURE__ */ new Date(864e13);
    var filter_1 = require_filter();
    Object.defineProperty(exports2, "filterCertAuthorities", { enumerable: true, get: function() {
      return filter_1.filterCertAuthorities;
    } });
    Object.defineProperty(exports2, "filterTLogAuthorities", { enumerable: true, get: function() {
      return filter_1.filterTLogAuthorities;
    } });
    function toTrustMaterial(root, keys) {
      const keyFinder = typeof keys === "function" ? keys : keyLocator(keys);
      return {
        certificateAuthorities: root.certificateAuthorities.map(createCertAuthority),
        timestampAuthorities: root.timestampAuthorities.map(createCertAuthority),
        tlogs: root.tlogs.map(createTLogAuthority),
        ctlogs: root.ctlogs.map(createTLogAuthority),
        publicKey: keyFinder
      };
    }
    function createTLogAuthority(tlogInstance) {
      const keyDetails = tlogInstance.publicKey.keyDetails;
      const keyType = keyDetails === protobuf_specs_1.PublicKeyDetails.PKCS1_RSA_PKCS1V5 || keyDetails === protobuf_specs_1.PublicKeyDetails.PKIX_RSA_PKCS1V5 || keyDetails === protobuf_specs_1.PublicKeyDetails.PKIX_RSA_PKCS1V15_2048_SHA256 || keyDetails === protobuf_specs_1.PublicKeyDetails.PKIX_RSA_PKCS1V15_3072_SHA256 || keyDetails === protobuf_specs_1.PublicKeyDetails.PKIX_RSA_PKCS1V15_4096_SHA256 ? "pkcs1" : "spki";
      return {
        logID: tlogInstance.logId.keyId,
        publicKey: core_1.crypto.createPublicKey(tlogInstance.publicKey.rawBytes, keyType),
        validFor: {
          start: tlogInstance.publicKey.validFor?.start || BEGINNING_OF_TIME,
          end: tlogInstance.publicKey.validFor?.end || END_OF_TIME
        }
      };
    }
    function createCertAuthority(ca) {
      return {
        certChain: ca.certChain.certificates.map((cert) => {
          return core_1.X509Certificate.parse(cert.rawBytes);
        }),
        validFor: {
          start: ca.validFor?.start || BEGINNING_OF_TIME,
          end: ca.validFor?.end || END_OF_TIME
        }
      };
    }
    function keyLocator(keys) {
      return (hint) => {
        const key = (keys || {})[hint];
        if (!key) {
          throw new error_1.VerificationError({
            code: "PUBLIC_KEY_ERROR",
            message: `key not found: ${hint}`
          });
        }
        return {
          publicKey: core_1.crypto.createPublicKey(key.rawBytes),
          validFor: (date) => {
            return (key.validFor?.start || BEGINNING_OF_TIME) <= date && (key.validFor?.end || END_OF_TIME) >= date;
          }
        };
      };
    }
  }
});

// node_modules/@sigstore/verify/dist/key/certificate.js
var require_certificate = __commonJS({
  "node_modules/@sigstore/verify/dist/key/certificate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CertificateChainVerifier = void 0;
    exports2.verifyCertificateChain = verifyCertificateChain;
    var error_1 = require_error9();
    var trust_1 = require_trust();
    function verifyCertificateChain(leaf, certificateAuthorities) {
      const cas = (0, trust_1.filterCertAuthorities)(certificateAuthorities, {
        start: leaf.notBefore,
        end: leaf.notAfter
      });
      let error;
      for (const ca of cas) {
        try {
          const verifier = new CertificateChainVerifier({
            trustedCerts: ca.certChain,
            untrustedCert: leaf
          });
          return verifier.verify();
        } catch (err) {
          error = err;
        }
      }
      throw new error_1.VerificationError({
        code: "CERTIFICATE_ERROR",
        message: "Failed to verify certificate chain",
        cause: error
      });
    }
    var CertificateChainVerifier = class {
      constructor(opts) {
        this.untrustedCert = opts.untrustedCert;
        this.trustedCerts = opts.trustedCerts;
        this.localCerts = dedupeCertificates([
          ...opts.trustedCerts,
          opts.untrustedCert
        ]);
      }
      verify() {
        const certificatePath = this.sort();
        this.checkPath(certificatePath);
        return certificatePath;
      }
      sort() {
        const leafCert = this.untrustedCert;
        let paths = this.buildPaths(leafCert);
        paths = paths.filter((path2) => path2.some((cert) => this.trustedCerts.includes(cert)));
        if (paths.length === 0) {
          throw new error_1.VerificationError({
            code: "CERTIFICATE_ERROR",
            message: "no trusted certificate path found"
          });
        }
        const path = paths.reduce((prev, curr) => prev.length < curr.length ? prev : curr);
        return [leafCert, ...path].slice(0, -1);
      }
      // Recursively build all possible paths from the leaf to the root
      buildPaths(certificate) {
        const paths = [];
        const issuers = this.findIssuer(certificate);
        if (issuers.length === 0) {
          throw new error_1.VerificationError({
            code: "CERTIFICATE_ERROR",
            message: "no valid certificate path found"
          });
        }
        for (let i = 0; i < issuers.length; i++) {
          const issuer = issuers[i];
          if (issuer.equals(certificate)) {
            paths.push([certificate]);
            continue;
          }
          const subPaths = this.buildPaths(issuer);
          for (let j = 0; j < subPaths.length; j++) {
            paths.push([issuer, ...subPaths[j]]);
          }
        }
        return paths;
      }
      // Return all possible issuers for the given certificate
      findIssuer(certificate) {
        let issuers = [];
        let keyIdentifier;
        if (certificate.subject.equals(certificate.issuer)) {
          if (certificate.verify()) {
            return [certificate];
          }
        }
        if (certificate.extAuthorityKeyID) {
          keyIdentifier = certificate.extAuthorityKeyID.keyIdentifier;
        }
        this.localCerts.forEach((possibleIssuer) => {
          if (keyIdentifier) {
            if (possibleIssuer.extSubjectKeyID) {
              if (possibleIssuer.extSubjectKeyID.keyIdentifier.equals(keyIdentifier)) {
                issuers.push(possibleIssuer);
              }
              return;
            }
          }
          if (possibleIssuer.subject.equals(certificate.issuer)) {
            issuers.push(possibleIssuer);
          }
        });
        issuers = issuers.filter((issuer) => {
          try {
            return certificate.verify(issuer);
          } catch (ex) {
            return false;
          }
        });
        return issuers;
      }
      checkPath(path) {
        if (path.length < 1) {
          throw new error_1.VerificationError({
            code: "CERTIFICATE_ERROR",
            message: "certificate chain must contain at least one certificate"
          });
        }
        const validCAs = path.slice(1).every((cert) => cert.isCA);
        if (!validCAs) {
          throw new error_1.VerificationError({
            code: "CERTIFICATE_ERROR",
            message: "intermediate certificate is not a CA"
          });
        }
        for (let i = path.length - 2; i >= 0; i--) {
          if (!path[i].issuer.equals(path[i + 1].subject)) {
            throw new error_1.VerificationError({
              code: "CERTIFICATE_ERROR",
              message: "incorrect certificate name chaining"
            });
          }
        }
        for (let i = 0; i < path.length; i++) {
          const cert = path[i];
          if (cert.extBasicConstraints?.isCA) {
            const pathLength = cert.extBasicConstraints.pathLenConstraint;
            if (pathLength !== void 0 && pathLength < i - 1) {
              throw new error_1.VerificationError({
                code: "CERTIFICATE_ERROR",
                message: "path length constraint exceeded"
              });
            }
          }
        }
      }
    };
    exports2.CertificateChainVerifier = CertificateChainVerifier;
    function dedupeCertificates(certs) {
      for (let i = 0; i < certs.length; i++) {
        for (let j = i + 1; j < certs.length; j++) {
          if (certs[i].equals(certs[j])) {
            certs.splice(j, 1);
            j--;
          }
        }
      }
      return certs;
    }
  }
});

// node_modules/@sigstore/verify/dist/key/sct.js
var require_sct2 = __commonJS({
  "node_modules/@sigstore/verify/dist/key/sct.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifySCTs = verifySCTs;
    var core_1 = require_dist7();
    var error_1 = require_error9();
    var trust_1 = require_trust();
    function verifySCTs(cert, issuer, ctlogs) {
      let extSCT;
      const clone = cert.clone();
      for (let i = 0; i < clone.extensions.length; i++) {
        const ext = clone.extensions[i];
        if (ext.subs[0].toOID() === core_1.EXTENSION_OID_SCT) {
          extSCT = new core_1.X509SCTExtension(ext);
          clone.extensions.splice(i, 1);
          break;
        }
      }
      if (!extSCT) {
        return [];
      }
      if (extSCT.signedCertificateTimestamps.length === 0) {
        return [];
      }
      const preCert = new core_1.ByteStream();
      const issuerId = core_1.crypto.digest("sha256", issuer.publicKey);
      preCert.appendView(issuerId);
      const tbs = clone.tbsCertificate.toDER();
      preCert.appendUint24(tbs.length);
      preCert.appendView(tbs);
      return extSCT.signedCertificateTimestamps.map((sct) => {
        const validCTLogs = (0, trust_1.filterTLogAuthorities)(ctlogs, {
          logID: sct.logID,
          targetDate: sct.datetime
        });
        const verified = validCTLogs.some((log) => sct.verify(preCert.buffer, log.publicKey));
        if (!verified) {
          throw new error_1.VerificationError({
            code: "CERTIFICATE_ERROR",
            message: "SCT verification failed"
          });
        }
        return sct.logID;
      });
    }
  }
});

// node_modules/@sigstore/verify/dist/key/index.js
var require_key4 = __commonJS({
  "node_modules/@sigstore/verify/dist/key/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyPublicKey = verifyPublicKey;
    exports2.verifyCertificate = verifyCertificate;
    var core_1 = require_dist7();
    var error_1 = require_error9();
    var certificate_1 = require_certificate();
    var sct_1 = require_sct2();
    var OID_FULCIO_ISSUER_V1 = "1.3.6.1.4.1.57264.1.1";
    var OID_FULCIO_ISSUER_V2 = "1.3.6.1.4.1.57264.1.8";
    function verifyPublicKey(hint, timestamps, trustMaterial) {
      const key = trustMaterial.publicKey(hint);
      timestamps.forEach((timestamp) => {
        if (!key.validFor(timestamp)) {
          throw new error_1.VerificationError({
            code: "PUBLIC_KEY_ERROR",
            message: `Public key is not valid for timestamp: ${timestamp.toISOString()}`
          });
        }
      });
      return { key: key.publicKey };
    }
    function verifyCertificate(leaf, timestamps, trustMaterial) {
      const path = (0, certificate_1.verifyCertificateChain)(leaf, trustMaterial.certificateAuthorities);
      const validForDate = timestamps.every((timestamp) => path.every((cert) => cert.validForDate(timestamp)));
      if (!validForDate) {
        throw new error_1.VerificationError({
          code: "CERTIFICATE_ERROR",
          message: "certificate is not valid or expired at the specified date"
        });
      }
      return {
        scts: (0, sct_1.verifySCTs)(path[0], path[1], trustMaterial.ctlogs),
        signer: getSigner(path[0])
      };
    }
    function getSigner(cert) {
      let issuer;
      const issuerExtension = cert.extension(OID_FULCIO_ISSUER_V2);
      if (issuerExtension) {
        issuer = issuerExtension.valueObj.subs?.[0]?.value.toString("ascii");
      } else {
        issuer = cert.extension(OID_FULCIO_ISSUER_V1)?.value.toString("ascii");
      }
      const identity = {
        extensions: { issuer },
        subjectAlternativeName: cert.subjectAltName
      };
      return {
        key: core_1.crypto.createPublicKey(cert.publicKey),
        identity
      };
    }
  }
});

// node_modules/@sigstore/verify/dist/policy.js
var require_policy2 = __commonJS({
  "node_modules/@sigstore/verify/dist/policy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifySubjectAlternativeName = verifySubjectAlternativeName;
    exports2.verifyExtensions = verifyExtensions;
    var error_1 = require_error9();
    function verifySubjectAlternativeName(policyIdentity, signerIdentity) {
      if (signerIdentity === void 0 || !signerIdentity.match(policyIdentity)) {
        throw new error_1.PolicyError({
          code: "UNTRUSTED_SIGNER_ERROR",
          message: `certificate identity error - expected ${policyIdentity}, got ${signerIdentity}`
        });
      }
    }
    function verifyExtensions(policyExtensions, signerExtensions = {}) {
      let key;
      for (key in policyExtensions) {
        if (signerExtensions[key] !== policyExtensions[key]) {
          throw new error_1.PolicyError({
            code: "UNTRUSTED_SIGNER_ERROR",
            message: `invalid certificate extension - expected ${key}=${policyExtensions[key]}, got ${key}=${signerExtensions[key]}`
          });
        }
      }
    }
  }
});

// node_modules/@sigstore/verify/dist/timestamp/checkpoint.js
var require_checkpoint = __commonJS({
  "node_modules/@sigstore/verify/dist/timestamp/checkpoint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyCheckpoint = verifyCheckpoint;
    var core_1 = require_dist7();
    var error_1 = require_error9();
    var trust_1 = require_trust();
    var CHECKPOINT_SEPARATOR = "\n\n";
    var SIGNATURE_REGEX = /\u2014 (\S+) (\S+)\n/g;
    function verifyCheckpoint(entry, tlogs) {
      const validTLogs = (0, trust_1.filterTLogAuthorities)(tlogs, {
        targetDate: new Date(Number(entry.integratedTime) * 1e3)
      });
      const inclusionProof = entry.inclusionProof;
      const signedNote = SignedNote.fromString(inclusionProof.checkpoint.envelope);
      const checkpoint = LogCheckpoint.fromString(signedNote.note);
      if (!verifySignedNote(signedNote, validTLogs)) {
        throw new error_1.VerificationError({
          code: "TLOG_INCLUSION_PROOF_ERROR",
          message: "invalid checkpoint signature"
        });
      }
      if (!core_1.crypto.bufferEqual(checkpoint.logHash, inclusionProof.rootHash)) {
        throw new error_1.VerificationError({
          code: "TLOG_INCLUSION_PROOF_ERROR",
          message: "root hash mismatch"
        });
      }
    }
    function verifySignedNote(signedNote, tlogs) {
      const data = Buffer.from(signedNote.note, "utf-8");
      return signedNote.signatures.every((signature) => {
        const tlog = tlogs.find((tlog2) => core_1.crypto.bufferEqual(tlog2.logID.subarray(0, 4), signature.keyHint));
        if (!tlog) {
          return false;
        }
        return core_1.crypto.verify(data, tlog.publicKey, signature.signature);
      });
    }
    var SignedNote = class _SignedNote {
      constructor(note, signatures) {
        this.note = note;
        this.signatures = signatures;
      }
      // Deserialize a SignedNote from a string
      static fromString(envelope) {
        if (!envelope.includes(CHECKPOINT_SEPARATOR)) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROOF_ERROR",
            message: "missing checkpoint separator"
          });
        }
        const split = envelope.indexOf(CHECKPOINT_SEPARATOR);
        const header = envelope.slice(0, split + 1);
        const data = envelope.slice(split + CHECKPOINT_SEPARATOR.length);
        const matches = data.matchAll(SIGNATURE_REGEX);
        const signatures = Array.from(matches, (match) => {
          const [, name, signature] = match;
          const sigBytes = Buffer.from(signature, "base64");
          if (sigBytes.length < 5) {
            throw new error_1.VerificationError({
              code: "TLOG_INCLUSION_PROOF_ERROR",
              message: "malformed checkpoint signature"
            });
          }
          return {
            name,
            keyHint: sigBytes.subarray(0, 4),
            signature: sigBytes.subarray(4)
          };
        });
        if (signatures.length === 0) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROOF_ERROR",
            message: "no signatures found in checkpoint"
          });
        }
        return new _SignedNote(header, signatures);
      }
    };
    var LogCheckpoint = class _LogCheckpoint {
      constructor(origin, logSize, logHash, rest) {
        this.origin = origin;
        this.logSize = logSize;
        this.logHash = logHash;
        this.rest = rest;
      }
      static fromString(note) {
        const lines = note.trimEnd().split("\n");
        if (lines.length < 3) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROOF_ERROR",
            message: "too few lines in checkpoint header"
          });
        }
        const origin = lines[0];
        const logSize = BigInt(lines[1]);
        const rootHash = Buffer.from(lines[2], "base64");
        const rest = lines.slice(3);
        return new _LogCheckpoint(origin, logSize, rootHash, rest);
      }
    };
  }
});

// node_modules/@sigstore/verify/dist/timestamp/merkle.js
var require_merkle = __commonJS({
  "node_modules/@sigstore/verify/dist/timestamp/merkle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyMerkleInclusion = verifyMerkleInclusion;
    var core_1 = require_dist7();
    var error_1 = require_error9();
    var RFC6962_LEAF_HASH_PREFIX = Buffer.from([0]);
    var RFC6962_NODE_HASH_PREFIX = Buffer.from([1]);
    function verifyMerkleInclusion(entry) {
      const inclusionProof = entry.inclusionProof;
      const logIndex = BigInt(inclusionProof.logIndex);
      const treeSize = BigInt(inclusionProof.treeSize);
      if (logIndex < 0n || logIndex >= treeSize) {
        throw new error_1.VerificationError({
          code: "TLOG_INCLUSION_PROOF_ERROR",
          message: `invalid index: ${logIndex}`
        });
      }
      const { inner, border } = decompInclProof(logIndex, treeSize);
      if (inclusionProof.hashes.length !== inner + border) {
        throw new error_1.VerificationError({
          code: "TLOG_INCLUSION_PROOF_ERROR",
          message: "invalid hash count"
        });
      }
      const innerHashes = inclusionProof.hashes.slice(0, inner);
      const borderHashes = inclusionProof.hashes.slice(inner);
      const leafHash = hashLeaf(entry.canonicalizedBody);
      const calculatedHash = chainBorderRight(chainInner(leafHash, innerHashes, logIndex), borderHashes);
      if (!core_1.crypto.bufferEqual(calculatedHash, inclusionProof.rootHash)) {
        throw new error_1.VerificationError({
          code: "TLOG_INCLUSION_PROOF_ERROR",
          message: "calculated root hash does not match inclusion proof"
        });
      }
    }
    function decompInclProof(index, size) {
      const inner = innerProofSize(index, size);
      const border = onesCount(index >> BigInt(inner));
      return { inner, border };
    }
    function chainInner(seed, hashes, index) {
      return hashes.reduce((acc, h, i) => {
        if (index >> BigInt(i) & BigInt(1)) {
          return hashChildren(h, acc);
        } else {
          return hashChildren(acc, h);
        }
      }, seed);
    }
    function chainBorderRight(seed, hashes) {
      return hashes.reduce((acc, h) => hashChildren(h, acc), seed);
    }
    function innerProofSize(index, size) {
      return bitLength(index ^ size - BigInt(1));
    }
    function onesCount(num) {
      return num.toString(2).split("1").length - 1;
    }
    function bitLength(n) {
      if (n === 0n) {
        return 0;
      }
      return n.toString(2).length;
    }
    function hashChildren(left, right) {
      return core_1.crypto.digest("sha256", RFC6962_NODE_HASH_PREFIX, left, right);
    }
    function hashLeaf(leaf) {
      return core_1.crypto.digest("sha256", RFC6962_LEAF_HASH_PREFIX, leaf);
    }
  }
});

// node_modules/@sigstore/verify/dist/timestamp/set.js
var require_set = __commonJS({
  "node_modules/@sigstore/verify/dist/timestamp/set.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyTLogSET = verifyTLogSET;
    var core_1 = require_dist7();
    var error_1 = require_error9();
    var trust_1 = require_trust();
    function verifyTLogSET(entry, tlogs) {
      const validTLogs = (0, trust_1.filterTLogAuthorities)(tlogs, {
        logID: entry.logId.keyId,
        targetDate: new Date(Number(entry.integratedTime) * 1e3)
      });
      const verified = validTLogs.some((tlog) => {
        const payload = toVerificationPayload(entry);
        const data = Buffer.from(core_1.json.canonicalize(payload), "utf8");
        const signature = entry.inclusionPromise.signedEntryTimestamp;
        return core_1.crypto.verify(data, tlog.publicKey, signature);
      });
      if (!verified) {
        throw new error_1.VerificationError({
          code: "TLOG_INCLUSION_PROMISE_ERROR",
          message: "inclusion promise could not be verified"
        });
      }
    }
    function toVerificationPayload(entry) {
      const { integratedTime, logIndex, logId, canonicalizedBody } = entry;
      return {
        body: canonicalizedBody.toString("base64"),
        integratedTime: Number(integratedTime),
        logIndex: Number(logIndex),
        logID: logId.keyId.toString("hex")
      };
    }
  }
});

// node_modules/@sigstore/verify/dist/timestamp/tsa.js
var require_tsa3 = __commonJS({
  "node_modules/@sigstore/verify/dist/timestamp/tsa.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyRFC3161Timestamp = verifyRFC3161Timestamp;
    var core_1 = require_dist7();
    var error_1 = require_error9();
    var certificate_1 = require_certificate();
    var trust_1 = require_trust();
    function verifyRFC3161Timestamp(timestamp, data, timestampAuthorities) {
      const signingTime = timestamp.signingTime;
      timestampAuthorities = (0, trust_1.filterCertAuthorities)(timestampAuthorities, {
        start: signingTime,
        end: signingTime
      });
      timestampAuthorities = filterCAsBySerialAndIssuer(timestampAuthorities, {
        serialNumber: timestamp.signerSerialNumber,
        issuer: timestamp.signerIssuer
      });
      const verified = timestampAuthorities.some((ca) => {
        try {
          verifyTimestampForCA(timestamp, data, ca);
          return true;
        } catch (e) {
          return false;
        }
      });
      if (!verified) {
        throw new error_1.VerificationError({
          code: "TIMESTAMP_ERROR",
          message: "timestamp could not be verified"
        });
      }
    }
    function verifyTimestampForCA(timestamp, data, ca) {
      const [leaf, ...cas] = ca.certChain;
      const signingKey = core_1.crypto.createPublicKey(leaf.publicKey);
      const signingTime = timestamp.signingTime;
      try {
        new certificate_1.CertificateChainVerifier({
          untrustedCert: leaf,
          trustedCerts: cas
        }).verify();
      } catch (e) {
        throw new error_1.VerificationError({
          code: "TIMESTAMP_ERROR",
          message: "invalid certificate chain"
        });
      }
      const validAtSigningTime = ca.certChain.every((cert) => cert.validForDate(signingTime));
      if (!validAtSigningTime) {
        throw new error_1.VerificationError({
          code: "TIMESTAMP_ERROR",
          message: "timestamp was signed with an expired certificate"
        });
      }
      timestamp.verify(data, signingKey);
    }
    function filterCAsBySerialAndIssuer(timestampAuthorities, criteria) {
      return timestampAuthorities.filter((ca) => ca.certChain.length > 0 && core_1.crypto.bufferEqual(ca.certChain[0].serialNumber, criteria.serialNumber) && core_1.crypto.bufferEqual(ca.certChain[0].issuer, criteria.issuer));
    }
  }
});

// node_modules/@sigstore/verify/dist/timestamp/index.js
var require_timestamp4 = __commonJS({
  "node_modules/@sigstore/verify/dist/timestamp/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyTSATimestamp = verifyTSATimestamp;
    exports2.verifyTLogTimestamp = verifyTLogTimestamp;
    var error_1 = require_error9();
    var checkpoint_1 = require_checkpoint();
    var merkle_1 = require_merkle();
    var set_1 = require_set();
    var tsa_1 = require_tsa3();
    function verifyTSATimestamp(timestamp, data, timestampAuthorities) {
      (0, tsa_1.verifyRFC3161Timestamp)(timestamp, data, timestampAuthorities);
      return {
        type: "timestamp-authority",
        logID: timestamp.signerSerialNumber,
        timestamp: timestamp.signingTime
      };
    }
    function verifyTLogTimestamp(entry, tlogAuthorities) {
      let inclusionVerified = false;
      if (isTLogEntryWithInclusionPromise(entry)) {
        (0, set_1.verifyTLogSET)(entry, tlogAuthorities);
        inclusionVerified = true;
      }
      if (isTLogEntryWithInclusionProof(entry)) {
        (0, merkle_1.verifyMerkleInclusion)(entry);
        (0, checkpoint_1.verifyCheckpoint)(entry, tlogAuthorities);
        inclusionVerified = true;
      }
      if (!inclusionVerified) {
        throw new error_1.VerificationError({
          code: "TLOG_MISSING_INCLUSION_ERROR",
          message: "inclusion could not be verified"
        });
      }
      return {
        type: "transparency-log",
        logID: entry.logId.keyId,
        timestamp: new Date(Number(entry.integratedTime) * 1e3)
      };
    }
    function isTLogEntryWithInclusionPromise(entry) {
      return entry.inclusionPromise !== void 0;
    }
    function isTLogEntryWithInclusionProof(entry) {
      return entry.inclusionProof !== void 0;
    }
  }
});

// node_modules/@sigstore/verify/dist/tlog/dsse.js
var require_dsse4 = __commonJS({
  "node_modules/@sigstore/verify/dist/tlog/dsse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyDSSETLogBody = verifyDSSETLogBody;
    var error_1 = require_error9();
    function verifyDSSETLogBody(tlogEntry, content) {
      switch (tlogEntry.apiVersion) {
        case "0.0.1":
          return verifyDSSE001TLogBody(tlogEntry, content);
        default:
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: `unsupported dsse version: ${tlogEntry.apiVersion}`
          });
      }
    }
    function verifyDSSE001TLogBody(tlogEntry, content) {
      if (tlogEntry.spec.signatures?.length !== 1) {
        throw new error_1.VerificationError({
          code: "TLOG_BODY_ERROR",
          message: "signature count mismatch"
        });
      }
      const tlogSig = tlogEntry.spec.signatures[0].signature;
      if (!content.compareSignature(Buffer.from(tlogSig, "base64")))
        throw new error_1.VerificationError({
          code: "TLOG_BODY_ERROR",
          message: "tlog entry signature mismatch"
        });
      const tlogHash = tlogEntry.spec.payloadHash?.value || "";
      if (!content.compareDigest(Buffer.from(tlogHash, "hex"))) {
        throw new error_1.VerificationError({
          code: "TLOG_BODY_ERROR",
          message: "DSSE payload hash mismatch"
        });
      }
    }
  }
});

// node_modules/@sigstore/verify/dist/tlog/hashedrekord.js
var require_hashedrekord = __commonJS({
  "node_modules/@sigstore/verify/dist/tlog/hashedrekord.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyHashedRekordTLogBody = verifyHashedRekordTLogBody;
    var error_1 = require_error9();
    function verifyHashedRekordTLogBody(tlogEntry, content) {
      switch (tlogEntry.apiVersion) {
        case "0.0.1":
          return verifyHashedrekord001TLogBody(tlogEntry, content);
        default:
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: `unsupported hashedrekord version: ${tlogEntry.apiVersion}`
          });
      }
    }
    function verifyHashedrekord001TLogBody(tlogEntry, content) {
      const tlogSig = tlogEntry.spec.signature.content || "";
      if (!content.compareSignature(Buffer.from(tlogSig, "base64"))) {
        throw new error_1.VerificationError({
          code: "TLOG_BODY_ERROR",
          message: "signature mismatch"
        });
      }
      const tlogDigest = tlogEntry.spec.data.hash?.value || "";
      if (!content.compareDigest(Buffer.from(tlogDigest, "hex"))) {
        throw new error_1.VerificationError({
          code: "TLOG_BODY_ERROR",
          message: "digest mismatch"
        });
      }
    }
  }
});

// node_modules/@sigstore/verify/dist/tlog/intoto.js
var require_intoto = __commonJS({
  "node_modules/@sigstore/verify/dist/tlog/intoto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyIntotoTLogBody = verifyIntotoTLogBody;
    var error_1 = require_error9();
    function verifyIntotoTLogBody(tlogEntry, content) {
      switch (tlogEntry.apiVersion) {
        case "0.0.2":
          return verifyIntoto002TLogBody(tlogEntry, content);
        default:
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: `unsupported intoto version: ${tlogEntry.apiVersion}`
          });
      }
    }
    function verifyIntoto002TLogBody(tlogEntry, content) {
      if (tlogEntry.spec.content.envelope.signatures?.length !== 1) {
        throw new error_1.VerificationError({
          code: "TLOG_BODY_ERROR",
          message: "signature count mismatch"
        });
      }
      const tlogSig = base64Decode(tlogEntry.spec.content.envelope.signatures[0].sig);
      if (!content.compareSignature(Buffer.from(tlogSig, "base64"))) {
        throw new error_1.VerificationError({
          code: "TLOG_BODY_ERROR",
          message: "tlog entry signature mismatch"
        });
      }
      const tlogHash = tlogEntry.spec.content.payloadHash?.value || "";
      if (!content.compareDigest(Buffer.from(tlogHash, "hex"))) {
        throw new error_1.VerificationError({
          code: "TLOG_BODY_ERROR",
          message: "DSSE payload hash mismatch"
        });
      }
    }
    function base64Decode(str) {
      return Buffer.from(str, "base64").toString("utf-8");
    }
  }
});

// node_modules/@sigstore/verify/dist/tlog/index.js
var require_tlog2 = __commonJS({
  "node_modules/@sigstore/verify/dist/tlog/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyTLogBody = verifyTLogBody;
    var error_1 = require_error9();
    var dsse_1 = require_dsse4();
    var hashedrekord_1 = require_hashedrekord();
    var intoto_1 = require_intoto();
    function verifyTLogBody(entry, sigContent) {
      const { kind, version } = entry.kindVersion;
      const body = JSON.parse(entry.canonicalizedBody.toString("utf8"));
      if (kind !== body.kind || version !== body.apiVersion) {
        throw new error_1.VerificationError({
          code: "TLOG_BODY_ERROR",
          message: `kind/version mismatch - expected: ${kind}/${version}, received: ${body.kind}/${body.apiVersion}`
        });
      }
      switch (body.kind) {
        case "dsse":
          return (0, dsse_1.verifyDSSETLogBody)(body, sigContent);
        case "intoto":
          return (0, intoto_1.verifyIntotoTLogBody)(body, sigContent);
        case "hashedrekord":
          return (0, hashedrekord_1.verifyHashedRekordTLogBody)(body, sigContent);
        /* istanbul ignore next */
        default:
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: `unsupported kind: ${kind}`
          });
      }
    }
  }
});

// node_modules/@sigstore/verify/dist/verifier.js
var require_verifier = __commonJS({
  "node_modules/@sigstore/verify/dist/verifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Verifier = void 0;
    var util_1 = require("util");
    var error_1 = require_error9();
    var key_1 = require_key4();
    var policy_1 = require_policy2();
    var timestamp_1 = require_timestamp4();
    var tlog_1 = require_tlog2();
    var Verifier = class {
      constructor(trustMaterial, options = {}) {
        this.trustMaterial = trustMaterial;
        this.options = {
          ctlogThreshold: options.ctlogThreshold ?? 1,
          tlogThreshold: options.tlogThreshold ?? 1,
          tsaThreshold: options.tsaThreshold ?? 0
        };
      }
      verify(entity, policy) {
        const timestamps = this.verifyTimestamps(entity);
        const signer = this.verifySigningKey(entity, timestamps);
        this.verifyTLogs(entity);
        this.verifySignature(entity, signer);
        if (policy) {
          this.verifyPolicy(policy, signer.identity || {});
        }
        return signer;
      }
      // Checks that all of the timestamps in the entity are valid and returns them
      verifyTimestamps(entity) {
        let tlogCount = 0;
        let tsaCount = 0;
        const timestamps = entity.timestamps.map((timestamp) => {
          switch (timestamp.$case) {
            case "timestamp-authority":
              tsaCount++;
              return (0, timestamp_1.verifyTSATimestamp)(timestamp.timestamp, entity.signature.signature, this.trustMaterial.timestampAuthorities);
            case "transparency-log":
              tlogCount++;
              return (0, timestamp_1.verifyTLogTimestamp)(timestamp.tlogEntry, this.trustMaterial.tlogs);
          }
        });
        if (containsDupes(timestamps)) {
          throw new error_1.VerificationError({
            code: "TIMESTAMP_ERROR",
            message: "duplicate timestamp"
          });
        }
        if (tlogCount < this.options.tlogThreshold) {
          throw new error_1.VerificationError({
            code: "TIMESTAMP_ERROR",
            message: `expected ${this.options.tlogThreshold} tlog timestamps, got ${tlogCount}`
          });
        }
        if (tsaCount < this.options.tsaThreshold) {
          throw new error_1.VerificationError({
            code: "TIMESTAMP_ERROR",
            message: `expected ${this.options.tsaThreshold} tsa timestamps, got ${tsaCount}`
          });
        }
        return timestamps.map((t) => t.timestamp);
      }
      // Checks that the signing key is valid for all of the the supplied timestamps
      // and returns the signer.
      verifySigningKey({ key }, timestamps) {
        switch (key.$case) {
          case "public-key": {
            return (0, key_1.verifyPublicKey)(key.hint, timestamps, this.trustMaterial);
          }
          case "certificate": {
            const result = (0, key_1.verifyCertificate)(key.certificate, timestamps, this.trustMaterial);
            if (containsDupes(result.scts)) {
              throw new error_1.VerificationError({
                code: "CERTIFICATE_ERROR",
                message: "duplicate SCT"
              });
            }
            if (result.scts.length < this.options.ctlogThreshold) {
              throw new error_1.VerificationError({
                code: "CERTIFICATE_ERROR",
                message: `expected ${this.options.ctlogThreshold} SCTs, got ${result.scts.length}`
              });
            }
            return result.signer;
          }
        }
      }
      // Checks that the tlog entries are valid for the supplied content
      verifyTLogs({ signature: content, tlogEntries }) {
        tlogEntries.forEach((entry) => (0, tlog_1.verifyTLogBody)(entry, content));
      }
      // Checks that the signature is valid for the supplied content
      verifySignature(entity, signer) {
        if (!entity.signature.verifySignature(signer.key)) {
          throw new error_1.VerificationError({
            code: "SIGNATURE_ERROR",
            message: "signature verification failed"
          });
        }
      }
      verifyPolicy(policy, identity) {
        if (policy.subjectAlternativeName) {
          (0, policy_1.verifySubjectAlternativeName)(policy.subjectAlternativeName, identity.subjectAlternativeName);
        }
        if (policy.extensions) {
          (0, policy_1.verifyExtensions)(policy.extensions, identity.extensions);
        }
      }
    };
    exports2.Verifier = Verifier;
    function containsDupes(arr) {
      for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
          if ((0, util_1.isDeepStrictEqual)(arr[i], arr[j])) {
            return true;
          }
        }
      }
      return false;
    }
  }
});

// node_modules/@sigstore/verify/dist/index.js
var require_dist12 = __commonJS({
  "node_modules/@sigstore/verify/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Verifier = exports2.toTrustMaterial = exports2.VerificationError = exports2.PolicyError = exports2.toSignedEntity = void 0;
    var bundle_1 = require_bundle3();
    Object.defineProperty(exports2, "toSignedEntity", { enumerable: true, get: function() {
      return bundle_1.toSignedEntity;
    } });
    var error_1 = require_error9();
    Object.defineProperty(exports2, "PolicyError", { enumerable: true, get: function() {
      return error_1.PolicyError;
    } });
    Object.defineProperty(exports2, "VerificationError", { enumerable: true, get: function() {
      return error_1.VerificationError;
    } });
    var trust_1 = require_trust();
    Object.defineProperty(exports2, "toTrustMaterial", { enumerable: true, get: function() {
      return trust_1.toTrustMaterial;
    } });
    var verifier_1 = require_verifier();
    Object.defineProperty(exports2, "Verifier", { enumerable: true, get: function() {
      return verifier_1.Verifier;
    } });
  }
});

// node_modules/sigstore/dist/config.js
var require_config2 = __commonJS({
  "node_modules/sigstore/dist/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_TIMEOUT = exports2.DEFAULT_RETRY = void 0;
    exports2.createBundleBuilder = createBundleBuilder;
    exports2.createKeyFinder = createKeyFinder;
    exports2.createVerificationPolicy = createVerificationPolicy;
    var core_1 = require_dist7();
    var sign_1 = require_dist8();
    var verify_1 = require_dist12();
    exports2.DEFAULT_RETRY = { retries: 2 };
    exports2.DEFAULT_TIMEOUT = 5e3;
    function createBundleBuilder(bundleType, options) {
      const bundlerOptions = {
        signer: initSigner(options),
        witnesses: initWitnesses(options)
      };
      switch (bundleType) {
        case "messageSignature":
          return new sign_1.MessageSignatureBundleBuilder(bundlerOptions);
        case "dsseEnvelope":
          return new sign_1.DSSEBundleBuilder({
            ...bundlerOptions,
            certificateChain: options.legacyCompatibility
          });
      }
    }
    function createKeyFinder(keySelector) {
      return (hint) => {
        const key = keySelector(hint);
        if (!key) {
          throw new verify_1.VerificationError({
            code: "PUBLIC_KEY_ERROR",
            message: `key not found: ${hint}`
          });
        }
        return {
          publicKey: core_1.crypto.createPublicKey(key),
          validFor: () => true
        };
      };
    }
    function createVerificationPolicy(options) {
      const policy = {};
      const san = options.certificateIdentityEmail || options.certificateIdentityURI;
      if (san) {
        policy.subjectAlternativeName = san;
      }
      if (options.certificateIssuer) {
        policy.extensions = { issuer: options.certificateIssuer };
      }
      return policy;
    }
    function initSigner(options) {
      return new sign_1.FulcioSigner({
        fulcioBaseURL: options.fulcioURL,
        identityProvider: options.identityProvider || initIdentityProvider(options),
        retry: options.retry ?? exports2.DEFAULT_RETRY,
        timeout: options.timeout ?? exports2.DEFAULT_TIMEOUT
      });
    }
    function initIdentityProvider(options) {
      const token = options.identityToken;
      if (token) {
        return { getToken: () => Promise.resolve(token) };
      } else {
        return new sign_1.CIContextProvider("sigstore");
      }
    }
    function initWitnesses(options) {
      const witnesses = [];
      if (isRekorEnabled(options)) {
        witnesses.push(new sign_1.RekorWitness({
          rekorBaseURL: options.rekorURL,
          entryType: options.legacyCompatibility ? "intoto" : "dsse",
          fetchOnConflict: false,
          retry: options.retry ?? exports2.DEFAULT_RETRY,
          timeout: options.timeout ?? exports2.DEFAULT_TIMEOUT
        }));
      }
      if (isTSAEnabled(options)) {
        witnesses.push(new sign_1.TSAWitness({
          tsaBaseURL: options.tsaServerURL,
          retry: options.retry ?? exports2.DEFAULT_RETRY,
          timeout: options.timeout ?? exports2.DEFAULT_TIMEOUT
        }));
      }
      return witnesses;
    }
    function isRekorEnabled(options) {
      return options.tlogUpload !== false;
    }
    function isTSAEnabled(options) {
      return options.tsaServerURL !== void 0;
    }
  }
});

// node_modules/sigstore/dist/sigstore.js
var require_sigstore = __commonJS({
  "node_modules/sigstore/dist/sigstore.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sign = sign;
    exports2.attest = attest;
    exports2.verify = verify;
    exports2.createVerifier = createVerifier;
    var bundle_1 = require_dist6();
    var tuf = __importStar(require_dist11());
    var verify_1 = require_dist12();
    var config = __importStar(require_config2());
    async function sign(payload, options = {}) {
      const bundler = config.createBundleBuilder("messageSignature", options);
      const bundle = await bundler.create({ data: payload });
      return (0, bundle_1.bundleToJSON)(bundle);
    }
    async function attest(payload, payloadType, options = {}) {
      const bundler = config.createBundleBuilder("dsseEnvelope", options);
      const bundle = await bundler.create({ data: payload, type: payloadType });
      return (0, bundle_1.bundleToJSON)(bundle);
    }
    async function verify(bundle, dataOrOptions, options) {
      let data;
      if (Buffer.isBuffer(dataOrOptions)) {
        data = dataOrOptions;
      } else {
        options = dataOrOptions;
      }
      return createVerifier(options).then((verifier) => verifier.verify(bundle, data));
    }
    async function createVerifier(options = {}) {
      const trustedRoot = await tuf.getTrustedRoot({
        mirrorURL: options.tufMirrorURL,
        rootPath: options.tufRootPath,
        cachePath: options.tufCachePath,
        forceCache: options.tufForceCache,
        retry: options.retry ?? config.DEFAULT_RETRY,
        timeout: options.timeout ?? config.DEFAULT_TIMEOUT
      });
      const keyFinder = options.keySelector ? config.createKeyFinder(options.keySelector) : void 0;
      const trustMaterial = (0, verify_1.toTrustMaterial)(trustedRoot, keyFinder);
      const verifierOptions = {
        ctlogThreshold: options.ctLogThreshold,
        tlogThreshold: options.tlogThreshold
      };
      const verifier = new verify_1.Verifier(trustMaterial, verifierOptions);
      const policy = config.createVerificationPolicy(options);
      return {
        verify: (bundle, payload) => {
          const deserializedBundle = (0, bundle_1.bundleFromJSON)(bundle);
          const signedEntity = (0, verify_1.toSignedEntity)(deserializedBundle, payload);
          verifier.verify(signedEntity, policy);
          return;
        }
      };
    }
  }
});

// node_modules/sigstore/dist/index.js
var require_dist13 = __commonJS({
  "node_modules/sigstore/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verify = exports2.sign = exports2.createVerifier = exports2.attest = exports2.VerificationError = exports2.PolicyError = exports2.TUFError = exports2.InternalError = exports2.DEFAULT_REKOR_URL = exports2.DEFAULT_FULCIO_URL = exports2.ValidationError = void 0;
    var bundle_1 = require_dist6();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return bundle_1.ValidationError;
    } });
    var sign_1 = require_dist8();
    Object.defineProperty(exports2, "DEFAULT_FULCIO_URL", { enumerable: true, get: function() {
      return sign_1.DEFAULT_FULCIO_URL;
    } });
    Object.defineProperty(exports2, "DEFAULT_REKOR_URL", { enumerable: true, get: function() {
      return sign_1.DEFAULT_REKOR_URL;
    } });
    Object.defineProperty(exports2, "InternalError", { enumerable: true, get: function() {
      return sign_1.InternalError;
    } });
    var tuf_1 = require_dist11();
    Object.defineProperty(exports2, "TUFError", { enumerable: true, get: function() {
      return tuf_1.TUFError;
    } });
    var verify_1 = require_dist12();
    Object.defineProperty(exports2, "PolicyError", { enumerable: true, get: function() {
      return verify_1.PolicyError;
    } });
    Object.defineProperty(exports2, "VerificationError", { enumerable: true, get: function() {
      return verify_1.VerificationError;
    } });
    var sigstore_1 = require_sigstore();
    Object.defineProperty(exports2, "attest", { enumerable: true, get: function() {
      return sigstore_1.attest;
    } });
    Object.defineProperty(exports2, "createVerifier", { enumerable: true, get: function() {
      return sigstore_1.createVerifier;
    } });
    Object.defineProperty(exports2, "sign", { enumerable: true, get: function() {
      return sigstore_1.sign;
    } });
    Object.defineProperty(exports2, "verify", { enumerable: true, get: function() {
      return sigstore_1.verify;
    } });
  }
});

// node_modules/pacote/lib/registry.js
var require_registry = __commonJS({
  "node_modules/pacote/lib/registry.js"(exports2, module2) {
    var crypto = require("node:crypto");
    var PackageJson = require_lib13();
    var pickManifest = require_lib11();
    var ssri = require_lib15();
    var npa = require_npa();
    var sigstore = require_dist13();
    var fetch = require_lib31();
    var Fetcher = require_fetcher2();
    var RemoteFetcher = require_remote2();
    var pacoteVersion = require_package5().version;
    var removeTrailingSlashes = require_trailing_slashes();
    var _ = require_protected();
    var corgiDoc = "application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*";
    var fullDoc = "application/json";
    var MISSING_TIME_CUTOFF = "2015-01-01T00:00:00.000Z";
    var RegistryFetcher = class extends Fetcher {
      #cacheKey;
      constructor(spec, opts) {
        super(spec, opts);
        this.packumentCache = this.opts.packumentCache || null;
        this.registry = fetch.pickRegistry(spec, opts);
        this.packumentUrl = `${removeTrailingSlashes(this.registry)}/${this.spec.escapedName}`;
        this.#cacheKey = `${this.fullMetadata ? "full" : "corgi"}:${this.packumentUrl}`;
        const parsed = new URL(this.registry);
        const regKey = `//${parsed.host}${parsed.pathname}`;
        if (this.opts[`${regKey}:_keys`]) {
          this.registryKeys = this.opts[`${regKey}:_keys`];
        }
      }
      async resolve() {
        await this.manifest();
        if (!this.resolved) {
          throw Object.assign(
            new Error("Invalid package manifest: no `dist.tarball` field"),
            { package: this.spec.toString() }
          );
        }
        return this.resolved;
      }
      #headers() {
        return {
          // npm will override UA, but ensure that we always send *something*
          "user-agent": this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,
          ...this.opts.headers || {},
          "pacote-version": pacoteVersion,
          "pacote-req-type": "packument",
          "pacote-pkg-id": `registry:${this.spec.name}`,
          accept: this.fullMetadata ? fullDoc : corgiDoc
        };
      }
      async packument() {
        if (this.packumentCache?.has(this.#cacheKey)) {
          return this.packumentCache.get(this.#cacheKey);
        }
        try {
          const res = await fetch(this.packumentUrl, {
            ...this.opts,
            headers: this.#headers(),
            spec: this.spec,
            // never check integrity for packuments themselves
            integrity: null
          });
          const packument = await res.json();
          const contentLength = res.headers.get("content-length");
          if (contentLength) {
            packument._contentLength = Number(contentLength);
          }
          this.packumentCache?.set(this.#cacheKey, packument);
          return packument;
        } catch (err) {
          this.packumentCache?.delete(this.#cacheKey);
          if (err.code !== "E404" || this.fullMetadata) {
            throw err;
          }
          this.fullMetadata = true;
          return this.packument();
        }
      }
      async manifest() {
        if (this.package) {
          return this.package;
        }
        if (this.opts.verifySignatures) {
          this.fullMetadata = true;
        }
        const packument = await this.packument();
        const steps = PackageJson.normalizeSteps.filter((s) => s !== "_attributes");
        const mani = await new PackageJson().fromContent(pickManifest(packument, this.spec.fetchSpec, {
          ...this.opts,
          defaultTag: this.defaultTag,
          before: this.before
        })).normalize({ steps }).then((p) => p.content);
        const time = packument.time?.[mani.version];
        if (time) {
          mani._time = time;
        }
        const { dist } = mani;
        if (dist) {
          this.resolved = mani._resolved = dist.tarball;
          mani._from = this.from;
          const distIntegrity = dist.integrity ? ssri.parse(dist.integrity) : dist.shasum ? ssri.fromHex(dist.shasum, "sha1", { ...this.opts }) : null;
          if (distIntegrity) {
            if (this.integrity && !this.integrity.match(distIntegrity)) {
              for (const algo of Object.keys(this.integrity)) {
                if (distIntegrity[algo]) {
                  throw Object.assign(new Error(
                    `Integrity checksum failed when using ${algo}: wanted ${this.integrity} but got ${distIntegrity}.`
                  ), { code: "EINTEGRITY" });
                }
              }
            }
            this.integrity = distIntegrity;
          }
        }
        if (this.integrity) {
          mani._integrity = String(this.integrity);
          if (dist.signatures) {
            if (this.opts.verifySignatures) {
              const message = `${mani._id}:${mani._integrity}`;
              for (const signature of dist.signatures) {
                const publicKey = this.registryKeys && this.registryKeys.filter((key) => key.keyid === signature.keyid)[0];
                if (!publicKey) {
                  throw Object.assign(new Error(
                    `${mani._id} has a registry signature with keyid: ${signature.keyid} but no corresponding public key can be found`
                  ), { code: "EMISSINGSIGNATUREKEY" });
                }
                const publishedTime = Date.parse(mani._time || MISSING_TIME_CUTOFF);
                const validPublicKey = !publicKey.expires || publishedTime < Date.parse(publicKey.expires);
                if (!validPublicKey) {
                  throw Object.assign(new Error(
                    `${mani._id} has a registry signature with keyid: ${signature.keyid} but the corresponding public key has expired ${publicKey.expires}`
                  ), { code: "EEXPIREDSIGNATUREKEY" });
                }
                const verifier = crypto.createVerify("SHA256");
                verifier.write(message);
                verifier.end();
                const valid = verifier.verify(
                  publicKey.pemkey,
                  signature.sig,
                  "base64"
                );
                if (!valid) {
                  throw Object.assign(new Error(
                    `${mani._id} has an invalid registry signature with keyid: ${publicKey.keyid} and signature: ${signature.sig}`
                  ), {
                    code: "EINTEGRITYSIGNATURE",
                    keyid: publicKey.keyid,
                    signature: signature.sig,
                    resolved: mani._resolved,
                    integrity: mani._integrity
                  });
                }
              }
              mani._signatures = dist.signatures;
            } else {
              mani._signatures = dist.signatures;
            }
          }
          if (dist.attestations) {
            if (this.opts.verifyAttestations) {
              const attestationsPath = new URL(dist.attestations.url).pathname;
              const attestationsUrl = removeTrailingSlashes(this.registry) + attestationsPath;
              const res = await fetch(attestationsUrl, {
                ...this.opts,
                // disable integrity check for attestations json payload, we check the
                // integrity in the verification steps below
                integrity: null
              });
              const { attestations } = await res.json();
              const bundles = attestations.map(({ predicateType, bundle }) => {
                const statement = JSON.parse(
                  Buffer.from(bundle.dsseEnvelope.payload, "base64").toString("utf8")
                );
                const keyid = bundle.dsseEnvelope.signatures[0].keyid;
                const signature = bundle.dsseEnvelope.signatures[0].sig;
                return {
                  predicateType,
                  bundle,
                  statement,
                  keyid,
                  signature
                };
              });
              const attestationKeyIds = bundles.map((b) => b.keyid).filter((k) => !!k);
              const attestationRegistryKeys = (this.registryKeys || []).filter((key) => attestationKeyIds.includes(key.keyid));
              if (!attestationRegistryKeys.length) {
                throw Object.assign(new Error(
                  `${mani._id} has attestations but no corresponding public key(s) can be found`
                ), { code: "EMISSINGSIGNATUREKEY" });
              }
              for (const { predicateType, bundle, keyid, signature, statement } of bundles) {
                const publicKey = attestationRegistryKeys.find((key) => key.keyid === keyid);
                if (keyid) {
                  if (!publicKey) {
                    throw Object.assign(new Error(
                      `${mani._id} has attestations with keyid: ${keyid} but no corresponding public key can be found`
                    ), { code: "EMISSINGSIGNATUREKEY" });
                  }
                  const integratedTime = new Date(
                    Number(
                      bundle.verificationMaterial.tlogEntries[0].integratedTime
                    ) * 1e3
                  );
                  const validPublicKey = !publicKey.expires || integratedTime < Date.parse(publicKey.expires);
                  if (!validPublicKey) {
                    throw Object.assign(new Error(
                      `${mani._id} has attestations with keyid: ${keyid} but the corresponding public key has expired ${publicKey.expires}`
                    ), { code: "EEXPIREDSIGNATUREKEY" });
                  }
                }
                const subject = {
                  name: statement.subject[0].name,
                  sha512: statement.subject[0].digest.sha512
                };
                const purl = this.spec.type === "version" ? npa.toPurl(this.spec) : this.spec;
                if (subject.name !== purl) {
                  throw Object.assign(new Error(
                    `${mani._id} package name and version (PURL): ${purl} doesn't match what was signed: ${subject.name}`
                  ), { code: "EATTESTATIONSUBJECT" });
                }
                const integrityHexDigest = ssri.parse(this.integrity).hexDigest();
                if (subject.sha512 !== integrityHexDigest) {
                  throw Object.assign(new Error(
                    `${mani._id} package integrity (hex digest): ${integrityHexDigest} doesn't match what was signed: ${subject.sha512}`
                  ), { code: "EATTESTATIONSUBJECT" });
                }
                try {
                  const options = {
                    tufCachePath: this.tufCache,
                    tufForceCache: true,
                    keySelector: publicKey ? () => publicKey.pemkey : void 0
                  };
                  await sigstore.verify(bundle, options);
                } catch (e) {
                  throw Object.assign(new Error(
                    `${mani._id} failed to verify attestation: ${e.message}`
                  ), {
                    code: "EATTESTATIONVERIFY",
                    predicateType,
                    keyid,
                    signature,
                    resolved: mani._resolved,
                    integrity: mani._integrity
                  });
                }
              }
              mani._attestations = dist.attestations;
            } else {
              mani._attestations = dist.attestations;
            }
          }
        }
        this.package = mani;
        return this.package;
      }
      [_.tarballFromResolved]() {
        return new RemoteFetcher(this.resolved, {
          ...this.opts,
          resolved: this.resolved,
          pkgid: `registry:${this.spec.name}@${this.resolved}`
        })[_.tarballFromResolved]();
      }
      get types() {
        return [
          "tag",
          "version",
          "range"
        ];
      }
    };
    module2.exports = RegistryFetcher;
  }
});

// node_modules/pacote/lib/fetcher.js
var require_fetcher2 = __commonJS({
  "node_modules/pacote/lib/fetcher.js"(exports2, module2) {
    var { basename, dirname } = require("node:path");
    var { rm, mkdir } = require("node:fs/promises");
    var PackageJson = require_lib13();
    var cacache = require_lib20();
    var fsm = require_lib19();
    var getContents = require_lib22();
    var npa = require_npa();
    var retry = require_promise_retry();
    var ssri = require_lib15();
    var tar = require_tar();
    var { Minipass } = require_commonjs3();
    var { log } = require_lib4();
    var _ = require_protected();
    var cacheDir = require_cache_dir();
    var isPackageBin = require_is_package_bin();
    var removeTrailingSlashes = require_trailing_slashes();
    var packageJsonPrepare = (p) => PackageJson.prepare(p).then((pkg) => pkg.content);
    var packageJsonNormalize = (p) => PackageJson.normalize(p).then((pkg) => pkg.content);
    var FetcherBase = class {
      constructor(spec, opts) {
        if (!opts || typeof opts !== "object") {
          throw new TypeError("options object is required");
        }
        this.spec = npa(spec, opts.where);
        this.allowGitIgnore = !!opts.allowGitIgnore;
        this.from = this.spec.registry ? `${this.spec.name}@${this.spec.rawSpec}` : this.spec.saveSpec;
        this.#assertType();
        this.opts = { ...opts };
        this.cache = opts.cache || cacheDir().cacache;
        this.tufCache = opts.tufCache || cacheDir().tufcache;
        this.resolved = opts.resolved || null;
        this.defaultIntegrityAlgorithm = opts.defaultIntegrityAlgorithm || "sha512";
        if (typeof opts.integrity === "string") {
          this.opts.integrity = ssri.parse(opts.integrity);
        }
        this.package = null;
        this.type = this.constructor.name;
        this.fmode = opts.fmode || 438;
        this.dmode = opts.dmode || 511;
        this.umask = opts.umask || 0;
        this.preferOnline = !!opts.preferOnline;
        this.preferOffline = !!opts.preferOffline;
        this.offline = !!opts.offline;
        this.before = opts.before;
        this.fullMetadata = this.before ? true : !!opts.fullMetadata;
        this.fullReadJson = !!opts.fullReadJson;
        this[_.readPackageJson] = this.fullReadJson ? packageJsonPrepare : packageJsonNormalize;
        this.replaceRegistryHost = !opts.replaceRegistryHost || opts.replaceRegistryHost === "npmjs" ? "registry.npmjs.org" : opts.replaceRegistryHost;
        this.defaultTag = opts.defaultTag || "latest";
        this.registry = removeTrailingSlashes(opts.registry || "https://registry.npmjs.org");
        this.npmBin = opts.npmBin || "npm";
        this.npmInstallCmd = opts.npmInstallCmd || ["install", "--force"];
        this.npmCliConfig = opts.npmCliConfig || [
          `--cache=${dirname(this.cache)}`,
          `--prefer-offline=${!!this.preferOffline}`,
          `--prefer-online=${!!this.preferOnline}`,
          `--offline=${!!this.offline}`,
          ...this.before ? [`--before=${this.before.toISOString()}`] : [],
          "--no-progress",
          "--no-save",
          "--no-audit",
          // override any omit settings from the environment
          "--include=dev",
          "--include=peer",
          "--include=optional",
          // we need the actual things, not just the lockfile
          "--no-package-lock-only",
          "--no-dry-run"
        ];
      }
      get integrity() {
        return this.opts.integrity || null;
      }
      set integrity(i) {
        if (!i) {
          return;
        }
        i = ssri.parse(i);
        const current = this.opts.integrity;
        if (current) {
          current.merge(i);
        } else {
          this.opts.integrity = i;
        }
      }
      get notImplementedError() {
        return new Error("not implemented in this fetcher type: " + this.type);
      }
      // override in child classes
      // Returns a Promise that resolves to this.resolved string value
      resolve() {
        return this.resolved ? Promise.resolve(this.resolved) : Promise.reject(this.notImplementedError);
      }
      packument() {
        return Promise.reject(this.notImplementedError);
      }
      // override in child class
      // returns a manifest containing:
      // - name
      // - version
      // - _resolved
      // - _integrity
      // - plus whatever else was in there (corgi, full metadata, or pj file)
      manifest() {
        return Promise.reject(this.notImplementedError);
      }
      // private, should be overridden.
      // Note that they should *not* calculate or check integrity or cache,
      // but *just*  return the raw tarball data stream.
      [_.tarballFromResolved]() {
        throw this.notImplementedError;
      }
      // public, should not be overridden
      tarball() {
        return this.tarballStream((stream) => stream.concat().then((data) => {
          data.integrity = this.integrity && String(this.integrity);
          data.resolved = this.resolved;
          data.from = this.from;
          return data;
        }));
      }
      // private
      // Note: cacache will raise a EINTEGRITY error if the integrity doesn't match
      #tarballFromCache() {
        const startTime = Date.now();
        const stream = cacache.get.stream.byDigest(this.cache, this.integrity, this.opts);
        const elapsedTime = Date.now() - startTime;
        log.http(
          "cache",
          `${this.spec} ${elapsedTime}ms (cache hit)`
        );
        return stream;
      }
      get [_.cacheFetches]() {
        return true;
      }
      #istream(stream) {
        if (!this.opts.cache || !this[_.cacheFetches]) {
          if (stream.hasIntegrityEmitter) {
            stream.on("integrity", (i) => this.integrity = i);
            return stream;
          }
          const istream = ssri.integrityStream(this.opts);
          istream.on("integrity", (i) => this.integrity = i);
          stream.on("error", (err) => istream.emit("error", err));
          return stream.pipe(istream);
        }
        const middleStream = new Minipass();
        stream.on("error", (err) => middleStream.emit("error", err));
        stream.pipe(middleStream, { end: false });
        const cstream = cacache.put.stream(
          this.opts.cache,
          `pacote:tarball:${this.from}`,
          this.opts
        );
        cstream.on("integrity", (i) => this.integrity = i);
        cstream.on("error", (err) => stream.emit("error", err));
        stream.pipe(cstream);
        cstream.promise().catch(() => {
        }).then(() => middleStream.end());
        return middleStream;
      }
      pickIntegrityAlgorithm() {
        return this.integrity ? this.integrity.pickAlgorithm(this.opts) : this.defaultIntegrityAlgorithm;
      }
      // TODO: check error class, once those are rolled out to our deps
      isDataCorruptionError(er) {
        return er.code === "EINTEGRITY" || er.code === "Z_DATA_ERROR";
      }
      // override the types getter
      get types() {
        return false;
      }
      #assertType() {
        if (this.types && !this.types.includes(this.spec.type)) {
          throw new TypeError(`Wrong spec type (${this.spec.type}) for ${this.constructor.name}. Supported types: ${this.types.join(", ")}`);
        }
      }
      // We allow ENOENTs from cacache, but not anywhere else.
      // An ENOENT trying to read a tgz file, for example, is Right Out.
      isRetriableError(er) {
        return this.isDataCorruptionError(er) || er.code === "ENOENT" || er.code === "EISDIR";
      }
      // Mostly internal, but has some uses
      // Pass in a function which returns a promise
      // Function will be called 1 or more times with streams that may fail.
      // Retries:
      // Function MUST handle errors on the stream by rejecting the promise,
      // so that retry logic can pick it up and either retry or fail whatever
      // promise it was making (ie, failing extraction, etc.)
      //
      // The return value of this method is a Promise that resolves the same
      // as whatever the streamHandler resolves to.
      //
      // This should never be overridden by child classes, but it is public.
      tarballStream(streamHandler) {
        const fromCache = !this.preferOnline && this.integrity && this.resolved ? streamHandler(this.#tarballFromCache()).catch((er) => {
          if (this.isDataCorruptionError(er)) {
            log.warn("tarball", `cached data for ${this.spec} (${this.integrity}) seems to be corrupted. Refreshing cache.`);
            return this.cleanupCached().then(() => {
              throw er;
            });
          } else {
            throw er;
          }
        }) : null;
        const fromResolved = (er) => {
          if (er) {
            if (!this.isRetriableError(er)) {
              throw er;
            }
            log.silly("tarball", `no local data for ${this.spec}. Extracting by manifest.`);
          }
          return this.resolve().then(() => retry((tryAgain) => streamHandler(this.#istream(this[_.tarballFromResolved]())).catch((streamErr) => {
            if (this.isRetriableError(streamErr)) {
              log.warn("tarball", `tarball data for ${this.spec} (${this.integrity}) seems to be corrupted. Trying again.`);
              return this.cleanupCached().then(() => tryAgain(streamErr));
            }
            throw streamErr;
          }), { retries: 1, minTimeout: 0, maxTimeout: 0 }));
        };
        return fromCache ? fromCache.catch(fromResolved) : fromResolved();
      }
      cleanupCached() {
        return cacache.rm.content(this.cache, this.integrity, this.opts);
      }
      #empty(path) {
        return getContents({ path, depth: 1 }).then((contents) => Promise.all(
          contents.map((entry) => rm(entry, { recursive: true, force: true }))
        ));
      }
      async #mkdir(dest) {
        await this.#empty(dest);
        return await mkdir(dest, { recursive: true });
      }
      // extraction is always the same.  the only difference is where
      // the tarball comes from.
      async extract(dest) {
        await this.#mkdir(dest);
        return this.tarballStream((tarball) => this.#extract(dest, tarball));
      }
      #toFile(dest) {
        return this.tarballStream((str) => new Promise((res, rej) => {
          const writer = new fsm.WriteStream(dest);
          str.on("error", (er) => writer.emit("error", er));
          writer.on("error", (er) => rej(er));
          writer.on("close", () => res({
            integrity: this.integrity && String(this.integrity),
            resolved: this.resolved,
            from: this.from
          }));
          str.pipe(writer);
        }));
      }
      // don't use this.#mkdir because we don't want to rimraf anything
      async tarballFile(dest) {
        const dir = dirname(dest);
        await mkdir(dir, { recursive: true });
        return this.#toFile(dest);
      }
      #extract(dest, tarball) {
        const extractor = tar.x(this.#tarxOptions({ cwd: dest }));
        const p = new Promise((resolve, reject) => {
          extractor.on("end", () => {
            resolve({
              resolved: this.resolved,
              integrity: this.integrity && String(this.integrity),
              from: this.from
            });
          });
          extractor.on("error", (er) => {
            log.warn("tar", er.message);
            log.silly("tar", er);
            reject(er);
          });
          tarball.on("error", (er) => reject(er));
        });
        tarball.pipe(extractor);
        return p;
      }
      // always ensure that entries are at least as permissive as our configured
      // dmode/fmode, but never more permissive than the umask allows.
      #entryMode(path, mode, type) {
        const m = /Directory|GNUDumpDir/.test(type) ? this.dmode : /File$/.test(type) ? this.fmode : (
          /* istanbul ignore next - should never happen in a pkg */
          0
        );
        const exe = isPackageBin(this.package, path) ? 73 : 0;
        return (mode | m) & ~this.umask | exe | 384;
      }
      #tarxOptions({ cwd }) {
        const sawIgnores = /* @__PURE__ */ new Set();
        return {
          cwd,
          noChmod: true,
          noMtime: true,
          filter: (name, entry) => {
            if (/Link$/.test(entry.type)) {
              return false;
            }
            entry.mode = this.#entryMode(entry.path, entry.mode, entry.type);
            if (/File$/.test(entry.type)) {
              const base = basename(entry.path);
              if (base === ".npmignore") {
                sawIgnores.add(entry.path);
              } else if (base === ".gitignore" && !this.allowGitIgnore) {
                const ni = entry.path.replace(/\.gitignore$/, ".npmignore");
                if (sawIgnores.has(ni)) {
                  return false;
                }
                entry.path = ni;
              }
              return true;
            }
          },
          strip: 1,
          onwarn: (
            /* istanbul ignore next - we can trust that tar logs */
            (code, msg, data) => {
              log.warn("tar", code, msg);
              log.silly("tar", code, msg, data);
            }
          ),
          umask: this.umask,
          // always ignore ownership info from tarball metadata
          preserveOwner: false
        };
      }
    };
    module2.exports = FetcherBase;
    var GitFetcher = require_git();
    var RegistryFetcher = require_registry();
    var FileFetcher = require_file();
    var DirFetcher = require_dir();
    var RemoteFetcher = require_remote2();
    FetcherBase.get = (rawSpec, opts = {}) => {
      const spec = npa(rawSpec, opts.where);
      switch (spec.type) {
        case "git":
          return new GitFetcher(spec, opts);
        case "remote":
          return new RemoteFetcher(spec, opts);
        case "version":
        case "range":
        case "tag":
        case "alias":
          return new RegistryFetcher(spec.subSpec || spec, opts);
        case "file":
          return new FileFetcher(spec, opts);
        case "directory":
          return new DirFetcher(spec, opts);
        default:
          throw new TypeError("Unknown spec type: " + spec.type);
      }
    };
  }
});

// node_modules/pacote/lib/index.js
var require_lib33 = __commonJS({
  "node_modules/pacote/lib/index.js"(exports2, module2) {
    var { get } = require_fetcher2();
    var GitFetcher = require_git();
    var RegistryFetcher = require_registry();
    var FileFetcher = require_file();
    var DirFetcher = require_dir();
    var RemoteFetcher = require_remote2();
    var tarball = (spec, opts) => get(spec, opts).tarball();
    tarball.stream = (spec, handler, opts) => get(spec, opts).tarballStream(handler);
    tarball.file = (spec, dest, opts) => get(spec, opts).tarballFile(dest);
    module2.exports = {
      GitFetcher,
      RegistryFetcher,
      FileFetcher,
      DirFetcher,
      RemoteFetcher,
      resolve: (spec, opts) => get(spec, opts).resolve(),
      extract: (spec, dest, opts) => get(spec, opts).extract(dest),
      manifest: (spec, opts) => get(spec, opts).manifest(),
      packument: (spec, opts) => get(spec, opts).packument(),
      tarball
    };
  }
});

// node_modules/@npmcli/metavuln-calculator/lib/hash.js
var require_hash = __commonJS({
  "node_modules/@npmcli/metavuln-calculator/lib/hash.js"(exports2, module2) {
    var { createHash } = require("crypto");
    module2.exports = ({ name, source }) => createHash("sha512").update(JSON.stringify([name, source])).digest("base64");
  }
});

// node_modules/@npmcli/metavuln-calculator/lib/get-dep-spec.js
var require_get_dep_spec = __commonJS({
  "node_modules/@npmcli/metavuln-calculator/lib/get-dep-spec.js"(exports2, module2) {
    module2.exports = (mani, name) => {
      const {
        dependencies: deps = {},
        optionalDependencies: optDeps = {},
        peerDependencies: peerDeps = {}
      } = mani;
      return deps && typeof deps[name] === "string" ? deps[name] : optDeps && typeof optDeps[name] === "string" ? optDeps[name] : peerDeps && typeof peerDeps[name] === "string" ? peerDeps[name] : null;
    };
  }
});

// node_modules/@npmcli/metavuln-calculator/lib/advisory.js
var require_advisory = __commonJS({
  "node_modules/@npmcli/metavuln-calculator/lib/advisory.js"(exports2, module2) {
    var hash = require_hash();
    var semver = require_semver2();
    var semverOpt = { includePrerelease: true, loose: true };
    var getDepSpec = require_get_dep_spec();
    var _source = Symbol("source");
    var _packument = Symbol("packument");
    var _versionVulnMemo = Symbol("versionVulnMemo");
    var _updated = Symbol("updated");
    var _options = Symbol("options");
    var _specVulnMemo = Symbol("specVulnMemo");
    var _testVersion = Symbol("testVersion");
    var _testVersions = Symbol("testVersions");
    var _calculateRange = Symbol("calculateRange");
    var _markVulnerable = Symbol("markVulnerable");
    var _testSpec = Symbol("testSpec");
    var Advisory = class {
      constructor(name, source, options = {}) {
        this.source = source.id;
        this[_source] = source;
        this[_options] = options;
        this.name = name;
        if (!source.name) {
          source.name = name;
        }
        this.dependency = source.name;
        if (this.type === "advisory") {
          this.title = source.title;
          this.url = source.url;
        } else {
          this.title = `Depends on vulnerable versions of ${source.name}`;
          this.url = null;
        }
        this.severity = source.severity || "high";
        this.versions = [];
        this.vulnerableVersions = [];
        this.cwe = source.cwe;
        this.cvss = source.cvss;
        this.range = this.type === "advisory" ? source.vulnerable_versions || "*" : null;
        this.id = hash(this);
        this[_packument] = null;
        this[_versionVulnMemo] = /* @__PURE__ */ new Map();
        this[_specVulnMemo] = /* @__PURE__ */ new Map();
        this[_updated] = false;
      }
      // true if we updated from what we had in cache
      get updated() {
        return this[_updated];
      }
      get type() {
        return this.dependency === this.name ? "advisory" : "metavuln";
      }
      get packument() {
        return this[_packument];
      }
      // load up the data from a cache entry and a fetched packument
      load(cached, packument) {
        if (!cached || typeof cached !== "object") {
          throw new TypeError("invalid cached data, expected object");
        }
        if (!packument || typeof packument !== "object") {
          throw new TypeError("invalid packument data, expected object");
        }
        if (cached.id && cached.id !== this.id) {
          throw Object.assign(new Error("loading from incorrect cache entry"), {
            expected: this.id,
            actual: cached.id
          });
        }
        if (packument.name !== this.name) {
          throw Object.assign(new Error("loading from incorrect packument"), {
            expected: this.name,
            actual: packument.name
          });
        }
        if (this[_packument]) {
          throw new Error("advisory object already loaded");
        }
        if (!this.range || cached.range && cached.range === this.range) {
          Object.assign(this, cached);
        }
        this[_packument] = packument;
        const pakuVersions = Object.keys(packument.versions || {});
        const allVersions = /* @__PURE__ */ new Set([...pakuVersions, ...this.versions]);
        const versionsAdded = [];
        const versionsRemoved = [];
        for (const v of allVersions) {
          if (!this.versions.includes(v)) {
            versionsAdded.push(v);
            this.versions.push(v);
          } else if (!pakuVersions.includes(v)) {
            versionsRemoved.push(v);
          }
        }
        this.versions = semver.sort(this.versions.filter((v) => !versionsRemoved.includes(v)), semverOpt);
        const unchanged = this.type === "advisory" ? this.range && this.range === cached.range : !this[_source].updated;
        this.vulnerableVersions = !unchanged ? [] : semver.sort(this.vulnerableVersions.filter((v) => !versionsRemoved.includes(v)), semverOpt);
        if (unchanged && !versionsAdded.length && !versionsRemoved.length) {
          return this;
        }
        this[_updated] = true;
        if (!unchanged || versionsAdded.length) {
          this[_testVersions](unchanged ? versionsAdded : this.versions);
        }
        this.vulnerableVersions = semver.sort(this.vulnerableVersions, semverOpt);
        if (this.type === "metavuln") {
          this[_calculateRange]();
        }
        return this;
      }
      [_calculateRange]() {
        const ranges = [];
        this.versions = semver.sort(this.versions, semverOpt);
        this.vulnerableVersions = semver.sort(this.vulnerableVersions, semverOpt);
        for (let v = 0, vulnVer = 0; v < this.versions.length; v++) {
          const vr = [this.versions[v]];
          while (v < this.versions.length) {
            if (this.versions[v] !== this.vulnerableVersions[vulnVer]) {
              if (/-/.test(this.versions[v])) {
                v++;
                continue;
              }
              break;
            }
            if (vr.length > 1) {
              vr[1] = this.versions[v];
            } else {
              vr.push(this.versions[v]);
            }
            v++;
            vulnVer++;
          }
          if (vr.length > 1) {
            const tail = this.versions[this.versions.length - 1];
            ranges.push(vr[1] === tail ? `>=${vr[0]}` : vr[0] === vr[1] ? vr[0] : vr.join(" - "));
          }
        }
        const metavuln = ranges.join(" || ").trim();
        this.range = !metavuln ? "<0.0.0-0" : semver.simplifyRange(this.versions, metavuln, semverOpt);
      }
      // returns true if marked as vulnerable, false if ok
      // spec is a dependency specifier, for metavuln cases
      // where the version might not be in the packument.  if
      // we have the packument and spec is not provided, then
      // we use the dependency version from the manifest.
      testVersion(version, spec = null) {
        const sv = String(version);
        if (this[_versionVulnMemo].has(sv)) {
          return this[_versionVulnMemo].get(sv);
        }
        const result = this[_testVersion](version, spec);
        if (result) {
          this[_markVulnerable](version);
        }
        this[_versionVulnMemo].set(sv, !!result);
        return result;
      }
      [_markVulnerable](version) {
        const sv = String(version);
        if (!this.vulnerableVersions.includes(sv)) {
          this.vulnerableVersions.push(sv);
        }
      }
      [_testVersion](version, spec) {
        const sv = String(version);
        if (this.vulnerableVersions.includes(sv)) {
          return true;
        }
        if (this.type === "advisory") {
          return semver.satisfies(version, this.range, semverOpt);
        }
        const mani = this[_packument]?.versions?.[version] || {
          dependencies: {
            [this.dependency]: spec
          }
        };
        if (!spec) {
          spec = getDepSpec(mani, this.dependency);
        }
        if (spec === null) {
          return false;
        }
        if (!semver.validRange(spec, semverOpt)) {
          return true;
        }
        const bd = mani.bundleDependencies;
        const bundled = bd && bd.includes(this[_source].name);
        const avoid = this[_source].range;
        if (bundled) {
          return semver.intersects(spec, avoid, semverOpt);
        }
        return this[_source].testSpec(spec);
      }
      testSpec(spec) {
        const memo = this[_specVulnMemo];
        if (memo.has(spec)) {
          return memo.get(spec);
        }
        const res = this[_testSpec](spec);
        memo.set(spec, res);
        return res;
      }
      [_testSpec](spec) {
        for (const v of this.versions) {
          const satisfies = semver.satisfies(v, spec);
          if (!satisfies) {
            continue;
          }
          if (!this.testVersion(v)) {
            return false;
          }
        }
        return true;
      }
      [_testVersions](versions) {
        if (!versions.length) {
          return;
        }
        const versionSets = /* @__PURE__ */ new Set();
        versions = semver.sort(versions.map((v) => semver.parse(v, semverOpt)));
        let last = versions[0].major + "." + versions[0].minor;
        let list = [];
        versionSets.add(list);
        for (const v of versions) {
          const k = v.major + "." + v.minor;
          if (k !== last) {
            last = k;
            list = [];
            versionSets.add(list);
          }
          list.push(v);
        }
        for (const set of versionSets) {
          let h = 0;
          const origHeadVuln = this.testVersion(set[h]);
          while (h < set.length && /-/.test(String(set[h]))) {
            h++;
          }
          if (h === set.length) {
            h = 0;
          } else if (origHeadVuln) {
            for (let hh = 0; hh < h; hh++) {
              this[_markVulnerable](set[hh]);
            }
          }
          let t = set.length - 1;
          const origTailVuln = this.testVersion(set[t]);
          while (t > h && /-/.test(String(set[t]))) {
            t--;
          }
          if (t === h) {
            t = set.length - 1;
          } else if (origTailVuln) {
            for (let tt = set.length - 1; tt > t; tt--) {
              this[_markVulnerable](set[tt]);
            }
          }
          const headVuln = h === 0 ? origHeadVuln : this.testVersion(set[h]);
          const tailVuln = t === set.length - 1 ? origTailVuln : this.testVersion(set[t]);
          if (headVuln && tailVuln) {
            for (let v = h; v < t; v++) {
              this[_markVulnerable](set[v]);
            }
            continue;
          }
          if (t < h + 2) {
            continue;
          }
          const mid = Math.floor(set.length / 2);
          const pre = set.slice(0, mid);
          const post = set.slice(mid);
          if (!/-/.test(String(pre[0]))) {
            const midVuln = this.testVersion(pre[pre.length - 1]);
            while (/-/.test(String(pre[pre.length - 1]))) {
              const v = pre.pop();
              if (midVuln) {
                this[_markVulnerable](v);
              }
            }
          }
          if (!/-/.test(String(post[post.length - 1]))) {
            const midVuln = this.testVersion(post[0]);
            while (/-/.test(String(post[0]))) {
              const v = post.shift();
              if (midVuln) {
                this[_markVulnerable](v);
              }
            }
          }
          versionSets.add(pre);
          versionSets.add(post);
        }
      }
    };
    module2.exports = Advisory;
  }
});

// node_modules/@npmcli/metavuln-calculator/lib/index.js
var require_lib34 = __commonJS({
  "node_modules/@npmcli/metavuln-calculator/lib/index.js"(exports2, module2) {
    var pacote = require_lib33();
    var cacache = require_lib20();
    var { time } = require_lib4();
    var Advisory = require_advisory();
    var { homedir } = require("os");
    var jsonParse = require_lib3();
    var _packument = Symbol("packument");
    var _cachePut = Symbol("cachePut");
    var _cacheGet = Symbol("cacheGet");
    var _cacheData = Symbol("cacheData");
    var _packuments = Symbol("packuments");
    var _cache = Symbol("cache");
    var _options = Symbol("options");
    var _advisories = Symbol("advisories");
    var _calculate = Symbol("calculate");
    var Calculator = class {
      constructor(options = {}) {
        this[_options] = { ...options };
        this[_cache] = this[_options].cache || homedir() + "/.npm/_cacache";
        this[_options].cache = this[_cache];
        this[_packuments] = /* @__PURE__ */ new Map();
        this[_cacheData] = /* @__PURE__ */ new Map();
        this[_advisories] = /* @__PURE__ */ new Map();
      }
      get cache() {
        return this[_cache];
      }
      get options() {
        return { ...this[_options] };
      }
      async calculate(name, source) {
        const k = `security-advisory:${name}:${source.id}`;
        if (this[_advisories].has(k)) {
          return this[_advisories].get(k);
        }
        const p = this[_calculate](name, source);
        this[_advisories].set(k, p);
        return p;
      }
      async [_calculate](name, source) {
        const k = `security-advisory:${name}:${source.id}`;
        const timeEnd = time.start(`metavuln:calculate:${k}`);
        const advisory = new Advisory(name, source, this[_options]);
        const [cached, packument] = await Promise.all([
          this[_cacheGet](advisory),
          this[_packument](name)
        ]);
        const timeEndLoad = time.start(`metavuln:load:${k}`);
        advisory.load(cached, packument);
        timeEndLoad();
        if (advisory.updated) {
          await this[_cachePut](advisory);
        }
        this[_advisories].set(k, advisory);
        timeEnd();
        return advisory;
      }
      async [_cachePut](advisory) {
        const { name, id } = advisory;
        const key = `security-advisory:${name}:${id}`;
        const timeEnd = time.start(`metavuln:cache:put:${key}`);
        const data = JSON.stringify(advisory);
        const options = { ...this[_options] };
        this[_cacheData].set(key, jsonParse(data));
        await cacache.put(this[_cache], key, data, options).catch(() => {
        });
        timeEnd();
      }
      async [_cacheGet](advisory) {
        const { name, id } = advisory;
        const key = `security-advisory:${name}:${id}`;
        if (this[_cacheData].has(key)) {
          return this[_cacheData].get(key);
        }
        const timeEnd = time.start(`metavuln:cache:get:${key}`);
        const p = cacache.get(this[_cache], key, { ...this[_options] }).catch(() => ({ data: "{}" })).then(({ data }) => {
          data = jsonParse(data);
          timeEnd();
          this[_cacheData].set(key, data);
          return data;
        });
        this[_cacheData].set(key, p);
        return p;
      }
      async [_packument](name) {
        if (this[_packuments].has(name)) {
          return this[_packuments].get(name);
        }
        const timeEnd = time.start(`metavuln:packument:${name}`);
        const p = pacote.packument(name, { ...this[_options] }).catch(() => {
          return {
            name,
            versions: {}
          };
        }).then((paku) => {
          timeEnd();
          this[_packuments].set(name, paku);
          return paku;
        });
        this[_packuments].set(name, p);
        return p;
      }
    };
    module2.exports = Calculator;
  }
});

// node_modules/@npmcli/arborist/lib/audit-report.js
var require_audit_report = __commonJS({
  "node_modules/@npmcli/arborist/lib/audit-report.js"(exports2, module2) {
    var localeCompare = require_string_locale_compare()("en");
    var npa = require_npa();
    var pickManifest = require_lib11();
    var Vuln = require_vuln();
    var Calculator = require_lib34();
    var _getReport = Symbol("getReport");
    var _fixAvailable = Symbol("fixAvailable");
    var _checkTopNode = Symbol("checkTopNode");
    var _init = Symbol("init");
    var _omit = Symbol("omit");
    var { log, time } = require_lib4();
    var npmFetch = require_lib31();
    var AuditReport = class _AuditReport extends Map {
      static load(tree, opts) {
        return new _AuditReport(tree, opts).run();
      }
      get auditReportVersion() {
        return 2;
      }
      toJSON() {
        const obj = {
          auditReportVersion: this.auditReportVersion,
          vulnerabilities: {},
          metadata: {
            vulnerabilities: {
              info: 0,
              low: 0,
              moderate: 0,
              high: 0,
              critical: 0,
              total: this.size
            },
            dependencies: {
              prod: 0,
              dev: 0,
              optional: 0,
              peer: 0,
              peerOptional: 0,
              total: this.tree.inventory.size - 1
            }
          }
        };
        for (const node of this.tree.inventory.values()) {
          const { dependencies } = obj.metadata;
          let prod = true;
          for (const type of [
            "dev",
            "optional",
            "peer",
            "peerOptional"
          ]) {
            if (node[type]) {
              dependencies[type]++;
              prod = false;
            }
          }
          if (prod) {
            dependencies.prod++;
          }
        }
        const vulnerabilities = [];
        for (const [name, vuln] of this.entries()) {
          vulnerabilities.push([name, vuln.toJSON()]);
          obj.metadata.vulnerabilities[vuln.severity]++;
        }
        obj.vulnerabilities = vulnerabilities.sort(([a], [b]) => localeCompare(a, b)).reduce((set, [name, vuln]) => {
          set[name] = vuln;
          return set;
        }, {});
        return obj;
      }
      constructor(tree, opts = {}) {
        super();
        const { omit } = opts;
        this[_omit] = new Set(omit || []);
        this.topVulns = /* @__PURE__ */ new Map();
        this.calculator = new Calculator(opts);
        this.error = null;
        this.options = opts;
        this.tree = tree;
        this.filterSet = opts.filterSet;
      }
      async run() {
        this.report = await this[_getReport]();
        log.silly("audit report", this.report);
        if (this.report) {
          await this[_init]();
        }
        return this;
      }
      isVulnerable(node) {
        const vuln = this.get(node.packageName);
        return !!(vuln && vuln.isVulnerable(node));
      }
      async [_init]() {
        const timeEnd = time.start("auditReport:init");
        const promises = [];
        for (const [name, advisories2] of Object.entries(this.report)) {
          for (const advisory of advisories2) {
            promises.push(this.calculator.calculate(name, advisory));
          }
        }
        const advisories = new Set(await Promise.all(promises));
        const seen = /* @__PURE__ */ new Set();
        for (const advisory of advisories) {
          const { name, range } = advisory;
          const k = `${name}@${range}`;
          const vuln = this.get(name) || new Vuln({ name, advisory });
          if (this.has(name)) {
            vuln.addAdvisory(advisory);
          }
          super.set(name, vuln);
          if (!seen.has(k)) {
            const p = [];
            for (const node of this.tree.inventory.query("packageName", name)) {
              if (!shouldAudit(node, this[_omit], this.filterSet)) {
                continue;
              }
              if (!advisory.testVersion(node.version)) {
                continue;
              }
              if (advisory.type === "metavuln") {
                vuln.addVia(this.get(advisory.dependency));
              }
              if (vuln.nodes.has(node)) {
                continue;
              }
              vuln.nodes.add(node);
              for (const { from: dep, spec } of node.edgesIn) {
                if (dep.isTop && !vuln.topNodes.has(dep)) {
                  this[_checkTopNode](dep, vuln, spec);
                } else {
                  const calc = this.calculator.calculate(dep.packageName, advisory);
                  p.push(calc.then((meta) => {
                    if (meta.testVersion(dep.version, spec)) {
                      advisories.add(meta);
                    }
                  }));
                }
              }
            }
            await Promise.all(p);
            seen.add(k);
          }
          if (this.get(name).nodes.size === 0) {
            this.delete(name);
            continue;
          }
          for (const advisory2 of vuln.advisories) {
            const relevant = [...vuln.nodes].some((n) => advisory2.testVersion(n.version));
            if (!relevant) {
              vuln.deleteAdvisory(advisory2);
            }
          }
        }
        timeEnd();
      }
      [_checkTopNode](topNode, vuln, spec) {
        vuln.fixAvailable = this[_fixAvailable](topNode, vuln, spec);
        if (vuln.fixAvailable !== true) {
          this.topVulns.set(vuln.name, vuln);
          vuln.topNodes.add(topNode);
        }
      }
      // check whether the top node is vulnerable.
      // check whether we can get out of the bad place with --force, and if
      // so, whether that update is SemVer Major
      [_fixAvailable](topNode, vuln, spec) {
        const paku = vuln.packument;
        if (!vuln.testSpec(spec)) {
          return true;
        }
        const specObj = npa(spec);
        if (!specObj.registry) {
          return false;
        }
        if (specObj.subSpec) {
          spec = specObj.subSpec.rawSpec;
        }
        try {
          const {
            _isSemVerMajor: isSemVerMajor,
            version,
            name
          } = pickManifest(paku, spec, {
            ...this.options,
            before: null,
            avoid: vuln.range,
            avoidStrict: true
          });
          return { name, version, isSemVerMajor };
        } catch (er) {
          return false;
        }
      }
      set() {
        throw new Error("do not call AuditReport.set() directly");
      }
      async [_getReport]() {
        if (this.options.audit === false || this.options.offline === true || this.tree.inventory.size === 1) {
          return null;
        }
        const timeEnd = time.start("auditReport:getReport");
        try {
          const body = prepareBulkData(this.tree, this[_omit], this.filterSet);
          log.silly("audit", "bulk request", body);
          if (!Object.keys(body).length) {
            return null;
          }
          const res = await npmFetch("/-/npm/v1/security/advisories/bulk", {
            ...this.options,
            registry: this.options.auditRegistry || this.options.registry,
            method: "POST",
            gzip: true,
            body
          });
          return await res.json();
        } catch (er) {
          log.verbose("audit error", er);
          log.silly("audit error", String(er.body));
          this.error = er;
          return null;
        } finally {
          timeEnd();
        }
      }
    };
    var shouldAudit = (node, omit, filterSet) => !node.version ? false : node.isRoot ? false : filterSet && filterSet.size !== 0 && !filterSet.has(node) ? false : omit.size === 0 ? true : !// otherwise, just ensure we're not omitting this one
    (node.dev && omit.has("dev") || node.optional && omit.has("optional") || node.devOptional && omit.has("dev") && omit.has("optional") || node.peer && omit.has("peer"));
    var prepareBulkData = (tree, omit, filterSet) => {
      const payload = {};
      for (const name of tree.inventory.query("packageName")) {
        const set = /* @__PURE__ */ new Set();
        for (const node of tree.inventory.query("packageName", name)) {
          if (!shouldAudit(node, omit, filterSet)) {
            continue;
          }
          set.add(node.version);
        }
        if (set.size) {
          payload[name] = [...set];
        }
      }
      return payload;
    };
    module2.exports = AuditReport;
  }
});

// node_modules/@npmcli/arborist/lib/relpath.js
var require_relpath = __commonJS({
  "node_modules/@npmcli/arborist/lib/relpath.js"(exports2, module2) {
    var { relative } = require("node:path");
    var relpath = (from, to) => relative(from, to).replace(/\\/g, "/");
    module2.exports = relpath;
  }
});

// node_modules/@npmcli/arborist/lib/packument-cache.js
var require_packument_cache = __commonJS({
  "node_modules/@npmcli/arborist/lib/packument-cache.js"(exports2, module2) {
    var { LRUCache } = require_commonjs2();
    var { getHeapStatistics } = require("node:v8");
    var { log } = require_lib4();
    var PackumentCache = class _PackumentCache extends LRUCache {
      static #heapLimit = Math.floor(getHeapStatistics().heap_size_limit);
      #sizeKey;
      #disposed = /* @__PURE__ */ new Set();
      #log(...args) {
        log.silly("packumentCache", ...args);
      }
      constructor({
        // How much of this.#heapLimit to take up
        heapFactor = 0.25,
        // How much of this.#maxSize we allow any one packument to take up
        // Anything over this is not cached
        maxEntryFactor = 0.5,
        sizeKey = "_contentLength"
      } = {}) {
        const maxSize = Math.floor(_PackumentCache.#heapLimit * heapFactor);
        const maxEntrySize = Math.floor(maxSize * maxEntryFactor);
        super({
          maxSize,
          maxEntrySize,
          sizeCalculation: (p) => {
            if (!p[sizeKey]) {
              return maxEntrySize + 1;
            }
            if (p[sizeKey] < 1e4) {
              return p[sizeKey] * 2;
            }
            if (p[sizeKey] < 1e6) {
              return Math.floor(p[sizeKey] * 1.5);
            }
            return maxEntrySize + 1;
          },
          dispose: (v, k) => {
            this.#disposed.add(k);
            this.#log(k, "dispose");
          }
        });
        this.#sizeKey = sizeKey;
        this.#log(`heap:${_PackumentCache.#heapLimit} maxSize:${maxSize} maxEntrySize:${maxEntrySize}`);
      }
      set(k, v, ...args) {
        const disposed = this.#disposed.has(k);
        if (disposed) {
          this.#disposed.delete(k);
        }
        this.#log(k, "set", `size:${v[this.#sizeKey]} disposed:${disposed}`);
        return super.set(k, v, ...args);
      }
      has(k, ...args) {
        const has = super.has(k, ...args);
        this.#log(k, `cache-${has ? "hit" : "miss"}`);
        return has;
      }
    };
    module2.exports = PackumentCache;
  }
});

// node_modules/proggy/lib/client.js
var require_client4 = __commonJS({
  "node_modules/proggy/lib/client.js"(exports2, module2) {
    var EE = require("events");
    var onProgress = Symbol("onProgress");
    var bars = Symbol("bars");
    var listener = Symbol("listener");
    var normData = Symbol("normData");
    var Client = class extends EE {
      constructor({ normalize = false, stopOnDone = false } = {}) {
        super();
        this.normalize = !!normalize;
        this.stopOnDone = !!stopOnDone;
        this[bars] = /* @__PURE__ */ new Map();
        this[listener] = null;
      }
      get size() {
        return this[bars].size;
      }
      get listening() {
        return !!this[listener];
      }
      addListener(...args) {
        return this.on(...args);
      }
      on(ev, ...args) {
        if (ev === "progress" && !this[listener]) {
          this.start();
        }
        return super.on(ev, ...args);
      }
      off(ev, ...args) {
        return this.removeListener(ev, ...args);
      }
      removeListener(ev, ...args) {
        const ret = super.removeListener(ev, ...args);
        if (ev === "progress" && this.listeners(ev).length === 0) {
          this.stop();
        }
        return ret;
      }
      stop() {
        if (this[listener]) {
          process.removeListener("progress", this[listener]);
          this[listener] = null;
        }
      }
      start() {
        if (!this[listener]) {
          this[listener] = (...args) => this[onProgress](...args);
          process.on("progress", this[listener]);
        }
      }
      [onProgress](key, data) {
        data = this[normData](key, data);
        if (!this[bars].has(key)) {
          this.emit("bar", key, data);
        }
        this[bars].set(key, data);
        this.emit("progress", key, data);
        if (data.done) {
          this[bars].delete(key);
          this.emit("barDone", key, data);
          if (this.size === 0) {
            if (this.stopOnDone) {
              this.stop();
            }
            this.emit("done");
          }
        }
      }
      [normData](key, data) {
        const actualValue = data.value;
        const actualTotal = data.total;
        let value = actualValue;
        let total = actualTotal;
        const done = data.done || value >= total;
        if (this.normalize) {
          const bar = this[bars].get(key);
          total = 100;
          if (done) {
            value = 100;
          } else {
            const pct = 100 * actualValue / actualTotal;
            if (bar) {
              value = pct > bar.value ? pct : (100 - bar.value) / 100 + bar.value;
            }
          }
        }
        return {
          ...data,
          key,
          name: data.name || key,
          value,
          total,
          actualValue,
          actualTotal,
          done
        };
      }
    };
    module2.exports = Client;
  }
});

// node_modules/proggy/lib/tracker.js
var require_tracker = __commonJS({
  "node_modules/proggy/lib/tracker.js"(exports2, module2) {
    var EE = require("events");
    var Tracker = class extends EE {
      constructor(name, key, total) {
        super();
        if (!name) {
          throw new Error("proggy: Tracker needs a name");
        }
        if (typeof key === "number" && !total) {
          total = key;
          key = null;
        }
        if (!total) {
          total = 100;
        }
        if (!key) {
          key = name;
        }
        this.done = false;
        this.name = name;
        this.key = key;
        this.value = 0;
        this.total = total;
      }
      finish(metadata = {}) {
        this.update(this.total, this.total, metadata);
      }
      update(value, total, metadata) {
        if (!metadata) {
          if (total && typeof total === "object") {
            metadata = total;
          } else {
            metadata = {};
          }
        }
        if (typeof total !== "number") {
          total = this.total;
        }
        if (this.done) {
          const msg = `proggy: updating completed tracker: ${JSON.stringify(this.key)}`;
          throw new Error(msg);
        }
        this.value = value;
        this.total = total;
        const done = this.value >= this.total;
        process.emit("progress", this.key, {
          ...metadata,
          name: this.name,
          key: this.key,
          value,
          total,
          done
        });
        if (done) {
          this.done = true;
          this.emit("done");
        }
      }
    };
    module2.exports = Tracker;
  }
});

// node_modules/proggy/lib/index.js
var require_lib35 = __commonJS({
  "node_modules/proggy/lib/index.js"(exports2) {
    exports2.Client = require_client4();
    exports2.Tracker = require_tracker();
    var trackers = /* @__PURE__ */ new Map();
    exports2.createTracker = (name, key, total) => {
      const tracker = new exports2.Tracker(name, key, total);
      if (trackers.has(tracker.key)) {
        const msg = `proggy: duplicate progress id ${JSON.stringify(tracker.key)}`;
        throw new Error(msg);
      }
      trackers.set(tracker.key, tracker);
      tracker.on("done", () => trackers.delete(tracker.key));
      return tracker;
    };
    exports2.createClient = (options = {}) => new exports2.Client(options);
  }
});

// node_modules/@npmcli/arborist/lib/tracker.js
var require_tracker2 = __commonJS({
  "node_modules/@npmcli/arborist/lib/tracker.js"(exports2, module2) {
    var proggy = require_lib35();
    module2.exports = (cls) => class Tracker extends cls {
      #progress = /* @__PURE__ */ new Map();
      #createTracker(key, name) {
        const tracker = new proggy.Tracker(name ?? key);
        tracker.on("done", () => this.#progress.delete(key));
        this.#progress.set(key, tracker);
      }
      addTracker(section, subsection = null, key = null) {
        if (section === null || section === void 0) {
          this.#onError(`Tracker can't be null or undefined`);
        }
        if (key === null) {
          key = subsection;
        }
        const hasTracker = this.#progress.has(section);
        const hasSubtracker = this.#progress.has(`${section}:${key}`);
        if (hasTracker && subsection === null) {
          this.#onError(`Tracker "${section}" already exists`);
        } else if (!hasTracker && subsection === null) {
          this.#createTracker(section);
        } else if (!hasTracker && subsection !== null) {
          this.#onError(`Parent tracker "${section}" does not exist`);
        } else if (!hasTracker || !hasSubtracker) {
          const parentTracker = this.#progress.get(section);
          parentTracker.update(parentTracker.value, parentTracker.total + 1);
          this.#createTracker(`${section}:${key}`, `${section}:${subsection}`);
        }
      }
      finishTracker(section, subsection = null, key = null) {
        if (section === null || section === void 0) {
          this.#onError(`Tracker can't be null or undefined`);
        }
        if (key === null) {
          key = subsection;
        }
        const hasTracker = this.#progress.has(section);
        const hasSubtracker = this.#progress.has(`${section}:${key}`);
        if (hasTracker && subsection === null) {
          const keys = this.#progress.keys();
          for (const key2 of keys) {
            if (key2.match(new RegExp(section + ":"))) {
              this.finishTracker(section, key2);
            }
          }
          this.#progress.get(section).finish();
        } else if (!hasTracker && subsection === null) {
          this.#onError(`Tracker "${section}" does not exist`);
        } else if (!hasTracker || hasSubtracker) {
          const parentTracker = this.#progress.get(section);
          parentTracker.update(parentTracker.value + 1);
          this.#progress.get(`${section}:${key}`).finish();
        }
      }
      #onError(msg) {
        throw new Error(msg);
      }
    };
  }
});

// node_modules/read-package-json-fast/lib/index.js
var require_lib36 = __commonJS({
  "node_modules/read-package-json-fast/lib/index.js"(exports2, module2) {
    var { readFile, lstat, readdir } = require("fs/promises");
    var parse = require_lib3();
    var normalizePackageBin = require_lib10();
    var { resolve, dirname, join, relative } = require("path");
    var rpj = (path) => readFile(path, "utf8").then((data) => readBinDir(path, normalize(stripUnderscores(parse(data))))).catch((er) => {
      er.path = path;
      throw er;
    });
    var readBinDir = async (path, data) => {
      if (data.bin) {
        return data;
      }
      const m = data.directories && data.directories.bin;
      if (!m || typeof m !== "string") {
        return data;
      }
      const root = dirname(path);
      const dir = join(".", join("/", m));
      data.bin = await walkBinDir(root, dir, {});
      return data;
    };
    var walkBinDir = async (root, dir, obj) => {
      const entries = await readdir(resolve(root, dir)).catch(() => []);
      for (const entry of entries) {
        if (entry.charAt(0) === ".") {
          continue;
        }
        const f = resolve(root, dir, entry);
        const st = await lstat(f).catch(() => null);
        if (!st) {
          continue;
        } else if (st.isFile()) {
          obj[entry] = relative(root, f);
        } else if (st.isDirectory()) {
          await walkBinDir(root, join(dir, entry), obj);
        }
      }
      return obj;
    };
    var stripUnderscores = (data) => {
      for (const key of Object.keys(data).filter((k) => /^_/.test(k))) {
        delete data[key];
      }
      return data;
    };
    var normalize = (data) => {
      addId(data);
      fixBundled(data);
      pruneRepeatedOptionals(data);
      fixScripts(data);
      fixFunding(data);
      normalizePackageBin(data);
      return data;
    };
    rpj.normalize = normalize;
    var addId = (data) => {
      if (data.name && data.version) {
        data._id = `${data.name}@${data.version}`;
      }
      return data;
    };
    var pruneRepeatedOptionals = (data) => {
      const od = data.optionalDependencies;
      const dd = data.dependencies || {};
      if (od && typeof od === "object") {
        for (const name of Object.keys(od)) {
          delete dd[name];
        }
      }
      if (Object.keys(dd).length === 0) {
        delete data.dependencies;
      }
      return data;
    };
    var fixBundled = (data) => {
      const bdd = data.bundledDependencies;
      const bd = data.bundleDependencies === void 0 ? bdd : data.bundleDependencies;
      if (bd === false) {
        data.bundleDependencies = [];
      } else if (bd === true) {
        data.bundleDependencies = Object.keys(data.dependencies || {});
      } else if (bd && typeof bd === "object") {
        if (!Array.isArray(bd)) {
          data.bundleDependencies = Object.keys(bd);
        } else {
          data.bundleDependencies = bd;
        }
      } else {
        delete data.bundleDependencies;
      }
      delete data.bundledDependencies;
      return data;
    };
    var fixScripts = (data) => {
      if (!data.scripts || typeof data.scripts !== "object") {
        delete data.scripts;
        return data;
      }
      for (const [name, script] of Object.entries(data.scripts)) {
        if (typeof script !== "string") {
          delete data.scripts[name];
        }
      }
      return data;
    };
    var fixFunding = (data) => {
      if (data.funding && typeof data.funding === "string") {
        data.funding = { url: data.funding };
      }
      return data;
    };
    module2.exports = rpj;
  }
});

// node_modules/promise-call-limit/dist/commonjs/index.js
var require_commonjs7 = __commonJS({
  "node_modules/promise-call-limit/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callLimit = void 0;
    var os = __importStar(require("node:os"));
    var defLimit = "availableParallelism" in os ? Math.max(1, os.availableParallelism() - 1) : Math.max(1, os.cpus().length - 1);
    var callLimit = (queue, { limit = defLimit, rejectLate } = {}) => new Promise((res, rej) => {
      let active = 0;
      let current = 0;
      const results = [];
      let rejected = false;
      let rejection;
      const reject = (er) => {
        if (rejected)
          return;
        rejected = true;
        rejection ??= er;
        if (!rejectLate)
          rej(rejection);
      };
      let resolved = false;
      const resolve = () => {
        if (resolved || active > 0)
          return;
        resolved = true;
        res(results);
      };
      const run = () => {
        const c = current++;
        if (c >= queue.length)
          return rejected ? reject() : resolve();
        active++;
        const step = queue[c];
        if (!step)
          throw new Error("walked off queue");
        results[c] = step().then((result) => {
          active--;
          results[c] = result;
          return result;
        }, (er) => {
          active--;
          reject(er);
        }).then((result) => {
          if (rejected && active === 0)
            return rej(rejection);
          run();
          return result;
        });
      };
      for (let i = 0; i < limit; i++)
        run();
    });
    exports2.callLimit = callLimit;
  }
});

// node_modules/@npmcli/arborist/lib/realpath.js
var require_realpath = __commonJS({
  "node_modules/@npmcli/arborist/lib/realpath.js"(exports2, module2) {
    var { lstat, readlink } = require("node:fs/promises");
    var { resolve, basename, dirname } = require("node:path");
    var realpathCached = (path, rpcache, stcache, depth) => {
      if (depth > 2e3) {
        throw eloop(path);
      }
      path = resolve(path);
      if (rpcache.has(path)) {
        return Promise.resolve(rpcache.get(path));
      }
      const dir = dirname(path);
      const base = basename(path);
      if (base && rpcache.has(dir)) {
        return realpathChild(dir, base, rpcache, stcache, depth);
      }
      if (!base) {
        rpcache.set(dir, dir);
        return Promise.resolve(dir);
      }
      return realpathCached(dir, rpcache, stcache, depth + 1).then(() => realpathCached(path, rpcache, stcache, depth + 1));
    };
    var lstatCached = (path, stcache) => {
      if (stcache.has(path)) {
        return Promise.resolve(stcache.get(path));
      }
      const p = lstat(path).then((st) => {
        stcache.set(path, st);
        return st;
      });
      stcache.set(path, p);
      return p;
    };
    var eloop = (path) => Object.assign(new Error(
      `ELOOP: too many symbolic links encountered, stat '${path}'`
    ), {
      errno: -62,
      syscall: "stat",
      code: "ELOOP",
      path
    });
    var realpathChild = (dir, base, rpcache, stcache, depth) => {
      const realdir = rpcache.get(dir);
      if (typeof realdir === "undefined") {
        throw new Error("in realpathChild without parent being in realpath cache");
      }
      const realish = resolve(realdir, base);
      return lstatCached(realish, stcache).then((st) => {
        if (!st.isSymbolicLink()) {
          rpcache.set(resolve(dir, base), realish);
          return realish;
        }
        return readlink(realish).then((target) => {
          const resolved = resolve(realdir, target);
          if (realish === resolved) {
            throw eloop(realish);
          }
          return realpathCached(resolved, rpcache, stcache, depth + 1);
        }).then((real) => {
          rpcache.set(resolve(dir, base), real);
          return real;
        });
      });
    };
    module2.exports = realpathCached;
  }
});

// node_modules/@npmcli/arborist/lib/debug.js
var require_debug2 = __commonJS({
  "node_modules/@npmcli/arborist/lib/debug.js"(exports2, module2) {
    var debug = process.env.ARBORIST_DEBUG !== "0" && (process.env.ARBORIST_DEBUG === "1" || /\barborist\b/.test(process.env.NODE_DEBUG || "") || process.env.npm_package_name === "@npmcli/arborist" && ["test", "snap"].includes(process.env.npm_lifecycle_event) || process.cwd() === require("node:path").resolve(__dirname, ".."));
    module2.exports = debug ? (fn) => fn() : () => {
    };
    var red = process.stderr.isTTY ? (msg) => `\x1B[31m${msg}\x1B[39m` : (m) => m;
    module2.exports.log = (...msg) => module2.exports(() => {
      const { format } = require("node:util");
      const prefix = `
${process.pid} ${red(format(msg.shift()))} `;
      msg = (prefix + format(...msg).trim().split("\n").join(prefix)).trim();
      console.error(msg);
    });
  }
});

// node_modules/@npmcli/arborist/lib/tree-check.js
var require_tree_check = __commonJS({
  "node_modules/@npmcli/arborist/lib/tree-check.js"(exports2, module2) {
    var debug = require_debug2();
    var checkTree = (tree, checkUnreachable = true) => {
      const log = [["START TREE CHECK", tree.path]];
      if (!tree.root || !tree.root.inventory) {
        return tree;
      }
      const { inventory } = tree.root;
      const seen = /* @__PURE__ */ new Set();
      const check = (node, via = tree, viaType = "self") => {
        log.push([
          "CHECK",
          node && node.location,
          via && via.location,
          viaType,
          "seen=" + seen.has(node),
          "promise=" + !!(node && node.then),
          "root=" + !!(node && node.isRoot)
        ]);
        if (!node || seen.has(node) || node.then) {
          return;
        }
        seen.add(node);
        if (node.isRoot && node !== tree.root) {
          throw Object.assign(new Error("double root"), {
            node: node.path,
            realpath: node.realpath,
            tree: tree.path,
            root: tree.root.path,
            via: via.path,
            viaType,
            log
          });
        }
        if (node.root !== tree.root) {
          throw Object.assign(new Error("node from other root in tree"), {
            node: node.path,
            realpath: node.realpath,
            tree: tree.path,
            root: tree.root.path,
            via: via.path,
            viaType,
            otherRoot: node.root && node.root.path,
            log
          });
        }
        if (!node.isRoot && node.inventory.size !== 0) {
          throw Object.assign(new Error("non-root has non-zero inventory"), {
            node: node.path,
            tree: tree.path,
            root: tree.root.path,
            via: via.path,
            viaType,
            inventory: [...node.inventory.values()].map((node2) => [node2.path, node2.location]),
            log
          });
        }
        if (!node.isRoot && !inventory.has(node) && !node.dummy) {
          throw Object.assign(new Error("not in inventory"), {
            node: node.path,
            tree: tree.path,
            root: tree.root.path,
            via: via.path,
            viaType,
            log
          });
        }
        const devEdges = [...node.edgesOut.values()].filter((e) => e.dev);
        if (!node.isTop && devEdges.length) {
          throw Object.assign(new Error("dev edges on non-top node"), {
            node: node.path,
            tree: tree.path,
            root: tree.root.path,
            via: via.path,
            viaType,
            devEdges: devEdges.map((e) => [e.type, e.name, e.spec, e.error]),
            log
          });
        }
        if (node.path === tree.root.path && node !== tree.root && !tree.root.isLink) {
          throw Object.assign(new Error("node with same path as root"), {
            node: node.path,
            tree: tree.path,
            root: tree.root.path,
            via: via.path,
            viaType,
            log
          });
        }
        if (!node.isLink && node.path !== node.realpath) {
          throw Object.assign(new Error("non-link with mismatched path/realpath"), {
            node: node.path,
            tree: tree.path,
            realpath: node.realpath,
            root: tree.root.path,
            via: via.path,
            viaType,
            log
          });
        }
        const { parent, fsParent, target } = node;
        check(parent, node, "parent");
        check(fsParent, node, "fsParent");
        check(target, node, "target");
        log.push(["CHILDREN", node.location, ...node.children.keys()]);
        for (const kid of node.children.values()) {
          check(kid, node, "children");
        }
        for (const kid of node.fsChildren) {
          check(kid, node, "fsChildren");
        }
        for (const link of node.linksIn) {
          check(link, node, "linksIn");
        }
        for (const top of node.tops) {
          check(top, node, "tops");
        }
        log.push(["DONE", node.location]);
      };
      check(tree);
      if (checkUnreachable) {
        for (const node of inventory.values()) {
          if (!seen.has(node) && node !== tree.root) {
            throw Object.assign(new Error("unreachable in inventory"), {
              node: node.path,
              realpath: node.realpath,
              location: node.location,
              root: tree.root.path,
              tree: tree.path,
              log
            });
          }
        }
      }
      return tree;
    };
    module2.exports = (tree) => tree;
    debug(() => module2.exports = checkTree);
  }
});

// node_modules/@npmcli/arborist/lib/peer-entry-sets.js
var require_peer_entry_sets = __commonJS({
  "node_modules/@npmcli/arborist/lib/peer-entry-sets.js"(exports2, module2) {
    var peerEntrySets = (node) => {
      const unionSet = /* @__PURE__ */ new Set([node]);
      for (const node2 of unionSet) {
        for (const edge of node2.edgesOut.values()) {
          if (edge.valid && edge.peer && edge.to) {
            unionSet.add(edge.to);
          }
        }
        for (const edge of node2.edgesIn) {
          if (edge.valid && edge.peer) {
            unionSet.add(edge.from);
          }
        }
      }
      const entrySets = /* @__PURE__ */ new Map();
      for (const peer of unionSet) {
        for (const edge of peer.edgesIn) {
          if (!edge.valid) {
            continue;
          }
          if (!edge.peer || edge.from.isTop) {
            const sub = /* @__PURE__ */ new Set([peer]);
            for (const peer2 of sub) {
              for (const edge2 of peer2.edgesOut.values()) {
                if (edge2.valid && edge2.peer && edge2.to) {
                  sub.add(edge2.to);
                }
              }
            }
            if (sub.has(node)) {
              entrySets.set(edge, sub);
            }
          }
        }
      }
      return entrySets;
    };
    module2.exports = peerEntrySets;
  }
});

// node_modules/@npmcli/arborist/lib/deepest-nesting-target.js
var require_deepest_nesting_target = __commonJS({
  "node_modules/@npmcli/arborist/lib/deepest-nesting-target.js"(exports2, module2) {
    var deepestNestingTarget = (start, name) => {
      for (const target of start.ancestry()) {
        if (target.isProjectRoot || !target.resolveParent || target.globalTop) {
          return target;
        }
        const targetEdge = target.edgesOut.get(name);
        if (!targetEdge || !targetEdge.peer) {
          return target;
        }
      }
    };
    module2.exports = deepestNestingTarget;
  }
});

// node_modules/@npmcli/arborist/lib/can-place-dep.js
var require_can_place_dep = __commonJS({
  "node_modules/@npmcli/arborist/lib/can-place-dep.js"(exports2, module2) {
    var localeCompare = require_string_locale_compare()("en");
    var semver = require_semver2();
    var debug = require_debug2();
    var peerEntrySets = require_peer_entry_sets();
    var deepestNestingTarget = require_deepest_nesting_target();
    var CONFLICT = Symbol("CONFLICT");
    var OK = Symbol("OK");
    var REPLACE = Symbol("REPLACE");
    var KEEP = Symbol("KEEP");
    var CanPlaceDep = class _CanPlaceDep {
      // dep is a dep that we're trying to place.  it should already live in
      // a virtual tree where its peer set is loaded as children of the root.
      // target is the actual place where we're trying to place this dep
      // in a node_modules folder.
      // edge is the edge that we're trying to satisfy with this placement.
      // parent is the CanPlaceDep object of the entry node when placing a peer.
      constructor(options) {
        const {
          dep,
          target,
          edge,
          preferDedupe,
          parent = null,
          peerPath = [],
          explicitRequest = false
        } = options;
        debug(() => {
          if (!dep) {
            throw new Error("no dep provided to CanPlaceDep");
          }
          if (!target) {
            throw new Error("no target provided to CanPlaceDep");
          }
          if (!edge) {
            throw new Error("no edge provided to CanPlaceDep");
          }
          this._treeSnapshot = JSON.stringify([...target.root.inventory.entries()].map(([loc, { packageName, version, resolved }]) => {
            return [loc, packageName, version, resolved];
          }).sort(([a], [b]) => localeCompare(a, b)));
        });
        this.canPlace = null;
        this.canPlaceSelf = null;
        this.dep = dep;
        this.target = target;
        this.edge = edge;
        this.explicitRequest = explicitRequest;
        this.peerPath = peerPath;
        this.preferDedupe = !!preferDedupe || edge.peer;
        this.parent = parent;
        this.children = [];
        this.isSource = target === this.peerSetSource;
        this.name = edge.name;
        this.current = target.children.get(this.name);
        this.targetEdge = target.edgesOut.get(this.name);
        this.conflicts = /* @__PURE__ */ new Map();
        this.edgeOverride = !dep.satisfies(edge);
        this.canPlace = this.checkCanPlace();
        if (!this.canPlaceSelf) {
          this.canPlaceSelf = this.canPlace;
        }
        debug(() => {
          const treeSnapshot = JSON.stringify([...target.root.inventory.entries()].map(([loc, { packageName, version, resolved }]) => {
            return [loc, packageName, version, resolved];
          }).sort(([a], [b]) => localeCompare(a, b)));
          if (this._treeSnapshot !== treeSnapshot) {
            throw Object.assign(new Error("tree changed in CanPlaceDep"), {
              expect: this._treeSnapshot,
              actual: treeSnapshot
            });
          }
        });
      }
      checkCanPlace() {
        const { target, targetEdge, current, dep } = this;
        if (dep.errors.length) {
          return current ? REPLACE : OK;
        }
        if (targetEdge && targetEdge.peer && !target.isTop) {
          return CONFLICT;
        }
        if (!current && targetEdge && !dep.satisfies(targetEdge) && targetEdge !== this.edge) {
          return CONFLICT;
        }
        return current ? this.checkCanPlaceCurrent() : this.checkCanPlaceNoCurrent();
      }
      // we know that the target has a dep by this name in its node_modules
      // already.  Can return KEEP, REPLACE, or CONFLICT.
      checkCanPlaceCurrent() {
        const { preferDedupe, explicitRequest, current, target, edge, dep } = this;
        if (dep.matches(current)) {
          if (current.satisfies(edge) || this.edgeOverride) {
            return explicitRequest ? REPLACE : KEEP;
          }
        }
        const { version: curVer } = current;
        const { version: newVer } = dep;
        const tryReplace = curVer && newVer && semver.gte(newVer, curVer);
        if (tryReplace && dep.canReplace(current)) {
          const cpp = this.canPlacePeers(REPLACE);
          if (cpp !== CONFLICT) {
            return cpp;
          }
        }
        if (current.satisfies(edge) && (!explicitRequest || preferDedupe)) {
          return KEEP;
        }
        if (preferDedupe && !tryReplace && dep.canReplace(current)) {
          const cpp = this.canPlacePeers(REPLACE);
          if (cpp !== CONFLICT) {
            return cpp;
          }
        }
        const myDeepest = this.deepestNestingTarget;
        if (target !== myDeepest) {
          return CONFLICT;
        }
        if (!edge.peer && target === edge.from) {
          return this.canPlacePeers(REPLACE);
        }
        if (!this.parent && !edge.peer) {
          return CONFLICT;
        }
        let canReplace = true;
        for (const [entryEdge, currentPeers] of peerEntrySets(current)) {
          if (entryEdge === this.edge || entryEdge === this.peerEntryEdge) {
            continue;
          }
          const entryNode = entryEdge.to;
          const entryRep = dep.parent.children.get(entryNode.name);
          if (entryRep) {
            if (entryRep.canReplace(entryNode, dep.parent.children.keys())) {
              continue;
            }
          }
          let canClobber = !entryRep;
          if (!entryRep) {
            const peerReplacementWalk = /* @__PURE__ */ new Set([entryNode]);
            OUTER: for (const currentPeer of peerReplacementWalk) {
              for (const edge2 of currentPeer.edgesOut.values()) {
                if (!edge2.peer || !edge2.valid) {
                  continue;
                }
                const rep = dep.parent.children.get(edge2.name);
                if (!rep) {
                  if (edge2.to) {
                    peerReplacementWalk.add(edge2.to);
                  }
                  continue;
                }
                if (!rep.satisfies(edge2)) {
                  canClobber = false;
                  break OUTER;
                }
              }
            }
          }
          if (canClobber) {
            continue;
          }
          let canNestCurrent = true;
          for (const currentPeer of currentPeers) {
            if (!canNestCurrent) {
              break;
            }
            const curDeep = deepestNestingTarget(entryEdge.from, currentPeer.name);
            if (curDeep === target || target.isDescendantOf(curDeep)) {
              canNestCurrent = false;
              canReplace = false;
            }
            if (canNestCurrent) {
              continue;
            }
          }
        }
        if (canReplace) {
          return this.canPlacePeers(REPLACE);
        }
        return CONFLICT;
      }
      checkCanPlaceNoCurrent() {
        const { target, peerEntryEdge, dep, name } = this;
        const current = target !== peerEntryEdge.from && target.resolve(name);
        if (current) {
          for (const edge of current.edgesIn.values()) {
            if (edge.from.isDescendantOf(target) && edge.valid) {
              if (!dep.satisfies(edge)) {
                return CONFLICT;
              }
            }
          }
        }
        return this.canPlacePeers(OK);
      }
      get deepestNestingTarget() {
        const start = this.parent ? this.parent.deepestNestingTarget : this.edge.from;
        return deepestNestingTarget(start, this.name);
      }
      get conflictChildren() {
        return this.allChildren.filter((c) => c.canPlace === CONFLICT);
      }
      get allChildren() {
        const set = new Set(this.children);
        for (const child of set) {
          for (const grandchild of child.children) {
            set.add(grandchild);
          }
        }
        return [...set];
      }
      get top() {
        return this.parent ? this.parent.top : this;
      }
      // check if peers can go here.  returns state or CONFLICT
      canPlacePeers(state) {
        this.canPlaceSelf = state;
        if (this._canPlacePeers) {
          return this._canPlacePeers;
        }
        const peerPath = [...this.peerPath, this.dep];
        let sawConflict = false;
        for (const peerEdge of this.dep.edgesOut.values()) {
          if (!peerEdge.peer || !peerEdge.to || peerPath.includes(peerEdge.to)) {
            continue;
          }
          const peer = peerEdge.to;
          const target = deepestNestingTarget(this.target, peer.name);
          const cpp = new _CanPlaceDep({
            dep: peer,
            target,
            parent: this,
            edge: peerEdge,
            peerPath,
            // always place peers in preferDedupe mode
            preferDedupe: true
          });
          debug(() => {
            if (this.children.some((c) => c.dep === cpp.dep)) {
              throw new Error("checking same dep repeatedly");
            }
          });
          this.children.push(cpp);
          if (cpp.canPlace === CONFLICT) {
            sawConflict = true;
          }
        }
        this._canPlacePeers = sawConflict ? CONFLICT : state;
        return this._canPlacePeers;
      }
      // what is the node that is causing this peerSet to be placed?
      get peerSetSource() {
        return this.parent ? this.parent.peerSetSource : this.edge.from;
      }
      get peerEntryEdge() {
        return this.top.edge;
      }
      static get CONFLICT() {
        return CONFLICT;
      }
      static get OK() {
        return OK;
      }
      static get REPLACE() {
        return REPLACE;
      }
      static get KEEP() {
        return KEEP;
      }
      get description() {
        const { canPlace } = this;
        return canPlace && canPlace.description || /* istanbul ignore next - old node affordance */
        canPlace;
      }
    };
    module2.exports = CanPlaceDep;
  }
});

// node_modules/@npmcli/arborist/lib/from-path.js
var require_from_path = __commonJS({
  "node_modules/@npmcli/arborist/lib/from-path.js"(exports2, module2) {
    var { dirname } = require("node:path");
    var npa = require_npa();
    var fromPath = (node, edge) => {
      if (edge && edge.overrides && edge.overrides.name === edge.name && edge.overrides.value) {
        if (node.sourceReference) {
          return node.sourceReference.root.realpath;
        }
        return node.root.realpath;
      }
      if (node.resolved) {
        const spec = npa(node.resolved);
        if (spec?.type === "file") {
          return dirname(spec.fetchSpec);
        }
      }
      return node.realpath;
    };
    module2.exports = fromPath;
  }
});

// node_modules/@npmcli/arborist/lib/dep-valid.js
var require_dep_valid = __commonJS({
  "node_modules/@npmcli/arborist/lib/dep-valid.js"(exports2, module2) {
    var semver = require_semver2();
    var npa = require_npa();
    var { relative } = require("node:path");
    var fromPath = require_from_path();
    var depValid = (child, requested, requestor) => {
      if (typeof requested === "string") {
        try {
          requested = npa.resolve(child.name, requested || "*", fromPath(requestor, requestor.edgesOut.get(child.name)));
        } catch (er2) {
          er2.dependency = child.name;
          er2.requested = requested;
          requestor.errors.push(er2);
          return false;
        }
      }
      if (!requested) {
        const er2 = new Error("Invalid dependency specifier");
        er2.dependency = child.name;
        er2.requested = requested;
        requestor.errors.push(er2);
        return false;
      }
      switch (requested.type) {
        case "range":
          if (requested.fetchSpec === "*") {
            return true;
          }
        // fallthrough
        case "version":
          return semver.satisfies(child.version, requested.fetchSpec, true);
        case "directory":
          return linkValid(child, requested, requestor);
        case "file":
          return tarballValid(child, requested, requestor);
        case "alias":
          return depValid(child, requested.subSpec, requestor);
        case "tag":
          return child.resolved && npa(child.resolved).type === "remote";
        case "remote":
          return child.resolved === requested.fetchSpec;
        case "git": {
          const resRepo = npa(child.resolved || "");
          const resHost = resRepo.hosted;
          const reqHost = requested.hosted;
          const reqCommit = /^[a-fA-F0-9]{40}$/.test(requested.gitCommittish || "");
          const nc = { noCommittish: !reqCommit };
          if (!resHost) {
            if (resRepo.fetchSpec !== requested.fetchSpec) {
              return false;
            }
          } else {
            if (reqHost?.ssh(nc) !== resHost.ssh(nc)) {
              return false;
            }
          }
          if (!requested.gitRange) {
            return true;
          }
          return semver.satisfies(child.package.version, requested.gitRange, {
            loose: true
          });
        }
        default:
          break;
      }
      const er = new Error("Unsupported dependency type");
      er.dependency = child.name;
      er.requested = requested;
      requestor.errors.push(er);
      return false;
    };
    var linkValid = (child, requested, requestor) => {
      const isLink = !!child.isLink;
      if (requestor.installLinks && !child.isWorkspace) {
        return !isLink;
      }
      return isLink && relative(child.realpath, requested.fetchSpec) === "";
    };
    var tarballValid = (child, requested) => {
      if (child.isLink) {
        return false;
      }
      if (child.resolved) {
        return child.resolved.replace(/\\/g, "/") === `file:${requested.fetchSpec.replace(/\\/g, "/")}`;
      }
      if (child.package._requested) {
        return child.package._requested.saveSpec === requested.saveSpec;
      }
      return false;
    };
    module2.exports = (child, requested, accept, requestor) => depValid(child, requested, requestor) || (typeof accept === "string" ? depValid(child, accept, requestor) : false);
  }
});

// node_modules/@npmcli/arborist/lib/override-set.js
var require_override_set = __commonJS({
  "node_modules/@npmcli/arborist/lib/override-set.js"(exports2, module2) {
    var npa = require_npa();
    var semver = require_semver2();
    var { log } = require_lib4();
    var OverrideSet = class _OverrideSet {
      constructor({ overrides, key, parent }) {
        this.parent = parent;
        this.children = /* @__PURE__ */ new Map();
        if (typeof overrides === "string") {
          overrides = { ".": overrides };
        }
        if (overrides["."] === "") {
          overrides["."] = "*";
        }
        if (parent) {
          const spec = npa(key);
          if (!spec.name) {
            throw new Error(`Override without name: ${key}`);
          }
          this.name = spec.name;
          spec.name = "";
          this.key = key;
          this.keySpec = spec.toString();
          this.value = overrides["."] || this.keySpec;
        }
        for (const [key2, childOverrides] of Object.entries(overrides)) {
          if (key2 === ".") {
            continue;
          }
          const child = new _OverrideSet({
            parent: this,
            key: key2,
            overrides: childOverrides
          });
          this.children.set(child.key, child);
        }
      }
      childrenAreEqual(other) {
        if (this.children.size !== other.children.size) {
          return false;
        }
        for (const [key] of this.children) {
          if (!other.children.has(key)) {
            return false;
          }
          if (this.children.get(key).value !== other.children.get(key).value) {
            return false;
          }
          if (!this.children.get(key).childrenAreEqual(other.children.get(key))) {
            return false;
          }
        }
        return true;
      }
      isEqual(other) {
        if (this === other) {
          return true;
        }
        if (!other) {
          return false;
        }
        if (this.key !== other.key || this.value !== other.value) {
          return false;
        }
        if (!this.childrenAreEqual(other)) {
          return false;
        }
        if (!this.parent) {
          return !other.parent;
        }
        return this.parent.isEqual(other.parent);
      }
      getEdgeRule(edge) {
        for (const rule of this.ruleset.values()) {
          if (rule.name !== edge.name) {
            continue;
          }
          if (rule.keySpec === "*") {
            return rule;
          }
          let spec = npa(`${edge.name}@${edge.rawSpec || edge.spec}`);
          if (spec.type === "alias") {
            spec = spec.subSpec;
          }
          if (spec.type === "git") {
            if (spec.gitRange && semver.intersects(spec.gitRange, rule.keySpec)) {
              return rule;
            }
            continue;
          }
          if (spec.type === "range" || spec.type === "version") {
            if (semver.intersects(spec.fetchSpec, rule.keySpec)) {
              return rule;
            }
            continue;
          }
          return rule;
        }
        return this;
      }
      getNodeRule(node) {
        for (const rule of this.ruleset.values()) {
          if (rule.name !== node.name) {
            continue;
          }
          if (semver.satisfies(node.version, rule.keySpec) || semver.satisfies(node.version, rule.value)) {
            return rule;
          }
        }
        return this;
      }
      getMatchingRule(node) {
        for (const rule of this.ruleset.values()) {
          if (rule.name !== node.name) {
            continue;
          }
          if (semver.satisfies(node.version, rule.keySpec) || semver.satisfies(node.version, rule.value)) {
            return rule;
          }
        }
        return null;
      }
      *ancestry() {
        for (let ancestor = this; ancestor; ancestor = ancestor.parent) {
          yield ancestor;
        }
      }
      get isRoot() {
        return !this.parent;
      }
      get ruleset() {
        const ruleset = /* @__PURE__ */ new Map();
        for (const override of this.ancestry()) {
          for (const kid of override.children.values()) {
            if (!ruleset.has(kid.key)) {
              ruleset.set(kid.key, kid);
            }
          }
          if (!override.isRoot && !ruleset.has(override.key)) {
            ruleset.set(override.key, override);
          }
        }
        return ruleset;
      }
      static findSpecificOverrideSet(first, second) {
        for (let overrideSet = second; overrideSet; overrideSet = overrideSet.parent) {
          if (overrideSet.isEqual(first)) {
            return second;
          }
        }
        for (let overrideSet = first; overrideSet; overrideSet = overrideSet.parent) {
          if (overrideSet.isEqual(second)) {
            return first;
          }
        }
        log.silly("Conflicting override sets", first, second);
      }
      static doOverrideSetsConflict(first, second) {
        return this.findSpecificOverrideSet(first, second) === void 0;
      }
    };
    module2.exports = OverrideSet;
  }
});

// node_modules/@npmcli/arborist/lib/edge.js
var require_edge = __commonJS({
  "node_modules/@npmcli/arborist/lib/edge.js"(exports2, module2) {
    var util = require("node:util");
    var npa = require_npa();
    var depValid = require_dep_valid();
    var OverrideSet = require_override_set();
    var ArboristEdge = class {
      constructor(edge) {
        this.name = edge.name;
        this.spec = edge.spec;
        this.type = edge.type;
        const edgeFrom = edge.from?.location;
        const edgeTo = edge.to?.location;
        const override = edge.overrides?.value;
        if (edgeFrom != null) {
          this.from = edgeFrom;
        }
        if (edgeTo) {
          this.to = edgeTo;
        }
        if (edge.error) {
          this.error = edge.error;
        }
        if (edge.peerConflicted) {
          this.peerConflicted = true;
        }
        if (override) {
          this.overridden = override;
        }
      }
    };
    var Edge = class _Edge {
      #accept;
      #error;
      #explanation;
      #from;
      #name;
      #spec;
      #to;
      #type;
      static types = Object.freeze([
        "prod",
        "dev",
        "optional",
        "peer",
        "peerOptional",
        "workspace"
      ]);
      // XXX where is this used?
      static errors = Object.freeze([
        "DETACHED",
        "MISSING",
        "PEER LOCAL",
        "INVALID"
      ]);
      constructor(options) {
        const { type, name, spec, accept, from, overrides } = options;
        if (typeof spec !== "string") {
          throw new TypeError("must provide string spec");
        }
        if (!_Edge.types.includes(type)) {
          throw new TypeError(`invalid type: ${type}
(valid types are: ${_Edge.types.join(", ")})`);
        }
        if (type === "workspace" && npa(spec).type !== "directory") {
          throw new TypeError("workspace edges must be a symlink");
        }
        if (typeof name !== "string") {
          throw new TypeError("must provide dependency name");
        }
        if (!from) {
          throw new TypeError('must provide "from" node');
        }
        if (accept !== void 0) {
          if (typeof accept !== "string") {
            throw new TypeError("accept field must be a string if provided");
          }
          this.#accept = accept || "*";
        }
        if (overrides !== void 0) {
          this.overrides = overrides;
        }
        this.#name = name;
        this.#type = type;
        this.#spec = spec;
        this.#explanation = null;
        this.#from = from;
        from.edgesOut.get(this.#name)?.detach();
        from.addEdgeOut(this);
        this.reload(true);
        this.peerConflicted = false;
      }
      satisfiedBy(node) {
        if (node.name !== this.#name || !this.#from) {
          return false;
        }
        if (node.hasShrinkwrap || node.inShrinkwrap || node.inBundle) {
          return depValid(node, this.rawSpec, this.#accept, this.#from);
        }
        if (!this.overrides?.keySpec) {
          return depValid(node, this.spec, this.#accept, this.#from);
        }
        if (depValid(node, this.spec, this.#accept, this.#from)) {
          return true;
        }
        if (!depValid(node, this.rawSpec, this.#accept, this.#from)) {
          return false;
        }
        return !depValid(node, this.overrides.keySpec, this.#accept, this.#from);
      }
      // return the edge data, and an explanation of how that edge came to be here
      explain(seen = []) {
        if (!this.#explanation) {
          const explanation = {
            type: this.#type,
            name: this.#name,
            spec: this.spec
          };
          if (this.rawSpec !== this.spec) {
            explanation.rawSpec = this.rawSpec;
            explanation.overridden = true;
          }
          if (this.bundled) {
            explanation.bundled = this.bundled;
          }
          if (this.error) {
            explanation.error = this.error;
          }
          if (this.#from) {
            explanation.from = this.#from.explain(null, seen);
          }
          this.#explanation = explanation;
        }
        return this.#explanation;
      }
      get bundled() {
        return !!this.#from?.package?.bundleDependencies?.includes(this.#name);
      }
      get workspace() {
        return this.#type === "workspace";
      }
      get prod() {
        return this.#type === "prod";
      }
      get dev() {
        return this.#type === "dev";
      }
      get optional() {
        return this.#type === "optional" || this.#type === "peerOptional";
      }
      get peer() {
        return this.#type === "peer" || this.#type === "peerOptional";
      }
      get type() {
        return this.#type;
      }
      get name() {
        return this.#name;
      }
      get rawSpec() {
        return this.#spec;
      }
      get spec() {
        if (this.overrides?.value && this.overrides.value !== "*" && this.overrides.name === this.#name) {
          if (this.overrides.value.startsWith("$")) {
            const ref = this.overrides.value.slice(1);
            let pkg = this.#from?.sourceReference ? this.#from?.sourceReference.root.package : this.#from?.root?.package;
            let specValue = this.#calculateReferentialOverrideSpec(ref, pkg);
            if (!specValue) {
              pkg = this.#from?.package;
              specValue = this.#calculateReferentialOverrideSpec(ref, pkg);
            }
            if (specValue) {
              return specValue;
            }
            throw new Error(`Unable to resolve reference ${this.overrides.value}`);
          }
          return this.overrides.value;
        }
        return this.#spec;
      }
      #calculateReferentialOverrideSpec(ref, pkg) {
        if (pkg.devDependencies?.[ref]) {
          return pkg.devDependencies[ref];
        }
        if (pkg.optionalDependencies?.[ref]) {
          return pkg.optionalDependencies[ref];
        }
        if (pkg.dependencies?.[ref]) {
          return pkg.dependencies[ref];
        }
        if (pkg.peerDependencies?.[ref]) {
          return pkg.peerDependencies[ref];
        }
      }
      get accept() {
        return this.#accept;
      }
      get valid() {
        return !this.error;
      }
      get missing() {
        return this.error === "MISSING";
      }
      get invalid() {
        return this.error === "INVALID";
      }
      get peerLocal() {
        return this.error === "PEER LOCAL";
      }
      get error() {
        if (!this.#error) {
          if (!this.#to) {
            if (this.optional) {
              this.#error = null;
            } else {
              this.#error = "MISSING";
            }
          } else if (this.peer && this.#from === this.#to.parent && !this.#from?.isTop) {
            this.#error = "PEER LOCAL";
          } else if (!this.satisfiedBy(this.#to)) {
            this.#error = "INVALID";
          } else if (this.overrides && this.#to.edgesOut.size && OverrideSet.doOverrideSetsConflict(this.overrides, this.#to.overrides)) {
            this.#error = "INVALID";
          } else {
            this.#error = "OK";
          }
        }
        if (this.#error === "OK") {
          return null;
        }
        return this.#error;
      }
      reload(hard = false) {
        this.#explanation = null;
        let needToUpdateOverrideSet = false;
        let newOverrideSet;
        let oldOverrideSet;
        if (this.#from?.overrides) {
          newOverrideSet = this.#from.overrides.getEdgeRule(this);
          if (newOverrideSet && !newOverrideSet.isEqual(this.overrides)) {
            needToUpdateOverrideSet = true;
            oldOverrideSet = this.overrides;
            this.overrides = newOverrideSet;
          }
        } else {
          delete this.overrides;
        }
        const newTo = this.#from?.resolve(this.#name);
        if (newTo !== this.#to) {
          if (this.#to) {
            this.#to.deleteEdgeIn(this);
          }
          this.#to = newTo;
          this.#error = null;
          if (this.#to) {
            this.#to.addEdgeIn(this);
          }
        } else if (hard) {
          this.#error = null;
        } else if (needToUpdateOverrideSet && this.#to) {
          this.#to.updateOverridesEdgeInRemoved(oldOverrideSet);
          this.#to.updateOverridesEdgeInAdded(newOverrideSet);
        }
      }
      detach() {
        this.#explanation = null;
        if (this.#to) {
          this.#to.deleteEdgeIn(this);
        }
        this.#from?.edgesOut.delete(this.#name);
        this.#to = null;
        this.#error = "DETACHED";
        this.#from = null;
      }
      get from() {
        return this.#from;
      }
      get to() {
        return this.#to;
      }
      toJSON() {
        return new ArboristEdge(this);
      }
      [util.inspect.custom]() {
        return this.toJSON();
      }
    };
    module2.exports = Edge;
  }
});

// node_modules/@npmcli/arborist/lib/inventory.js
var require_inventory = __commonJS({
  "node_modules/@npmcli/arborist/lib/inventory.js"(exports2, module2) {
    var { hasOwnProperty } = Object.prototype;
    var debug = require_debug2();
    var keys = ["name", "license", "funding", "realpath", "packageName"];
    var Inventory = class extends Map {
      #index;
      constructor() {
        super();
        this.#index = /* @__PURE__ */ new Map();
        for (const key of keys) {
          this.#index.set(key, /* @__PURE__ */ new Map());
        }
      }
      // XXX where is this used?
      get primaryKey() {
        return "location";
      }
      // XXX where is this used?
      get indexes() {
        return [...keys];
      }
      *filter(fn) {
        for (const node of this.values()) {
          if (fn(node)) {
            yield node;
          }
        }
      }
      add(node) {
        const root = super.get("");
        if (root && node.root !== root && node.root !== root.root) {
          debug(() => {
            throw Object.assign(new Error("adding external node to inventory"), {
              root: root.path,
              node: node.path,
              nodeRoot: node.root.path
            });
          });
          return;
        }
        const current = super.get(node.location);
        if (current) {
          if (current === node) {
            return;
          }
          this.delete(current);
        }
        super.set(node.location, node);
        for (const [key, map] of this.#index.entries()) {
          let val;
          if (hasOwnProperty.call(node, key)) {
            val = node[key];
          } else if (key === "license" && node.package) {
            if (node.package.license) {
              val = node.package.license;
            } else if (node.package.licence) {
              val = node.package.licence;
            } else if (Array.isArray(node.package.licenses)) {
              val = node.package.licenses[0];
            } else if (Array.isArray(node.package.licences)) {
              val = node.package.licences[0];
            }
          } else if (node[key]) {
            val = node[key];
          } else {
            val = node.package?.[key];
          }
          if (val && typeof val === "object") {
            if (key === "license") {
              val = val.type;
            } else if (key === "funding") {
              val = val.url;
            }
          }
          if (!map.has(val)) {
            map.set(val, /* @__PURE__ */ new Set());
          }
          map.get(val).add(node);
        }
      }
      delete(node) {
        if (!this.has(node)) {
          return;
        }
        super.delete(node.location);
        for (const [key, map] of this.#index.entries()) {
          let val;
          if (node[key] !== void 0) {
            val = node[key];
          } else {
            val = node.package?.[key];
          }
          const set = map.get(val);
          if (set) {
            set.delete(node);
            if (set.size === 0) {
              map.delete(node[key]);
            }
          }
        }
      }
      query(key, val) {
        const map = this.#index.get(key);
        if (arguments.length === 2) {
          if (map.has(val)) {
            return map.get(val);
          }
          return /* @__PURE__ */ new Set();
        }
        return map.keys();
      }
      has(node) {
        return super.get(node.location) === node;
      }
      set() {
        throw new Error("direct set() not supported, use inventory.add(node)");
      }
    };
    module2.exports = Inventory;
  }
});

// node_modules/bin-links/lib/is-windows.js
var require_is_windows = __commonJS({
  "node_modules/bin-links/lib/is-windows.js"(exports2, module2) {
    var platform = process.env.__TESTING_BIN_LINKS_PLATFORM__ || process.platform;
    module2.exports = platform === "win32";
  }
});

// node_modules/bin-links/lib/get-node-modules.js
var require_get_node_modules = __commonJS({
  "node_modules/bin-links/lib/get-node-modules.js"(exports2, module2) {
    var { dirname, basename } = require("path");
    var memo = /* @__PURE__ */ new Map();
    module2.exports = (path) => {
      if (memo.has(path)) {
        return memo.get(path);
      }
      const scopeOrNm = dirname(path);
      const nm = basename(scopeOrNm) === "node_modules" ? scopeOrNm : dirname(scopeOrNm);
      memo.set(path, nm);
      return nm;
    };
  }
});

// node_modules/bin-links/lib/get-prefix.js
var require_get_prefix = __commonJS({
  "node_modules/bin-links/lib/get-prefix.js"(exports2, module2) {
    var { dirname } = require("path");
    var getNodeModules = require_get_node_modules();
    module2.exports = (path) => dirname(getNodeModules(path));
  }
});

// node_modules/bin-links/lib/bin-target.js
var require_bin_target = __commonJS({
  "node_modules/bin-links/lib/bin-target.js"(exports2, module2) {
    var isWindows = require_is_windows();
    var getPrefix = require_get_prefix();
    var getNodeModules = require_get_node_modules();
    var { dirname } = require("path");
    module2.exports = ({ top, path }) => !top ? getNodeModules(path) + "/.bin" : isWindows ? getPrefix(path) : dirname(getPrefix(path)) + "/bin";
  }
});

// node_modules/cmd-shim/lib/to-batch-syntax.js
var require_to_batch_syntax = __commonJS({
  "node_modules/cmd-shim/lib/to-batch-syntax.js"(exports2) {
    exports2.replaceDollarWithPercentPair = replaceDollarWithPercentPair;
    exports2.convertToSetCommand = convertToSetCommand;
    exports2.convertToSetCommands = convertToSetCommands;
    function convertToSetCommand(key, value) {
      var line = "";
      key = key || "";
      key = key.trim();
      value = value || "";
      value = value.trim();
      if (key && value && value.length > 0) {
        line = "@SET " + key + "=" + replaceDollarWithPercentPair(value) + "\r\n";
      }
      return line;
    }
    function extractVariableValuePairs(declarations) {
      var pairs = {};
      declarations.map(function(declaration) {
        var split = declaration.split("=");
        pairs[split[0]] = split[1];
      });
      return pairs;
    }
    function convertToSetCommands(variableString) {
      var variableValuePairs = extractVariableValuePairs(variableString.split(" "));
      var variableDeclarationsAsBatch = "";
      Object.keys(variableValuePairs).forEach(function(key) {
        variableDeclarationsAsBatch += convertToSetCommand(key, variableValuePairs[key]);
      });
      return variableDeclarationsAsBatch;
    }
    function replaceDollarWithPercentPair(value) {
      var dollarExpressions = /\$\{?([^$@#?\- \t{}:]+)\}?/g;
      var result = "";
      var startIndex = 0;
      do {
        var match = dollarExpressions.exec(value);
        if (match) {
          var betweenMatches = value.substring(startIndex, match.index) || "";
          result += betweenMatches + "%" + match[1] + "%";
          startIndex = dollarExpressions.lastIndex;
        }
      } while (dollarExpressions.lastIndex > 0);
      result += value.slice(startIndex);
      return result;
    }
  }
});

// node_modules/cmd-shim/lib/index.js
var require_lib37 = __commonJS({
  "node_modules/cmd-shim/lib/index.js"(exports2, module2) {
    var {
      chmod,
      mkdir,
      readFile,
      stat,
      unlink,
      writeFile
    } = require("fs/promises");
    var { dirname, relative } = require("path");
    var toBatchSyntax = require_to_batch_syntax();
    var shebangExpr = /^#!\s*(?:\/usr\/bin\/env\s+(?:-S\s+)?((?:[^ \t=]+=[^ \t=]+\s+)*))?([^ \t]+)(.*)$/;
    var cmdShimIfExists = (from, to) => stat(from).then(() => cmdShim(from, to), () => {
    });
    var rm = (path) => unlink(path).catch(() => {
    });
    var cmdShim = (from, to) => stat(from).then(() => cmdShim_(from, to));
    var cmdShim_ = (from, to) => Promise.all([
      rm(to),
      rm(to + ".cmd"),
      rm(to + ".ps1")
    ]).then(() => writeShim(from, to));
    var writeShim = (from, to) => (
      // make a cmd file and a sh script
      // First, check if the bin is a #! of some sort.
      // If not, then assume it's something that'll be compiled, or some other
      // sort of script, and just call it directly.
      mkdir(dirname(to), { recursive: true }).then(() => readFile(from, "utf8")).then((data) => {
        const firstLine = data.trim().split(/\r*\n/)[0];
        const shebang = firstLine.match(shebangExpr);
        if (!shebang) {
          return writeShim_(from, to);
        }
        const vars = shebang[1] || "";
        const prog = shebang[2];
        const args = shebang[3] || "";
        return writeShim_(from, to, prog, args, vars);
      }, () => writeShim_(from, to))
    );
    var writeShim_ = (from, to, prog, args, variables) => {
      let shTarget = relative(dirname(to), from);
      let target = shTarget.split("/").join("\\");
      let longProg;
      let shProg = prog && prog.split("\\").join("/");
      let shLongProg;
      let pwshProg = shProg && `"${shProg}$exe"`;
      let pwshLongProg;
      shTarget = shTarget.split("\\").join("/");
      args = args || "";
      variables = variables || "";
      if (!prog) {
        prog = `"%dp0%\\${target}"`;
        shProg = `"$basedir/${shTarget}"`;
        pwshProg = shProg;
        args = "";
        target = "";
        shTarget = "";
      } else {
        longProg = `"%dp0%\\${prog}.exe"`;
        shLongProg = `"$basedir/${prog}"`;
        pwshLongProg = `"$basedir/${prog}$exe"`;
        target = `"%dp0%\\${target}"`;
        shTarget = `"$basedir/${shTarget}"`;
      }
      const head = "@ECHO off\r\nGOTO start\r\n:find_dp0\r\nSET dp0=%~dp0\r\nEXIT /b\r\n:start\r\nSETLOCAL\r\nCALL :find_dp0\r\n";
      let cmd;
      if (longProg) {
        shLongProg = shLongProg.trim();
        args = args.trim();
        const variablesBatch = toBatchSyntax.convertToSetCommands(variables);
        cmd = head + variablesBatch + `\r
IF EXIST ${longProg} (\r
  SET "_prog=${longProg.replace(/(^")|("$)/g, "")}"\r
) ELSE (\r
  SET "_prog=${prog.replace(/(^")|("$)/g, "")}"\r
  SET PATHEXT=%PATHEXT:;.JS;=;%\r
)\r
\r
endLocal & goto #_undefined_# 2>NUL || title %COMSPEC% & "%_prog%" ${args} ${target} %*\r
`;
      } else {
        cmd = `${head}${prog} ${args} ${target} %*\r
`;
      }
      let sh = "#!/bin/sh\n";
      sh = sh + `basedir=$(dirname "$(echo "$0" | sed -e 's,\\\\,/,g')")

case \`uname\` in
    *CYGWIN*|*MINGW*|*MSYS*)
        if command -v cygpath > /dev/null 2>&1; then
            basedir=\`cygpath -w "$basedir"\`
        fi
    ;;
esac

`;
      if (shLongProg) {
        sh = sh + `if [ -x ${shLongProg} ]; then
  exec ${variables}${shLongProg} ${args} ${shTarget} "$@"
else 
  exec ${variables}${shProg} ${args} ${shTarget} "$@"
fi
`;
      } else {
        sh = sh + `exec ${shProg} ${args} ${shTarget} "$@"
`;
      }
      let pwsh = '#!/usr/bin/env pwsh\n$basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\n\n$exe=""\nif ($PSVersionTable.PSVersion -lt "6.0" -or $IsWindows) {\n  # Fix case when both the Windows and Linux builds of Node\n  # are installed in the same directory\n  $exe=".exe"\n}\n';
      if (shLongProg) {
        pwsh = pwsh + `$ret=0
if (Test-Path ${pwshLongProg}) {
  # Support pipeline input
  if ($MyInvocation.ExpectingInput) {
    $input | & ${pwshLongProg} ${args} ${shTarget} $args
  } else {
    & ${pwshLongProg} ${args} ${shTarget} $args
  }
  $ret=$LASTEXITCODE
} else {
  # Support pipeline input
  if ($MyInvocation.ExpectingInput) {
    $input | & ${pwshProg} ${args} ${shTarget} $args
  } else {
    & ${pwshProg} ${args} ${shTarget} $args
  }
  $ret=$LASTEXITCODE
}
exit $ret
`;
      } else {
        pwsh = pwsh + `# Support pipeline input
if ($MyInvocation.ExpectingInput) {
  $input | & ${pwshProg} ${args} ${shTarget} $args
} else {
  & ${pwshProg} ${args} ${shTarget} $args
}
exit $LASTEXITCODE
`;
      }
      return Promise.all([
        writeFile(to + ".ps1", pwsh, "utf8"),
        writeFile(to + ".cmd", cmd, "utf8"),
        writeFile(to, sh, "utf8")
      ]).then(() => chmodShim(to));
    };
    var chmodShim = (to) => Promise.all([
      chmod(to, 493),
      chmod(to + ".cmd", 493),
      chmod(to + ".ps1", 493)
    ]);
    module2.exports = cmdShim;
    cmdShim.ifExists = cmdShimIfExists;
  }
});

// node_modules/read-cmd-shim/lib/index.js
var require_lib38 = __commonJS({
  "node_modules/read-cmd-shim/lib/index.js"(exports2, module2) {
    var fs2 = require("fs");
    var { promisify } = require("util");
    var { readFileSync } = fs2;
    var readFile = promisify(fs2.readFile);
    var extractPath = (path, cmdshimContents) => {
      if (/[.]cmd$/.test(path)) {
        return extractPathFromCmd(cmdshimContents);
      } else if (/[.]ps1$/.test(path)) {
        return extractPathFromPowershell(cmdshimContents);
      } else {
        return extractPathFromCygwin(cmdshimContents);
      }
    };
    var extractPathFromPowershell = (cmdshimContents) => {
      const matches = cmdshimContents.match(/"[$]basedir[/]([^"]+?)"\s+[$]args/);
      return matches && matches[1];
    };
    var extractPathFromCmd = (cmdshimContents) => {
      const matches = cmdshimContents.match(/"%(?:~dp0|dp0%)\\([^"]+?)"\s+%[*]/);
      return matches && matches[1];
    };
    var extractPathFromCygwin = (cmdshimContents) => {
      const matches = cmdshimContents.match(/"[$]basedir[/]([^"]+?)"\s+"[$]@"/);
      return matches && matches[1];
    };
    var wrapError = (thrown, newError) => {
      newError.message = thrown.message;
      newError.code = thrown.code;
      newError.path = thrown.path;
      return newError;
    };
    var notaShim = (path, er) => {
      if (!er) {
        er = new Error();
        Error.captureStackTrace(er, notaShim);
      }
      er.code = "ENOTASHIM";
      er.message = `Can't read shim path from '${path}', it doesn't appear to be a cmd-shim`;
      return er;
    };
    var readCmdShim = (path) => {
      const er = new Error();
      Error.captureStackTrace(er, readCmdShim);
      return readFile(path).then((contents) => {
        const destination = extractPath(path, contents.toString());
        if (destination) {
          return destination;
        }
        throw notaShim(path, er);
      }, (readFileEr) => {
        throw wrapError(readFileEr, er);
      });
    };
    var readCmdShimSync = (path) => {
      const contents = readFileSync(path);
      const destination = extractPath(path, contents.toString());
      if (!destination) {
        throw notaShim(path);
      }
      return destination;
    };
    readCmdShim.sync = readCmdShimSync;
    module2.exports = readCmdShim;
  }
});

// node_modules/signal-exit/dist/cjs/signals.js
var require_signals = __commonJS({
  "node_modules/signal-exit/dist/cjs/signals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signals = void 0;
    exports2.signals = [];
    exports2.signals.push("SIGHUP", "SIGINT", "SIGTERM");
    if (process.platform !== "win32") {
      exports2.signals.push(
        "SIGALRM",
        "SIGABRT",
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      exports2.signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
    }
  }
});

// node_modules/signal-exit/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/signal-exit/dist/cjs/index.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unload = exports2.load = exports2.onExit = exports2.signals = void 0;
    var signals_js_1 = require_signals();
    Object.defineProperty(exports2, "signals", { enumerable: true, get: function() {
      return signals_js_1.signals;
    } });
    var processOk = (process3) => !!process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
    var kExitEmitter = Symbol.for("signal-exit emitter");
    var global2 = globalThis;
    var ObjectDefineProperty = Object.defineProperty.bind(Object);
    var Emitter = class {
      emitted = {
        afterExit: false,
        exit: false
      };
      listeners = {
        afterExit: [],
        exit: []
      };
      count = 0;
      id = Math.random();
      constructor() {
        if (global2[kExitEmitter]) {
          return global2[kExitEmitter];
        }
        ObjectDefineProperty(global2, kExitEmitter, {
          value: this,
          writable: false,
          enumerable: false,
          configurable: false
        });
      }
      on(ev, fn) {
        this.listeners[ev].push(fn);
      }
      removeListener(ev, fn) {
        const list = this.listeners[ev];
        const i = list.indexOf(fn);
        if (i === -1) {
          return;
        }
        if (i === 0 && list.length === 1) {
          list.length = 0;
        } else {
          list.splice(i, 1);
        }
      }
      emit(ev, code, signal) {
        if (this.emitted[ev]) {
          return false;
        }
        this.emitted[ev] = true;
        let ret = false;
        for (const fn of this.listeners[ev]) {
          ret = fn(code, signal) === true || ret;
        }
        if (ev === "exit") {
          ret = this.emit("afterExit", code, signal) || ret;
        }
        return ret;
      }
    };
    var SignalExitBase = class {
    };
    var signalExitWrap = (handler) => {
      return {
        onExit(cb, opts) {
          return handler.onExit(cb, opts);
        },
        load() {
          return handler.load();
        },
        unload() {
          return handler.unload();
        }
      };
    };
    var SignalExitFallback = class extends SignalExitBase {
      onExit() {
        return () => {
        };
      }
      load() {
      }
      unload() {
      }
    };
    var SignalExit = class extends SignalExitBase {
      // "SIGHUP" throws an `ENOSYS` error on Windows,
      // so use a supported signal instead
      /* c8 ignore start */
      #hupSig = process2.platform === "win32" ? "SIGINT" : "SIGHUP";
      /* c8 ignore stop */
      #emitter = new Emitter();
      #process;
      #originalProcessEmit;
      #originalProcessReallyExit;
      #sigListeners = {};
      #loaded = false;
      constructor(process3) {
        super();
        this.#process = process3;
        this.#sigListeners = {};
        for (const sig of signals_js_1.signals) {
          this.#sigListeners[sig] = () => {
            const listeners = this.#process.listeners(sig);
            let { count } = this.#emitter;
            const p = process3;
            if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") {
              count += p.__signal_exit_emitter__.count;
            }
            if (listeners.length === count) {
              this.unload();
              const ret = this.#emitter.emit("exit", null, sig);
              const s = sig === "SIGHUP" ? this.#hupSig : sig;
              if (!ret)
                process3.kill(process3.pid, s);
            }
          };
        }
        this.#originalProcessReallyExit = process3.reallyExit;
        this.#originalProcessEmit = process3.emit;
      }
      onExit(cb, opts) {
        if (!processOk(this.#process)) {
          return () => {
          };
        }
        if (this.#loaded === false) {
          this.load();
        }
        const ev = opts?.alwaysLast ? "afterExit" : "exit";
        this.#emitter.on(ev, cb);
        return () => {
          this.#emitter.removeListener(ev, cb);
          if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) {
            this.unload();
          }
        };
      }
      load() {
        if (this.#loaded) {
          return;
        }
        this.#loaded = true;
        this.#emitter.count += 1;
        for (const sig of signals_js_1.signals) {
          try {
            const fn = this.#sigListeners[sig];
            if (fn)
              this.#process.on(sig, fn);
          } catch (_) {
          }
        }
        this.#process.emit = (ev, ...a) => {
          return this.#processEmit(ev, ...a);
        };
        this.#process.reallyExit = (code) => {
          return this.#processReallyExit(code);
        };
      }
      unload() {
        if (!this.#loaded) {
          return;
        }
        this.#loaded = false;
        signals_js_1.signals.forEach((sig) => {
          const listener = this.#sigListeners[sig];
          if (!listener) {
            throw new Error("Listener not defined for signal: " + sig);
          }
          try {
            this.#process.removeListener(sig, listener);
          } catch (_) {
          }
        });
        this.#process.emit = this.#originalProcessEmit;
        this.#process.reallyExit = this.#originalProcessReallyExit;
        this.#emitter.count -= 1;
      }
      #processReallyExit(code) {
        if (!processOk(this.#process)) {
          return 0;
        }
        this.#process.exitCode = code || 0;
        this.#emitter.emit("exit", this.#process.exitCode, null);
        return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
      }
      #processEmit(ev, ...args) {
        const og = this.#originalProcessEmit;
        if (ev === "exit" && processOk(this.#process)) {
          if (typeof args[0] === "number") {
            this.#process.exitCode = args[0];
          }
          const ret = og.call(this.#process, ev, ...args);
          this.#emitter.emit("exit", this.#process.exitCode, null);
          return ret;
        } else {
          return og.call(this.#process, ev, ...args);
        }
      }
    };
    var process2 = globalThis.process;
    _a = signalExitWrap(processOk(process2) ? new SignalExit(process2) : new SignalExitFallback()), /**
     * Called when the process is exiting, whether via signal, explicit
     * exit, or running out of stuff to do.
     *
     * If the global process object is not suitable for instrumentation,
     * then this will be a no-op.
     *
     * Returns a function that may be used to unload signal-exit.
     */
    exports2.onExit = _a.onExit, /**
     * Load the listeners.  Likely you never need to call this, unless
     * doing a rather deep integration with signal-exit functionality.
     * Mostly exposed for the benefit of testing.
     *
     * @internal
     */
    exports2.load = _a.load, /**
     * Unload the listeners.  Likely you never need to call this, unless
     * doing a rather deep integration with signal-exit functionality.
     * Mostly exposed for the benefit of testing.
     *
     * @internal
     */
    exports2.unload = _a.unload;
  }
});

// node_modules/write-file-atomic/lib/index.js
var require_lib39 = __commonJS({
  "node_modules/write-file-atomic/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = writeFile;
    module2.exports.sync = writeFileSync;
    module2.exports._getTmpname = getTmpname;
    module2.exports._cleanupOnExit = cleanupOnExit;
    var fs2 = require("fs");
    var MurmurHash3 = require_imurmurhash();
    var { onExit } = require_cjs2();
    var path = require("path");
    var { promisify } = require("util");
    var activeFiles = {};
    var threadId = function getId() {
      try {
        const workerThreads = require("worker_threads");
        return workerThreads.threadId;
      } catch (e) {
        return 0;
      }
    }();
    var invocations = 0;
    function getTmpname(filename) {
      return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
    }
    function cleanupOnExit(tmpfile) {
      return () => {
        try {
          fs2.unlinkSync(typeof tmpfile === "function" ? tmpfile() : tmpfile);
        } catch {
        }
      };
    }
    function serializeActiveFile(absoluteName) {
      return new Promise((resolve) => {
        if (!activeFiles[absoluteName]) {
          activeFiles[absoluteName] = [];
        }
        activeFiles[absoluteName].push(resolve);
        if (activeFiles[absoluteName].length === 1) {
          resolve();
        }
      });
    }
    function isChownErrOk(err) {
      if (err.code === "ENOSYS") {
        return true;
      }
      const nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (err.code === "EINVAL" || err.code === "EPERM") {
          return true;
        }
      }
      return false;
    }
    async function writeFileAsync(filename, data, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      let fd;
      let tmpfile;
      const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile));
      const absoluteName = path.resolve(filename);
      try {
        await serializeActiveFile(absoluteName);
        const truename = await promisify(fs2.realpath)(filename).catch(() => filename);
        tmpfile = getTmpname(truename);
        if (!options.mode || !options.chown) {
          const stats = await promisify(fs2.stat)(truename).catch(() => {
          });
          if (stats) {
            if (options.mode == null) {
              options.mode = stats.mode;
            }
            if (options.chown == null && process.getuid) {
              options.chown = { uid: stats.uid, gid: stats.gid };
            }
          }
        }
        fd = await promisify(fs2.open)(tmpfile, "w", options.mode);
        if (options.tmpfileCreated) {
          await options.tmpfileCreated(tmpfile);
        }
        if (ArrayBuffer.isView(data)) {
          await promisify(fs2.write)(fd, data, 0, data.length, 0);
        } else if (data != null) {
          await promisify(fs2.write)(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        if (options.fsync !== false) {
          await promisify(fs2.fsync)(fd);
        }
        await promisify(fs2.close)(fd);
        fd = null;
        if (options.chown) {
          await promisify(fs2.chown)(tmpfile, options.chown.uid, options.chown.gid).catch((err) => {
            if (!isChownErrOk(err)) {
              throw err;
            }
          });
        }
        if (options.mode) {
          await promisify(fs2.chmod)(tmpfile, options.mode).catch((err) => {
            if (!isChownErrOk(err)) {
              throw err;
            }
          });
        }
        await promisify(fs2.rename)(tmpfile, truename);
      } finally {
        if (fd) {
          await promisify(fs2.close)(fd).catch(
            /* istanbul ignore next */
            () => {
            }
          );
        }
        removeOnExitHandler();
        await promisify(fs2.unlink)(tmpfile).catch(() => {
        });
        activeFiles[absoluteName].shift();
        if (activeFiles[absoluteName].length > 0) {
          activeFiles[absoluteName][0]();
        } else {
          delete activeFiles[absoluteName];
        }
      }
    }
    async function writeFile(filename, data, options, callback) {
      if (options instanceof Function) {
        callback = options;
        options = {};
      }
      const promise = writeFileAsync(filename, data, options);
      if (callback) {
        try {
          const result = await promise;
          return callback(result);
        } catch (err) {
          return callback(err);
        }
      }
      return promise;
    }
    function writeFileSync(filename, data, options) {
      if (typeof options === "string") {
        options = { encoding: options };
      } else if (!options) {
        options = {};
      }
      try {
        filename = fs2.realpathSync(filename);
      } catch (ex) {
      }
      const tmpfile = getTmpname(filename);
      if (!options.mode || !options.chown) {
        try {
          const stats = fs2.statSync(filename);
          options = Object.assign({}, options);
          if (!options.mode) {
            options.mode = stats.mode;
          }
          if (!options.chown && process.getuid) {
            options.chown = { uid: stats.uid, gid: stats.gid };
          }
        } catch (ex) {
        }
      }
      let fd;
      const cleanup = cleanupOnExit(tmpfile);
      const removeOnExitHandler = onExit(cleanup);
      let threw = true;
      try {
        fd = fs2.openSync(tmpfile, "w", options.mode || 438);
        if (options.tmpfileCreated) {
          options.tmpfileCreated(tmpfile);
        }
        if (ArrayBuffer.isView(data)) {
          fs2.writeSync(fd, data, 0, data.length, 0);
        } else if (data != null) {
          fs2.writeSync(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        if (options.fsync !== false) {
          fs2.fsyncSync(fd);
        }
        fs2.closeSync(fd);
        fd = null;
        if (options.chown) {
          try {
            fs2.chownSync(tmpfile, options.chown.uid, options.chown.gid);
          } catch (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }
        }
        if (options.mode) {
          try {
            fs2.chmodSync(tmpfile, options.mode);
          } catch (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }
        }
        fs2.renameSync(tmpfile, filename);
        threw = false;
      } finally {
        if (fd) {
          try {
            fs2.closeSync(fd);
          } catch (ex) {
          }
        }
        removeOnExitHandler();
        if (threw) {
          cleanup();
        }
      }
    }
  }
});

// node_modules/bin-links/lib/fix-bin.js
var require_fix_bin = __commonJS({
  "node_modules/bin-links/lib/fix-bin.js"(exports2, module2) {
    var {
      chmod,
      open,
      readFile
    } = require("fs/promises");
    var execMode = 511 & ~process.umask();
    var writeFileAtomic = require_lib39();
    var isWindowsHashBang = (buf) => buf[0] === "#".charCodeAt(0) && buf[1] === "!".charCodeAt(0) && /^#![^\n]+\r\n/.test(buf.toString());
    var isWindowsHashbangFile = (file) => {
      const FALSE = () => false;
      return open(file, "r").then((fh) => {
        const buf = Buffer.alloc(2048);
        return fh.read(buf, 0, 2048, 0).then(
          () => {
            const isWHB = isWindowsHashBang(buf);
            return fh.close().then(() => isWHB, () => isWHB);
          },
          // don't leak FD if read() fails
          () => fh.close().then(FALSE, FALSE)
        );
      }, FALSE);
    };
    var dos2Unix = (file) => readFile(file, "utf8").then((content) => writeFileAtomic(file, content.replace(/^(#![^\n]+)\r\n/, "$1\n")));
    var fixBin = (file, mode = execMode) => chmod(file, mode).then(() => isWindowsHashbangFile(file)).then((isWHB) => isWHB ? dos2Unix(file) : null);
    module2.exports = fixBin;
  }
});

// node_modules/bin-links/lib/shim-bin.js
var require_shim_bin = __commonJS({
  "node_modules/bin-links/lib/shim-bin.js"(exports2, module2) {
    var { resolve, dirname } = require("path");
    var { lstat } = require("fs/promises");
    var throwNonEnoent = (er) => {
      if (er.code !== "ENOENT") {
        throw er;
      }
    };
    var cmdShim = require_lib37();
    var readCmdShim = require_lib38();
    var fixBin = require_fix_bin();
    var seen = /* @__PURE__ */ new Set();
    var failEEXIST = ({ to, from }) => Promise.reject(Object.assign(new Error("EEXIST: file already exists"), {
      path: to,
      dest: from,
      code: "EEXIST"
    }));
    var handleReadCmdShimError = ({ er, from, to }) => er.code === "ENOENT" ? null : er.code === "ENOTASHIM" ? failEEXIST({ from, to }) : Promise.reject(er);
    var SKIP = Symbol("skip - missing or already installed");
    var shimBin = ({ path, to, from, absFrom, force }) => {
      const shims = [
        to,
        to + ".cmd",
        to + ".ps1"
      ];
      for (const shim of shims) {
        if (seen.has(shim)) {
          return true;
        }
        seen.add(shim);
      }
      return Promise.all([
        ...shims,
        absFrom
      ].map((f) => lstat(f).catch(throwNonEnoent))).then((stats) => {
        const [, , , stFrom] = stats;
        if (!stFrom) {
          return SKIP;
        }
        if (force) {
          return false;
        }
        return Promise.all(shims.map((s, i) => [s, stats[i]]).map(([s, st]) => {
          if (!st) {
            return false;
          }
          return readCmdShim(s).then((target) => {
            target = resolve(dirname(to), target);
            if (target.indexOf(resolve(path)) !== 0) {
              return failEEXIST({ from, to, path });
            }
            return false;
          }, (er) => handleReadCmdShimError({ er, from, to }));
        }));
      }).then((skip) => skip !== SKIP && doShim(absFrom, to));
    };
    var doShim = (absFrom, to) => cmdShim(absFrom, to).then(() => fixBin(absFrom));
    var resetSeen = () => {
      for (const p of seen) {
        seen.delete(p);
      }
    };
    module2.exports = Object.assign(shimBin, { resetSeen });
  }
});

// node_modules/bin-links/lib/link-gently.js
var require_link_gently = __commonJS({
  "node_modules/bin-links/lib/link-gently.js"(exports2, module2) {
    var { resolve, dirname } = require("path");
    var { lstat, mkdir, readlink, rm, symlink } = require("fs/promises");
    var { log } = require_lib4();
    var throwSignificant = (er) => {
      if (er.code === "ENOENT") {
        return;
      }
      if (er.code === "EACCES") {
        log.warn("error adding file", er.message);
        return;
      }
      throw er;
    };
    var rmOpts = {
      recursive: true,
      force: true
    };
    var seen = /* @__PURE__ */ new Set();
    var SKIP = Symbol("skip - missing or already installed");
    var CLOBBER = Symbol("clobber - ours or in forceful mode");
    var linkGently = async ({ path, to, from, absFrom, force }) => {
      if (seen.has(to)) {
        return false;
      }
      seen.add(to);
      return Promise.all([
        lstat(absFrom).catch(throwSignificant),
        lstat(to).catch(throwSignificant)
      ]).then(([stFrom, stTo]) => {
        if (!stFrom) {
          return SKIP;
        }
        if (stTo) {
          if (!stTo.isSymbolicLink()) {
            return force && rm(to, rmOpts).then(() => CLOBBER);
          }
          return readlink(to).then((target) => {
            if (target === from) {
              return SKIP;
            }
            target = resolve(dirname(to), target);
            if (target.indexOf(path) === 0 || force) {
              return rm(to, rmOpts).then(() => CLOBBER);
            }
            return false;
          });
        } else {
          return mkdir(dirname(to), { recursive: true });
        }
      }).then((skipOrClobber) => {
        if (skipOrClobber === SKIP) {
          return false;
        }
        return symlink(from, to, "file").catch((er) => {
          if (skipOrClobber === CLOBBER || force) {
            return rm(to, rmOpts).then(() => symlink(from, to, "file"));
          }
          throw er;
        }).then(() => true);
      });
    };
    var resetSeen = () => {
      for (const p of seen) {
        seen.delete(p);
      }
    };
    module2.exports = Object.assign(linkGently, { resetSeen });
  }
});

// node_modules/bin-links/lib/link-bin.js
var require_link_bin = __commonJS({
  "node_modules/bin-links/lib/link-bin.js"(exports2, module2) {
    var linkGently = require_link_gently();
    var fixBin = require_fix_bin();
    var linkBin = ({ path, to, from, absFrom, force }) => linkGently({ path, to, from, absFrom, force }).then((linked) => linked && fixBin(absFrom));
    module2.exports = linkBin;
  }
});

// node_modules/bin-links/lib/link-bins.js
var require_link_bins = __commonJS({
  "node_modules/bin-links/lib/link-bins.js"(exports2, module2) {
    var isWindows = require_is_windows();
    var binTarget = require_bin_target();
    var { dirname, resolve, relative } = require("path");
    var linkBin = isWindows ? require_shim_bin() : require_link_bin();
    var normalize = require_lib10();
    var linkBins = ({ path, pkg, top, force }) => {
      pkg = normalize(pkg);
      if (!pkg.bin) {
        return Promise.resolve([]);
      }
      const promises = [];
      const target = binTarget({ path, top });
      for (const [key, val] of Object.entries(pkg.bin)) {
        const to = resolve(target, key);
        const absFrom = resolve(path, val);
        const from = relative(dirname(to), absFrom);
        promises.push(linkBin({ path, from, to, absFrom, force }));
      }
      return Promise.all(promises);
    };
    module2.exports = linkBins;
  }
});

// node_modules/bin-links/lib/man-target.js
var require_man_target = __commonJS({
  "node_modules/bin-links/lib/man-target.js"(exports2, module2) {
    var isWindows = require_is_windows();
    var getPrefix = require_get_prefix();
    var { dirname } = require("path");
    module2.exports = ({ top, path }) => !top || isWindows ? null : dirname(getPrefix(path)) + "/share/man";
  }
});

// node_modules/bin-links/lib/link-mans.js
var require_link_mans = __commonJS({
  "node_modules/bin-links/lib/link-mans.js"(exports2, module2) {
    var { dirname, relative, join, resolve, basename } = require("path");
    var linkGently = require_link_gently();
    var manTarget = require_man_target();
    var linkMans = async ({ path, pkg, top, force }) => {
      const target = manTarget({ path, top });
      if (!target || !Array.isArray(pkg?.man) || !pkg.man.length) {
        return [];
      }
      const links = [];
      for (let man of new Set(pkg.man)) {
        if (!man || typeof man !== "string") {
          continue;
        }
        man = join("/", man).replace(/\\|:/g, "/").slice(1);
        const parseMan = man.match(/\.([0-9]+)(\.gz)?$/);
        if (!parseMan) {
          throw Object.assign(new Error(
            "invalid man entry name\nMan files must end with a number, and optionally a .gz suffix if they are compressed."
          ), {
            code: "EBADMAN",
            path,
            pkgid: pkg._id,
            man
          });
        }
        const section = parseMan[1];
        const base = basename(man);
        const absFrom = resolve(path, man);
        if (absFrom.indexOf(path) !== 0) {
          throw Object.assign(new Error("invalid man entry"), {
            code: "EBADMAN",
            path,
            pkgid: pkg._id,
            man
          });
        }
        const to = resolve(target, "man" + section, base);
        const from = relative(dirname(to), absFrom);
        links.push(linkGently({ from, to, path, absFrom, force }));
      }
      return Promise.all(links);
    };
    module2.exports = linkMans;
  }
});

// node_modules/bin-links/lib/check-bin.js
var require_check_bin = __commonJS({
  "node_modules/bin-links/lib/check-bin.js"(exports2, module2) {
    var isWindows = require_is_windows();
    var binTarget = require_bin_target();
    var { resolve, dirname } = require("path");
    var readCmdShim = require_lib38();
    var { readlink } = require("fs/promises");
    var checkBin = async ({ bin, path, top, global: global2, force }) => {
      if (force || !global2 || !top) {
        return;
      }
      const target = resolve(binTarget({ path, top }), bin);
      path = resolve(path);
      return isWindows ? checkShim({ target, path }) : checkLink({ target, path });
    };
    var handleReadLinkError = async ({ er, target }) => er.code === "ENOENT" ? null : failEEXIST({ target });
    var checkLink = async ({ target, path }) => {
      const current = await readlink(target).catch((er) => handleReadLinkError({ er, target }));
      if (!current) {
        return;
      }
      const resolved = resolve(dirname(target), current);
      if (resolved.toLowerCase().indexOf(path.toLowerCase()) !== 0) {
        return failEEXIST({ target });
      }
    };
    var handleReadCmdShimError = ({ er, target }) => er.code === "ENOENT" ? null : failEEXIST({ target });
    var failEEXIST = ({ target }) => Promise.reject(Object.assign(new Error("EEXIST: file already exists"), {
      path: target,
      code: "EEXIST"
    }));
    var checkShim = async ({ target, path }) => {
      const shims = [
        target,
        target + ".cmd",
        target + ".ps1"
      ];
      await Promise.all(shims.map(async (shim) => {
        const current = await readCmdShim(shim).catch((er) => handleReadCmdShimError({ er, target: shim }));
        if (!current) {
          return;
        }
        const resolved = resolve(dirname(shim), current.replace(/\\/g, "/"));
        if (resolved.toLowerCase().indexOf(path.toLowerCase()) !== 0) {
          return failEEXIST({ target: shim });
        }
      }));
    };
    module2.exports = checkBin;
  }
});

// node_modules/bin-links/lib/check-bins.js
var require_check_bins = __commonJS({
  "node_modules/bin-links/lib/check-bins.js"(exports2, module2) {
    var checkBin = require_check_bin();
    var normalize = require_lib10();
    var checkBins = async ({ pkg, path, top, global: global2, force }) => {
      if (force || !global2 || !top) {
        return;
      }
      pkg = normalize(pkg);
      if (!pkg.bin) {
        return;
      }
      await Promise.all(Object.keys(pkg.bin).map((bin) => checkBin({ bin, path, top, global: global2, force })));
    };
    module2.exports = checkBins;
  }
});

// node_modules/bin-links/lib/get-paths.js
var require_get_paths = __commonJS({
  "node_modules/bin-links/lib/get-paths.js"(exports2, module2) {
    var binTarget = require_bin_target();
    var manTarget = require_man_target();
    var { resolve, basename, extname } = require("path");
    var isWindows = require_is_windows();
    module2.exports = ({ path, pkg, global: global2, top }) => {
      if (top && !global2) {
        return [];
      }
      const binSet = [];
      const binTarg = binTarget({ path, top });
      if (pkg.bin) {
        for (const bin of Object.keys(pkg.bin)) {
          const b = resolve(binTarg, bin);
          binSet.push(b);
          if (isWindows) {
            binSet.push(b + ".cmd");
            binSet.push(b + ".ps1");
          }
        }
      }
      const manTarg = manTarget({ path, top });
      const manSet = [];
      if (manTarg && pkg.man && Array.isArray(pkg.man) && pkg.man.length) {
        for (const man of pkg.man) {
          if (!/.\.[0-9]+(\.gz)?$/.test(man)) {
            return binSet;
          }
          const section = extname(basename(man, ".gz")).slice(1);
          const base = basename(man);
          manSet.push(resolve(manTarg, "man" + section, base));
        }
      }
      return manSet.length ? [...binSet, ...manSet] : binSet;
    };
  }
});

// node_modules/bin-links/lib/index.js
var require_lib40 = __commonJS({
  "node_modules/bin-links/lib/index.js"(exports2, module2) {
    var linkBins = require_link_bins();
    var linkMans = require_link_mans();
    var binLinks = (opts) => {
      const { path, pkg, force, global: global2, top } = opts;
      if (top && !global2) {
        return Promise.resolve();
      }
      return Promise.all([
        // allow clobbering within the local node_modules/.bin folder.
        // only global bins are protected in this way, or else it is
        // yet another vector for excessive dependency conflicts.
        linkBins({ path, pkg, top, force: force || !top }),
        linkMans({ path, pkg, top, force })
      ]);
    };
    var shimBin = require_shim_bin();
    var linkGently = require_link_gently();
    var resetSeen = () => {
      shimBin.resetSeen();
      linkGently.resetSeen();
    };
    var checkBins = require_check_bins();
    var getPaths = require_get_paths();
    module2.exports = Object.assign(binLinks, {
      checkBins,
      resetSeen,
      getPaths
    });
  }
});

// node_modules/@npmcli/arborist/lib/gather-dep-set.js
var require_gather_dep_set = __commonJS({
  "node_modules/@npmcli/arborist/lib/gather-dep-set.js"(exports2, module2) {
    var gatherDepSet = (set, edgeFilter) => {
      const deps = new Set(set);
      for (const node of deps) {
        for (const edge of node.edgesOut.values()) {
          if (edge.to && edgeFilter(edge)) {
            deps.add(edge.to);
          }
        }
      }
      let changed = true;
      while (changed === true && deps.size > 0) {
        changed = false;
        for (const dep of deps) {
          for (const edge of dep.edgesIn) {
            if (!deps.has(edge.from) && edgeFilter(edge)) {
              changed = true;
              deps.delete(dep);
              break;
            }
          }
        }
      }
      return deps;
    };
    module2.exports = gatherDepSet;
  }
});

// node_modules/walk-up-path/dist/commonjs/index.js
var require_commonjs8 = __commonJS({
  "node_modules/walk-up-path/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.walkUp = void 0;
    var path_1 = require("path");
    var walkUp = function* (path) {
      for (path = (0, path_1.resolve)(path); path; ) {
        yield path;
        const pp = (0, path_1.dirname)(path);
        if (pp === path) {
          break;
        } else {
          path = pp;
        }
      }
    };
    exports2.walkUp = walkUp;
  }
});

// node_modules/@npmcli/arborist/lib/consistent-resolve.js
var require_consistent_resolve = __commonJS({
  "node_modules/@npmcli/arborist/lib/consistent-resolve.js"(exports2, module2) {
    var npa = require_npa();
    var relpath = require_relpath();
    var consistentResolve = (resolved, fromPath, toPath, relPaths = false) => {
      if (!resolved) {
        return null;
      }
      try {
        const hostedOpt = { noCommittish: false };
        const {
          fetchSpec,
          saveSpec,
          type,
          hosted,
          rawSpec,
          raw
        } = npa(resolved, fromPath);
        if (type === "file" || type === "directory") {
          if (relPaths && toPath) {
            return `file:${relpath(toPath, fetchSpec)}`;
          }
          return `file:${fetchSpec}`;
        }
        if (hosted) {
          return `git+${hosted.auth ? hosted.https(hostedOpt) : hosted.sshurl(hostedOpt)}`;
        }
        if (type === "git") {
          return saveSpec;
        }
        if (rawSpec === "*") {
          return raw;
        }
        return rawSpec;
      } catch (_) {
        return resolved;
      }
    };
    module2.exports = consistentResolve;
  }
});

// node_modules/@npmcli/arborist/lib/printable.js
var require_printable = __commonJS({
  "node_modules/@npmcli/arborist/lib/printable.js"(exports2, module2) {
    var localeCompare = require_string_locale_compare()("en");
    var util = require("node:util");
    var relpath = require_relpath();
    var ArboristNode = class {
      constructor(tree, path) {
        this.name = tree.name;
        if (tree.packageName && tree.packageName !== this.name) {
          this.packageName = tree.packageName;
        }
        if (tree.version) {
          this.version = tree.version;
        }
        this.location = tree.location;
        this.path = tree.path;
        if (tree.realpath !== this.path) {
          this.realpath = tree.realpath;
        }
        if (tree.resolved !== null) {
          this.resolved = tree.resolved;
        }
        if (tree.extraneous) {
          this.extraneous = true;
        }
        if (tree.dev) {
          this.dev = true;
        }
        if (tree.optional) {
          this.optional = true;
        }
        if (tree.devOptional && !tree.dev && !tree.optional) {
          this.devOptional = true;
        }
        if (tree.peer) {
          this.peer = true;
        }
        if (tree.inBundle) {
          this.bundled = true;
        }
        if (tree.inDepBundle) {
          this.bundler = tree.getBundler().location;
        }
        if (tree.isProjectRoot) {
          this.isProjectRoot = true;
        }
        if (tree.isWorkspace) {
          this.isWorkspace = true;
        }
        const bd = tree.package && tree.package.bundleDependencies;
        if (bd && bd.length) {
          this.bundleDependencies = bd;
        }
        if (tree.inShrinkwrap) {
          this.inShrinkwrap = true;
        } else if (tree.hasShrinkwrap) {
          this.hasShrinkwrap = true;
        }
        if (tree.error) {
          this.error = treeError(tree.error);
        }
        if (tree.errors && tree.errors.length) {
          this.errors = tree.errors.map(treeError);
        }
        if (tree.overrides) {
          this.overrides = new Map([...tree.overrides.ruleset.values()].map((override) => [override.key, override.value]));
        }
        if (tree.edgesOut.size) {
          this.edgesOut = new Map([...tree.edgesOut.entries()].sort(([a], [b]) => localeCompare(a, b)).map(([name, edge]) => [name, new EdgeOut(edge)]));
        }
        if (tree.edgesIn.size) {
          this.edgesIn = new Set([...tree.edgesIn].sort((a, b) => localeCompare(a.from.location, b.from.location)).map((edge) => new EdgeIn(edge)));
        }
        if (tree.workspaces && tree.workspaces.size) {
          this.workspaces = new Map([...tree.workspaces.entries()].map(([name, path2]) => [name, relpath(tree.root.realpath, path2)]));
        }
        if (tree.fsChildren.size) {
          this.fsChildren = new Set([...tree.fsChildren].sort(({ path: a }, { path: b }) => localeCompare(a, b)).map((tree2) => printableTree(tree2, path)));
        }
        if (tree.children.size) {
          this.children = new Map([...tree.children.entries()].sort(([a], [b]) => localeCompare(a, b)).map(([name, tree2]) => [name, printableTree(tree2, path)]));
        }
      }
    };
    var ArboristVirtualNode = class extends ArboristNode {
      constructor(tree, path) {
        super(tree, path);
        this.sourceReference = printableTree(tree.sourceReference, path);
      }
    };
    var ArboristLink = class extends ArboristNode {
      constructor(tree, path) {
        super(tree, path);
        this.target = printableTree(tree.target, path);
      }
    };
    var treeError = ({ code, path }) => ({
      code,
      ...path ? { path } : {}
    });
    var Edge = class {
      constructor(edge) {
        this.type = edge.type;
        this.name = edge.name;
        this.spec = edge.rawSpec || "*";
        if (edge.rawSpec !== edge.spec) {
          this.override = edge.spec;
        }
        if (edge.error) {
          this.error = edge.error;
        }
        if (edge.peerConflicted) {
          this.peerConflicted = edge.peerConflicted;
        }
      }
    };
    var EdgeOut = class extends Edge {
      constructor(edge) {
        super(edge);
        this.to = edge.to && edge.to.location;
      }
      [util.inspect.custom]() {
        return `{ ${this.type} ${this.name}@${this.spec}${this.override ? ` overridden:${this.override}` : ""}${this.to ? " -> " + this.to : ""}${this.error ? " " + this.error : ""}${this.peerConflicted ? " peerConflicted" : ""} }`;
      }
    };
    var EdgeIn = class extends Edge {
      constructor(edge) {
        super(edge);
        this.from = edge.from && edge.from.location;
      }
      [util.inspect.custom]() {
        return `{ ${this.from || '""'} ${this.type} ${this.name}@${this.spec}${this.error ? " " + this.error : ""}${this.peerConflicted ? " peerConflicted" : ""} }`;
      }
    };
    var printableTree = (tree, path = []) => {
      if (!tree) {
        return tree;
      }
      const Cls = tree.isLink ? ArboristLink : tree.sourceReference ? ArboristVirtualNode : ArboristNode;
      if (path.includes(tree)) {
        const obj = Object.create(Cls.prototype);
        return Object.assign(obj, { location: tree.location });
      }
      path.push(tree);
      return new Cls(tree, path);
    };
    module2.exports = printableTree;
  }
});

// node_modules/@npmcli/arborist/lib/case-insensitive-map.js
var require_case_insensitive_map = __commonJS({
  "node_modules/@npmcli/arborist/lib/case-insensitive-map.js"(exports2, module2) {
    module2.exports = class CIMap extends Map {
      #keys = /* @__PURE__ */ new Map();
      constructor(items = []) {
        super();
        for (const [key, val] of items) {
          this.set(key, val);
        }
      }
      #normKey(key) {
        if (typeof key !== "string") {
          return key;
        }
        return key.normalize("NFKD").toLowerCase();
      }
      get(key) {
        const normKey = this.#normKey(key);
        return this.#keys.has(normKey) ? super.get(this.#keys.get(normKey)) : void 0;
      }
      set(key, val) {
        const normKey = this.#normKey(key);
        if (this.#keys.has(normKey)) {
          super.delete(this.#keys.get(normKey));
        }
        this.#keys.set(normKey, key);
        return super.set(key, val);
      }
      delete(key) {
        const normKey = this.#normKey(key);
        if (this.#keys.has(normKey)) {
          const prevKey = this.#keys.get(normKey);
          this.#keys.delete(normKey);
          return super.delete(prevKey);
        }
      }
      has(key) {
        const normKey = this.#normKey(key);
        return this.#keys.has(normKey) && super.has(this.#keys.get(normKey));
      }
    };
  }
});

// node_modules/postcss-selector-parser/dist/util/unesc.js
var require_unesc = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/unesc.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = unesc;
    function gobbleHex(str) {
      var lower = str.toLowerCase();
      var hex = "";
      var spaceTerminated = false;
      for (var i = 0; i < 6 && lower[i] !== void 0; i++) {
        var code = lower.charCodeAt(i);
        var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
        spaceTerminated = code === 32;
        if (!valid) {
          break;
        }
        hex += lower[i];
      }
      if (hex.length === 0) {
        return void 0;
      }
      var codePoint = parseInt(hex, 16);
      var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
      if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
        return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
      }
      return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
    }
    var CONTAINS_ESCAPE = /\\/;
    function unesc(str) {
      var needToProcess = CONTAINS_ESCAPE.test(str);
      if (!needToProcess) {
        return str;
      }
      var ret = "";
      for (var i = 0; i < str.length; i++) {
        if (str[i] === "\\") {
          var gobbled = gobbleHex(str.slice(i + 1, i + 7));
          if (gobbled !== void 0) {
            ret += gobbled[0];
            i += gobbled[1];
            continue;
          }
          if (str[i + 1] === "\\") {
            ret += "\\";
            i++;
            continue;
          }
          if (str.length === i + 1) {
            ret += str[i];
          }
          continue;
        }
        ret += str[i];
      }
      return ret;
    }
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/util/getProp.js
var require_getProp = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/getProp.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = getProp;
    function getProp(obj) {
      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
      }
      while (props.length > 0) {
        var prop = props.shift();
        if (!obj[prop]) {
          return void 0;
        }
        obj = obj[prop];
      }
      return obj;
    }
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/util/ensureObject.js
var require_ensureObject = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/ensureObject.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = ensureObject;
    function ensureObject(obj) {
      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
      }
      while (props.length > 0) {
        var prop = props.shift();
        if (!obj[prop]) {
          obj[prop] = {};
        }
        obj = obj[prop];
      }
    }
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/util/stripComments.js
var require_stripComments = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/stripComments.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = stripComments;
    function stripComments(str) {
      var s = "";
      var commentStart = str.indexOf("/*");
      var lastEnd = 0;
      while (commentStart >= 0) {
        s = s + str.slice(lastEnd, commentStart);
        var commentEnd = str.indexOf("*/", commentStart + 2);
        if (commentEnd < 0) {
          return s;
        }
        lastEnd = commentEnd + 2;
        commentStart = str.indexOf("/*", lastEnd);
      }
      s = s + str.slice(lastEnd);
      return s;
    }
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/util/index.js
var require_util3 = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/index.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.unesc = exports2.stripComments = exports2.getProp = exports2.ensureObject = void 0;
    var _unesc = _interopRequireDefault(require_unesc());
    exports2.unesc = _unesc["default"];
    var _getProp = _interopRequireDefault(require_getProp());
    exports2.getProp = _getProp["default"];
    var _ensureObject = _interopRequireDefault(require_ensureObject());
    exports2.ensureObject = _ensureObject["default"];
    var _stripComments = _interopRequireDefault(require_stripComments());
    exports2.stripComments = _stripComments["default"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
  }
});

// node_modules/postcss-selector-parser/dist/selectors/node.js
var require_node3 = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/node.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _util = require_util3();
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var cloneNode = function cloneNode2(obj, parent) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      var cloned = new obj.constructor();
      for (var i in obj) {
        if (!obj.hasOwnProperty(i)) {
          continue;
        }
        var value = obj[i];
        var type = typeof value;
        if (i === "parent" && type === "object") {
          if (parent) {
            cloned[i] = parent;
          }
        } else if (value instanceof Array) {
          cloned[i] = value.map(function(j) {
            return cloneNode2(j, cloned);
          });
        } else {
          cloned[i] = cloneNode2(value, cloned);
        }
      }
      return cloned;
    };
    var Node = /* @__PURE__ */ function() {
      function Node2(opts) {
        if (opts === void 0) {
          opts = {};
        }
        Object.assign(this, opts);
        this.spaces = this.spaces || {};
        this.spaces.before = this.spaces.before || "";
        this.spaces.after = this.spaces.after || "";
      }
      var _proto = Node2.prototype;
      _proto.remove = function remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      };
      _proto.replaceWith = function replaceWith() {
        if (this.parent) {
          for (var index in arguments) {
            this.parent.insertBefore(this, arguments[index]);
          }
          this.remove();
        }
        return this;
      };
      _proto.next = function next() {
        return this.parent.at(this.parent.index(this) + 1);
      };
      _proto.prev = function prev() {
        return this.parent.at(this.parent.index(this) - 1);
      };
      _proto.clone = function clone(overrides) {
        if (overrides === void 0) {
          overrides = {};
        }
        var cloned = cloneNode(this);
        for (var name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      };
      _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
        if (!this.raws) {
          this.raws = {};
        }
        var originalValue = this[name];
        var originalEscaped = this.raws[name];
        this[name] = originalValue + value;
        if (originalEscaped || valueEscaped !== value) {
          this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
        } else {
          delete this.raws[name];
        }
      };
      _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
        if (!this.raws) {
          this.raws = {};
        }
        this[name] = value;
        this.raws[name] = valueEscaped;
      };
      _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
        this[name] = value;
        if (this.raws) {
          delete this.raws[name];
        }
      };
      _proto.isAtPosition = function isAtPosition(line, column) {
        if (this.source && this.source.start && this.source.end) {
          if (this.source.start.line > line) {
            return false;
          }
          if (this.source.end.line < line) {
            return false;
          }
          if (this.source.start.line === line && this.source.start.column > column) {
            return false;
          }
          if (this.source.end.line === line && this.source.end.column < column) {
            return false;
          }
          return true;
        }
        return void 0;
      };
      _proto.stringifyProperty = function stringifyProperty(name) {
        return this.raws && this.raws[name] || this[name];
      };
      _proto.valueToString = function valueToString() {
        return String(this.stringifyProperty("value"));
      };
      _proto.toString = function toString() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      };
      _createClass(Node2, [{
        key: "rawSpaceBefore",
        get: function get() {
          var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
          if (rawSpace === void 0) {
            rawSpace = this.spaces && this.spaces.before;
          }
          return rawSpace || "";
        },
        set: function set(raw) {
          (0, _util.ensureObject)(this, "raws", "spaces");
          this.raws.spaces.before = raw;
        }
      }, {
        key: "rawSpaceAfter",
        get: function get() {
          var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
          if (rawSpace === void 0) {
            rawSpace = this.spaces.after;
          }
          return rawSpace || "";
        },
        set: function set(raw) {
          (0, _util.ensureObject)(this, "raws", "spaces");
          this.raws.spaces.after = raw;
        }
      }]);
      return Node2;
    }();
    exports2["default"] = Node;
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/types.js
var require_types2 = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/types.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.UNIVERSAL = exports2.TAG = exports2.STRING = exports2.SELECTOR = exports2.ROOT = exports2.PSEUDO = exports2.NESTING = exports2.ID = exports2.COMMENT = exports2.COMBINATOR = exports2.CLASS = exports2.ATTRIBUTE = void 0;
    var TAG = "tag";
    exports2.TAG = TAG;
    var STRING = "string";
    exports2.STRING = STRING;
    var SELECTOR = "selector";
    exports2.SELECTOR = SELECTOR;
    var ROOT = "root";
    exports2.ROOT = ROOT;
    var PSEUDO = "pseudo";
    exports2.PSEUDO = PSEUDO;
    var NESTING = "nesting";
    exports2.NESTING = NESTING;
    var ID = "id";
    exports2.ID = ID;
    var COMMENT = "comment";
    exports2.COMMENT = COMMENT;
    var COMBINATOR = "combinator";
    exports2.COMBINATOR = COMBINATOR;
    var CLASS = "class";
    exports2.CLASS = CLASS;
    var ATTRIBUTE = "attribute";
    exports2.ATTRIBUTE = ATTRIBUTE;
    var UNIVERSAL = "universal";
    exports2.UNIVERSAL = UNIVERSAL;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/container.js
var require_container = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/container.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var types = _interopRequireWildcard(require_types2());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
          if (i >= o.length) return { done: true };
          return { done: false, value: o[i++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Container = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Container2, _Node);
      function Container2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        if (!_this.nodes) {
          _this.nodes = [];
        }
        return _this;
      }
      var _proto = Container2.prototype;
      _proto.append = function append(selector) {
        selector.parent = this;
        this.nodes.push(selector);
        return this;
      };
      _proto.prepend = function prepend(selector) {
        selector.parent = this;
        this.nodes.unshift(selector);
        return this;
      };
      _proto.at = function at(index) {
        return this.nodes[index];
      };
      _proto.index = function index(child) {
        if (typeof child === "number") {
          return child;
        }
        return this.nodes.indexOf(child);
      };
      _proto.removeChild = function removeChild(child) {
        child = this.index(child);
        this.at(child).parent = void 0;
        this.nodes.splice(child, 1);
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (index >= child) {
            this.indexes[id] = index - 1;
          }
        }
        return this;
      };
      _proto.removeAll = function removeAll() {
        for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
          var node = _step.value;
          node.parent = void 0;
        }
        this.nodes = [];
        return this;
      };
      _proto.empty = function empty() {
        return this.removeAll();
      };
      _proto.insertAfter = function insertAfter(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex + 1, 0, newNode);
        newNode.parent = this;
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (oldIndex <= index) {
            this.indexes[id] = index + 1;
          }
        }
        return this;
      };
      _proto.insertBefore = function insertBefore(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex, 0, newNode);
        newNode.parent = this;
        var index;
        for (var id in this.indexes) {
          index = this.indexes[id];
          if (index <= oldIndex) {
            this.indexes[id] = index + 1;
          }
        }
        return this;
      };
      _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
        var found = void 0;
        this.each(function(node) {
          if (node.atPosition) {
            var foundChild = node.atPosition(line, col);
            if (foundChild) {
              found = foundChild;
              return false;
            }
          } else if (node.isAtPosition(line, col)) {
            found = node;
            return false;
          }
        });
        return found;
      };
      _proto.atPosition = function atPosition(line, col) {
        if (this.isAtPosition(line, col)) {
          return this._findChildAtPosition(line, col) || this;
        } else {
          return void 0;
        }
      };
      _proto._inferEndPosition = function _inferEndPosition() {
        if (this.last && this.last.source && this.last.source.end) {
          this.source = this.source || {};
          this.source.end = this.source.end || {};
          Object.assign(this.source.end, this.last.source.end);
        }
      };
      _proto.each = function each(callback) {
        if (!this.lastEach) {
          this.lastEach = 0;
        }
        if (!this.indexes) {
          this.indexes = {};
        }
        this.lastEach++;
        var id = this.lastEach;
        this.indexes[id] = 0;
        if (!this.length) {
          return void 0;
        }
        var index, result;
        while (this.indexes[id] < this.length) {
          index = this.indexes[id];
          result = callback(this.at(index), index);
          if (result === false) {
            break;
          }
          this.indexes[id] += 1;
        }
        delete this.indexes[id];
        if (result === false) {
          return false;
        }
      };
      _proto.walk = function walk(callback) {
        return this.each(function(node, i) {
          var result = callback(node, i);
          if (result !== false && node.length) {
            result = node.walk(callback);
          }
          if (result === false) {
            return false;
          }
        });
      };
      _proto.walkAttributes = function walkAttributes(callback) {
        var _this2 = this;
        return this.walk(function(selector) {
          if (selector.type === types.ATTRIBUTE) {
            return callback.call(_this2, selector);
          }
        });
      };
      _proto.walkClasses = function walkClasses(callback) {
        var _this3 = this;
        return this.walk(function(selector) {
          if (selector.type === types.CLASS) {
            return callback.call(_this3, selector);
          }
        });
      };
      _proto.walkCombinators = function walkCombinators(callback) {
        var _this4 = this;
        return this.walk(function(selector) {
          if (selector.type === types.COMBINATOR) {
            return callback.call(_this4, selector);
          }
        });
      };
      _proto.walkComments = function walkComments(callback) {
        var _this5 = this;
        return this.walk(function(selector) {
          if (selector.type === types.COMMENT) {
            return callback.call(_this5, selector);
          }
        });
      };
      _proto.walkIds = function walkIds(callback) {
        var _this6 = this;
        return this.walk(function(selector) {
          if (selector.type === types.ID) {
            return callback.call(_this6, selector);
          }
        });
      };
      _proto.walkNesting = function walkNesting(callback) {
        var _this7 = this;
        return this.walk(function(selector) {
          if (selector.type === types.NESTING) {
            return callback.call(_this7, selector);
          }
        });
      };
      _proto.walkPseudos = function walkPseudos(callback) {
        var _this8 = this;
        return this.walk(function(selector) {
          if (selector.type === types.PSEUDO) {
            return callback.call(_this8, selector);
          }
        });
      };
      _proto.walkTags = function walkTags(callback) {
        var _this9 = this;
        return this.walk(function(selector) {
          if (selector.type === types.TAG) {
            return callback.call(_this9, selector);
          }
        });
      };
      _proto.walkUniversals = function walkUniversals(callback) {
        var _this10 = this;
        return this.walk(function(selector) {
          if (selector.type === types.UNIVERSAL) {
            return callback.call(_this10, selector);
          }
        });
      };
      _proto.split = function split(callback) {
        var _this11 = this;
        var current = [];
        return this.reduce(function(memo, node, index) {
          var split2 = callback.call(_this11, node);
          current.push(node);
          if (split2) {
            memo.push(current);
            current = [];
          } else if (index === _this11.length - 1) {
            memo.push(current);
          }
          return memo;
        }, []);
      };
      _proto.map = function map(callback) {
        return this.nodes.map(callback);
      };
      _proto.reduce = function reduce(callback, memo) {
        return this.nodes.reduce(callback, memo);
      };
      _proto.every = function every(callback) {
        return this.nodes.every(callback);
      };
      _proto.some = function some(callback) {
        return this.nodes.some(callback);
      };
      _proto.filter = function filter(callback) {
        return this.nodes.filter(callback);
      };
      _proto.sort = function sort(callback) {
        return this.nodes.sort(callback);
      };
      _proto.toString = function toString() {
        return this.map(String).join("");
      };
      _createClass(Container2, [{
        key: "first",
        get: function get() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function get() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function get() {
          return this.nodes.length;
        }
      }]);
      return Container2;
    }(_node["default"]);
    exports2["default"] = Container;
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/root.js
var require_root2 = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/root.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _container = _interopRequireDefault(require_container());
    var _types = require_types2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Root = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Root2, _Container);
      function Root2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.ROOT;
        return _this;
      }
      var _proto = Root2.prototype;
      _proto.toString = function toString() {
        var str = this.reduce(function(memo, selector) {
          memo.push(String(selector));
          return memo;
        }, []).join(",");
        return this.trailingComma ? str + "," : str;
      };
      _proto.error = function error(message, options) {
        if (this._error) {
          return this._error(message, options);
        } else {
          return new Error(message);
        }
      };
      _createClass(Root2, [{
        key: "errorGenerator",
        set: function set(handler) {
          this._error = handler;
        }
      }]);
      return Root2;
    }(_container["default"]);
    exports2["default"] = Root;
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/selector.js
var require_selector = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/selector.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _container = _interopRequireDefault(require_container());
    var _types = require_types2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Selector = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Selector2, _Container);
      function Selector2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.SELECTOR;
        return _this;
      }
      return Selector2;
    }(_container["default"]);
    exports2["default"] = Selector;
    module2.exports = exports2.default;
  }
});

// node_modules/cssesc/cssesc.js
var require_cssesc = __commonJS({
  "node_modules/cssesc/cssesc.js"(exports2, module2) {
    "use strict";
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var merge = function merge2(options, defaults) {
      if (!options) {
        return defaults;
      }
      var result = {};
      for (var key in defaults) {
        result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
      }
      return result;
    };
    var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    var cssesc = function cssesc2(string, options) {
      options = merge(options, cssesc2.options);
      if (options.quotes != "single" && options.quotes != "double") {
        options.quotes = "single";
      }
      var quote = options.quotes == "double" ? '"' : "'";
      var isIdentifier = options.isIdentifier;
      var firstChar = string.charAt(0);
      var output = "";
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var character = string.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options.escapeEverything) {
            if (regexAnySingleEscape.test(character)) {
              value = "\\" + character;
            } else {
              value = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character)) {
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
            value = "\\" + character;
          } else {
            value = character;
          }
        }
        output += value;
      }
      if (isIdentifier) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
          return $0;
        }
        return ($1 || "") + $2;
      });
      if (!isIdentifier && options.wrap) {
        return quote + output + quote;
      }
      return output;
    };
    cssesc.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc.version = "3.0.0";
    module2.exports = cssesc;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/className.js
var require_className = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/className.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _util = require_util3();
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var ClassName = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(ClassName2, _Node);
      function ClassName2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.CLASS;
        _this._constructed = true;
        return _this;
      }
      var _proto = ClassName2.prototype;
      _proto.valueToString = function valueToString() {
        return "." + _Node.prototype.valueToString.call(this);
      };
      _createClass(ClassName2, [{
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(v) {
          if (this._constructed) {
            var escaped = (0, _cssesc["default"])(v, {
              isIdentifier: true
            });
            if (escaped !== v) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.value = escaped;
            } else if (this.raws) {
              delete this.raws.value;
            }
          }
          this._value = v;
        }
      }]);
      return ClassName2;
    }(_node["default"]);
    exports2["default"] = ClassName;
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/comment.js
var require_comment = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/comment.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Comment = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Comment2, _Node);
      function Comment2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.COMMENT;
        return _this;
      }
      return Comment2;
    }(_node["default"]);
    exports2["default"] = Comment;
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/id.js
var require_id = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/id.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var ID = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(ID2, _Node);
      function ID2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.ID;
        return _this;
      }
      var _proto = ID2.prototype;
      _proto.valueToString = function valueToString() {
        return "#" + _Node.prototype.valueToString.call(this);
      };
      return ID2;
    }(_node["default"]);
    exports2["default"] = ID;
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/namespace.js
var require_namespace = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/namespace.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _util = require_util3();
    var _node = _interopRequireDefault(require_node3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Namespace = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Namespace2, _Node);
      function Namespace2() {
        return _Node.apply(this, arguments) || this;
      }
      var _proto = Namespace2.prototype;
      _proto.qualifiedName = function qualifiedName(value) {
        if (this.namespace) {
          return this.namespaceString + "|" + value;
        } else {
          return value;
        }
      };
      _proto.valueToString = function valueToString() {
        return this.qualifiedName(_Node.prototype.valueToString.call(this));
      };
      _createClass(Namespace2, [{
        key: "namespace",
        get: function get() {
          return this._namespace;
        },
        set: function set(namespace) {
          if (namespace === true || namespace === "*" || namespace === "&") {
            this._namespace = namespace;
            if (this.raws) {
              delete this.raws.namespace;
            }
            return;
          }
          var escaped = (0, _cssesc["default"])(namespace, {
            isIdentifier: true
          });
          this._namespace = namespace;
          if (escaped !== namespace) {
            (0, _util.ensureObject)(this, "raws");
            this.raws.namespace = escaped;
          } else if (this.raws) {
            delete this.raws.namespace;
          }
        }
      }, {
        key: "ns",
        get: function get() {
          return this._namespace;
        },
        set: function set(namespace) {
          this.namespace = namespace;
        }
      }, {
        key: "namespaceString",
        get: function get() {
          if (this.namespace) {
            var ns = this.stringifyProperty("namespace");
            if (ns === true) {
              return "";
            } else {
              return ns;
            }
          } else {
            return "";
          }
        }
      }]);
      return Namespace2;
    }(_node["default"]);
    exports2["default"] = Namespace;
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/tag.js
var require_tag2 = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/tag.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Tag = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Tag2, _Namespace);
      function Tag2(opts) {
        var _this;
        _this = _Namespace.call(this, opts) || this;
        _this.type = _types.TAG;
        return _this;
      }
      return Tag2;
    }(_namespace["default"]);
    exports2["default"] = Tag;
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/string.js
var require_string = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/string.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var String2 = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(String3, _Node);
      function String3(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.STRING;
        return _this;
      }
      return String3;
    }(_node["default"]);
    exports2["default"] = String2;
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/pseudo.js
var require_pseudo = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _container = _interopRequireDefault(require_container());
    var _types = require_types2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Pseudo = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Pseudo2, _Container);
      function Pseudo2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.PSEUDO;
        return _this;
      }
      var _proto = Pseudo2.prototype;
      _proto.toString = function toString() {
        var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
      };
      return Pseudo2;
    }(_container["default"]);
    exports2["default"] = Pseudo;
    module2.exports = exports2.default;
  }
});

// node_modules/util-deprecate/node.js
var require_node4 = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/attribute.js
var require_attribute = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/attribute.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    exports2.unescapeValue = unescapeValue;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _unesc = _interopRequireDefault(require_unesc());
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types2();
    var _CSSESC_QUOTE_OPTIONS;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var deprecate = require_node4();
    var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
    var warnOfDeprecatedValueAssignment = deprecate(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
    var warnOfDeprecatedQuotedAssignment = deprecate(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
    var warnOfDeprecatedConstructor = deprecate(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function unescapeValue(value) {
      var deprecatedUsage = false;
      var quoteMark = null;
      var unescaped = value;
      var m = unescaped.match(WRAPPED_IN_QUOTES);
      if (m) {
        quoteMark = m[1];
        unescaped = m[2];
      }
      unescaped = (0, _unesc["default"])(unescaped);
      if (unescaped !== value) {
        deprecatedUsage = true;
      }
      return {
        deprecatedUsage,
        unescaped,
        quoteMark
      };
    }
    function handleDeprecatedContructorOpts(opts) {
      if (opts.quoteMark !== void 0) {
        return opts;
      }
      if (opts.value === void 0) {
        return opts;
      }
      warnOfDeprecatedConstructor();
      var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
      if (!opts.raws) {
        opts.raws = {};
      }
      if (opts.raws.value === void 0) {
        opts.raws.value = opts.value;
      }
      opts.value = unescaped;
      opts.quoteMark = quoteMark;
      return opts;
    }
    var Attribute = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Attribute2, _Namespace);
      function Attribute2(opts) {
        var _this;
        if (opts === void 0) {
          opts = {};
        }
        _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
        _this.type = _types.ATTRIBUTE;
        _this.raws = _this.raws || {};
        Object.defineProperty(_this.raws, "unquoted", {
          get: deprecate(function() {
            return _this.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: deprecate(function() {
            return _this.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        });
        _this._constructed = true;
        return _this;
      }
      var _proto = Attribute2.prototype;
      _proto.getQuotedValue = function getQuotedValue(options) {
        if (options === void 0) {
          options = {};
        }
        var quoteMark = this._determineQuoteMark(options);
        var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
        var escaped = (0, _cssesc["default"])(this._value, cssescopts);
        return escaped;
      };
      _proto._determineQuoteMark = function _determineQuoteMark(options) {
        return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
      };
      _proto.setValue = function setValue(value, options) {
        if (options === void 0) {
          options = {};
        }
        this._value = value;
        this._quoteMark = this._determineQuoteMark(options);
        this._syncRawValue();
      };
      _proto.smartQuoteMark = function smartQuoteMark(options) {
        var v = this.value;
        var numSingleQuotes = v.replace(/[^']/g, "").length;
        var numDoubleQuotes = v.replace(/[^"]/g, "").length;
        if (numSingleQuotes + numDoubleQuotes === 0) {
          var escaped = (0, _cssesc["default"])(v, {
            isIdentifier: true
          });
          if (escaped === v) {
            return Attribute2.NO_QUOTE;
          } else {
            var pref = this.preferredQuoteMark(options);
            if (pref === Attribute2.NO_QUOTE) {
              var quote = this.quoteMark || options.quoteMark || Attribute2.DOUBLE_QUOTE;
              var opts = CSSESC_QUOTE_OPTIONS[quote];
              var quoteValue = (0, _cssesc["default"])(v, opts);
              if (quoteValue.length < escaped.length) {
                return quote;
              }
            }
            return pref;
          }
        } else if (numDoubleQuotes === numSingleQuotes) {
          return this.preferredQuoteMark(options);
        } else if (numDoubleQuotes < numSingleQuotes) {
          return Attribute2.DOUBLE_QUOTE;
        } else {
          return Attribute2.SINGLE_QUOTE;
        }
      };
      _proto.preferredQuoteMark = function preferredQuoteMark(options) {
        var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;
        if (quoteMark === void 0) {
          quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
        }
        if (quoteMark === void 0) {
          quoteMark = Attribute2.DOUBLE_QUOTE;
        }
        return quoteMark;
      };
      _proto._syncRawValue = function _syncRawValue() {
        var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
        if (rawValue === this._value) {
          if (this.raws) {
            delete this.raws.value;
          }
        } else {
          this.raws.value = rawValue;
        }
      };
      _proto._handleEscapes = function _handleEscapes(prop, value) {
        if (this._constructed) {
          var escaped = (0, _cssesc["default"])(value, {
            isIdentifier: true
          });
          if (escaped !== value) {
            this.raws[prop] = escaped;
          } else {
            delete this.raws[prop];
          }
        }
      };
      _proto._spacesFor = function _spacesFor(name) {
        var attrSpaces = {
          before: "",
          after: ""
        };
        var spaces = this.spaces[name] || {};
        var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
        return Object.assign(attrSpaces, spaces, rawSpaces);
      };
      _proto._stringFor = function _stringFor(name, spaceName, concat) {
        if (spaceName === void 0) {
          spaceName = name;
        }
        if (concat === void 0) {
          concat = defaultAttrConcat;
        }
        var attrSpaces = this._spacesFor(spaceName);
        return concat(this.stringifyProperty(name), attrSpaces);
      };
      _proto.offsetOf = function offsetOf(name) {
        var count = 1;
        var attributeSpaces = this._spacesFor("attribute");
        count += attributeSpaces.before.length;
        if (name === "namespace" || name === "ns") {
          return this.namespace ? count : -1;
        }
        if (name === "attributeNS") {
          return count;
        }
        count += this.namespaceString.length;
        if (this.namespace) {
          count += 1;
        }
        if (name === "attribute") {
          return count;
        }
        count += this.stringifyProperty("attribute").length;
        count += attributeSpaces.after.length;
        var operatorSpaces = this._spacesFor("operator");
        count += operatorSpaces.before.length;
        var operator = this.stringifyProperty("operator");
        if (name === "operator") {
          return operator ? count : -1;
        }
        count += operator.length;
        count += operatorSpaces.after.length;
        var valueSpaces = this._spacesFor("value");
        count += valueSpaces.before.length;
        var value = this.stringifyProperty("value");
        if (name === "value") {
          return value ? count : -1;
        }
        count += value.length;
        count += valueSpaces.after.length;
        var insensitiveSpaces = this._spacesFor("insensitive");
        count += insensitiveSpaces.before.length;
        if (name === "insensitive") {
          return this.insensitive ? count : -1;
        }
        return -1;
      };
      _proto.toString = function toString() {
        var _this2 = this;
        var selector = [this.rawSpaceBefore, "["];
        selector.push(this._stringFor("qualifiedAttribute", "attribute"));
        if (this.operator && (this.value || this.value === "")) {
          selector.push(this._stringFor("operator"));
          selector.push(this._stringFor("value"));
          selector.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
            if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
              attrSpaces.before = " ";
            }
            return defaultAttrConcat(attrValue, attrSpaces);
          }));
        }
        selector.push("]");
        selector.push(this.rawSpaceAfter);
        return selector.join("");
      };
      _createClass(Attribute2, [{
        key: "quoted",
        get: function get() {
          var qm = this.quoteMark;
          return qm === "'" || qm === '"';
        },
        set: function set(value) {
          warnOfDeprecatedQuotedAssignment();
        }
        /**
         * returns a single (`'`) or double (`"`) quote character if the value is quoted.
         * returns `null` if the value is not quoted.
         * returns `undefined` if the quotation state is unknown (this can happen when
         * the attribute is constructed without specifying a quote mark.)
         */
      }, {
        key: "quoteMark",
        get: function get() {
          return this._quoteMark;
        },
        set: function set(quoteMark) {
          if (!this._constructed) {
            this._quoteMark = quoteMark;
            return;
          }
          if (this._quoteMark !== quoteMark) {
            this._quoteMark = quoteMark;
            this._syncRawValue();
          }
        }
      }, {
        key: "qualifiedAttribute",
        get: function get() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function get() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        },
        set: (
          /**
           * Before 3.0, the value had to be set to an escaped value including any wrapped
           * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
           * is unescaped during parsing and any quote marks are removed.
           *
           * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
           * a deprecation warning is raised when the new value contains any characters that would
           * require escaping (including if it contains wrapped quotes).
           *
           * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
           * how the new value is quoted.
           */
          function set(v) {
            if (this._constructed) {
              var _unescapeValue2 = unescapeValue(v), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
              if (deprecatedUsage) {
                warnOfDeprecatedValueAssignment();
              }
              if (unescaped === this._value && quoteMark === this._quoteMark) {
                return;
              }
              this._value = unescaped;
              this._quoteMark = quoteMark;
              this._syncRawValue();
            } else {
              this._value = v;
            }
          }
        )
      }, {
        key: "insensitive",
        get: function get() {
          return this._insensitive;
        },
        set: function set(insensitive) {
          if (!insensitive) {
            this._insensitive = false;
            if (this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i")) {
              this.raws.insensitiveFlag = void 0;
            }
          }
          this._insensitive = insensitive;
        }
      }, {
        key: "attribute",
        get: function get() {
          return this._attribute;
        },
        set: function set(name) {
          this._handleEscapes("attribute", name);
          this._attribute = name;
        }
      }]);
      return Attribute2;
    }(_namespace["default"]);
    exports2["default"] = Attribute;
    Attribute.NO_QUOTE = null;
    Attribute.SINGLE_QUOTE = "'";
    Attribute.DOUBLE_QUOTE = '"';
    var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
      "'": {
        quotes: "single",
        wrap: true
      },
      '"': {
        quotes: "double",
        wrap: true
      }
    }, _CSSESC_QUOTE_OPTIONS[null] = {
      isIdentifier: true
    }, _CSSESC_QUOTE_OPTIONS);
    function defaultAttrConcat(attrValue, attrSpaces) {
      return "" + attrSpaces.before + attrValue + attrSpaces.after;
    }
  }
});

// node_modules/postcss-selector-parser/dist/selectors/universal.js
var require_universal = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/universal.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Universal = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Universal2, _Namespace);
      function Universal2(opts) {
        var _this;
        _this = _Namespace.call(this, opts) || this;
        _this.type = _types.UNIVERSAL;
        _this.value = "*";
        return _this;
      }
      return Universal2;
    }(_namespace["default"]);
    exports2["default"] = Universal;
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/combinator.js
var require_combinator = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/combinator.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Combinator = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Combinator2, _Node);
      function Combinator2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.COMBINATOR;
        return _this;
      }
      return Combinator2;
    }(_node["default"]);
    exports2["default"] = Combinator;
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/nesting.js
var require_nesting = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/nesting.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _node = _interopRequireDefault(require_node3());
    var _types = require_types2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Nesting = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Nesting2, _Node);
      function Nesting2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.NESTING;
        _this.value = "&";
        return _this;
      }
      return Nesting2;
    }(_node["default"]);
    exports2["default"] = Nesting;
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/sortAscending.js
var require_sortAscending = __commonJS({
  "node_modules/postcss-selector-parser/dist/sortAscending.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = sortAscending;
    function sortAscending(list) {
      return list.sort(function(a, b) {
        return a - b;
      });
    }
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/tokenTypes.js
var require_tokenTypes = __commonJS({
  "node_modules/postcss-selector-parser/dist/tokenTypes.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.word = exports2.tilde = exports2.tab = exports2.str = exports2.space = exports2.slash = exports2.singleQuote = exports2.semicolon = exports2.plus = exports2.pipe = exports2.openSquare = exports2.openParenthesis = exports2.newline = exports2.greaterThan = exports2.feed = exports2.equals = exports2.doubleQuote = exports2.dollar = exports2.cr = exports2.comment = exports2.comma = exports2.combinator = exports2.colon = exports2.closeSquare = exports2.closeParenthesis = exports2.caret = exports2.bang = exports2.backslash = exports2.at = exports2.asterisk = exports2.ampersand = void 0;
    var ampersand = 38;
    exports2.ampersand = ampersand;
    var asterisk = 42;
    exports2.asterisk = asterisk;
    var at = 64;
    exports2.at = at;
    var comma = 44;
    exports2.comma = comma;
    var colon = 58;
    exports2.colon = colon;
    var semicolon = 59;
    exports2.semicolon = semicolon;
    var openParenthesis = 40;
    exports2.openParenthesis = openParenthesis;
    var closeParenthesis = 41;
    exports2.closeParenthesis = closeParenthesis;
    var openSquare = 91;
    exports2.openSquare = openSquare;
    var closeSquare = 93;
    exports2.closeSquare = closeSquare;
    var dollar = 36;
    exports2.dollar = dollar;
    var tilde = 126;
    exports2.tilde = tilde;
    var caret = 94;
    exports2.caret = caret;
    var plus = 43;
    exports2.plus = plus;
    var equals = 61;
    exports2.equals = equals;
    var pipe = 124;
    exports2.pipe = pipe;
    var greaterThan = 62;
    exports2.greaterThan = greaterThan;
    var space = 32;
    exports2.space = space;
    var singleQuote = 39;
    exports2.singleQuote = singleQuote;
    var doubleQuote = 34;
    exports2.doubleQuote = doubleQuote;
    var slash = 47;
    exports2.slash = slash;
    var bang = 33;
    exports2.bang = bang;
    var backslash = 92;
    exports2.backslash = backslash;
    var cr = 13;
    exports2.cr = cr;
    var feed = 12;
    exports2.feed = feed;
    var newline = 10;
    exports2.newline = newline;
    var tab = 9;
    exports2.tab = tab;
    var str = singleQuote;
    exports2.str = str;
    var comment = -1;
    exports2.comment = comment;
    var word = -2;
    exports2.word = word;
    var combinator = -3;
    exports2.combinator = combinator;
  }
});

// node_modules/postcss-selector-parser/dist/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/postcss-selector-parser/dist/tokenize.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.FIELDS = void 0;
    exports2["default"] = tokenize;
    var t = _interopRequireWildcard(require_tokenTypes());
    var _unescapable;
    var _wordDelimiters;
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
    var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
    var hex = {};
    var hexChars = "0123456789abcdefABCDEF";
    for (i = 0; i < hexChars.length; i++) {
      hex[hexChars.charCodeAt(i)] = true;
    }
    var i;
    function consumeWord(css, start) {
      var next = start;
      var code;
      do {
        code = css.charCodeAt(next);
        if (wordDelimiters[code]) {
          return next - 1;
        } else if (code === t.backslash) {
          next = consumeEscape(css, next) + 1;
        } else {
          next++;
        }
      } while (next < css.length);
      return next - 1;
    }
    function consumeEscape(css, start) {
      var next = start;
      var code = css.charCodeAt(next + 1);
      if (unescapable[code]) {
      } else if (hex[code]) {
        var hexDigits = 0;
        do {
          next++;
          hexDigits++;
          code = css.charCodeAt(next + 1);
        } while (hex[code] && hexDigits < 6);
        if (hexDigits < 6 && code === t.space) {
          next++;
        }
      } else {
        next++;
      }
      return next;
    }
    var FIELDS = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    exports2.FIELDS = FIELDS;
    function tokenize(input) {
      var tokens = [];
      var css = input.css.valueOf();
      var _css = css, length = _css.length;
      var offset = -1;
      var line = 1;
      var start = 0;
      var end = 0;
      var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;
      function unclosed(what, fix) {
        if (input.safe) {
          css += fix;
          next = css.length - 1;
        } else {
          throw input.error("Unclosed " + what, line, start - offset, start);
        }
      }
      while (start < length) {
        code = css.charCodeAt(start);
        if (code === t.newline) {
          offset = start;
          line += 1;
        }
        switch (code) {
          case t.space:
          case t.tab:
          case t.newline:
          case t.cr:
          case t.feed:
            next = start;
            do {
              next += 1;
              code = css.charCodeAt(next);
              if (code === t.newline) {
                offset = next;
                line += 1;
              }
            } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);
            tokenType = t.space;
            endLine = line;
            endColumn = next - offset - 1;
            end = next;
            break;
          case t.plus:
          case t.greaterThan:
          case t.tilde:
          case t.pipe:
            next = start;
            do {
              next += 1;
              code = css.charCodeAt(next);
            } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);
            tokenType = t.combinator;
            endLine = line;
            endColumn = start - offset;
            end = next;
            break;
          // Consume these characters as single tokens.
          case t.asterisk:
          case t.ampersand:
          case t.bang:
          case t.comma:
          case t.equals:
          case t.dollar:
          case t.caret:
          case t.openSquare:
          case t.closeSquare:
          case t.colon:
          case t.semicolon:
          case t.openParenthesis:
          case t.closeParenthesis:
            next = start;
            tokenType = code;
            endLine = line;
            endColumn = start - offset;
            end = next + 1;
            break;
          case t.singleQuote:
          case t.doubleQuote:
            quote = code === t.singleQuote ? "'" : '"';
            next = start;
            do {
              escaped = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                unclosed("quote", quote);
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === t.backslash) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            tokenType = t.str;
            endLine = line;
            endColumn = start - offset;
            end = next + 1;
            break;
          default:
            if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
              next = css.indexOf("*/", start + 2) + 1;
              if (next === 0) {
                unclosed("comment", "*/");
              }
              content = css.slice(start, next + 1);
              lines = content.split("\n");
              last = lines.length - 1;
              if (last > 0) {
                nextLine = line + last;
                nextOffset = next - lines[last].length;
              } else {
                nextLine = line;
                nextOffset = offset;
              }
              tokenType = t.comment;
              line = nextLine;
              endLine = nextLine;
              endColumn = next - nextOffset;
            } else if (code === t.slash) {
              next = start;
              tokenType = code;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
            } else {
              next = consumeWord(css, start);
              tokenType = t.word;
              endLine = line;
              endColumn = next - offset;
            }
            end = next + 1;
            break;
        }
        tokens.push([
          tokenType,
          // [0] Token type
          line,
          // [1] Starting line
          start - offset,
          // [2] Starting column
          endLine,
          // [3] Ending line
          endColumn,
          // [4] Ending column
          start,
          // [5] Start position / Source index
          end
          // [6] End position
        ]);
        if (nextOffset) {
          offset = nextOffset;
          nextOffset = null;
        }
        start = end;
      }
      return tokens;
    }
  }
});

// node_modules/postcss-selector-parser/dist/parser.js
var require_parser = __commonJS({
  "node_modules/postcss-selector-parser/dist/parser.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _root = _interopRequireDefault(require_root2());
    var _selector = _interopRequireDefault(require_selector());
    var _className = _interopRequireDefault(require_className());
    var _comment = _interopRequireDefault(require_comment());
    var _id = _interopRequireDefault(require_id());
    var _tag = _interopRequireDefault(require_tag2());
    var _string = _interopRequireDefault(require_string());
    var _pseudo = _interopRequireDefault(require_pseudo());
    var _attribute = _interopRequireWildcard(require_attribute());
    var _universal = _interopRequireDefault(require_universal());
    var _combinator = _interopRequireDefault(require_combinator());
    var _nesting = _interopRequireDefault(require_nesting());
    var _sortAscending = _interopRequireDefault(require_sortAscending());
    var _tokenize = _interopRequireWildcard(require_tokenize());
    var tokens = _interopRequireWildcard(require_tokenTypes());
    var types = _interopRequireWildcard(require_types2());
    var _util = require_util3();
    var _WHITESPACE_TOKENS;
    var _Object$assign;
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
    var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
    function tokenStart(token) {
      return {
        line: token[_tokenize.FIELDS.START_LINE],
        column: token[_tokenize.FIELDS.START_COL]
      };
    }
    function tokenEnd(token) {
      return {
        line: token[_tokenize.FIELDS.END_LINE],
        column: token[_tokenize.FIELDS.END_COL]
      };
    }
    function getSource(startLine, startColumn, endLine, endColumn) {
      return {
        start: {
          line: startLine,
          column: startColumn
        },
        end: {
          line: endLine,
          column: endColumn
        }
      };
    }
    function getTokenSource(token) {
      return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
    }
    function getTokenSourceSpan(startToken, endToken) {
      if (!startToken) {
        return void 0;
      }
      return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
    }
    function unescapeProp(node, prop) {
      var value = node[prop];
      if (typeof value !== "string") {
        return;
      }
      if (value.indexOf("\\") !== -1) {
        (0, _util.ensureObject)(node, "raws");
        node[prop] = (0, _util.unesc)(value);
        if (node.raws[prop] === void 0) {
          node.raws[prop] = value;
        }
      }
      return node;
    }
    function indexesOf(array, item) {
      var i = -1;
      var indexes = [];
      while ((i = array.indexOf(item, i + 1)) !== -1) {
        indexes.push(i);
      }
      return indexes;
    }
    function uniqs() {
      var list = Array.prototype.concat.apply([], arguments);
      return list.filter(function(item, i) {
        return i === list.indexOf(item);
      });
    }
    var Parser = /* @__PURE__ */ function() {
      function Parser2(rule, options) {
        if (options === void 0) {
          options = {};
        }
        this.rule = rule;
        this.options = Object.assign({
          lossy: false,
          safe: false
        }, options);
        this.position = 0;
        this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
        this.tokens = (0, _tokenize["default"])({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new _root["default"]({
          source: rootSource
        });
        this.root.errorGenerator = this._errorGenerator();
        var selector = new _selector["default"]({
          source: {
            start: {
              line: 1,
              column: 1
            }
          },
          sourceIndex: 0
        });
        this.root.append(selector);
        this.current = selector;
        this.loop();
      }
      var _proto = Parser2.prototype;
      _proto._errorGenerator = function _errorGenerator() {
        var _this = this;
        return function(message, errorOptions) {
          if (typeof _this.rule === "string") {
            return new Error(message);
          }
          return _this.rule.error(message, errorOptions);
        };
      };
      _proto.attribute = function attribute() {
        var attr = [];
        var startingToken = this.currToken;
        this.position++;
        while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
          attr.push(this.currToken);
          this.position++;
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
          return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        }
        var len = attr.length;
        var node = {
          source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        };
        if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
          return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
        }
        var pos = 0;
        var spaceBefore = "";
        var commentBefore = "";
        var lastAdded = null;
        var spaceAfterMeaningfulToken = false;
        while (pos < len) {
          var token = attr[pos];
          var content = this.content(token);
          var next = attr[pos + 1];
          switch (token[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              spaceAfterMeaningfulToken = true;
              if (this.options.lossy) {
                break;
              }
              if (lastAdded) {
                (0, _util.ensureObject)(node, "spaces", lastAdded);
                var prevContent = node.spaces[lastAdded].after || "";
                node.spaces[lastAdded].after = prevContent + content;
                var existingComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || null;
                if (existingComment) {
                  node.raws.spaces[lastAdded].after = existingComment + content;
                }
              } else {
                spaceBefore = spaceBefore + content;
                commentBefore = commentBefore + content;
              }
              break;
            case tokens.asterisk:
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                if (spaceBefore) {
                  (0, _util.ensureObject)(node, "spaces", "attribute");
                  node.spaces.attribute.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                  node.raws.spaces.attribute.before = spaceBefore;
                  commentBefore = "";
                }
                node.namespace = (node.namespace || "") + content;
                var rawValue = (0, _util.getProp)(node, "raws", "namespace") || null;
                if (rawValue) {
                  node.raws.namespace += content;
                }
                lastAdded = "namespace";
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.dollar:
              if (lastAdded === "value") {
                var oldRawValue = (0, _util.getProp)(node, "raws", "value");
                node.value += "$";
                if (oldRawValue) {
                  node.raws.value = oldRawValue + "$";
                }
                break;
              }
            // Falls through
            case tokens.caret:
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.combinator:
              if (content === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              }
              if (content !== "|") {
                spaceAfterMeaningfulToken = false;
                break;
              }
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              } else if (!node.namespace && !node.attribute) {
                node.namespace = true;
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.word:
              if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
              !node.operator && !node.namespace) {
                node.namespace = content;
                lastAdded = "namespace";
              } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                if (spaceBefore) {
                  (0, _util.ensureObject)(node, "spaces", "attribute");
                  node.spaces.attribute.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                  node.raws.spaces.attribute.before = commentBefore;
                  commentBefore = "";
                }
                node.attribute = (node.attribute || "") + content;
                var _rawValue = (0, _util.getProp)(node, "raws", "attribute") || null;
                if (_rawValue) {
                  node.raws.attribute += content;
                }
                lastAdded = "attribute";
              } else if (!node.value && node.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node.quoteMark)) {
                var _unescaped = (0, _util.unesc)(content);
                var _oldRawValue = (0, _util.getProp)(node, "raws", "value") || "";
                var oldValue = node.value || "";
                node.value = oldValue + _unescaped;
                node.quoteMark = null;
                if (_unescaped !== content || _oldRawValue) {
                  (0, _util.ensureObject)(node, "raws");
                  node.raws.value = (_oldRawValue || oldValue) + content;
                }
                lastAdded = "value";
              } else {
                var insensitive = content === "i" || content === "I";
                if ((node.value || node.value === "") && (node.quoteMark || spaceAfterMeaningfulToken)) {
                  node.insensitive = insensitive;
                  if (!insensitive || content === "I") {
                    (0, _util.ensureObject)(node, "raws");
                    node.raws.insensitiveFlag = content;
                  }
                  lastAdded = "insensitive";
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, "spaces", "insensitive");
                    node.spaces.insensitive.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node, "raws", "spaces", "insensitive");
                    node.raws.spaces.insensitive.before = commentBefore;
                    commentBefore = "";
                  }
                } else if (node.value || node.value === "") {
                  lastAdded = "value";
                  node.value += content;
                  if (node.raws.value) {
                    node.raws.value += content;
                  }
                }
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.str:
              if (!node.attribute || !node.operator) {
                return this.error("Expected an attribute followed by an operator preceding the string.", {
                  index: token[_tokenize.FIELDS.START_POS]
                });
              }
              var _unescapeValue = (0, _attribute.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
              node.value = unescaped;
              node.quoteMark = quoteMark;
              lastAdded = "value";
              (0, _util.ensureObject)(node, "raws");
              node.raws.value = content;
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.equals:
              if (!node.attribute) {
                return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
              }
              if (node.value) {
                return this.error('Unexpected "=" found; an operator was already defined.', {
                  index: token[_tokenize.FIELDS.START_POS]
                });
              }
              node.operator = node.operator ? node.operator + content : content;
              lastAdded = "operator";
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.comment:
              if (lastAdded) {
                if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                  var lastComment = (0, _util.getProp)(node, "spaces", lastAdded, "after") || "";
                  var rawLastComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || lastComment;
                  (0, _util.ensureObject)(node, "raws", "spaces", lastAdded);
                  node.raws.spaces[lastAdded].after = rawLastComment + content;
                } else {
                  var lastValue = node[lastAdded] || "";
                  var rawLastValue = (0, _util.getProp)(node, "raws", lastAdded) || lastValue;
                  (0, _util.ensureObject)(node, "raws");
                  node.raws[lastAdded] = rawLastValue + content;
                }
              } else {
                commentBefore = commentBefore + content;
              }
              break;
            default:
              return this.error('Unexpected "' + content + '" found.', {
                index: token[_tokenize.FIELDS.START_POS]
              });
          }
          pos++;
        }
        unescapeProp(node, "attribute");
        unescapeProp(node, "namespace");
        this.newNode(new _attribute["default"](node));
        this.position++;
      };
      _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
        if (stopPosition < 0) {
          stopPosition = this.tokens.length;
        }
        var startPosition = this.position;
        var nodes = [];
        var space = "";
        var lastComment = void 0;
        do {
          if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
            if (!this.options.lossy) {
              space += this.content();
            }
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
            var spaces = {};
            if (space) {
              spaces.before = space;
              space = "";
            }
            lastComment = new _comment["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              spaces
            });
            nodes.push(lastComment);
          }
        } while (++this.position < stopPosition);
        if (space) {
          if (lastComment) {
            lastComment.spaces.after = space;
          } else if (!this.options.lossy) {
            var firstToken = this.tokens[startPosition];
            var lastToken = this.tokens[this.position - 1];
            nodes.push(new _string["default"]({
              value: "",
              source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces: {
                before: space,
                after: ""
              }
            }));
          }
        }
        return nodes;
      };
      _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
        var _this2 = this;
        if (requiredSpace === void 0) {
          requiredSpace = false;
        }
        var space = "";
        var rawSpace = "";
        nodes.forEach(function(n) {
          var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);
          var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);
          space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
          rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
        });
        if (rawSpace === space) {
          rawSpace = void 0;
        }
        var result = {
          space,
          rawSpace
        };
        return result;
      };
      _proto.isNamedCombinator = function isNamedCombinator(position) {
        if (position === void 0) {
          position = this.position;
        }
        return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
      };
      _proto.namedCombinator = function namedCombinator() {
        if (this.isNamedCombinator()) {
          var nameRaw = this.content(this.tokens[this.position + 1]);
          var name = (0, _util.unesc)(nameRaw).toLowerCase();
          var raws = {};
          if (name !== nameRaw) {
            raws.value = "/" + nameRaw + "/";
          }
          var node = new _combinator["default"]({
            value: "/" + name + "/",
            source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
            raws
          });
          this.position = this.position + 3;
          return node;
        } else {
          this.unexpected();
        }
      };
      _proto.combinator = function combinator() {
        var _this3 = this;
        if (this.content() === "|") {
          return this.namespace();
        }
        var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
        if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          if (nodes.length > 0) {
            var last = this.current.last;
            if (last) {
              var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
              if (rawSpace !== void 0) {
                last.rawSpaceAfter += rawSpace;
              }
              last.spaces.after += space;
            } else {
              nodes.forEach(function(n) {
                return _this3.newNode(n);
              });
            }
          }
          return;
        }
        var firstToken = this.currToken;
        var spaceOrDescendantSelectorNodes = void 0;
        if (nextSigTokenPos > this.position) {
          spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
        }
        var node;
        if (this.isNamedCombinator()) {
          node = this.namedCombinator();
        } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
          node = new _combinator["default"]({
            value: this.content(),
            source: getTokenSource(this.currToken),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
          });
          this.position++;
        } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
        } else if (!spaceOrDescendantSelectorNodes) {
          this.unexpected();
        }
        if (node) {
          if (spaceOrDescendantSelectorNodes) {
            var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
            node.spaces.before = _space;
            node.rawSpaceBefore = _rawSpace;
          }
        } else {
          var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
          if (!_rawSpace2) {
            _rawSpace2 = _space2;
          }
          var spaces = {};
          var raws = {
            spaces: {}
          };
          if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
            spaces.before = _space2.slice(0, _space2.length - 1);
            raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
          } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
            spaces.after = _space2.slice(1);
            raws.spaces.after = _rawSpace2.slice(1);
          } else {
            raws.value = _rawSpace2;
          }
          node = new _combinator["default"]({
            value: " ",
            source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
            sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
            spaces,
            raws
          });
        }
        if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
          node.spaces.after = this.optionalSpace(this.content());
          this.position++;
        }
        return this.newNode(node);
      };
      _proto.comma = function comma() {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = true;
          this.position++;
          return;
        }
        this.current._inferEndPosition();
        var selector = new _selector["default"]({
          source: {
            start: tokenStart(this.tokens[this.position + 1])
          },
          sourceIndex: this.tokens[this.position + 1][_tokenize.FIELDS.START_POS]
        });
        this.current.parent.append(selector);
        this.current = selector;
        this.position++;
      };
      _proto.comment = function comment() {
        var current = this.currToken;
        this.newNode(new _comment["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.error = function error(message, opts) {
        throw this.root.error(message, opts);
      };
      _proto.missingBackslash = function missingBackslash() {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[_tokenize.FIELDS.START_POS]
        });
      };
      _proto.missingParenthesis = function missingParenthesis() {
        return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.missingSquareBracket = function missingSquareBracket() {
        return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.unexpected = function unexpected() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.unexpectedPipe = function unexpectedPipe() {
        return this.error("Unexpected '|'.", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.namespace = function namespace() {
        var before = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
          this.position++;
          return this.word(before);
        } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
          this.position++;
          return this.universal(before);
        }
        this.unexpectedPipe();
      };
      _proto.nesting = function nesting() {
        if (this.nextToken) {
          var nextContent = this.content(this.nextToken);
          if (nextContent === "|") {
            this.position++;
            return;
          }
        }
        var current = this.currToken;
        this.newNode(new _nesting["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.parentheses = function parentheses() {
        var last = this.current.last;
        var unbalanced = 1;
        this.position++;
        if (last && last.type === types.PSEUDO) {
          var selector = new _selector["default"]({
            source: {
              start: tokenStart(this.tokens[this.position])
            },
            sourceIndex: this.tokens[this.position][_tokenize.FIELDS.START_POS]
          });
          var cache = this.current;
          last.append(selector);
          this.current = selector;
          while (this.position < this.tokens.length && unbalanced) {
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              unbalanced++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              unbalanced--;
            }
            if (unbalanced) {
              this.parse();
            } else {
              this.current.source.end = tokenEnd(this.currToken);
              this.current.parent.source.end = tokenEnd(this.currToken);
              this.position++;
            }
          }
          this.current = cache;
        } else {
          var parenStart = this.currToken;
          var parenValue = "(";
          var parenEnd;
          while (this.position < this.tokens.length && unbalanced) {
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              unbalanced++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              unbalanced--;
            }
            parenEnd = this.currToken;
            parenValue += this.parseParenthesisToken(this.currToken);
            this.position++;
          }
          if (last) {
            last.appendToPropertyAndEscape("value", parenValue, parenValue);
          } else {
            this.newNode(new _string["default"]({
              value: parenValue,
              source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
              sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
            }));
          }
        }
        if (unbalanced) {
          return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        }
      };
      _proto.pseudo = function pseudo() {
        var _this4 = this;
        var pseudoStr = "";
        var startingToken = this.currToken;
        while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
          pseudoStr += this.content();
          this.position++;
        }
        if (!this.currToken) {
          return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
          this.splitWord(false, function(first, length) {
            pseudoStr += first;
            _this4.newNode(new _pseudo["default"]({
              value: pseudoStr,
              source: getTokenSourceSpan(startingToken, _this4.currToken),
              sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
            }));
            if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              _this4.error("Misplaced parenthesis.", {
                index: _this4.nextToken[_tokenize.FIELDS.START_POS]
              });
            }
          });
        } else {
          return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
        }
      };
      _proto.space = function space() {
        var content = this.content();
        if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node) {
          return node.type === "comment";
        })) {
          this.spaces = this.optionalSpace(content);
          this.position++;
        } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          this.current.last.spaces.after = this.optionalSpace(content);
          this.position++;
        } else {
          this.combinator();
        }
      };
      _proto.string = function string() {
        var current = this.currToken;
        this.newNode(new _string["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.universal = function universal(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === "|") {
          this.position++;
          return this.namespace();
        }
        var current = this.currToken;
        this.newNode(new _universal["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }), namespace);
        this.position++;
      };
      _proto.splitWord = function splitWord(namespace, firstCallback) {
        var _this5 = this;
        var nextToken = this.nextToken;
        var word = this.content();
        while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
          this.position++;
          var current = this.content();
          word += current;
          if (current.lastIndexOf("\\") === current.length - 1) {
            var next = this.nextToken;
            if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
              word += this.requiredSpace(this.content(next));
              this.position++;
            }
          }
          nextToken = this.nextToken;
        }
        var hasClass = indexesOf(word, ".").filter(function(i) {
          var escapedDot = word[i - 1] === "\\";
          var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
          return !escapedDot && !isKeyframesPercent;
        });
        var hasId = indexesOf(word, "#").filter(function(i) {
          return word[i - 1] !== "\\";
        });
        var interpolations = indexesOf(word, "#{");
        if (interpolations.length) {
          hasId = hasId.filter(function(hashIndex) {
            return !~interpolations.indexOf(hashIndex);
          });
        }
        var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
        indices.forEach(function(ind, i) {
          var index = indices[i + 1] || word.length;
          var value = word.slice(ind, index);
          if (i === 0 && firstCallback) {
            return firstCallback.call(_this5, value, indices.length);
          }
          var node;
          var current2 = _this5.currToken;
          var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i];
          var source = getSource(current2[1], current2[2] + ind, current2[3], current2[2] + (index - 1));
          if (~hasClass.indexOf(ind)) {
            var classNameOpts = {
              value: value.slice(1),
              source,
              sourceIndex
            };
            node = new _className["default"](unescapeProp(classNameOpts, "value"));
          } else if (~hasId.indexOf(ind)) {
            var idOpts = {
              value: value.slice(1),
              source,
              sourceIndex
            };
            node = new _id["default"](unescapeProp(idOpts, "value"));
          } else {
            var tagOpts = {
              value,
              source,
              sourceIndex
            };
            unescapeProp(tagOpts, "value");
            node = new _tag["default"](tagOpts);
          }
          _this5.newNode(node, namespace);
          namespace = null;
        });
        this.position++;
      };
      _proto.word = function word(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === "|") {
          this.position++;
          return this.namespace();
        }
        return this.splitWord(namespace);
      };
      _proto.loop = function loop() {
        while (this.position < this.tokens.length) {
          this.parse(true);
        }
        this.current._inferEndPosition();
        return this.root;
      };
      _proto.parse = function parse(throwOnParenthesis) {
        switch (this.currToken[_tokenize.FIELDS.TYPE]) {
          case tokens.space:
            this.space();
            break;
          case tokens.comment:
            this.comment();
            break;
          case tokens.openParenthesis:
            this.parentheses();
            break;
          case tokens.closeParenthesis:
            if (throwOnParenthesis) {
              this.missingParenthesis();
            }
            break;
          case tokens.openSquare:
            this.attribute();
            break;
          case tokens.dollar:
          case tokens.caret:
          case tokens.equals:
          case tokens.word:
            this.word();
            break;
          case tokens.colon:
            this.pseudo();
            break;
          case tokens.comma:
            this.comma();
            break;
          case tokens.asterisk:
            this.universal();
            break;
          case tokens.ampersand:
            this.nesting();
            break;
          case tokens.slash:
          case tokens.combinator:
            this.combinator();
            break;
          case tokens.str:
            this.string();
            break;
          // These cases throw; no break needed.
          case tokens.closeSquare:
            this.missingSquareBracket();
          case tokens.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      };
      _proto.expected = function expected(description, index, found) {
        if (Array.isArray(description)) {
          var last = description.pop();
          description = description.join(", ") + " or " + last;
        }
        var an = /^[aeiou]/.test(description[0]) ? "an" : "a";
        if (!found) {
          return this.error("Expected " + an + " " + description + ".", {
            index
          });
        }
        return this.error("Expected " + an + " " + description + ', found "' + found + '" instead.', {
          index
        });
      };
      _proto.requiredSpace = function requiredSpace(space) {
        return this.options.lossy ? " " : space;
      };
      _proto.optionalSpace = function optionalSpace(space) {
        return this.options.lossy ? "" : space;
      };
      _proto.lossySpace = function lossySpace(space, required) {
        if (this.options.lossy) {
          return required ? " " : "";
        } else {
          return space;
        }
      };
      _proto.parseParenthesisToken = function parseParenthesisToken(token) {
        var content = this.content(token);
        if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
          return this.requiredSpace(content);
        } else {
          return content;
        }
      };
      _proto.newNode = function newNode(node, namespace) {
        if (namespace) {
          if (/^ +$/.test(namespace)) {
            if (!this.options.lossy) {
              this.spaces = (this.spaces || "") + namespace;
            }
            namespace = true;
          }
          node.namespace = namespace;
          unescapeProp(node, "namespace");
        }
        if (this.spaces) {
          node.spaces.before = this.spaces;
          this.spaces = "";
        }
        return this.current.append(node);
      };
      _proto.content = function content(token) {
        if (token === void 0) {
          token = this.currToken;
        }
        return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
      };
      _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
        if (startPosition === void 0) {
          startPosition = this.position + 1;
        }
        var searchPosition = startPosition;
        while (searchPosition < this.tokens.length) {
          if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
            searchPosition++;
            continue;
          } else {
            return searchPosition;
          }
        }
        return -1;
      };
      _createClass(Parser2, [{
        key: "currToken",
        get: function get() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function get() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function get() {
          return this.tokens[this.position - 1];
        }
      }]);
      return Parser2;
    }();
    exports2["default"] = Parser;
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/processor.js
var require_processor2 = __commonJS({
  "node_modules/postcss-selector-parser/dist/processor.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _parser = _interopRequireDefault(require_parser());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var Processor = /* @__PURE__ */ function() {
      function Processor2(func, options) {
        this.func = func || function noop() {
        };
        this.funcRes = null;
        this.options = options;
      }
      var _proto = Processor2.prototype;
      _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var merged = Object.assign({}, this.options, options);
        if (merged.updateSelector === false) {
          return false;
        } else {
          return typeof rule !== "string";
        }
      };
      _proto._isLossy = function _isLossy(options) {
        if (options === void 0) {
          options = {};
        }
        var merged = Object.assign({}, this.options, options);
        if (merged.lossless === false) {
          return true;
        } else {
          return false;
        }
      };
      _proto._root = function _root(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var parser = new _parser["default"](rule, this._parseOptions(options));
        return parser.root;
      };
      _proto._parseOptions = function _parseOptions(options) {
        return {
          lossy: this._isLossy(options)
        };
      };
      _proto._run = function _run(rule, options) {
        var _this = this;
        if (options === void 0) {
          options = {};
        }
        return new Promise(function(resolve, reject) {
          try {
            var root = _this._root(rule, options);
            Promise.resolve(_this.func(root)).then(function(transform) {
              var string = void 0;
              if (_this._shouldUpdateSelector(rule, options)) {
                string = root.toString();
                rule.selector = string;
              }
              return {
                transform,
                root,
                string
              };
            }).then(resolve, reject);
          } catch (e) {
            reject(e);
            return;
          }
        });
      };
      _proto._runSync = function _runSync(rule, options) {
        if (options === void 0) {
          options = {};
        }
        var root = this._root(rule, options);
        var transform = this.func(root);
        if (transform && typeof transform.then === "function") {
          throw new Error("Selector processor returned a promise to a synchronous call.");
        }
        var string = void 0;
        if (options.updateSelector && typeof rule !== "string") {
          string = root.toString();
          rule.selector = string;
        }
        return {
          transform,
          root,
          string
        };
      };
      _proto.ast = function ast(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.root;
        });
      };
      _proto.astSync = function astSync(rule, options) {
        return this._runSync(rule, options).root;
      };
      _proto.transform = function transform(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.transform;
        });
      };
      _proto.transformSync = function transformSync(rule, options) {
        return this._runSync(rule, options).transform;
      };
      _proto.process = function process2(rule, options) {
        return this._run(rule, options).then(function(result) {
          return result.string || result.root.toString();
        });
      };
      _proto.processSync = function processSync(rule, options) {
        var result = this._runSync(rule, options);
        return result.string || result.root.toString();
      };
      return Processor2;
    }();
    exports2["default"] = Processor;
    module2.exports = exports2.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/constructors.js
var require_constructors = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/constructors.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.universal = exports2.tag = exports2.string = exports2.selector = exports2.root = exports2.pseudo = exports2.nesting = exports2.id = exports2.comment = exports2.combinator = exports2.className = exports2.attribute = void 0;
    var _attribute = _interopRequireDefault(require_attribute());
    var _className = _interopRequireDefault(require_className());
    var _combinator = _interopRequireDefault(require_combinator());
    var _comment = _interopRequireDefault(require_comment());
    var _id = _interopRequireDefault(require_id());
    var _nesting = _interopRequireDefault(require_nesting());
    var _pseudo = _interopRequireDefault(require_pseudo());
    var _root = _interopRequireDefault(require_root2());
    var _selector = _interopRequireDefault(require_selector());
    var _string = _interopRequireDefault(require_string());
    var _tag = _interopRequireDefault(require_tag2());
    var _universal = _interopRequireDefault(require_universal());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var attribute = function attribute2(opts) {
      return new _attribute["default"](opts);
    };
    exports2.attribute = attribute;
    var className = function className2(opts) {
      return new _className["default"](opts);
    };
    exports2.className = className;
    var combinator = function combinator2(opts) {
      return new _combinator["default"](opts);
    };
    exports2.combinator = combinator;
    var comment = function comment2(opts) {
      return new _comment["default"](opts);
    };
    exports2.comment = comment;
    var id = function id2(opts) {
      return new _id["default"](opts);
    };
    exports2.id = id;
    var nesting = function nesting2(opts) {
      return new _nesting["default"](opts);
    };
    exports2.nesting = nesting;
    var pseudo = function pseudo2(opts) {
      return new _pseudo["default"](opts);
    };
    exports2.pseudo = pseudo;
    var root = function root2(opts) {
      return new _root["default"](opts);
    };
    exports2.root = root;
    var selector = function selector2(opts) {
      return new _selector["default"](opts);
    };
    exports2.selector = selector;
    var string = function string2(opts) {
      return new _string["default"](opts);
    };
    exports2.string = string;
    var tag = function tag2(opts) {
      return new _tag["default"](opts);
    };
    exports2.tag = tag;
    var universal = function universal2(opts) {
      return new _universal["default"](opts);
    };
    exports2.universal = universal;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/guards.js
var require_guards = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/guards.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.isComment = exports2.isCombinator = exports2.isClassName = exports2.isAttribute = void 0;
    exports2.isContainer = isContainer;
    exports2.isIdentifier = void 0;
    exports2.isNamespace = isNamespace;
    exports2.isNesting = void 0;
    exports2.isNode = isNode;
    exports2.isPseudo = void 0;
    exports2.isPseudoClass = isPseudoClass;
    exports2.isPseudoElement = isPseudoElement;
    exports2.isUniversal = exports2.isTag = exports2.isString = exports2.isSelector = exports2.isRoot = void 0;
    var _types = require_types2();
    var _IS_TYPE;
    var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
    function isNode(node) {
      return typeof node === "object" && IS_TYPE[node.type];
    }
    function isNodeType(type, node) {
      return isNode(node) && node.type === type;
    }
    var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
    exports2.isAttribute = isAttribute;
    var isClassName = isNodeType.bind(null, _types.CLASS);
    exports2.isClassName = isClassName;
    var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
    exports2.isCombinator = isCombinator;
    var isComment = isNodeType.bind(null, _types.COMMENT);
    exports2.isComment = isComment;
    var isIdentifier = isNodeType.bind(null, _types.ID);
    exports2.isIdentifier = isIdentifier;
    var isNesting = isNodeType.bind(null, _types.NESTING);
    exports2.isNesting = isNesting;
    var isPseudo = isNodeType.bind(null, _types.PSEUDO);
    exports2.isPseudo = isPseudo;
    var isRoot = isNodeType.bind(null, _types.ROOT);
    exports2.isRoot = isRoot;
    var isSelector = isNodeType.bind(null, _types.SELECTOR);
    exports2.isSelector = isSelector;
    var isString = isNodeType.bind(null, _types.STRING);
    exports2.isString = isString;
    var isTag = isNodeType.bind(null, _types.TAG);
    exports2.isTag = isTag;
    var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
    exports2.isUniversal = isUniversal;
    function isPseudoElement(node) {
      return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
    }
    function isPseudoClass(node) {
      return isPseudo(node) && !isPseudoElement(node);
    }
    function isContainer(node) {
      return !!(isNode(node) && node.walk);
    }
    function isNamespace(node) {
      return isAttribute(node) || isTag(node);
    }
  }
});

// node_modules/postcss-selector-parser/dist/selectors/index.js
var require_selectors = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/index.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _types = require_types2();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _types[key]) return;
      exports2[key] = _types[key];
    });
    var _constructors = require_constructors();
    Object.keys(_constructors).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _constructors[key]) return;
      exports2[key] = _constructors[key];
    });
    var _guards = require_guards();
    Object.keys(_guards).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _guards[key]) return;
      exports2[key] = _guards[key];
    });
  }
});

// node_modules/postcss-selector-parser/dist/index.js
var require_dist14 = __commonJS({
  "node_modules/postcss-selector-parser/dist/index.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2["default"] = void 0;
    var _processor = _interopRequireDefault(require_processor2());
    var selectors = _interopRequireWildcard(require_selectors());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var parser = function parser2(processor) {
      return new _processor["default"](processor);
    };
    Object.assign(parser, selectors);
    delete parser.__esModule;
    var _default = parser;
    exports2["default"] = _default;
    module2.exports = exports2.default;
  }
});

// node_modules/@npmcli/query/lib/index.js
var require_lib41 = __commonJS({
  "node_modules/@npmcli/query/lib/index.js"(exports2, module2) {
    "use strict";
    var parser = require_dist14();
    var arrayDelimiter = Symbol("arrayDelimiter");
    var escapeSlashes = (str) => str.replace(/\//g, "\\/");
    var unescapeSlashes = (str) => str.replace(/\\\//g, "/");
    var fixupAttr = (astNode) => {
      const properties = [];
      const matcher = {};
      for (const selectorAstNode of astNode.nodes) {
        const [firstAstNode] = selectorAstNode.nodes;
        if (firstAstNode.type === "tag") {
          properties.push(firstAstNode.value);
        }
      }
      const lastSelectorAstNode = astNode.nodes.pop();
      const [attributeAstNode] = lastSelectorAstNode.nodes;
      if (attributeAstNode.value === ":attr") {
        const appendParts = fixupAttr(attributeAstNode);
        properties.push(arrayDelimiter, ...appendParts.lookupProperties);
        matcher.qualifiedAttribute = appendParts.attributeMatcher.qualifiedAttribute;
        matcher.operator = appendParts.attributeMatcher.operator;
        matcher.value = appendParts.attributeMatcher.value;
        matcher.attribute = appendParts.attributeMatcher.attribute;
        if (appendParts.attributeMatcher.insensitive) {
          matcher.insensitive = true;
        }
      } else {
        if (attributeAstNode.type !== "attribute") {
          throw Object.assign(
            new Error("`:attr` pseudo-class expects an attribute matcher as the last value"),
            { code: "EQUERYATTR" }
          );
        }
        matcher.qualifiedAttribute = unescapeSlashes(attributeAstNode.qualifiedAttribute);
        matcher.operator = attributeAstNode.operator;
        matcher.value = attributeAstNode.value;
        matcher.attribute = matcher.qualifiedAttribute;
        if (attributeAstNode.insensitive) {
          matcher.insensitive = true;
        }
      }
      astNode.lookupProperties = properties;
      astNode.attributeMatcher = matcher;
      astNode.nodes.length = 0;
      return astNode;
    };
    var fixupNestedPseudo = (astNode) => {
      const newRootNode = parser.root();
      astNode.nestedNode = newRootNode;
      newRootNode.nodes = [...astNode.nodes];
      astNode.nodes.length = 0;
      for (const currAstNode of newRootNode.nodes) {
        currAstNode.parent = newRootNode;
      }
      transformAst(newRootNode);
    };
    var fixupSemverSpecs = (astNode) => {
      if (astNode.nodes.length === 3) {
        const funcNode = astNode.nodes.pop().nodes[0];
        if (funcNode.type === "tag") {
          astNode.semverFunc = funcNode.value;
        } else if (funcNode.type === "string") {
          astNode.semverFunc = funcNode.value.slice(1, -1);
        } else {
          throw Object.assign(
            new Error("`:semver` pseudo-class expects a function name as last value"),
            { code: "ESEMVERFUNC" }
          );
        }
      }
      if (astNode.nodes.length === 1) {
        const semverNode = astNode.nodes.pop();
        astNode.semverValue = semverNode.nodes.reduce((res, next) => `${res}${String(next)}`, "");
      } else if (astNode.nodes.length === 2) {
        for (let i = 0; i < astNode.nodes.length; ++i) {
          const type = astNode.nodes[i].nodes[0].type;
          if (type === "tag" || type === "combinator") {
            const semverNode = astNode.nodes.splice(i, 1)[0];
            astNode.semverValue = semverNode.nodes.reduce((res, next) => `${res}${String(next)}`, "");
            astNode.semverPosition = i;
            break;
          }
        }
        if (typeof astNode.semverValue === "undefined") {
          throw Object.assign(
            new Error("`:semver` pseudo-class expects a static value in the first or second position"),
            { code: "ESEMVERVALUE" }
          );
        }
      }
      if (astNode.nodes.length === 1) {
        fixupAttr(astNode);
      } else {
        astNode.attributeMatcher = {
          insensitive: false,
          attribute: "version",
          qualifiedAttribute: "version"
        };
        astNode.lookupProperties = [];
      }
      astNode.nodes.length = 0;
    };
    var fixupTypes = (astNode) => {
      const [valueAstNode] = astNode.nodes[0].nodes;
      const { value } = valueAstNode || {};
      astNode.typeValue = value;
      astNode.nodes.length = 0;
    };
    var fixupPaths = (astNode) => {
      astNode.pathValue = unescapeSlashes(String(astNode.nodes[0]));
      astNode.nodes.length = 0;
    };
    var fixupOutdated = (astNode) => {
      if (astNode.nodes.length) {
        astNode.outdatedKind = String(astNode.nodes[0]);
        astNode.nodes.length = 0;
      }
    };
    var fixupVuln = (astNode) => {
      const vulns = [];
      if (astNode.nodes.length) {
        for (const selector of astNode.nodes) {
          const vuln = {};
          for (const node of selector.nodes) {
            if (node.type !== "attribute") {
              throw Object.assign(
                new Error(':vuln pseudo-class only accepts attribute matchers or "cwe" tag'),
                { code: "EQUERYATTR" }
              );
            }
            if (!["severity", "cwe"].includes(node._attribute)) {
              throw Object.assign(
                new Error(':vuln pseudo-class only matches "severity" and "cwe" attributes'),
                { code: "EQUERYATTR" }
              );
            }
            if (!node.operator) {
              node.operator = "=";
              node.value = "*";
            }
            if (node.operator !== "=") {
              throw Object.assign(
                new Error(':vuln pseudo-class attribute selector only accepts "=" operator', node),
                { code: "EQUERYATTR" }
              );
            }
            if (!vuln[node._attribute]) {
              vuln[node._attribute] = [];
            }
            vuln[node._attribute].push(node._value);
          }
          vulns.push(vuln);
        }
        astNode.vulns = vulns;
        astNode.nodes.length = 0;
      }
    };
    var transformAst = (selector) => {
      selector.walk((nextAstNode) => {
        switch (nextAstNode.value) {
          case ":attr":
            return fixupAttr(nextAstNode);
          case ":is":
          case ":has":
          case ":not":
            return fixupNestedPseudo(nextAstNode);
          case ":path":
            return fixupPaths(nextAstNode);
          case ":semver":
            return fixupSemverSpecs(nextAstNode);
          case ":type":
            return fixupTypes(nextAstNode);
          case ":outdated":
            return fixupOutdated(nextAstNode);
          case ":vuln":
            return fixupVuln(nextAstNode);
        }
      });
    };
    var queryParser = (query) => {
      if (!query) {
        return [];
      }
      return parser(transformAst).astSync(escapeSlashes(query), { lossless: false });
    };
    module2.exports = {
      parser: queryParser,
      arrayDelimiter
    };
  }
});

// node_modules/@npmcli/arborist/lib/query-selector-all.js
var require_query_selector_all = __commonJS({
  "node_modules/@npmcli/arborist/lib/query-selector-all.js"(exports2, module2) {
    "use strict";
    var { resolve } = require("node:path");
    var { parser, arrayDelimiter } = require_lib41();
    var localeCompare = require_string_locale_compare()("en");
    var { log } = require_lib4();
    var { minimatch } = require_commonjs();
    var npa = require_npa();
    var pacote = require_lib33();
    var semver = require_semver2();
    var npmFetch = require_lib31();
    var Results = class {
      #currentAstSelector;
      #initialItems;
      #inventory;
      #outdatedCache = /* @__PURE__ */ new Map();
      #vulnCache;
      #pendingCombinator;
      #results = /* @__PURE__ */ new Map();
      #targetNode;
      constructor(opts) {
        this.#currentAstSelector = opts.rootAstNode.nodes[0];
        this.#inventory = opts.inventory;
        this.#initialItems = opts.initialItems;
        this.#vulnCache = opts.vulnCache;
        this.#targetNode = opts.targetNode;
        this.currentResults = this.#initialItems;
        this.flatOptions = opts.flatOptions || {};
        this.currentAstNode = opts.rootAstNode;
      }
      get currentResults() {
        return this.#results.get(this.#currentAstSelector);
      }
      set currentResults(value) {
        this.#results.set(this.#currentAstSelector, value);
      }
      // retrieves the initial items to which start the filtering / matching
      // for most of the different types of recognized ast nodes, e.g: class (aka
      // depType), id, *, etc in different contexts we need to start with the
      // current list of filtered results, for example a query for `.workspace`
      // actually means the same as `*.workspace` so we want to start with the full
      // inventory if that's the first ast node we're reading but if it appears in
      // the middle of a query it should respect the previous filtered results,
      // combinators are a special case in which we always want to have the
      // complete inventory list in order to use the left-hand side ast node as a
      // filter combined with the element on its right-hand side
      get initialItems() {
        const firstParsed = this.currentAstNode.parent.nodes[0] === this.currentAstNode && this.currentAstNode.parent.parent.type === "root";
        if (firstParsed) {
          return this.#initialItems;
        }
        if (this.currentAstNode.prev().type === "combinator") {
          return this.#inventory;
        }
        return this.currentResults;
      }
      // combinators need information about previously filtered items along
      // with info of the items parsed / retrieved from the selector right
      // past the combinator, for this reason combinators are stored and
      // only ran as the last part of each selector logic
      processPendingCombinator(nextResults) {
        if (this.#pendingCombinator) {
          const res = this.#pendingCombinator(this.currentResults, nextResults);
          this.#pendingCombinator = null;
          this.currentResults = res;
        } else {
          this.currentResults = nextResults;
        }
      }
      // when collecting results to a root astNode, we traverse the list of child
      // selector nodes and collect all of their resulting arborist nodes into a
      // single/flat Set of items, this ensures we also deduplicate items
      collect(rootAstNode) {
        return new Set(rootAstNode.nodes.flatMap((n) => this.#results.get(n)));
      }
      // selector types map to the '.type' property of the ast nodes via `${astNode.type}Type`
      //
      // attribute selector [name=value], etc
      attributeType() {
        const nextResults = this.initialItems.filter(
          (node) => attributeMatch(this.currentAstNode, node.package)
        );
        this.processPendingCombinator(nextResults);
      }
      // dependency type selector (i.e. .prod, .dev, etc)
      // css calls this class, we interpret is as dependency type
      classType() {
        const depTypeFn = depTypes[String(this.currentAstNode)];
        if (!depTypeFn) {
          throw Object.assign(
            new Error(`\`${String(this.currentAstNode)}\` is not a supported dependency type.`),
            { code: "EQUERYNODEPTYPE" }
          );
        }
        const nextResults = depTypeFn(this.initialItems);
        this.processPendingCombinator(nextResults);
      }
      // combinators (i.e. '>', ' ', '~')
      combinatorType() {
        this.#pendingCombinator = combinators[String(this.currentAstNode)];
      }
      // name selectors (i.e. #foo)
      // css calls this id, we interpret it as name
      idType() {
        const name = this.currentAstNode.value;
        const nextResults = this.initialItems.filter(
          (node) => name === node.name || name === node.package.name
        );
        this.processPendingCombinator(nextResults);
      }
      // pseudo selectors (prefixed with :)
      async pseudoType() {
        const pseudoFn = `${this.currentAstNode.value.slice(1)}Pseudo`;
        if (!this[pseudoFn]) {
          throw Object.assign(
            new Error(`\`${this.currentAstNode.value}\` is not a supported pseudo selector.`),
            { code: "EQUERYNOPSEUDO" }
          );
        }
        const nextResults = await this[pseudoFn]();
        this.processPendingCombinator(nextResults);
      }
      selectorType() {
        this.#currentAstSelector = this.currentAstNode;
        if (!this.currentResults) {
          this.currentResults = [];
        }
      }
      universalType() {
        this.processPendingCombinator(this.initialItems);
      }
      // pseudo selectors map to the 'value' property of the pseudo selectors in the ast nodes
      // via selectors via `${value.slice(1)}Pseudo`
      attrPseudo() {
        const { lookupProperties, attributeMatcher } = this.currentAstNode;
        return this.initialItems.filter((node) => {
          let objs = [node.package];
          for (const prop of lookupProperties) {
            if (prop === arrayDelimiter) {
              objs = objs.flat();
              continue;
            }
            objs = objs.flatMap((obj) => obj[prop] || []);
            const noAttr = objs.every((obj) => !obj);
            if (noAttr) {
              return false;
            }
          }
          return objs.some((obj) => attributeMatch(attributeMatcher, obj));
        });
      }
      emptyPseudo() {
        return this.initialItems.filter((node) => node.edgesOut.size === 0);
      }
      extraneousPseudo() {
        return this.initialItems.filter((node) => node.extraneous);
      }
      async hasPseudo() {
        const found = [];
        for (const item of this.initialItems) {
          const res = await retrieveNodesFromParsedAst({
            flatOptions: this.flatOptions,
            initialItems: [item],
            inventory: this.#inventory,
            rootAstNode: this.currentAstNode.nestedNode,
            targetNode: item,
            vulnCache: this.#vulnCache
          });
          if (res.size > 0) {
            found.push(item);
          }
        }
        return found;
      }
      invalidPseudo() {
        const found = [];
        for (const node of this.initialItems) {
          for (const edge of node.edgesIn) {
            if (edge.invalid) {
              found.push(node);
              break;
            }
          }
        }
        return found;
      }
      async isPseudo() {
        const res = await retrieveNodesFromParsedAst({
          flatOptions: this.flatOptions,
          initialItems: this.initialItems,
          inventory: this.#inventory,
          rootAstNode: this.currentAstNode.nestedNode,
          targetNode: this.currentAstNode,
          vulnCache: this.#vulnCache
        });
        return [...res];
      }
      linkPseudo() {
        return this.initialItems.filter((node) => node.isLink || node.isTop && !node.isRoot);
      }
      missingPseudo() {
        return this.#inventory.reduce((res, node) => {
          for (const edge of node.edgesOut.values()) {
            if (edge.missing) {
              const pkg = { name: edge.name, version: edge.spec };
              const item = new this.#targetNode.constructor({ pkg });
              item.queryContext = {
                missing: true
              };
              item.edgesIn = /* @__PURE__ */ new Set([edge]);
              res.push(item);
            }
          }
          return res;
        }, []);
      }
      async notPseudo() {
        const res = await retrieveNodesFromParsedAst({
          flatOptions: this.flatOptions,
          initialItems: this.initialItems,
          inventory: this.#inventory,
          rootAstNode: this.currentAstNode.nestedNode,
          targetNode: this.currentAstNode,
          vulnCache: this.#vulnCache
        });
        const internalSelector = new Set(res);
        return this.initialItems.filter((node) => !internalSelector.has(node));
      }
      overriddenPseudo() {
        return this.initialItems.filter((node) => node.overridden);
      }
      pathPseudo() {
        return this.initialItems.filter((node) => {
          if (!this.currentAstNode.pathValue) {
            return true;
          }
          return minimatch(
            node.realpath.replace(/\\+/g, "/"),
            resolve(node.root.realpath, this.currentAstNode.pathValue).replace(/\\+/g, "/")
          );
        });
      }
      privatePseudo() {
        return this.initialItems.filter((node) => node.package.private);
      }
      rootPseudo() {
        return this.initialItems.filter((node) => node === this.#targetNode.root);
      }
      scopePseudo() {
        return this.initialItems.filter((node) => node === this.#targetNode);
      }
      semverPseudo() {
        const {
          attributeMatcher,
          lookupProperties,
          semverFunc = "infer",
          semverValue
        } = this.currentAstNode;
        const { qualifiedAttribute } = attributeMatcher;
        if (!semverValue) {
          log.warn("query", "usage of :semver() with no parameters is deprecated");
          return this.initialItems;
        }
        if (!semver.valid(semverValue) && !semver.validRange(semverValue)) {
          throw Object.assign(
            new Error(`\`${semverValue}\` is not a valid semver version or range`),
            { code: "EQUERYINVALIDSEMVER" }
          );
        }
        const valueIsVersion = !!semver.valid(semverValue);
        const nodeMatches = (node, obj) => {
          if (attributeMatcher.operator) {
            if (!attributeMatch(attributeMatcher, obj)) {
              return false;
            }
          }
          const attrValue = obj[qualifiedAttribute];
          if (!semver.valid(attrValue) && !semver.validRange(attrValue) || typeof attrValue !== "string") {
            return false;
          }
          const attrIsVersion = !!semver.valid(attrValue);
          let actualFunc = semverFunc;
          if (actualFunc === "infer") {
            if (valueIsVersion && attrIsVersion) {
              actualFunc = "eq";
            } else if (!valueIsVersion && !attrIsVersion) {
              actualFunc = "intersects";
            } else {
              actualFunc = "satisfies";
            }
          }
          if (["eq", "neq", "gt", "gte", "lt", "lte"].includes(actualFunc)) {
            if (!valueIsVersion || !attrIsVersion) {
              return false;
            }
            return semver[actualFunc](attrValue, semverValue);
          } else if (["gtr", "ltr", "satisfies"].includes(actualFunc)) {
            if (!valueIsVersion && !attrIsVersion) {
              return false;
            }
            return valueIsVersion ? semver[actualFunc](semverValue, attrValue) : semver[actualFunc](attrValue, semverValue);
          } else if (["intersects", "subset"].includes(actualFunc)) {
            return semver[actualFunc](attrValue, semverValue);
          } else {
            throw Object.assign(
              new Error(`\`semver.${actualFunc}\` is not a supported operator.`),
              { code: "EQUERYINVALIDOPERATOR" }
            );
          }
        };
        return this.initialItems.filter((node) => {
          if (!lookupProperties.length) {
            return nodeMatches(node, node.package);
          }
          let objs = [node.package];
          for (const prop of lookupProperties) {
            if (prop === arrayDelimiter) {
              objs = objs.flat();
              continue;
            }
            objs = objs.flatMap((obj) => obj[prop] || []);
            const noAttr = objs.every((obj) => !obj);
            if (noAttr) {
              return false;
            }
            return objs.some((obj) => nodeMatches(node, obj));
          }
        });
      }
      typePseudo() {
        if (!this.currentAstNode.typeValue) {
          return this.initialItems;
        }
        return this.initialItems.flatMap((node) => {
          const found = [];
          for (const edge of node.edgesIn) {
            if (npa(`${edge.name}@${edge.spec}`).type === this.currentAstNode.typeValue) {
              found.push(edge.to);
            }
          }
          return found;
        });
      }
      dedupedPseudo() {
        return this.initialItems.filter((node) => node.target.edgesIn.size > 1);
      }
      async vulnPseudo() {
        if (!this.initialItems.length) {
          return this.initialItems;
        }
        if (!this.#vulnCache) {
          const packages = {};
          this.initialItems.map((node) => {
            if (node.isProjectRoot || node.package.private) {
              return;
            }
            if (!packages[node.name]) {
              packages[node.name] = [];
            }
            if (!packages[node.name].includes(node.version)) {
              packages[node.name].push(node.version);
            }
          });
          const res = await npmFetch("/-/npm/v1/security/advisories/bulk", {
            ...this.flatOptions,
            registry: this.flatOptions.auditRegistry || this.flatOptions.registry,
            method: "POST",
            gzip: true,
            body: packages
          });
          this.#vulnCache = await res.json();
        }
        const advisories = this.#vulnCache;
        const { vulns } = this.currentAstNode;
        return this.initialItems.filter((item) => {
          const vulnerable = advisories[item.name]?.filter((advisory) => {
            if (!semver.intersects(advisory.vulnerable_versions, item.version)) {
              return false;
            }
            if (!vulns) {
              return true;
            }
            for (const vuln of vulns) {
              if (vuln.severity && !vuln.severity.includes("*")) {
                if (!vuln.severity.includes(advisory.severity)) {
                  continue;
                }
              }
              if (vuln?.cwe) {
                if (vuln.cwe.includes("*")) {
                  if (!advisory.cwe.length) {
                    continue;
                  }
                } else if (!vuln.cwe.every((cwe) => advisory.cwe.includes(`CWE-${cwe}`))) {
                  continue;
                }
              }
              return true;
            }
          });
          if (vulnerable?.length) {
            item.queryContext = {
              advisories: vulnerable
            };
            return true;
          }
          return false;
        });
      }
      async outdatedPseudo() {
        const { outdatedKind = "any" } = this.currentAstNode;
        const initialResults = await Promise.all(this.initialItems.map(async (node) => {
          if (node.isProjectRoot) {
            return false;
          }
          if (node.package.private) {
            return false;
          }
          if (!this.#outdatedCache.has(node.name)) {
            this.#outdatedCache.set(node.name, getPackageVersions(node.name, this.flatOptions));
          }
          const availableVersions = await this.#outdatedCache.get(node.name);
          node.queryContext.versions = availableVersions;
          const greaterVersions = availableVersions.filter((available) => {
            return semver.gt(available, node.version);
          });
          if (!greaterVersions.length) {
            return false;
          }
          if (outdatedKind === "any") {
            return node;
          }
          if (["major", "minor", "patch"].includes(outdatedKind)) {
            const filteredVersions = greaterVersions.filter((version) => {
              return semver.diff(node.version, version) === outdatedKind;
            });
            if (!filteredVersions.length) {
              return false;
            }
            return node;
          }
          if (outdatedKind === "in-range") {
            const inRangeContext = [];
            for (const edge of node.edgesIn) {
              const inRangeVersions = greaterVersions.filter((version) => {
                return semver.satisfies(version, edge.spec);
              });
              if (!inRangeVersions.length) {
                continue;
              }
              inRangeContext.push({
                from: edge.from.location,
                versions: inRangeVersions
              });
            }
            if (!inRangeContext.length) {
              return false;
            }
            node.queryContext.outdated = {
              ...node.queryContext.outdated,
              inRange: inRangeContext
            };
            return node;
          }
          if (outdatedKind === "out-of-range") {
            const outOfRangeContext = [];
            for (const edge of node.edgesIn) {
              const outOfRangeVersions = greaterVersions.filter((version) => {
                return !semver.satisfies(version, edge.spec);
              });
              if (!outOfRangeVersions.length) {
                continue;
              }
              outOfRangeContext.push({
                from: edge.from.location,
                versions: outOfRangeVersions
              });
            }
            if (!outOfRangeContext.length) {
              return false;
            }
            node.queryContext.outdated = {
              ...node.queryContext.outdated,
              outOfRange: outOfRangeContext
            };
            return node;
          }
          return false;
        }));
        return initialResults.filter(Boolean);
      }
    };
    var attributeOperators = {
      // attribute value is equivalent
      "="({ attr, value }) {
        return attr === value;
      },
      // attribute value contains word
      "~="({ attr, value }) {
        return (attr.match(/\w+/g) || []).includes(value);
      },
      // attribute value contains string
      "*="({ attr, value }) {
        return attr.includes(value);
      },
      // attribute value is equal or starts with
      "|="({ attr, value }) {
        return attr.startsWith(`${value}-`);
      },
      // attribute value starts with
      "^="({ attr, value }) {
        return attr.startsWith(value);
      },
      // attribute value ends with
      "$="({ attr, value }) {
        return attr.endsWith(value);
      }
    };
    var attributeOperator = ({ attr, value, insensitive, operator }) => {
      if (typeof attr === "number") {
        attr = String(attr);
      }
      if (typeof attr !== "string") {
        return false;
      }
      if (insensitive) {
        attr = attr.toLowerCase();
      }
      return attributeOperators[operator]({
        attr,
        insensitive,
        value
      });
    };
    var attributeMatch = (matcher, obj) => {
      const insensitive = !!matcher.insensitive;
      const operator = matcher.operator || "";
      const attribute = matcher.qualifiedAttribute;
      let value = matcher.value || "";
      if (operator === "") {
        return Boolean(obj[attribute]);
      }
      if (insensitive) {
        value = value.toLowerCase();
      }
      if (Array.isArray(obj[attribute])) {
        return obj[attribute].find((i, index) => {
          const attr = obj[attribute][index] || "";
          return attributeOperator({ attr, value, insensitive, operator });
        });
      } else {
        const attr = obj[attribute] || "";
        return attributeOperator({ attr, value, insensitive, operator });
      }
    };
    var edgeIsType = (node, type, seen = /* @__PURE__ */ new Set()) => {
      for (const edgeIn of node.edgesIn) {
        if (seen.has(edgeIn)) {
          continue;
        }
        seen.add(edgeIn);
        if (edgeIn.type === type || edgeIn.from[type] || edgeIsType(edgeIn.from, type, seen)) {
          return true;
        }
      }
      return false;
    };
    var filterByType = (nodes, type) => {
      const found = [];
      for (const node of nodes) {
        if (node[type] || edgeIsType(node, type)) {
          found.push(node);
        }
      }
      return found;
    };
    var depTypes = {
      // dependency
      ".prod"(prevResults) {
        const found = [];
        for (const node of prevResults) {
          if (!node.dev) {
            found.push(node);
          }
        }
        return found;
      },
      // devDependency
      ".dev"(prevResults) {
        return filterByType(prevResults, "dev");
      },
      // optionalDependency
      ".optional"(prevResults) {
        return filterByType(prevResults, "optional");
      },
      // peerDependency
      ".peer"(prevResults) {
        return filterByType(prevResults, "peer");
      },
      // workspace
      ".workspace"(prevResults) {
        return prevResults.filter((node) => node.isWorkspace);
      },
      // bundledDependency
      ".bundled"(prevResults) {
        return prevResults.filter((node) => node.inBundle);
      }
    };
    var hasParent = (node, compareNodes) => {
      for (let compareNode of compareNodes) {
        if (compareNode.isLink) {
          compareNode = compareNode.target;
        }
        if (node.isTop && node.resolveParent === compareNode) {
          return true;
        }
        for (const edge of node.edgesIn) {
          if (edge && edge.from === compareNode) {
            return true;
          }
        }
      }
      return false;
    };
    var hasAscendant = (node, compareNodes, seen = /* @__PURE__ */ new Set()) => {
      if (hasParent(node, compareNodes)) {
        return true;
      }
      if (node.isTop && node.resolveParent) {
        if (hasAscendant(node.resolveParent, compareNodes)) {
          return true;
        }
      }
      for (const edge of node.edgesIn) {
        if (seen.has(edge)) {
          continue;
        }
        seen.add(edge);
        if (edge && edge.from && hasAscendant(edge.from, compareNodes, seen)) {
          return true;
        }
      }
      for (const linkNode of node.linksIn) {
        if (hasAscendant(linkNode, compareNodes, seen)) {
          return true;
        }
      }
      return false;
    };
    var combinators = {
      // direct descendant
      ">"(prevResults, nextResults) {
        return nextResults.filter((node) => hasParent(node, prevResults));
      },
      // any descendant
      " "(prevResults, nextResults) {
        return nextResults.filter((node) => hasAscendant(node, prevResults));
      },
      // sibling
      "~"(prevResults, nextResults) {
        const parentNodes = /* @__PURE__ */ new Set();
        for (const node of prevResults) {
          for (const edge of node.edgesIn) {
            parentNodes.add(edge.from);
          }
        }
        return nextResults.filter(
          (node) => !prevResults.includes(node) && hasParent(node, [...parentNodes])
        );
      }
    };
    var getPackageVersions = async (name, opts) => {
      let packument;
      try {
        packument = await pacote.packument(name, {
          ...opts,
          fullMetadata: false
          // we only need the corgi
        });
      } catch (err) {
        log.warn("query", `could not retrieve packument for ${name}: ${err.message}`);
        return [];
      }
      let candidates = Object.keys(packument.versions).sort(semver.compare);
      if (packument.time && opts.before) {
        candidates = candidates.filter((version) => {
          if (!packument.time[version]) {
            return false;
          }
          return Date.parse(packument.time[version]) <= opts.before;
        });
      }
      return candidates;
    };
    var retrieveNodesFromParsedAst = async (opts) => {
      const rootAstNode = opts.rootAstNode;
      if (!rootAstNode.nodes) {
        return /* @__PURE__ */ new Set();
      }
      const results = new Results(opts);
      const astNodeQueue = /* @__PURE__ */ new Set();
      rootAstNode.walk((nextAstNode) => {
        astNodeQueue.add(nextAstNode);
      });
      for (const nextAstNode of astNodeQueue) {
        results.currentAstNode = nextAstNode;
        const updateFn = `${results.currentAstNode.type}Type`;
        if (typeof results[updateFn] !== "function") {
          throw Object.assign(
            new Error(`\`${results.currentAstNode.type}\` is not a supported selector.`),
            { code: "EQUERYNOSELECTOR" }
          );
        }
        await results[updateFn]();
      }
      return results.collect(rootAstNode);
    };
    var querySelectorAll = async (targetNode, query, flatOptions) => {
      const inventory = [...targetNode.root.inventory.values()];
      const res = await retrieveNodesFromParsedAst({
        initialItems: inventory,
        inventory,
        flatOptions,
        rootAstNode: parser(query),
        targetNode
      });
      return [...res].sort((a, b) => localeCompare(a.location, b.location));
    };
    module2.exports = querySelectorAll;
  }
});

// node_modules/@npmcli/arborist/lib/node.js
var require_node5 = __commonJS({
  "node_modules/@npmcli/arborist/lib/node.js"(exports2, module2) {
    var semver = require_semver2();
    var nameFromFolder = require_lib2();
    var Edge = require_edge();
    var Inventory = require_inventory();
    var OverrideSet = require_override_set();
    var { normalize } = require_lib36();
    var { getPaths: getBinPaths } = require_lib40();
    var npa = require_npa();
    var debug = require_debug2();
    var gatherDepSet = require_gather_dep_set();
    var treeCheck = require_tree_check();
    var { walkUp } = require_commonjs8();
    var { log } = require_lib4();
    var { resolve, relative, dirname, basename } = require("node:path");
    var util = require("node:util");
    var _package = Symbol("_package");
    var _parent = Symbol("_parent");
    var _target = Symbol.for("_target");
    var _fsParent = Symbol("_fsParent");
    var _reloadNamedEdges = Symbol("_reloadNamedEdges");
    var _loadDeps = Symbol.for("Arborist.Node._loadDeps");
    var _refreshLocation = Symbol.for("_refreshLocation");
    var _changePath = Symbol.for("_changePath");
    var _delistFromMeta = Symbol.for("_delistFromMeta");
    var _explain = Symbol("_explain");
    var _explanation = Symbol("_explanation");
    var relpath = require_relpath();
    var consistentResolve = require_consistent_resolve();
    var printableTree = require_printable();
    var CaseInsensitiveMap = require_case_insensitive_map();
    var querySelectorAll = require_query_selector_all();
    var Node = class _Node {
      #global;
      #meta;
      #root;
      #workspaces;
      constructor(options) {
        const {
          root,
          path,
          realpath,
          parent,
          error,
          meta,
          fsParent,
          resolved,
          integrity,
          // allow setting name explicitly when we haven't set a path yet
          name,
          children,
          fsChildren,
          installLinks = false,
          legacyPeerDeps = false,
          linksIn,
          isInStore = false,
          hasShrinkwrap,
          overrides,
          loadOverrides = false,
          extraneous = true,
          dev = true,
          optional = true,
          devOptional = true,
          peer = true,
          global: global2 = false,
          dummy = false,
          sourceReference = null,
          ideallyInert = false
        } = options;
        this.queryContext = {};
        this.#global = global2;
        this.#workspaces = null;
        this.errors = error ? [error] : [];
        this.isInStore = isInStore;
        this.sourceReference = sourceReference;
        const pkg = sourceReference ? sourceReference.package : normalize(options.pkg || {});
        this.name = name || nameFromFolder(path || pkg.name || realpath) || pkg.name || null;
        this.path = path ? resolve(path) : null;
        if (!this.name && (!this.path || this.path !== dirname(this.path))) {
          throw new TypeError("could not detect node name from path or package");
        }
        this.realpath = !this.isLink ? this.path : resolve(realpath);
        this.resolved = resolved || null;
        if (!this.resolved) {
          const resolved2 = consistentResolve(pkg._resolved);
          if (resolved2 && !(/^file:/.test(resolved2) && pkg._where)) {
            this.resolved = resolved2;
          }
        }
        this.integrity = integrity || pkg._integrity || null;
        this.hasShrinkwrap = hasShrinkwrap || pkg._hasShrinkwrap || false;
        this.installLinks = installLinks;
        this.legacyPeerDeps = legacyPeerDeps;
        this.children = new CaseInsensitiveMap();
        this.fsChildren = /* @__PURE__ */ new Set();
        this.inventory = new Inventory();
        this.tops = /* @__PURE__ */ new Set();
        this.linksIn = new Set(linksIn || []);
        if (!dummy) {
          this.dev = dev;
          this.optional = optional;
          this.devOptional = devOptional;
          this.peer = peer;
          this.extraneous = extraneous;
          this.dummy = false;
        } else {
          this.dummy = true;
          this.dev = false;
          this.optional = false;
          this.devOptional = false;
          this.peer = false;
          this.extraneous = false;
        }
        this.ideallyInert = ideallyInert;
        this.edgesIn = /* @__PURE__ */ new Set();
        this.edgesOut = new CaseInsensitiveMap();
        this[_package] = pkg && typeof pkg === "object" ? pkg : {};
        if (overrides) {
          this.overrides = overrides;
        } else if (loadOverrides) {
          const overrides2 = this[_package].overrides || {};
          if (Object.keys(overrides2).length > 0) {
            this.overrides = new OverrideSet({
              overrides: this[_package].overrides
            });
          }
        }
        this.meta = meta;
        this[_parent] = null;
        this.parent = parent || null;
        this[_fsParent] = null;
        this.fsParent = fsParent || null;
        if (!parent && !fsParent) {
          this.root = root || null;
        }
        if (children) {
          for (const c of children) {
            new _Node({ ...c, parent: this });
          }
        }
        if (fsChildren) {
          for (const c of fsChildren) {
            new _Node({ ...c, fsParent: this });
          }
        }
        this[_loadDeps]();
      }
      get meta() {
        return this.#meta;
      }
      set meta(meta) {
        this.#meta = meta;
        if (meta) {
          meta.add(this);
        }
      }
      get global() {
        if (this.#root === this) {
          return this.#global;
        }
        return this.#root.global;
      }
      // true for packages installed directly in the global node_modules folder
      get globalTop() {
        return this.global && this.parent && this.parent.isProjectRoot;
      }
      get workspaces() {
        return this.#workspaces;
      }
      set workspaces(workspaces) {
        if (this.#workspaces) {
          for (const name of this.#workspaces.keys()) {
            if (!workspaces.has(name)) {
              this.edgesOut.get(name).detach();
            }
          }
        }
        this.#workspaces = workspaces;
        this.#loadWorkspaces();
        this[_loadDeps]();
      }
      get binPaths() {
        if (!this.parent) {
          return [];
        }
        return getBinPaths({
          pkg: this[_package],
          path: this.path,
          global: this.global,
          top: this.globalTop
        });
      }
      get hasInstallScript() {
        const { hasInstallScript, scripts } = this.package;
        const { install, preinstall, postinstall } = scripts || {};
        return !!(hasInstallScript || install || preinstall || postinstall);
      }
      get version() {
        return this[_package].version || "";
      }
      get packageName() {
        return this[_package].name || null;
      }
      get pkgid() {
        const { name = "", version = "" } = this.package;
        const { isProjectRoot } = this;
        const myname = isProjectRoot ? name || this.name : this.name;
        const alias = !isProjectRoot && name && myname !== name ? `npm:${name}@` : "";
        return `${myname}@${alias}${version}`;
      }
      get overridden() {
        if (!this.overrides) {
          return false;
        }
        if (!this.overrides.value) {
          return false;
        }
        if (this.overrides.name !== this.name) {
          return false;
        }
        for (const edge of this.edgesIn) {
          if (edge.overrides && edge.overrides.name === this.name && edge.overrides.value === this.version) {
            if (!edge.overrides.isEqual(edge.from.overrides)) {
              return true;
            }
          }
        }
        return false;
      }
      get package() {
        return this[_package];
      }
      set package(pkg) {
        for (const edge of this.edgesOut.values()) {
          edge.detach();
        }
        this[_explanation] = null;
        if (!pkg || typeof pkg !== "object") {
          debug(() => {
            throw new Error("setting Node.package to non-object");
          });
          pkg = {};
        }
        this[_package] = pkg;
        this.#loadWorkspaces();
        this[_loadDeps]();
        this.edgesIn.forEach((edge) => edge.reload(true));
      }
      // node.explain(nodes seen already, edge we're trying to satisfy
      // if edge is not specified, it lists every edge into the node.
      explain(edge = null, seen = []) {
        if (this[_explanation]) {
          return this[_explanation];
        }
        return this[_explanation] = this[_explain](edge, seen);
      }
      [_explain](edge, seen) {
        if (this.isProjectRoot && !this.sourceReference) {
          return {
            location: this.path
          };
        }
        const why = {
          name: this.isProjectRoot || this.isTop ? this.packageName : this.name,
          version: this.package.version
        };
        if (this.errors.length || !this.packageName || !this.package.version) {
          why.errors = this.errors.length ? this.errors : [
            new Error("invalid package: lacks name and/or version")
          ];
          why.package = this.package;
        }
        if (this.root.sourceReference) {
          const { name, version } = this.root.package;
          why.whileInstalling = {
            name,
            version,
            path: this.root.sourceReference.path
          };
        }
        if (this.sourceReference) {
          return this.sourceReference.explain(edge, seen);
        }
        if (seen.includes(this)) {
          return why;
        }
        why.location = this.location;
        why.isWorkspace = this.isWorkspace;
        seen = seen.concat(this);
        why.dependents = [];
        if (edge) {
          why.dependents.push(edge.explain(seen));
        } else {
          const edges = [];
          for (const edge2 of this.edgesIn) {
            if (!edge2.valid && !edge2.from.isProjectRoot) {
              continue;
            }
            edges.push(edge2);
          }
          for (const edge2 of edges) {
            why.dependents.push(edge2.explain(seen));
          }
        }
        if (this.linksIn.size) {
          why.linksIn = [...this.linksIn].map((link) => link[_explain](edge, seen));
        }
        return why;
      }
      isDescendantOf(node) {
        for (let p = this; p; p = p.resolveParent) {
          if (p === node) {
            return true;
          }
        }
        return false;
      }
      getBundler(path = []) {
        if (path.includes(this)) {
          return null;
        }
        path.push(this);
        const parent = this[_parent];
        if (!parent) {
          return null;
        }
        const pBundler = parent.getBundler(path);
        if (pBundler) {
          return pBundler;
        }
        const ppkg = parent.package;
        const bd = ppkg && ppkg.bundleDependencies;
        if (Array.isArray(bd) && bd.includes(this.name)) {
          return parent;
        }
        for (const edge of this.edgesIn) {
          const eBundler = edge.from.getBundler(path);
          if (!eBundler) {
            continue;
          }
          if (eBundler === parent) {
            return eBundler;
          }
        }
        return null;
      }
      get inBundle() {
        return !!this.getBundler();
      }
      // when reifying, if a package is technically in a bundleDependencies list,
      // but that list is the root project, we still have to install it.  This
      // getter returns true if it's in a dependency's bundle list, not the root's.
      get inDepBundle() {
        const bundler = this.getBundler();
        return !!bundler && bundler !== this.root;
      }
      get isWorkspace() {
        if (this.isProjectRoot) {
          return false;
        }
        const { root } = this;
        const { type, to } = root.edgesOut.get(this.packageName) || {};
        return type === "workspace" && to && (to.target === this || to === this);
      }
      get isRoot() {
        return this === this.root;
      }
      get isProjectRoot() {
        return this === this.root || this === this.root.target;
      }
      get isRegistryDependency() {
        if (this.edgesIn.size === 0) {
          return false;
        }
        for (const edge of this.edgesIn) {
          if (!npa(edge.spec).registry) {
            return false;
          }
        }
        return true;
      }
      *ancestry() {
        for (let anc = this; anc; anc = anc.resolveParent) {
          yield anc;
        }
      }
      set root(root) {
        while (root && root.root !== root) {
          root = root.root;
        }
        root = root || this;
        this[_delistFromMeta]();
        if (!this.path || !root.realpath || !root.path) {
          this.#root = root;
          return;
        }
        this.#root = this;
        for (const link of this.linksIn) {
          link[_target] = null;
          this.linksIn.delete(link);
        }
        const { target } = this;
        if (this.isLink) {
          if (target) {
            target.linksIn.delete(this);
            if (target.root === this) {
              target[_delistFromMeta]();
            }
          }
          this[_target] = null;
        }
        if (this.parent && this.parent.root !== root) {
          this.parent.children.delete(this.name);
          this[_parent] = null;
        }
        if (this.fsParent && this.fsParent.root !== root) {
          this.fsParent.fsChildren.delete(this);
          this[_fsParent] = null;
        }
        if (root === this) {
          this[_refreshLocation]();
        } else {
          const loc = relpath(root.realpath, this.path);
          const current = root.inventory.get(loc);
          if (current) {
            current.root = null;
          }
          this.#root = root;
          this[_refreshLocation]();
          for (const p of walkUp(dirname(this.path))) {
            if (p === this.path) {
              continue;
            }
            const ploc = relpath(root.realpath, p);
            const parent = root.inventory.get(ploc);
            if (parent) {
              if (parent.isLink) {
                debug(() => {
                  throw Object.assign(new Error("assigning parentage to link"), {
                    path: this.path,
                    parent: parent.path,
                    parentReal: parent.realpath
                  });
                });
                continue;
              }
              const childLoc = `${ploc}${ploc ? "/" : ""}node_modules/${this.name}`;
              const isParent = this.location === childLoc;
              if (isParent) {
                const oldChild = parent.children.get(this.name);
                if (oldChild && oldChild !== this) {
                  oldChild.root = null;
                }
                if (this.parent) {
                  this.parent.children.delete(this.name);
                  this.parent[_reloadNamedEdges](this.name);
                }
                parent.children.set(this.name, this);
                this[_parent] = parent;
                if (!this.isLink) {
                  parent[_reloadNamedEdges](this.name);
                }
              } else {
                if (this.fsParent) {
                  this.fsParent.fsChildren.delete(this);
                }
                parent.fsChildren.add(this);
                this[_fsParent] = parent;
              }
              break;
            }
          }
          if (!this.parent) {
            root.tops.add(this);
          } else {
            root.tops.delete(this);
          }
          const nmloc = `${this.location}${this.location ? "/" : ""}node_modules/`;
          for (const child of root.tops) {
            const isChild = child.location === nmloc + child.name;
            const isFsChild = dirname(child.path).startsWith(this.path) && child !== this && !child.parent && (!child.fsParent || child.fsParent === this || dirname(this.path).startsWith(child.fsParent.path));
            if (!isChild && !isFsChild) {
              continue;
            }
            if (this.isLink) {
              child.root = null;
            } else {
              if (child.fsParent) {
                child.fsParent.fsChildren.delete(child);
              }
              child[_fsParent] = null;
              if (isChild) {
                this.children.set(child.name, child);
                child[_parent] = this;
                root.tops.delete(child);
              } else {
                this.fsChildren.add(child);
                child[_fsParent] = this;
              }
            }
          }
          for (const node of root.inventory.query("realpath", this.realpath)) {
            if (node === this) {
              continue;
            }
            debug(() => {
              if (node.root !== root) {
                throw new Error("inventory contains node from other root");
              }
            });
            if (this.isLink) {
              const target2 = node.target;
              this[_target] = target2;
              this[_package] = target2.package;
              target2.linksIn.add(this);
              if (this.parent) {
                this.parent[_reloadNamedEdges](this.name);
              }
              break;
            } else {
              if (node.isLink) {
                node[_target] = this;
                node[_package] = this.package;
                this.linksIn.add(node);
                if (node.parent) {
                  node.parent[_reloadNamedEdges](node.name);
                }
              } else {
                debug(() => {
                  throw Object.assign(new Error("duplicate node in root setter"), {
                    path: this.path,
                    realpath: this.realpath,
                    root: root.realpath
                  });
                });
              }
            }
          }
        }
        for (const edge of this.edgesIn) {
          if (edge.from.root !== root) {
            edge.reload();
          }
        }
        for (const edge of this.edgesOut.values()) {
          if (!edge.to || edge.to.root !== root) {
            edge.reload();
          }
        }
        const family = new Set([
          ...this.fsChildren,
          ...this.children.values(),
          ...this.inventory.values()
        ].filter((n) => n !== this));
        for (const child of family) {
          if (child.root !== root) {
            child[_delistFromMeta]();
            child[_parent] = null;
            this.children.delete(child.name);
            child[_fsParent] = null;
            this.fsChildren.delete(child);
            for (const l of child.linksIn) {
              l[_target] = null;
              child.linksIn.delete(l);
            }
          }
        }
        for (const child of family) {
          if (child.root !== root) {
            child.root = root;
          }
        }
        if (this.isLink && target && !this.target && root !== this) {
          target.root = root;
        }
        treeCheck(this);
        if (this !== root) {
          treeCheck(root);
        }
      }
      get root() {
        return this.#root || this;
      }
      #loadWorkspaces() {
        if (!this.#workspaces) {
          return;
        }
        for (const [name, path] of this.#workspaces.entries()) {
          new Edge({ from: this, name, spec: `file:${path}`, type: "workspace" });
        }
      }
      [_loadDeps]() {
        const pd = this.package.peerDependencies;
        const ad = this.package.acceptDependencies || {};
        if (pd && typeof pd === "object" && !this.legacyPeerDeps) {
          const pm = this.package.peerDependenciesMeta || {};
          const peerDependencies = {};
          const peerOptional = {};
          for (const [name, dep] of Object.entries(pd)) {
            if (pm[name]?.optional) {
              peerOptional[name] = dep;
            } else {
              peerDependencies[name] = dep;
            }
          }
          this.#loadDepType(peerDependencies, "peer", ad);
          this.#loadDepType(peerOptional, "peerOptional", ad);
        }
        this.#loadDepType(this.package.dependencies, "prod", ad);
        this.#loadDepType(this.package.optionalDependencies, "optional", ad);
        const { globalTop, isTop, path, sourceReference } = this;
        const {
          globalTop: srcGlobalTop,
          isTop: srcTop,
          path: srcPath
        } = sourceReference || {};
        const thisDev = isTop && !globalTop && path;
        const srcDev = !sourceReference || srcTop && !srcGlobalTop && srcPath;
        if (thisDev && srcDev) {
          this.#loadDepType(this.package.devDependencies, "dev", ad);
        }
      }
      #loadDepType(deps, type, ad) {
        for (const [name, spec] of Object.entries(deps || {})) {
          const current = this.edgesOut.get(name);
          if (!current || current.type !== "workspace") {
            new Edge({ from: this, name, spec, accept: ad[name], type });
          }
        }
      }
      get fsParent() {
        return this[_fsParent];
      }
      set fsParent(fsParent) {
        if (!fsParent) {
          if (this[_fsParent]) {
            this.root = null;
          }
          return;
        }
        debug(() => {
          if (fsParent === this) {
            throw new Error("setting node to its own fsParent");
          }
          if (fsParent.realpath === this.realpath) {
            throw new Error("setting fsParent to same path");
          }
          if (!this[_fsParent] && this.realpath.indexOf(fsParent.realpath) !== 0) {
            throw Object.assign(new Error("setting fsParent improperly"), {
              path: this.path,
              realpath: this.realpath,
              fsParent: {
                path: fsParent.path,
                realpath: fsParent.realpath
              }
            });
          }
        });
        if (fsParent.isLink) {
          fsParent = fsParent.target;
        }
        if (this === fsParent || fsParent.realpath === this.realpath) {
          return;
        }
        if (this[_fsParent] === fsParent) {
          return;
        }
        const oldFsParent = this[_fsParent];
        const newPath = !oldFsParent ? this.path : resolve(fsParent.path, relative(oldFsParent.path, this.path));
        const nmPath = resolve(fsParent.path, "node_modules", this.name);
        if (newPath === nmPath) {
          this.parent = fsParent;
          return;
        }
        const pathChange = newPath !== this.path;
        const oldParent = this.parent;
        const oldName = this.name;
        if (this.parent) {
          this.parent.children.delete(this.name);
          this[_parent] = null;
        }
        if (this.fsParent) {
          this.fsParent.fsChildren.delete(this);
          this[_fsParent] = null;
        }
        if (pathChange) {
          this[_changePath](newPath);
        }
        if (oldParent) {
          oldParent[_reloadNamedEdges](oldName);
        }
        this.root = fsParent.root;
      }
      // is it safe to replace one node with another?  check the edges to
      // make sure no one will get upset.  Note that the node might end up
      // having its own unmet dependencies, if the new node has new deps.
      // Note that there are cases where Arborist will opt to insert a node
      // into the tree even though this function returns false!  This is
      // necessary when a root dependency is added or updated, or when a
      // root dependency brings peer deps along with it.  In that case, we
      // will go ahead and create the invalid state, and then try to resolve
      // it with more tree construction, because it's a user request.
      canReplaceWith(node, ignorePeers) {
        if (node.name !== this.name) {
          return false;
        }
        if (node.packageName !== this.packageName) {
          return false;
        }
        if (this.edgesOut.size) {
          if (node.overrides) {
            if (!node.overrides.isEqual(this.overrides)) {
              return false;
            }
          } else {
            if (this.overrides) {
              return false;
            }
          }
        }
        ignorePeers = new Set(ignorePeers);
        const depSet = gatherDepSet([this], (e) => e.to !== this && e.valid);
        for (const edge of this.edgesIn) {
          if (!this.isTop && edge.from.parent === this.parent && edge.peer && ignorePeers.has(edge.from.name)) {
            continue;
          }
          if (!depSet.has(edge.from) && !edge.satisfiedBy(node)) {
            return false;
          }
        }
        return true;
      }
      canReplace(node, ignorePeers) {
        return node.canReplaceWith(this, ignorePeers);
      }
      // return true if it's safe to remove this node, because anything that
      // is depending on it would be fine with the thing that they would resolve
      // to if it was removed, or nothing is depending on it in the first place.
      canDedupe(preferDedupe = false, explicitRequest = false) {
        if (this.inDepBundle || this.inShrinkwrap) {
          return false;
        }
        if (!this.resolveParent || !this.resolveParent.resolveParent) {
          return false;
        }
        if (this.edgesIn.size === 0) {
          return true;
        }
        const other = this.resolveParent.resolveParent.resolve(this.name);
        if (!other) {
          return false;
        }
        if (other.matches(this)) {
          return true;
        }
        if (!other.canReplace(this)) {
          return false;
        }
        if (preferDedupe || semver.eq(other.version, this.version)) {
          return true;
        }
        if (!this.overridden && semver.gt(other.version, this.version)) {
          return true;
        }
        if (explicitRequest) {
          return true;
        }
        return false;
      }
      satisfies(requested) {
        if (requested instanceof Edge) {
          return this.name === requested.name && requested.satisfiedBy(this);
        }
        const parsed = npa(requested);
        const { name = this.name, rawSpec: spec } = parsed;
        return this.name === name && this.satisfies(new Edge({
          from: new _Node({ path: this.root.realpath }),
          type: "prod",
          name,
          spec
        }));
      }
      matches(node) {
        if (node === this) {
          return true;
        }
        if (node.name !== this.name) {
          return false;
        }
        if (this.isLink) {
          return node.isLink && this.target.matches(node.target);
        }
        if (this.isProjectRoot && node.isProjectRoot) {
          return this.path === node.path;
        }
        if (this.integrity && node.integrity) {
          return this.integrity === node.integrity;
        }
        if (this.resolved && node.resolved) {
          return this.resolved === node.resolved;
        }
        return this.packageName && node.packageName && this.packageName === node.packageName && this.version && node.version && this.version === node.version;
      }
      // replace this node with the supplied argument
      // Useful when mutating an ideal tree, so we can avoid having to call
      // the parent/root setters more than necessary.
      replaceWith(node) {
        node.replace(this);
      }
      replace(node) {
        this[_delistFromMeta]();
        if (node.parent?.children.get(this.name) === node) {
          this.path = resolve(node.parent.path, "node_modules", this.name);
        } else {
          this.path = node.path;
          this.name = node.name;
        }
        if (!this.isLink) {
          this.realpath = this.path;
        }
        this[_refreshLocation]();
        if (!this.isLink) {
          for (const kid of node.children.values()) {
            kid.parent = this;
          }
          if (node.isLink && node.target) {
            node.target.root = null;
          }
        }
        if (!node.isRoot) {
          this.root = node.root;
        }
        treeCheck(this);
      }
      get inShrinkwrap() {
        return this.parent && (this.parent.hasShrinkwrap || this.parent.inShrinkwrap);
      }
      get parent() {
        return this[_parent];
      }
      // This setter keeps everything in order when we move a node from
      // one point in a logical tree to another.  Edges get reloaded,
      // metadata updated, etc.  It's also called when we *replace* a node
      // with another by the same name (eg, to update or dedupe).
      // This does a couple of walks out on the node_modules tree, recursing
      // into child nodes.  However, as setting the parent is typically done
      // with nodes that don't have have many children, and (deduped) package
      // trees tend to be broad rather than deep, it's not that bad.
      // The only walk that starts from the parent rather than this node is
      // limited by edge name.
      set parent(parent) {
        if (!parent) {
          if (this[_parent]) {
            this.root = null;
          }
          return;
        }
        if (parent.isLink) {
          parent = parent.target;
        }
        if (this === parent) {
          return;
        }
        const oldParent = this[_parent];
        if (oldParent === parent) {
          return;
        }
        const newPath = resolve(parent.path, "node_modules", this.name);
        const pathChange = newPath !== this.path;
        if (oldParent) {
          oldParent.children.delete(this.name);
          this[_parent] = null;
        }
        if (this.fsParent) {
          this.fsParent.fsChildren.delete(this);
          this[_fsParent] = null;
        }
        if (pathChange) {
          this[_changePath](newPath);
        }
        this.root = parent.root;
      }
      // Call this before changing path or updating the _root reference.
      // Removes the node from its root the metadata and inventory.
      [_delistFromMeta]() {
        const root = this.root;
        if (!root.realpath || !this.path) {
          return;
        }
        root.inventory.delete(this);
        root.tops.delete(this);
        if (root.meta) {
          root.meta.delete(this.path);
        }
        debug(() => {
          if ([...root.inventory.values()].includes(this)) {
            throw new Error("failed to delist");
          }
        });
      }
      // update this.path/realpath and the paths of all children/fsChildren
      [_changePath](newPath) {
        this[_delistFromMeta]();
        const oldPath = this.path;
        this.path = newPath;
        const namePattern = /(?:^|\/|\\)node_modules[\\/](@[^/\\]+[\\/][^\\/]+|[^\\/]+)$/;
        const nameChange = newPath.match(namePattern);
        if (nameChange && this.name !== nameChange[1]) {
          this.name = nameChange[1].replace(/\\/g, "/");
        }
        if (!this.isLink) {
          this.realpath = newPath;
          for (const link of this.linksIn) {
            link[_delistFromMeta]();
            link.realpath = newPath;
            link[_refreshLocation]();
          }
        }
        for (const child of this.fsChildren) {
          child[_changePath](resolve(newPath, relative(oldPath, child.path)));
        }
        for (const [name, child] of this.children.entries()) {
          child[_changePath](resolve(newPath, "node_modules", name));
        }
        this[_refreshLocation]();
      }
      // Called whenever the root/parent is changed.
      // NB: need to remove from former root's meta/inventory and then update
      // this.path BEFORE calling this method!
      [_refreshLocation]() {
        const root = this.root;
        const loc = relpath(root.realpath, this.path);
        this.location = loc;
        root.inventory.add(this);
        if (root.meta) {
          root.meta.add(this);
        }
      }
      assertRootOverrides() {
        if (!this.isProjectRoot || !this.overrides) {
          return;
        }
        for (const edge of this.edgesOut.values()) {
          if (edge.spec !== edge.rawSpec && !edge.spec.startsWith("$")) {
            throw Object.assign(new Error(`Override for ${edge.name}@${edge.rawSpec} conflicts with direct dependency`), { code: "EOVERRIDE" });
          }
        }
      }
      addEdgeOut(edge) {
        if (this.overrides) {
          edge.overrides = this.overrides.getEdgeRule(edge);
        }
        this.edgesOut.set(edge.name, edge);
      }
      recalculateOutEdgesOverrides() {
        for (const edge of this.edgesOut.values()) {
          edge.reload(true);
          if (edge.to) {
            edge.to.updateOverridesEdgeInAdded(edge.overrides);
          }
        }
      }
      updateOverridesEdgeInRemoved(otherOverrideSet) {
        if (!this.overrides || !this.overrides.isEqual(otherOverrideSet)) {
          return false;
        }
        let newOverrideSet;
        for (const edge of this.edgesIn) {
          if (newOverrideSet && edge.overrides) {
            newOverrideSet = OverrideSet.findSpecificOverrideSet(edge.overrides, newOverrideSet);
          } else {
            newOverrideSet = edge.overrides;
          }
        }
        if (this.overrides.isEqual(newOverrideSet)) {
          return false;
        }
        this.overrides = newOverrideSet;
        if (this.overrides) {
          this.recalculateOutEdgesOverrides();
        }
        return true;
      }
      // This logic isn't perfect either. When we have two edges in that have different override sets, then we have to decide which set is correct.
      // This function assumes the more specific override set is applicable, so if we have dependencies A->B->C and A->C
      // and an override set that specifies what happens for C under A->B, this will work even if the new A->C edge comes along and tries to change
      // the override set.
      // The strictly correct logic is not to allow two edges with different overrides to point to the same node, because even if this node can satisfy
      // both, one of its dependencies might need to be different depending on the edge leading to it.
      // However, this might cause a lot of duplication, because the conflict in the dependencies might never actually happen.
      updateOverridesEdgeInAdded(otherOverrideSet) {
        if (!otherOverrideSet) {
          return false;
        }
        if (!this.overrides) {
          this.overrides = otherOverrideSet;
          this.recalculateOutEdgesOverrides();
          return true;
        }
        if (this.overrides.isEqual(otherOverrideSet)) {
          return false;
        }
        const newOverrideSet = OverrideSet.findSpecificOverrideSet(this.overrides, otherOverrideSet);
        if (newOverrideSet) {
          if (!this.overrides.isEqual(newOverrideSet)) {
            this.overrides = newOverrideSet;
            this.recalculateOutEdgesOverrides();
            return true;
          }
          return false;
        }
        log.silly("Conflicting override sets", this.name);
      }
      deleteEdgeIn(edge) {
        this.edgesIn.delete(edge);
        if (edge.overrides) {
          this.updateOverridesEdgeInRemoved(edge.overrides);
        }
      }
      addEdgeIn(edge) {
        if (!this.overrides || !this.overrides.isEqual(edge.overrides)) {
          this.updateOverridesEdgeInAdded(edge.overrides);
        }
        this.edgesIn.add(edge);
        if (this.root.meta) {
          this.root.meta.addEdge(edge);
        }
      }
      [_reloadNamedEdges](name, rootLoc = this.location) {
        const edge = this.edgesOut.get(name);
        const rootLocResolved = edge && edge.to && edge.to.location === `${rootLoc}/node_modules/${edge.name}`;
        const sameResolved = edge && this.resolve(name) === edge.to;
        const recheck = rootLocResolved || !sameResolved;
        if (edge && recheck) {
          edge.reload(true);
        }
        for (const c of this.children.values()) {
          c[_reloadNamedEdges](name, rootLoc);
        }
        for (const c of this.fsChildren) {
          c[_reloadNamedEdges](name, rootLoc);
        }
      }
      get isLink() {
        return false;
      }
      get target() {
        return this;
      }
      set target(n) {
        debug(() => {
          throw Object.assign(new Error("cannot set target on non-Link Nodes"), {
            path: this.path
          });
        });
      }
      get depth() {
        if (this.isTop) {
          return 0;
        }
        return this.parent.depth + 1;
      }
      get isTop() {
        return !this.parent || this.globalTop;
      }
      get top() {
        if (this.isTop) {
          return this;
        }
        return this.parent.top;
      }
      get isFsTop() {
        return !this.fsParent;
      }
      get fsTop() {
        if (this.isFsTop) {
          return this;
        }
        return this.fsParent.fsTop;
      }
      get resolveParent() {
        return this.parent || this.fsParent;
      }
      resolve(name) {
        debug(() => {
          if (typeof name !== "string" || !name) {
            throw new Error("non-string passed to Node.resolve");
          }
        });
        const mine = this.children.get(name);
        if (mine) {
          return mine;
        }
        const resolveParent = this.resolveParent;
        if (resolveParent) {
          return resolveParent.resolve(name);
        }
        return null;
      }
      inNodeModules() {
        const rp = this.realpath;
        const name = this.name;
        const scoped = name.charAt(0) === "@";
        const d = dirname(rp);
        const nm = scoped ? dirname(d) : d;
        const dir = dirname(nm);
        const base = scoped ? `${basename(d)}/${basename(rp)}` : basename(rp);
        return base === name && basename(nm) === "node_modules" ? dir : false;
      }
      // maybe accept both string value or array of strings
      // seems to be what dom API does
      querySelectorAll(query, opts) {
        return querySelectorAll(this, query, opts);
      }
      toJSON() {
        return printableTree(this);
      }
      [util.inspect.custom]() {
        return this.toJSON();
      }
    };
    module2.exports = Node;
  }
});

// node_modules/@npmcli/arborist/lib/link.js
var require_link = __commonJS({
  "node_modules/@npmcli/arborist/lib/link.js"(exports2, module2) {
    var relpath = require_relpath();
    var Node = require_node5();
    var _loadDeps = Symbol.for("Arborist.Node._loadDeps");
    var _target = Symbol.for("_target");
    var { dirname } = require("node:path");
    var _delistFromMeta = Symbol.for("_delistFromMeta");
    var _refreshLocation = Symbol.for("_refreshLocation");
    var Link = class extends Node {
      constructor(options) {
        const { root, realpath, target, parent, fsParent, isStoreLink } = options;
        if (!realpath && !(target && target.path)) {
          throw new TypeError("must provide realpath for Link node");
        }
        super({
          ...options,
          realpath: realpath || target.path,
          root: root || (parent ? parent.root : fsParent ? fsParent.root : target ? target.root : null)
        });
        this.isStoreLink = isStoreLink || false;
        if (target) {
          this.target = target;
        } else if (this.realpath === this.root.path) {
          this.target = this.root;
        } else {
          this.target = new Node({
            ...options,
            path: realpath,
            parent: null,
            fsParent: null,
            root: this.root
          });
        }
      }
      get version() {
        return this.target ? this.target.version : this.package.version || "";
      }
      get target() {
        return this[_target];
      }
      set target(target) {
        const current = this[_target];
        if (target === current) {
          return;
        }
        if (!target) {
          if (current && current.linksIn) {
            current.linksIn.delete(this);
          }
          if (this.path) {
            this[_delistFromMeta]();
            this[_target] = null;
            this.package = {};
            this[_refreshLocation]();
          } else {
            this[_target] = null;
          }
          return;
        }
        if (!this.path) {
          if (target.path) {
            this.realpath = target.path;
          } else {
            target.path = target.realpath = this.realpath;
          }
          target.root = this.root;
          this[_target] = target;
          target.linksIn.add(this);
          this.package = target.package;
          return;
        }
        this[_delistFromMeta]();
        this.package = target.package;
        this.realpath = target.path;
        this[_refreshLocation]();
        target.root = this.root;
      }
      // a link always resolves to the relative path to its target
      get resolved() {
        return this.path && this.realpath ? `file:${relpath(dirname(this.path), this.realpath)}` : null;
      }
      set resolved(r) {
      }
      // deps are resolved on the target, not the Link
      // so this is a no-op
      [_loadDeps]() {
      }
      // links can't have children, only their targets can
      // fix it to an empty list so that we can still call
      // things that iterate over them, just as a no-op
      get children() {
        return /* @__PURE__ */ new Map();
      }
      set children(c) {
      }
      get isLink() {
        return true;
      }
    };
    module2.exports = Link;
  }
});

// node_modules/@npmcli/arborist/lib/place-dep.js
var require_place_dep = __commonJS({
  "node_modules/@npmcli/arborist/lib/place-dep.js"(exports2, module2) {
    var localeCompare = require_string_locale_compare()("en");
    var { log } = require_lib4();
    var { redact } = require_lib28();
    var deepestNestingTarget = require_deepest_nesting_target();
    var CanPlaceDep = require_can_place_dep();
    var {
      KEEP,
      CONFLICT
    } = CanPlaceDep;
    var debug = require_debug2();
    var Link = require_link();
    var gatherDepSet = require_gather_dep_set();
    var peerEntrySets = require_peer_entry_sets();
    var PlaceDep = class _PlaceDep {
      constructor(options) {
        this.auditReport = options.auditReport;
        this.dep = options.dep;
        this.edge = options.edge;
        this.explicitRequest = options.explicitRequest;
        this.force = options.force;
        this.installLinks = options.installLinks;
        this.installStrategy = options.installStrategy;
        this.legacyPeerDeps = options.legacyPeerDeps;
        this.parent = options.parent || null;
        this.preferDedupe = options.preferDedupe;
        this.strictPeerDeps = options.strictPeerDeps;
        this.updateNames = options.updateNames;
        this.canPlace = null;
        this.canPlaceSelf = null;
        this.checks = /* @__PURE__ */ new Map();
        this.children = [];
        this.needEvaluation = /* @__PURE__ */ new Set();
        this.peerConflict = null;
        this.placed = null;
        this.target = null;
        this.current = this.edge.to;
        this.name = this.edge.name;
        this.top = this.parent?.top || this;
        if (this.edge.to && !this.edge.error && !this.explicitRequest && !this.updateNames.includes(this.edge.name) && !this.auditReport?.isVulnerable(this.edge.to)) {
          return;
        }
        const start = this.getStartNode();
        for (const target2 of start.ancestry()) {
          const targetEdge = target2.edgesOut.get(this.edge.name);
          if (!target2.isTop && targetEdge && targetEdge.peer) {
            continue;
          }
          const cpd = new CanPlaceDep({
            dep: this.dep,
            edge: this.edge,
            // note: this sets the parent's canPlace as the parent of this
            // canPlace, but it does NOT add this canPlace to the parent's
            // children.  This way, we can know that it's a peer dep, and
            // get the top edge easily, while still maintaining the
            // tree of checks that factored into the original decision.
            parent: this.parent && this.parent.canPlace,
            target: target2,
            preferDedupe: this.preferDedupe,
            explicitRequest: this.explicitRequest
          });
          this.checks.set(target2, cpd);
          if (cpd.canPlaceSelf !== CONFLICT) {
            this.canPlaceSelf = cpd;
          }
          if (cpd.canPlace !== CONFLICT) {
            this.canPlace = cpd;
          } else {
            break;
          }
          if (this.dep.errors.length) {
            break;
          }
          if (this.installStrategy === "nested") {
            break;
          }
          if (this.installStrategy === "shallow") {
            const rp = target2.resolveParent;
            if (rp && rp.isProjectRoot) {
              break;
            }
          }
        }
        if (!this.canPlace) {
          if (!this.force && (this.isMine || this.strictPeerDeps)) {
            return this.failPeerConflict();
          }
          if (!this.canPlaceSelf) {
            this.warnPeerConflict();
            return;
          }
          this.canPlace = this.canPlaceSelf;
        }
        if (!this.canPlace) {
          debug(() => {
            throw new Error("canPlace not set, but trying to place in tree");
          });
          return;
        }
        const { target } = this.canPlace;
        log.silly(
          "placeDep",
          target.location || "ROOT",
          `${this.dep.name}@${this.dep.version}`,
          this.canPlace.description,
          `for: ${this.edge.from.package._id || this.edge.from.location}`,
          `want: ${redact(this.edge.spec || "*")}`
        );
        const placementType = this.canPlace.canPlace === CONFLICT ? this.canPlace.canPlaceSelf : this.canPlace.canPlace;
        if (placementType === KEEP) {
          if (this.edge.peer && !this.edge.valid) {
            this.warnPeerConflict();
          }
          this.pruneDedupable(target);
          return;
        }
        for (let p = target; p; p = p.resolveParent) {
          if (p.matches(this.dep) && !p.isTop) {
            this.placed = new Link({ parent: target, target: p });
            return;
          }
        }
        const virtualRoot = this.dep.parent;
        this.placed = new this.dep.constructor({
          name: this.dep.name,
          pkg: this.dep.package,
          resolved: this.dep.resolved,
          integrity: this.dep.integrity,
          installLinks: this.installLinks,
          legacyPeerDeps: this.legacyPeerDeps,
          error: this.dep.errors[0],
          ...this.dep.overrides ? { overrides: this.dep.overrides } : {},
          ...this.dep.isLink ? { target: this.dep.target, realpath: this.dep.realpath } : {}
        });
        this.oldDep = target.children.get(this.name);
        if (this.oldDep) {
          this.replaceOldDep();
        } else {
          this.placed.parent = target;
        }
        if (this.edge.peer && !this.placed.satisfies(this.edge)) {
          this.warnPeerConflict();
        }
        if (this.edge.valid && this.edge.to && this.edge.to !== this.placed) {
          this.pruneDedupable(this.edge.to, false);
        }
        for (const node of target.root.inventory.query("name", this.name)) {
          if (node.isDescendantOf(target) && !node.isTop) {
            this.pruneDedupable(node, false);
            if (node.root === target.root) {
              for (const kid of node.children.values()) {
                this.pruneDedupable(kid, false);
              }
            }
          }
        }
        for (const peerEdge of this.placed.edgesOut.values()) {
          if (peerEdge.valid || !peerEdge.peer || peerEdge.peerConflicted) {
            continue;
          }
          const peer = virtualRoot.children.get(peerEdge.name);
          if (!peer) {
            continue;
          }
          if (!peer.satisfies(peerEdge)) {
            continue;
          }
          this.children.push(new _PlaceDep({
            auditReport: this.auditReport,
            explicitRequest: this.explicitRequest,
            force: this.force,
            installLinks: this.installLinks,
            installStrategy: this.installStrategy,
            legacyPeerDeps: this.legaycPeerDeps,
            preferDedupe: this.preferDedupe,
            strictPeerDeps: this.strictPeerDeps,
            updateNames: this.updateName,
            parent: this,
            dep: peer,
            node: this.placed,
            edge: peerEdge
          }));
        }
      }
      replaceOldDep() {
        const target = this.oldDep.parent;
        const oldDeps = [];
        for (const [name, edge] of this.oldDep.edgesOut.entries()) {
          if (!this.placed.edgesOut.has(name) && edge.to) {
            oldDeps.push(...gatherDepSet([edge.to], (e) => e.to !== edge.to));
          }
        }
        const prunePeerSets = [];
        for (const edge of this.oldDep.edgesIn) {
          if (this.placed.satisfies(edge) || !edge.peer || edge.from.parent !== target || edge.peerConflicted) {
            continue;
          }
          for (const entryEdge of peerEntrySets(edge.from).keys()) {
            const entryNode = entryEdge.to;
            const deepestTarget = deepestNestingTarget(entryNode);
            if (deepestTarget !== target && !(entryEdge.from.isProjectRoot || entryEdge.from.isWorkspace)) {
              prunePeerSets.push(...gatherDepSet([entryNode], (e) => {
                return e.to !== entryNode && !e.peerConflicted;
              }));
            } else {
              this.warnPeerConflict(edge, this.dep);
            }
          }
        }
        this.placed.replace(this.oldDep);
        this.pruneForReplacement(this.placed, oldDeps);
        for (const dep of prunePeerSets) {
          for (const edge of dep.edgesIn) {
            this.needEvaluation.add(edge.from);
          }
          dep.root = null;
        }
      }
      pruneForReplacement(node, oldDeps) {
        const invalidDeps = new Set([...node.edgesOut.values()].filter((e) => e.to && !e.valid).map((e) => e.to));
        for (const dep of oldDeps) {
          const set = gatherDepSet([dep], (e) => e.to !== dep && e.valid);
          for (const dep2 of set) {
            invalidDeps.add(dep2);
          }
        }
        const deps = gatherDepSet(invalidDeps, (edge) => edge.from !== node && edge.to !== node && edge.valid);
        for (const dep of deps) {
          dep.root = null;
        }
      }
      // prune all the nodes in a branch of the tree that can be safely removed
      // This is only the most basic duplication detection; it finds if there
      // is another satisfying node further up the tree, and if so, dedupes.
      // Even in installStategy is nested, we do this amount of deduplication.
      pruneDedupable(node, descend = true) {
        if (node.canDedupe(this.preferDedupe, this.explicitRequest)) {
          const deps = gatherDepSet([node], (e) => e.to !== node && e.valid);
          for (const node2 of deps) {
            node2.root = null;
          }
          return;
        }
        if (descend) {
          const nodeSort = (a, b) => localeCompare(a.location, b.location);
          const children = [...node.children.values()].sort(nodeSort);
          for (const child of children) {
            this.pruneDedupable(child);
          }
          const fsChildren = [...node.fsChildren].sort(nodeSort);
          for (const topNode of fsChildren) {
            const children2 = [...topNode.children.values()].sort(nodeSort);
            for (const child of children2) {
              this.pruneDedupable(child);
            }
          }
        }
      }
      get isMine() {
        const { edge } = this.top;
        const { from: node } = edge;
        if (node.isWorkspace || node.isProjectRoot) {
          return true;
        }
        if (!edge.peer) {
          return false;
        }
        let hasPeerEdges = false;
        for (const edge2 of node.edgesIn) {
          if (edge2.peer) {
            hasPeerEdges = true;
            continue;
          }
          if (edge2.from.isWorkspace || edge2.from.isProjectRoot) {
            return true;
          }
        }
        if (hasPeerEdges) {
          for (const edge2 of peerEntrySets(node).keys()) {
            if (edge2.from.isWorkspace || edge2.from.isProjectRoot) {
              return true;
            }
          }
        }
        return false;
      }
      warnPeerConflict(edge, dep) {
        edge = edge || this.edge;
        dep = dep || this.dep;
        edge.peerConflicted = true;
        const expl = this.explainPeerConflict(edge, dep);
        log.warn("ERESOLVE", "overriding peer dependency", expl);
      }
      failPeerConflict(edge, dep) {
        edge = edge || this.top.edge;
        dep = dep || this.top.dep;
        const expl = this.explainPeerConflict(edge, dep);
        throw Object.assign(new Error("could not resolve"), expl);
      }
      explainPeerConflict(edge, dep) {
        const { from: node } = edge;
        const curNode = node.resolve(edge.name);
        const expl = {
          code: "ERESOLVE",
          edge: edge.explain(),
          dep: dep.explain(edge),
          force: this.force,
          isMine: this.isMine,
          strictPeerDeps: this.strictPeerDeps
        };
        if (this.parent) {
          expl.current = curNode && curNode.explain(edge);
          expl.peerConflict = this.current && this.current.explain(this.edge);
        } else {
          expl.current = curNode && curNode.explain();
          if (this.canPlaceSelf && this.canPlaceSelf.canPlaceSelf !== CONFLICT) {
            const cps = this.canPlaceSelf;
            for (const peer of cps.conflictChildren) {
              if (peer.current) {
                expl.peerConflict = {
                  current: peer.current.explain(),
                  peer: peer.dep.explain(peer.edge)
                };
                break;
              }
            }
          } else {
            expl.peerConflict = {
              current: this.current && this.current.explain(),
              peer: this.dep.explain(this.edge)
            };
          }
        }
        return expl;
      }
      getStartNode() {
        const from = this.parent?.getStartNode() || this.edge.from;
        return deepestNestingTarget(from, this.name);
      }
      // XXX this only appears to be used by tests
      get allChildren() {
        const set = new Set(this.children);
        for (const child of set) {
          for (const grandchild of child.children) {
            set.add(grandchild);
          }
        }
        return [...set];
      }
    };
    module2.exports = PlaceDep;
  }
});

// node_modules/@npmcli/arborist/lib/calc-dep-flags.js
var require_calc_dep_flags = __commonJS({
  "node_modules/@npmcli/arborist/lib/calc-dep-flags.js"(exports2, module2) {
    var { depth } = require_lib();
    var calcDepFlags = (tree, resetRoot = true) => {
      if (resetRoot) {
        tree.dev = false;
        tree.optional = false;
        tree.devOptional = false;
        tree.peer = false;
      }
      const ret = depth({
        tree,
        visit: (node) => calcDepFlagsStep(node),
        filter: (node) => node,
        getChildren: (node, tree2) => [...tree2.edgesOut.values()].map((edge) => edge.to)
      });
      return ret;
    };
    var calcDepFlagsStep = (node) => {
      node.extraneous = false;
      resetParents(node, "extraneous");
      resetParents(node, "dev");
      resetParents(node, "peer");
      resetParents(node, "devOptional");
      resetParents(node, "optional");
      if (node.isLink) {
        if (node.target == null) {
          return node;
        }
        node.target.dev = node.dev;
        node.target.optional = node.optional;
        node.target.devOptional = node.devOptional;
        node.target.peer = node.peer;
        return calcDepFlagsStep(node.target);
      }
      node.edgesOut.forEach(({ peer, optional, dev, to }) => {
        if (!to) {
          return;
        }
        to.extraneous = false;
        const unsetDevOpt = !node.devOptional && !node.dev && !node.optional && !dev && !optional;
        const unsetDev = unsetDevOpt || !node.dev && !dev;
        const unsetOpt = unsetDevOpt || !node.optional && !optional;
        const unsetPeer = !node.peer && !peer;
        if (unsetPeer) {
          unsetFlag(to, "peer");
        }
        if (unsetDevOpt) {
          unsetFlag(to, "devOptional");
        }
        if (unsetDev) {
          unsetFlag(to, "dev");
        }
        if (unsetOpt) {
          unsetFlag(to, "optional");
        }
      });
      return node;
    };
    var resetParents = (node, flag) => {
      if (node[flag]) {
        return;
      }
      for (let p = node; p && (p === node || p[flag]); p = p.resolveParent) {
        p[flag] = false;
      }
    };
    var unsetFlag = (node, flag) => {
      if (node[flag]) {
        node[flag] = false;
        depth({
          tree: node,
          visit: (node2) => {
            node2.extraneous = node2[flag] = false;
            if (node2.isLink && node2.target) {
              node2.target.extraneous = node2.target[flag] = false;
            }
          },
          getChildren: (node2) => {
            const children = [];
            const targetNode = node2.isLink && node2.target ? node2.target : node2;
            for (const edge of targetNode.edgesOut.values()) {
              if (edge.to && edge.to[flag] && (flag !== "peer" && edge.type === "peer" || edge.type === "prod")) {
                children.push(edge.to);
              }
            }
            return children;
          }
        });
      }
    };
    module2.exports = calcDepFlags;
  }
});

// node_modules/@npmcli/arborist/lib/yarn-lock.js
var require_yarn_lock = __commonJS({
  "node_modules/@npmcli/arborist/lib/yarn-lock.js"(exports2, module2) {
    var localeCompare = require_string_locale_compare()("en");
    var consistentResolve = require_consistent_resolve();
    var { dirname } = require("node:path");
    var { breadth } = require_lib();
    var yarnEntryPriorities = {
      name: 1,
      version: 2,
      uid: 3,
      resolved: 4,
      integrity: 5,
      registry: 6,
      dependencies: 7
    };
    var priorityThenLocaleCompare = (a, b) => {
      if (!yarnEntryPriorities[a] && !yarnEntryPriorities[b]) {
        return localeCompare(a, b);
      }
      return (yarnEntryPriorities[a] || 100) > (yarnEntryPriorities[b] || 100) ? 1 : -1;
    };
    var quoteIfNeeded = (val) => {
      if (typeof val === "boolean" || typeof val === "number" || val.startsWith("true") || val.startsWith("false") || /[:\s\n\\",[\]]/g.test(val) || !/^[a-zA-Z]/g.test(val)) {
        return JSON.stringify(val);
      }
      return val;
    };
    var sortKV = (obj) => Object.keys(obj).sort(localeCompare).map((k) => `    ${quoteIfNeeded(k)} ${quoteIfNeeded(obj[k])}`).join("\n");
    var match = (p, n) => p.integrity && n.integrity ? p.integrity === n.integrity : p.resolved && n.resolved ? p.resolved === n.resolved : p.version && n.version ? p.version === n.version : true;
    var prefix = `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1


`;
    var nullSymbol = Symbol("null");
    var YarnLock = class _YarnLock {
      static parse(data) {
        return new _YarnLock().parse(data);
      }
      static fromTree(tree) {
        return new _YarnLock().fromTree(tree);
      }
      constructor() {
        this.entries = null;
        this.endCurrent();
      }
      endCurrent() {
        this.current = null;
        this.subkey = nullSymbol;
      }
      parse(data) {
        const ENTRY_START = /^[^\s].*:$/;
        const SUBKEY = /^ {2}[^\s]+:$/;
        const SUBVAL = /^ {4}[^\s]+ .+$/;
        const METADATA = /^ {2}[^\s]+ .+$/;
        this.entries = /* @__PURE__ */ new Map();
        this.current = null;
        const linere = /([^\r\n]*)\r?\n/gm;
        let match2;
        let lineNum = 0;
        if (!/\n$/.test(data)) {
          data += "\n";
        }
        while (match2 = linere.exec(data)) {
          const line = match2[1];
          lineNum++;
          if (line.charAt(0) === "#") {
            continue;
          }
          if (line === "") {
            this.endCurrent();
            continue;
          }
          if (ENTRY_START.test(line)) {
            this.endCurrent();
            const specs = this.splitQuoted(line.slice(0, -1), /, */);
            this.current = new YarnLockEntry(specs);
            specs.forEach((spec) => this.entries.set(spec, this.current));
            continue;
          }
          if (SUBKEY.test(line)) {
            this.subkey = line.slice(2, -1);
            this.current[this.subkey] = {};
            continue;
          }
          if (SUBVAL.test(line) && this.current && this.current[this.subkey]) {
            const subval = this.splitQuoted(line.trimLeft(), " ");
            if (subval.length === 2) {
              this.current[this.subkey][subval[0]] = subval[1];
              continue;
            }
          }
          if (METADATA.test(line) && this.current) {
            const metadata = this.splitQuoted(line.trimLeft(), " ");
            if (metadata.length === 2) {
              if (metadata[0] === "resolved") {
                metadata[1] = metadata[1].replace(/#.*/, "");
              }
              this.current[metadata[0]] = metadata[1];
              continue;
            }
          }
          throw Object.assign(new Error("invalid or corrupted yarn.lock file"), {
            position: match2.index,
            content: match2[0],
            line: lineNum
          });
        }
        this.endCurrent();
        return this;
      }
      splitQuoted(str, delim) {
        const split = str.split(delim);
        const out = [];
        let o = 0;
        for (let i = 0; i < split.length; i++) {
          const chunk = split[i];
          if (/^".*"$/.test(chunk)) {
            out[o++] = chunk.trim().slice(1, -1);
          } else if (/^"/.test(chunk)) {
            let collect = chunk.trimLeft().slice(1);
            while (++i < split.length) {
              const n = split[i];
              if (/[^\\](\\\\)*"$/.test(n)) {
                collect += n.trimRight().slice(0, -1);
                break;
              } else {
                collect += n;
              }
            }
            out[o++] = collect;
          } else {
            out[o++] = chunk.trim();
          }
        }
        return out;
      }
      toString() {
        return prefix + [.../* @__PURE__ */ new Set([...this.entries.values()])].map((e) => e.toString()).sort((a, b) => localeCompare(a.replace(/"/g, ""), b.replace(/"/g, ""))).join("\n\n") + "\n";
      }
      fromTree(tree) {
        this.entries = /* @__PURE__ */ new Map();
        breadth({
          tree,
          visit: (node) => this.addEntryFromNode(node),
          getChildren: (node) => [...node.children.values(), ...node.fsChildren].sort((a, b) => a.depth - b.depth || localeCompare(a.name, b.name))
        });
        return this;
      }
      addEntryFromNode(node) {
        const specs = [...node.edgesIn].map((e) => `${node.name}@${e.spec}`).sort(localeCompare);
        const n = this.entryDataFromNode(node);
        let priorEntry = null;
        const newSpecs = [];
        for (const s of specs) {
          const prev = this.entries.get(s);
          if (!prev) {
            if (priorEntry) {
              priorEntry.addSpec(s);
            } else {
              newSpecs.push(s);
            }
            continue;
          }
          const m = match(prev, n);
          if (!m) {
            continue;
          }
          if (!priorEntry) {
            priorEntry = prev;
            for (const s2 of newSpecs) {
              priorEntry.addSpec(s2);
              this.entries.set(s2, priorEntry);
            }
            newSpecs.length = 0;
            continue;
          }
          priorEntry.addSpec(s);
          this.entries.set(s, priorEntry);
        }
        if (!priorEntry) {
          const entry = Object.assign(new YarnLockEntry(newSpecs), n);
          for (const s of newSpecs) {
            this.entries.set(s, entry);
          }
        } else {
          Object.assign(priorEntry, n);
        }
      }
      entryDataFromNode(node) {
        const n = {};
        if (node.package.dependencies) {
          n.dependencies = node.package.dependencies;
        }
        if (node.package.optionalDependencies) {
          n.optionalDependencies = node.package.optionalDependencies;
        }
        if (node.version) {
          n.version = node.version;
        }
        if (node.resolved) {
          n.resolved = consistentResolve(
            node.resolved,
            node.isLink ? dirname(node.path) : node.path,
            node.root.path,
            true
          );
        }
        if (node.integrity) {
          n.integrity = node.integrity;
        }
        return n;
      }
      static get Entry() {
        return YarnLockEntry;
      }
    };
    var YarnLockEntry = class {
      #specs;
      constructor(specs) {
        this.#specs = new Set(specs);
        this.resolved = null;
        this.version = null;
        this.integrity = null;
        this.dependencies = null;
        this.optionalDependencies = null;
      }
      toString() {
        return ([...this.#specs].sort(localeCompare).map(quoteIfNeeded).join(", ") + ":\n" + Object.getOwnPropertyNames(this).filter((prop) => this[prop] !== null).sort(priorityThenLocaleCompare).map((prop) => typeof this[prop] !== "object" ? `  ${prop} ${prop === "integrity" ? this[prop] : JSON.stringify(this[prop])}
` : Object.keys(this[prop]).length === 0 ? "" : `  ${prop}:
` + sortKV(this[prop]) + "\n").join("")).trim();
      }
      addSpec(spec) {
        this.#specs.add(spec);
      }
    };
    module2.exports = YarnLock;
  }
});

// node_modules/@npmcli/arborist/lib/spec-from-lock.js
var require_spec_from_lock = __commonJS({
  "node_modules/@npmcli/arborist/lib/spec-from-lock.js"(exports2, module2) {
    var npa = require_npa();
    var specFromLock = (name, lock, where) => {
      try {
        if (lock.version) {
          const spec = npa.resolve(name, lock.version, where);
          if (lock.integrity || spec.type === "git") {
            return spec;
          }
        }
        if (lock.from) {
          const spec = npa.resolve(name, lock.from, where);
          if (spec.registry && lock.version) {
            return npa.resolve(name, lock.version, where);
          } else if (!lock.resolved) {
            return spec;
          }
        }
        if (lock.resolved) {
          return npa.resolve(name, lock.resolved, where);
        }
      } catch {
      }
      try {
        return npa.resolve(name, lock.version, where);
      } catch {
        return {};
      }
    };
    module2.exports = specFromLock;
  }
});

// node_modules/@npmcli/arborist/lib/version-from-tgz.js
var require_version_from_tgz = __commonJS({
  "node_modules/@npmcli/arborist/lib/version-from-tgz.js"(exports2, module2) {
    var semver = require_semver2();
    var { basename } = require("node:path");
    var { URL: URL2 } = require("node:url");
    module2.exports = (name, tgz) => {
      const base = basename(tgz);
      if (!base.endsWith(".tgz")) {
        return null;
      }
      if (tgz.startsWith("http:/") || tgz.startsWith("https:/")) {
        const u = new URL2(tgz);
        const tfsplit = u.pathname.slice(1).split("/-/");
        if (tfsplit.length > 1) {
          const afterTF = tfsplit.pop();
          if (afterTF === base) {
            const pre = tfsplit.pop();
            const preSplit = pre.split(/\/|%2f/i);
            const project2 = preSplit.pop();
            const scope2 = preSplit.pop();
            return versionFromBaseScopeName(base, scope2, project2);
          }
        }
      }
      const split = name.split(/\/|%2f/i);
      const project = split.pop();
      const scope = split.pop();
      return versionFromBaseScopeName(base, scope, project);
    };
    var versionFromBaseScopeName = (base, scope, name) => {
      if (!base.startsWith(name + "-")) {
        return null;
      }
      const parsed = semver.parse(base.substring(name.length + 1, base.length - 4));
      return parsed ? {
        name: scope && scope.charAt(0) === "@" ? `${scope}/${name}` : name,
        version: parsed.version
      } : null;
    };
  }
});

// node_modules/just-diff/index.cjs
var require_just_diff = __commonJS({
  "node_modules/just-diff/index.cjs"(exports2, module2) {
    module2.exports = {
      diff,
      jsonPatchPathConverter
    };
    function diff(obj1, obj2, pathConverter) {
      if (!obj1 || typeof obj1 != "object" || !obj2 || typeof obj2 != "object") {
        throw new Error("both arguments must be objects or arrays");
      }
      pathConverter || (pathConverter = function(arr) {
        return arr;
      });
      function getDiff({ obj1: obj12, obj2: obj22, basePath, basePathForRemoves, diffs: diffs2 }) {
        var obj1Keys = Object.keys(obj12);
        var obj1KeysLength = obj1Keys.length;
        var obj2Keys = Object.keys(obj22);
        var obj2KeysLength = obj2Keys.length;
        var path;
        var lengthDelta = obj12.length - obj22.length;
        if (trimFromRight(obj12, obj22)) {
          for (var i = 0; i < obj1KeysLength; i++) {
            var key = Array.isArray(obj12) ? Number(obj1Keys[i]) : obj1Keys[i];
            if (!(key in obj22)) {
              path = basePathForRemoves.concat(key);
              diffs2.remove.push({
                op: "remove",
                path: pathConverter(path)
              });
            }
          }
          for (var i = 0; i < obj2KeysLength; i++) {
            var key = Array.isArray(obj22) ? Number(obj2Keys[i]) : obj2Keys[i];
            pushReplaces({
              key,
              obj1: obj12,
              obj2: obj22,
              path: basePath.concat(key),
              pathForRemoves: basePath.concat(key),
              diffs: diffs2
            });
          }
        } else {
          for (var i = 0; i < lengthDelta; i++) {
            path = basePathForRemoves.concat(i);
            diffs2.remove.push({
              op: "remove",
              path: pathConverter(path)
            });
          }
          var obj1Trimmed = obj12.slice(lengthDelta);
          ;
          for (var i = 0; i < obj2KeysLength; i++) {
            pushReplaces({
              key: i,
              obj1: obj1Trimmed,
              obj2: obj22,
              path: basePath.concat(i),
              // since list of removes are reversed before presenting result,
              // we need to ignore existing parent removes when doing nested removes
              pathForRemoves: basePath.concat(i + lengthDelta),
              diffs: diffs2
            });
          }
        }
      }
      var diffs = { remove: [], replace: [], add: [] };
      getDiff({
        obj1,
        obj2,
        basePath: [],
        basePathForRemoves: [],
        diffs
      });
      return diffs.remove.reverse().concat(diffs.replace).concat(diffs.add);
      function pushReplaces({ key, obj1: obj12, obj2: obj22, path, pathForRemoves, diffs: diffs2 }) {
        var obj1AtKey = obj12[key];
        var obj2AtKey = obj22[key];
        if (!(key in obj12) && key in obj22) {
          var obj2Value = obj2AtKey;
          diffs2.add.push({
            op: "add",
            path: pathConverter(path),
            value: obj2Value
          });
        } else if (obj1AtKey !== obj2AtKey) {
          if (Object(obj1AtKey) !== obj1AtKey || Object(obj2AtKey) !== obj2AtKey || differentTypes(obj1AtKey, obj2AtKey)) {
            pushReplace(path, diffs2, obj2AtKey);
          } else {
            if (!Object.keys(obj1AtKey).length && !Object.keys(obj2AtKey).length && String(obj1AtKey) != String(obj2AtKey)) {
              pushReplace(path, diffs2, obj2AtKey);
            } else {
              getDiff({
                obj1: obj12[key],
                obj2: obj22[key],
                basePath: path,
                basePathForRemoves: pathForRemoves,
                diffs: diffs2
              });
            }
          }
        }
      }
      function pushReplace(path, diffs2, newValue) {
        diffs2.replace.push({
          op: "replace",
          path: pathConverter(path),
          value: newValue
        });
      }
    }
    function jsonPatchPathConverter(arrayPath) {
      return [""].concat(arrayPath).join("/");
    }
    function differentTypes(a, b) {
      return Object.prototype.toString.call(a) != Object.prototype.toString.call(b);
    }
    function trimFromRight(obj1, obj2) {
      var lengthDelta = obj1.length - obj2.length;
      if (Array.isArray(obj1) && Array.isArray(obj2) && lengthDelta > 0) {
        var leftMatches = 0;
        var rightMatches = 0;
        for (var i = 0; i < obj2.length; i++) {
          if (String(obj1[i]) === String(obj2[i])) {
            leftMatches++;
          } else {
            break;
          }
        }
        for (var j = obj2.length; j > 0; j--) {
          if (String(obj1[j + lengthDelta]) === String(obj2[j])) {
            rightMatches++;
          } else {
            break;
          }
        }
        return leftMatches >= rightMatches;
      }
      return true;
    }
  }
});

// node_modules/just-diff-apply/index.cjs
var require_just_diff_apply = __commonJS({
  "node_modules/just-diff-apply/index.cjs"(exports2, module2) {
    module2.exports = {
      diffApply,
      jsonPatchPathConverter
    };
    var REMOVE = "remove";
    var REPLACE = "replace";
    var ADD = "add";
    var MOVE = "move";
    function diffApply(obj, diff, pathConverter) {
      if (!obj || typeof obj != "object") {
        throw new Error("base object must be an object or an array");
      }
      if (!Array.isArray(diff)) {
        throw new Error("diff must be an array");
      }
      var diffLength = diff.length;
      for (var i = 0; i < diffLength; i++) {
        var thisDiff = diff[i];
        var subObject = obj;
        var thisOp = thisDiff.op;
        var thisPath = transformPath(pathConverter, thisDiff.path);
        var thisFromPath = thisDiff.from && transformPath(pathConverter, thisDiff.from);
        var toPath, toPathCopy, lastToProp, subToObject, valueToMove;
        if (thisFromPath) {
          toPath = thisPath;
          thisPath = thisFromPath;
          toPathCopy = toPath.slice();
          lastToProp = toPathCopy.pop();
          prototypeCheck(lastToProp);
          if (lastToProp == null) {
            return false;
          }
          var thisToProp;
          while ((thisToProp = toPathCopy.shift()) != null) {
            prototypeCheck(thisToProp);
            if (!(thisToProp in subToObject)) {
              subToObject[thisToProp] = {};
            }
            subToObject = subToObject[thisToProp];
          }
        }
        var pathCopy = thisPath.slice();
        var lastProp = pathCopy.pop();
        prototypeCheck(lastProp);
        if (lastProp == null) {
          return false;
        }
        var thisProp;
        while ((thisProp = pathCopy.shift()) != null) {
          prototypeCheck(thisProp);
          if (!(thisProp in subObject)) {
            subObject[thisProp] = {};
          }
          subObject = subObject[thisProp];
        }
        if (thisOp === REMOVE || thisOp === REPLACE || thisOp === MOVE) {
          var path = thisOp === MOVE ? thisDiff.from : thisDiff.path;
          if (!subObject.hasOwnProperty(lastProp)) {
            throw new Error(["expected to find property", path, "in object", obj].join(" "));
          }
        }
        if (thisOp === REMOVE || thisOp === MOVE) {
          if (thisOp === MOVE) {
            valueToMove = subObject[lastProp];
          }
          Array.isArray(subObject) ? subObject.splice(lastProp, 1) : delete subObject[lastProp];
        }
        if (thisOp === REPLACE || thisOp === ADD) {
          subObject[lastProp] = thisDiff.value;
        }
        if (thisOp === MOVE) {
          subObject[lastToProp] = valueToMove;
        }
      }
      return subObject;
    }
    function transformPath(pathConverter, thisPath) {
      if (pathConverter) {
        thisPath = pathConverter(thisPath);
        if (!Array.isArray(thisPath)) {
          throw new Error([
            "pathConverter must return an array, returned:",
            thisPath
          ].join(" "));
        }
      } else {
        if (!Array.isArray(thisPath)) {
          throw new Error([
            "diff path",
            thisPath,
            "must be an array, consider supplying a path converter"
          ].join(" "));
        }
      }
      return thisPath;
    }
    function jsonPatchPathConverter(stringPath) {
      return stringPath.split("/").slice(1);
    }
    function prototypeCheck(prop) {
      if (prop == "__proto__" || prop == "constructor" || prop == "prototype") {
        throw new Error("setting of prototype values not supported");
      }
    }
  }
});

// node_modules/parse-conflict-json/lib/index.js
var require_lib42 = __commonJS({
  "node_modules/parse-conflict-json/lib/index.js"(exports2, module2) {
    var parseJSON = require_lib3();
    var { diff } = require_just_diff();
    var { diffApply } = require_just_diff_apply();
    var globalObjectProperties = Object.getOwnPropertyNames(Object.prototype);
    var stripBOM = (content) => {
      content = content.toString();
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var PARENT_RE = /\|{7,}/g;
    var OURS_RE = /<{7,}/g;
    var THEIRS_RE = /={7,}/g;
    var END_RE = />{7,}/g;
    var isDiff = (str) => str.match(OURS_RE) && str.match(THEIRS_RE) && str.match(END_RE);
    var parseConflictJSON = (str, reviver, prefer) => {
      prefer = prefer || "ours";
      if (prefer !== "theirs" && prefer !== "ours") {
        throw new TypeError('prefer param must be "ours" or "theirs" if set');
      }
      str = stripBOM(str);
      if (!isDiff(str)) {
        return parseJSON(str);
      }
      const pieces = str.split(/[\n\r]+/g).reduce((acc, line) => {
        if (line.match(PARENT_RE)) {
          acc.state = "parent";
        } else if (line.match(OURS_RE)) {
          acc.state = "ours";
        } else if (line.match(THEIRS_RE)) {
          acc.state = "theirs";
        } else if (line.match(END_RE)) {
          acc.state = "top";
        } else {
          if (acc.state === "top" || acc.state === "ours") {
            acc.ours += line;
          }
          if (acc.state === "top" || acc.state === "theirs") {
            acc.theirs += line;
          }
          if (acc.state === "top" || acc.state === "parent") {
            acc.parent += line;
          }
        }
        return acc;
      }, {
        state: "top",
        ours: "",
        theirs: "",
        parent: ""
      });
      const parent = parseJSON(pieces.parent, reviver);
      const ours = parseJSON(pieces.ours, reviver);
      const theirs = parseJSON(pieces.theirs, reviver);
      return prefer === "ours" ? resolve(parent, ours, theirs) : resolve(parent, theirs, ours);
    };
    var isObj = (obj) => obj && typeof obj === "object";
    var copyPath = (to, from, path, i) => {
      const p = path[i];
      if (isObj(to[p]) && isObj(from[p]) && Array.isArray(to[p]) === Array.isArray(from[p])) {
        return copyPath(to[p], from[p], path, i + 1);
      }
      to[p] = from[p];
    };
    var resolve = (parent, ours, theirs) => {
      const dours = diff(parent, ours);
      for (let i = 0; i < dours.length; i++) {
        if (globalObjectProperties.find((prop) => dours[i].path.includes(prop))) {
          continue;
        }
        try {
          diffApply(theirs, [dours[i]]);
        } catch (e) {
          copyPath(theirs, ours, dours[i].path, 0);
        }
      }
      return theirs;
    };
    module2.exports = Object.assign(parseConflictJSON, { isDiff });
  }
});

// node_modules/json-stringify-nice/index.js
var require_json_stringify_nice = __commonJS({
  "node_modules/json-stringify-nice/index.js"(exports2, module2) {
    var isObj = (val) => !!val && !Array.isArray(val) && typeof val === "object";
    var compare = (ak, bk, prefKeys) => prefKeys.includes(ak) && !prefKeys.includes(bk) ? -1 : prefKeys.includes(bk) && !prefKeys.includes(ak) ? 1 : prefKeys.includes(ak) && prefKeys.includes(bk) ? prefKeys.indexOf(ak) - prefKeys.indexOf(bk) : ak.localeCompare(bk, "en");
    var sort = (replacer, seen) => (key, val) => {
      const prefKeys = Array.isArray(replacer) ? replacer : [];
      if (typeof replacer === "function")
        val = replacer(key, val);
      if (!isObj(val))
        return val;
      if (seen.has(val))
        return seen.get(val);
      const ret = Object.entries(val).sort(
        ([ak, av], [bk, bv]) => isObj(av) === isObj(bv) ? compare(ak, bk, prefKeys) : isObj(av) ? 1 : -1
      ).reduce((set, [k, v]) => {
        set[k] = v;
        return set;
      }, {});
      seen.set(val, ret);
      return ret;
    };
    module2.exports = (obj, replacer, space = 2) => JSON.stringify(obj, sort(replacer, /* @__PURE__ */ new Map()), space) + (space ? "\n" : "");
  }
});

// node_modules/@npmcli/arborist/lib/override-resolves.js
var require_override_resolves = __commonJS({
  "node_modules/@npmcli/arborist/lib/override-resolves.js"(exports2, module2) {
    function overrideResolves(resolved, opts) {
      const { omitLockfileRegistryResolved = false } = opts;
      if (omitLockfileRegistryResolved) {
        return void 0;
      }
      return resolved;
    }
    module2.exports = { overrideResolves };
  }
});

// node_modules/@npmcli/arborist/lib/shrinkwrap.js
var require_shrinkwrap = __commonJS({
  "node_modules/@npmcli/arborist/lib/shrinkwrap.js"(exports2, module2) {
    var localeCompare = require_string_locale_compare()("en");
    var defaultLockfileVersion = 3;
    var mismatch = (a, b) => a && b && a !== b;
    var { log } = require_lib4();
    var YarnLock = require_yarn_lock();
    var {
      readFile,
      readdir,
      readlink,
      rm,
      stat,
      writeFile
    } = require("node:fs/promises");
    var { resolve, basename, relative } = require("node:path");
    var specFromLock = require_spec_from_lock();
    var versionFromTgz = require_version_from_tgz();
    var npa = require_npa();
    var pkgJson = require_lib13();
    var parseJSON = require_lib42();
    var nameFromFolder = require_lib2();
    var stringify = require_json_stringify_nice();
    var swKeyOrder = [
      "name",
      "version",
      "lockfileVersion",
      "resolved",
      "integrity",
      "requires",
      "packages",
      "dependencies"
    ];
    var yarnRegRe = /^https?:\/\/registry\.yarnpkg\.com\//;
    var npmRegRe = /^https?:\/\/registry\.npmjs\.org\//;
    var specFromResolved = (resolved) => {
      try {
        return npa(resolved);
      } catch (er) {
        return {};
      }
    };
    var relpath = require_relpath();
    var consistentResolve = require_consistent_resolve();
    var { overrideResolves } = require_override_resolves();
    var pkgMetaKeys = [
      // note: name is included if necessary, for alias packages
      "version",
      "dependencies",
      "peerDependencies",
      "peerDependenciesMeta",
      "optionalDependencies",
      "bundleDependencies",
      "acceptDependencies",
      "funding",
      "engines",
      "os",
      "cpu",
      "_integrity",
      "license",
      "_hasShrinkwrap",
      "hasInstallScript",
      "bin",
      "deprecated",
      "workspaces"
    ];
    var nodeMetaKeys = [
      "integrity",
      "inBundle",
      "hasShrinkwrap",
      "hasInstallScript",
      "ideallyInert"
    ];
    var metaFieldFromPkg = (pkg, key) => {
      const val = pkg[key];
      if (val) {
        if (key === "license" && typeof val === "object" && val.type) {
          return val.type;
        }
        if (typeof val !== "object" || Object.keys(val).length) {
          return val;
        }
      }
      return null;
    };
    var assertNoNewer = async (path, data, lockTime, dir, seen) => {
      const base = basename(dir);
      const isNM = dir !== path && base === "node_modules";
      const isScope = dir !== path && base.startsWith("@");
      const isParent = dir === path || isNM || isScope;
      const parent = isParent ? dir : resolve(dir, "node_modules");
      const rel = relpath(path, dir);
      const inert = data.packages[rel]?.ideallyInert;
      if (inert) {
        return;
      }
      seen.add(rel);
      let entries;
      if (dir === path) {
        entries = [{ name: "node_modules", isDirectory: () => true }];
      } else {
        const { mtime: dirTime } = await stat(dir);
        if (dirTime > lockTime) {
          throw new Error(`out of date, updated: ${rel}`);
        }
        if (!isScope && !isNM && !data.packages[rel]) {
          throw new Error(`missing from lockfile: ${rel}`);
        }
        entries = await readdir(parent, { withFileTypes: true }).catch(() => []);
      }
      await Promise.all(entries.map(async (dirent) => {
        const child = resolve(parent, dirent.name);
        if (dirent.isDirectory() && !dirent.name.startsWith(".")) {
          await assertNoNewer(path, data, lockTime, child, seen);
        } else if (dirent.isSymbolicLink()) {
          const target = resolve(parent, await readlink(child));
          const tstat = await stat(target).catch(
            /* istanbul ignore next - windows */
            () => null
          );
          seen.add(relpath(path, child));
          if (tstat?.isDirectory() && !seen.has(relpath(path, target))) {
            await assertNoNewer(path, data, lockTime, target, seen);
          }
        }
      }));
      if (dir !== path) {
        return;
      }
      for (const loc in data.packages) {
        if (!seen.has(loc) && !data.packages[loc].ideallyInert) {
          throw new Error(`missing from node_modules: ${loc}`);
        }
      }
    };
    var Shrinkwrap = class _Shrinkwrap {
      static get defaultLockfileVersion() {
        return defaultLockfileVersion;
      }
      static load(options) {
        return new _Shrinkwrap(options).load();
      }
      static get keyOrder() {
        return swKeyOrder;
      }
      static async reset(options) {
        const s = new _Shrinkwrap(options);
        s.reset();
        const [sw, lock] = await s.resetFiles;
        if (s.hiddenLockfile) {
          s.filename = resolve(s.path, "node_modules/.package-lock.json");
        } else if (s.shrinkwrapOnly || sw) {
          s.filename = resolve(s.path, "npm-shrinkwrap.json");
        } else {
          s.filename = resolve(s.path, "package-lock.json");
        }
        s.loadedFromDisk = !!(sw || lock);
        s.type = basename(s.filename);
        return s;
      }
      static metaFromNode(node, path, options = {}) {
        if (node.isLink) {
          return {
            resolved: relpath(path, node.realpath),
            link: true
          };
        }
        const meta = {};
        for (const key of pkgMetaKeys) {
          const val = metaFieldFromPkg(node.package, key);
          if (val) {
            meta[key.replace(/^_/, "")] = val;
          }
        }
        const pname = node.packageName;
        if (pname && (node === node.root || pname !== node.name || nameFromFolder(node.realpath) !== pname)) {
          meta.name = pname;
        }
        if (node.isTop && node.package.devDependencies) {
          meta.devDependencies = node.package.devDependencies;
        }
        for (const key of nodeMetaKeys) {
          if (node[key]) {
            meta[key] = node[key];
          }
        }
        const resolved = consistentResolve(node.resolved, node.path, path, true);
        if (!resolved) {
        } else if (node.isRegistryDependency) {
          meta.resolved = overrideResolves(resolved, options);
        } else {
          meta.resolved = resolved;
        }
        if (node.extraneous) {
          meta.extraneous = true;
        } else {
          if (node.peer) {
            meta.peer = true;
          }
          if (node.dev) {
            meta.dev = true;
          }
          if (node.optional) {
            meta.optional = true;
          }
          if (node.devOptional && !node.dev && !node.optional) {
            meta.devOptional = true;
          }
        }
        return meta;
      }
      #awaitingUpdate = /* @__PURE__ */ new Map();
      constructor(options = {}) {
        const {
          path,
          indent = 2,
          newline = "\n",
          shrinkwrapOnly = false,
          hiddenLockfile = false,
          lockfileVersion,
          resolveOptions = {}
        } = options;
        if (hiddenLockfile) {
          this.lockfileVersion = 3;
        } else if (lockfileVersion) {
          this.lockfileVersion = parseInt(lockfileVersion, 10);
        } else {
          this.lockfileVersion = null;
        }
        this.tree = null;
        this.path = resolve(path || ".");
        this.filename = null;
        this.data = null;
        this.indent = indent;
        this.newline = newline;
        this.loadedFromDisk = false;
        this.type = null;
        this.yarnLock = null;
        this.hiddenLockfile = hiddenLockfile;
        this.loadingError = null;
        this.resolveOptions = resolveOptions;
        this.shrinkwrapOnly = shrinkwrapOnly;
      }
      // check to see if a spec is present in the yarn.lock file, and if so,
      // if we should use it, and what it should resolve to.  This is only
      // done when we did not load a shrinkwrap from disk.  Also, decorate
      // the options object if provided with the resolved and integrity that
      // we expect.
      checkYarnLock(spec, options = {}) {
        spec = npa(spec);
        const { yarnLock, loadedFromDisk } = this;
        const useYarnLock = yarnLock && !loadedFromDisk;
        const fromYarn = useYarnLock && yarnLock.entries.get(spec.raw);
        if (fromYarn && fromYarn.version) {
          const { resolved, version, integrity } = fromYarn;
          const isYarnReg = spec.registry && yarnRegRe.test(resolved);
          const isnpmReg = spec.registry && !isYarnReg && npmRegRe.test(resolved);
          const isReg = isnpmReg || isYarnReg;
          const tgz = isReg && versionFromTgz(spec.name, resolved) || {};
          let yspec = resolved;
          if (tgz.name === spec.name && tgz.version === version) {
            yspec = version;
          } else if (isReg && tgz.name && tgz.version) {
            yspec = `npm:${tgz.name}@${tgz.version}`;
          }
          if (yspec) {
            options.resolved = resolved.replace(yarnRegRe, "https://registry.npmjs.org/");
            options.integrity = integrity;
            return npa(`${spec.name}@${yspec}`);
          }
        }
        return spec;
      }
      // throw away the shrinkwrap data so we can start fresh
      // still worth doing a load() first so we know which files to write.
      reset() {
        this.tree = null;
        this.#awaitingUpdate = /* @__PURE__ */ new Map();
        const lockfileVersion = this.lockfileVersion || defaultLockfileVersion;
        this.originalLockfileVersion = lockfileVersion;
        this.data = {
          lockfileVersion,
          requires: true,
          packages: {},
          dependencies: {}
        };
      }
      // files to potentially read from and write to, in order of priority
      get #filenameSet() {
        if (this.shrinkwrapOnly) {
          return [`${this.path}/npm-shrinkwrap.json`];
        }
        if (this.hiddenLockfile) {
          return [`${this.path}/node_modules/.package-lock.json`];
        }
        return [
          `${this.path}/npm-shrinkwrap.json`,
          `${this.path}/package-lock.json`,
          `${this.path}/yarn.lock`
        ];
      }
      get loadFiles() {
        return Promise.all(
          this.#filenameSet.map((file) => file && readFile(file, "utf8").then((d) => d, (er) => {
            if (er.code === "ENOENT") {
              return "";
            } else {
              throw er;
            }
          }))
        );
      }
      get resetFiles() {
        return Promise.all(
          this.#filenameSet.slice(0, 2).map(
            (file) => file && stat(file).then((st) => st.isFile(), (er) => {
              if (er.code === "ENOENT") {
                return null;
              } else {
                throw er;
              }
            })
          )
        );
      }
      inferFormattingOptions(packageJSONData) {
        const {
          [Symbol.for("indent")]: indent,
          [Symbol.for("newline")]: newline
        } = packageJSONData;
        if (indent !== void 0) {
          this.indent = indent;
        }
        if (newline !== void 0) {
          this.newline = newline;
        }
      }
      async load() {
        let data;
        try {
          const [sw, lock, yarn] = await this.loadFiles;
          data = sw || lock || "{}";
          if (this.hiddenLockfile) {
            this.filename = resolve(this.path, "node_modules/.package-lock.json");
          } else if (this.shrinkwrapOnly || sw) {
            this.filename = resolve(this.path, "npm-shrinkwrap.json");
          } else {
            this.filename = resolve(this.path, "package-lock.json");
          }
          this.type = basename(this.filename);
          this.loadedFromDisk = Boolean(sw || lock);
          if (yarn) {
            this.yarnLock = new YarnLock();
            try {
              this.yarnLock.parse(yarn);
            } catch {
            }
          }
          data = parseJSON(data);
          this.inferFormattingOptions(data);
          if (this.hiddenLockfile && data.packages) {
            const lockTime = +(await stat(this.filename)).mtime + 10;
            await assertNoNewer(this.path, data, lockTime, this.path, /* @__PURE__ */ new Set());
          }
        } catch (er) {
          if (typeof this.filename === "string") {
            const rel = relpath(this.path, this.filename);
            log.verbose("shrinkwrap", `failed to load ${rel}`, er.message);
          } else {
            log.verbose("shrinkwrap", `failed to load ${this.path}`, er.message);
          }
          this.loadingError = er;
          this.loadedFromDisk = false;
          this.ancientLockfile = false;
          data = {};
        }
        let lockfileVersion = defaultLockfileVersion;
        if (this.lockfileVersion) {
          lockfileVersion = this.lockfileVersion;
        } else if (data.lockfileVersion && data.lockfileVersion !== 1) {
          lockfileVersion = data.lockfileVersion;
        }
        this.data = {
          ...data,
          lockfileVersion,
          requires: true,
          packages: data.packages || {},
          dependencies: data.dependencies || {}
        };
        this.originalLockfileVersion = data.lockfileVersion;
        if (!this.lockfileVersion) {
          this.lockfileVersion = this.data.lockfileVersion = lockfileVersion;
        }
        this.ancientLockfile = this.loadedFromDisk && !(data.lockfileVersion >= 2) && !data.requires;
        if (data.dependencies && !data.packages) {
          let pkg;
          try {
            pkg = await pkgJson.normalize(this.path);
            pkg = pkg.content;
          } catch {
            pkg = {};
          }
          this.#loadAll("", null, this.data);
          this.#fixDependencies(pkg);
        }
        return this;
      }
      #loadAll(location, name, lock) {
        const meta = this.#metaFromLock(location, name, lock);
        if (meta.link) {
          location = meta.resolved;
        }
        if (lock.dependencies) {
          for (const name2 in lock.dependencies) {
            const loc = location + (location ? "/" : "") + "node_modules/" + name2;
            this.#loadAll(loc, name2, lock.dependencies[name2]);
          }
        }
      }
      // v1 lockfiles track the optional/dev flags, but they don't tell us
      // which thing had what kind of dep on what other thing, so we need
      // to correct that now, or every link will be considered prod
      #fixDependencies(pkg) {
        const root = this.data.packages[""];
        for (const key of pkgMetaKeys) {
          const val = metaFieldFromPkg(pkg, key);
          if (val) {
            root[key.replace(/^_/, "")] = val;
          }
        }
        for (const loc in this.data.packages) {
          const meta = this.data.packages[loc];
          if (!meta.requires || !loc) {
            continue;
          }
          for (const name in meta.requires) {
            const dep = this.#resolveMetaNode(loc, name);
            let depType = "dependencies";
            if (dep?.optional && !meta.optional) {
              depType = "optionalDependencies";
            } else if (dep?.dev && !meta.dev) {
              depType = "devDependencies";
            }
            if (!meta[depType]) {
              meta[depType] = {};
            }
            meta[depType][name] = meta.requires[name];
          }
          delete meta.requires;
        }
      }
      #resolveMetaNode(loc, name) {
        for (let path = loc; true; path = path.replace(/(^|\/)[^/]*$/, "")) {
          const check = `${path}${path ? "/" : ""}node_modules/${name}`;
          if (this.data.packages[check]) {
            return this.data.packages[check];
          }
          if (!path) {
            break;
          }
        }
        return null;
      }
      #lockFromLoc(lock, path, i = 0) {
        if (!lock) {
          return null;
        }
        if (path[i] === "") {
          i++;
        }
        if (i >= path.length) {
          return lock;
        }
        if (!lock.dependencies) {
          return null;
        }
        return this.#lockFromLoc(lock.dependencies[path[i]], path, i + 1);
      }
      // pass in a path relative to the root path, or an absolute path,
      // get back a /-normalized location based on root path.
      #pathToLoc(path) {
        return relpath(this.path, resolve(this.path, path));
      }
      delete(nodePath) {
        if (!this.data) {
          throw new Error("run load() before getting or setting data");
        }
        const location = this.#pathToLoc(nodePath);
        this.#awaitingUpdate.delete(location);
        delete this.data.packages[location];
        const path = location.split(/(?:^|\/)node_modules\//);
        const name = path.pop();
        const pLock = this.#lockFromLoc(this.data, path);
        if (pLock && pLock.dependencies) {
          delete pLock.dependencies[name];
        }
      }
      get(nodePath) {
        if (!this.data) {
          throw new Error("run load() before getting or setting data");
        }
        const location = this.#pathToLoc(nodePath);
        if (this.#awaitingUpdate.has(location)) {
          this.#updateWaitingNode(location);
        }
        if (this.data.packages[location]) {
          return this.data.packages[location];
        }
        const path = location.split(/(?:^|\/)node_modules\//);
        const name = path[path.length - 1];
        const lock = this.#lockFromLoc(this.data, path);
        return this.#metaFromLock(location, name, lock);
      }
      #metaFromLock(location, name, lock) {
        if (!lock) {
          return {};
        }
        const spec = specFromLock(name, lock, this.path);
        if (spec.type === "directory") {
          const target = relpath(this.path, spec.fetchSpec);
          this.data.packages[location] = {
            link: true,
            resolved: target
          };
          if (!this.data.packages[target]) {
            this.#metaFromLock(target, name, { ...lock, version: null });
          }
          return this.data.packages[location];
        }
        const meta = {};
        if (lock.requires && typeof lock.requires === "object") {
          meta.requires = lock.requires;
        }
        if (lock.optional) {
          meta.optional = true;
        }
        if (lock.dev) {
          meta.dev = true;
        }
        if (location === "") {
          meta.name = lock.name;
        }
        if (lock.integrity) {
          meta.integrity = lock.integrity;
        }
        if (lock.version && !lock.integrity) {
          if (spec.type === "git") {
            meta.resolved = consistentResolve(spec, this.path, this.path);
            return this.data.packages[location] = meta;
          } else if (spec.registry) {
            meta.version = lock.version;
          }
        }
        if (lock.resolved || spec.type && !spec.registry) {
          if (spec.registry) {
            meta.resolved = lock.resolved;
          } else if (spec.type === "file") {
            meta.resolved = consistentResolve(spec, this.path, this.path, true);
          } else if (spec.fetchSpec) {
            meta.resolved = spec.fetchSpec;
          }
        }
        if (!meta.version) {
          if (spec.type === "file" || spec.type === "remote") {
            const fromTgz = versionFromTgz(spec.name, spec.fetchSpec) || versionFromTgz(spec.name, meta.resolved);
            if (fromTgz) {
              meta.version = fromTgz.version;
              if (fromTgz.name !== name) {
                meta.name = fromTgz.name;
              }
            }
          } else if (spec.type === "alias") {
            meta.name = spec.subSpec.name;
            meta.version = spec.subSpec.fetchSpec;
          } else if (spec.type === "version") {
            meta.version = spec.fetchSpec;
          }
        }
        if (lock.ideallyInert) {
          meta.ideallyInert = true;
        }
        if (lock.bundled) {
          meta.inBundle = true;
        }
        return this.data.packages[location] = meta;
      }
      add(node) {
        if (!this.data) {
          throw new Error("run load() before getting or setting data");
        }
        const loc = relpath(this.path, node.path);
        if (node.path === this.path) {
          this.tree = node;
        }
        if (node.resolved === null || node.integrity === null) {
          const {
            resolved,
            integrity,
            hasShrinkwrap,
            version
          } = this.get(node.path);
          let pathFixed = null;
          if (resolved) {
            if (!/^file:/.test(resolved)) {
              pathFixed = resolved;
            } else {
              pathFixed = `file:${resolve(this.path, resolved.slice(5))}`;
            }
          }
          const resolvedOk = !resolved || !node.resolved || node.resolved === pathFixed;
          const integrityOk = !integrity || !node.integrity || node.integrity === integrity;
          const versionOk = !version || !node.version || version === node.version;
          const allOk = (resolved || integrity || version) && resolvedOk && integrityOk && versionOk;
          if (allOk) {
            node.resolved = node.resolved || pathFixed || null;
            node.integrity = node.integrity || integrity || null;
            node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false;
          } else {
            const {
              resolved: resolved2,
              integrity: integrity2,
              hasShrinkwrap: hasShrinkwrap2
            } = _Shrinkwrap.metaFromNode(node, this.path, this.resolveOptions);
            node.resolved = node.resolved || resolved2 || null;
            node.integrity = node.integrity || integrity2 || null;
            node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap2 || false;
          }
        }
        this.#awaitingUpdate.set(loc, node);
      }
      addEdge(edge) {
        if (!this.yarnLock || !edge.valid) {
          return;
        }
        const { to: node } = edge;
        if (node.resolved !== null && node.integrity !== null) {
          return;
        }
        if (!this.yarnLock.entries || !this.yarnLock.entries.size) {
          return;
        }
        let pathFixed = null;
        if (node.resolved) {
          if (!/file:/.test(node.resolved)) {
            pathFixed = node.resolved;
          } else {
            pathFixed = consistentResolve(node.resolved, node.path, this.path, true);
          }
        }
        const spec = npa(`${node.name}@${edge.spec}`);
        const entry = this.yarnLock.entries.get(`${node.name}@${edge.spec}`);
        if (!entry || mismatch(node.version, entry.version) || mismatch(node.integrity, entry.integrity) || mismatch(pathFixed, entry.resolved)) {
          return;
        }
        if (entry.resolved && yarnRegRe.test(entry.resolved) && spec.registry) {
          entry.resolved = entry.resolved.replace(yarnRegRe, "https://registry.npmjs.org/");
        }
        node.integrity = node.integrity || entry.integrity || null;
        node.resolved = node.resolved || consistentResolve(entry.resolved, this.path, node.path) || null;
        this.#awaitingUpdate.set(relpath(this.path, node.path), node);
      }
      #updateWaitingNode(loc) {
        const node = this.#awaitingUpdate.get(loc);
        this.#awaitingUpdate.delete(loc);
        this.data.packages[loc] = _Shrinkwrap.metaFromNode(
          node,
          this.path,
          this.resolveOptions
        );
      }
      commit() {
        if (this.tree) {
          if (this.yarnLock) {
            this.yarnLock.fromTree(this.tree);
          }
          const root = _Shrinkwrap.metaFromNode(
            this.tree.target,
            this.path,
            this.resolveOptions
          );
          this.data.packages = {};
          if (Object.keys(root).length) {
            this.data.packages[""] = root;
          }
          for (const node of this.tree.root.inventory.values()) {
            if (node === this.tree || node.isRoot || node.location === "") {
              continue;
            }
            const loc = relpath(this.path, node.path);
            this.data.packages[loc] = _Shrinkwrap.metaFromNode(
              node,
              this.path,
              this.resolveOptions
            );
          }
        } else if (this.#awaitingUpdate.size > 0) {
          for (const loc of this.#awaitingUpdate.keys()) {
            this.#updateWaitingNode(loc);
          }
        }
        if (!this.lockfileVersion) {
          this.lockfileVersion = defaultLockfileVersion;
        }
        this.data.lockfileVersion = this.lockfileVersion;
        if (this.hiddenLockfile) {
          delete this.data.packages[""];
          delete this.data.dependencies;
        } else if (this.tree && this.lockfileVersion <= 3) {
          this.#buildLegacyLockfile(this.tree, this.data);
        }
        if (!this.hiddenLockfile) {
          for (const node of Object.values(this.data.packages)) {
            delete node.ideallyInert;
          }
        }
        if (this.lockfileVersion >= 3) {
          const { dependencies, ...data } = this.data;
          return data;
        } else if (this.lockfileVersion < 2) {
          const { packages, ...data } = this.data;
          return data;
        } else {
          return { ...this.data };
        }
      }
      #buildLegacyLockfile(node, lock, path = []) {
        if (node === this.tree) {
          lock.name = node.packageName || node.name;
          if (node.version) {
            lock.version = node.version;
          }
        }
        const edge = [...node.edgesIn].filter((e) => e.valid).sort((a, b) => {
          const aloc = a.from.location.split("node_modules");
          const bloc = b.from.location.split("node_modules");
          if (aloc.length > bloc.length) {
            return 1;
          }
          if (bloc.length > aloc.length) {
            return -1;
          }
          return localeCompare(aloc[aloc.length - 1], bloc[bloc.length - 1]);
        })[0];
        const res = consistentResolve(node.resolved, this.path, this.path, true);
        const rSpec = specFromResolved(res);
        let spec = rSpec;
        if (edge) {
          spec = npa.resolve(node.name, edge.spec, edge.from.realpath);
        }
        if (node.isLink) {
          lock.version = `file:${relpath(this.path, node.realpath)}`;
        } else if (spec && (spec.type === "file" || spec.type === "remote")) {
          lock.version = spec.saveSpec;
        } else if (spec && spec.type === "git" || rSpec.type === "git") {
          lock.version = node.resolved;
          if (spec.raw) {
            lock.from = spec.raw;
          }
        } else if (!node.isRoot && node.package && node.packageName && node.packageName !== node.name) {
          lock.version = `npm:${node.packageName}@${node.version}`;
        } else if (node.package && node.version) {
          lock.version = node.version;
        }
        if (node.inDepBundle) {
          lock.bundled = true;
        }
        if (node.resolved && !node.isLink && rSpec.type !== "git" && rSpec.type !== "file" && rSpec.type !== "directory" && spec.type !== "directory" && spec.type !== "git" && spec.type !== "file" && spec.type !== "remote") {
          lock.resolved = overrideResolves(node.resolved, this.resolveOptions);
        }
        if (node.integrity) {
          lock.integrity = node.integrity;
        }
        if (node.extraneous) {
          lock.extraneous = true;
        } else if (!node.isLink) {
          if (node.peer) {
            lock.peer = true;
          }
          if (node.devOptional && !node.dev && !node.optional) {
            lock.devOptional = true;
          }
          if (node.dev) {
            lock.dev = true;
          }
          if (node.optional) {
            lock.optional = true;
          }
        }
        const depender = node.target;
        if (depender.edgesOut.size > 0) {
          if (node !== this.tree) {
            const entries = [...depender.edgesOut.entries()];
            lock.requires = entries.reduce((set, [k, v]) => {
              const { spec: spec2, peer } = v;
              if (peer) {
                return set;
              }
              if (spec2.startsWith("file:")) {
                const p = resolve(node.realpath, spec2.slice("file:".length));
                set[k] = `file:${relpath(node.realpath, p)}`;
              } else {
                set[k] = spec2;
              }
              return set;
            }, {});
          } else {
            lock.requires = true;
          }
        }
        const { children } = node.target;
        if (!children.size) {
          delete lock.dependencies;
        } else {
          const kidPath = [...path, node.realpath];
          const dependencies = {};
          let found = false;
          for (const [name, kid] of children.entries()) {
            if (path.includes(kid.realpath)) {
              continue;
            }
            dependencies[name] = this.#buildLegacyLockfile(kid, {}, kidPath);
            found = true;
          }
          if (found) {
            lock.dependencies = dependencies;
          }
        }
        return lock;
      }
      toJSON() {
        if (!this.data) {
          throw new Error("run load() before getting or setting data");
        }
        return this.commit();
      }
      toString(options = {}) {
        const data = this.toJSON();
        const { format = true } = options;
        const defaultIndent = this.indent || 2;
        const indent = format === true ? defaultIndent : format || 0;
        const eol = format ? this.newline || "\n" : "";
        return stringify(data, swKeyOrder, indent).replace(/\n/g, eol);
      }
      save(options = {}) {
        if (!this.data) {
          throw new Error("run load() before saving data");
        }
        const json = this.toString(options);
        if (!this.hiddenLockfile && this.originalLockfileVersion !== void 0 && this.originalLockfileVersion !== this.lockfileVersion) {
          log.warn(
            "shrinkwrap",
            `Converting lock file (${relative(process.cwd(), this.filename)}) from v${this.originalLockfileVersion} -> v${this.lockfileVersion}`
          );
        }
        return Promise.all([
          writeFile(this.filename, json).catch((er) => {
            if (this.hiddenLockfile) {
              return rm(this.filename, { recursive: true, force: true });
            }
            throw er;
          }),
          this.yarnLock && this.yarnLock.entries.size && writeFile(this.path + "/yarn.lock", this.yarnLock.toString())
        ]);
      }
    };
    module2.exports = Shrinkwrap;
  }
});

// node_modules/@npmcli/arborist/lib/optional-set.js
var require_optional_set = __commonJS({
  "node_modules/@npmcli/arborist/lib/optional-set.js"(exports2, module2) {
    var gatherDepSet = require_gather_dep_set();
    var optionalSet = (node) => {
      if (!node.optional) {
        return /* @__PURE__ */ new Set();
      }
      const set = /* @__PURE__ */ new Set([node]);
      for (const node2 of set) {
        for (const edge of node2.edgesIn) {
          if (!edge.optional) {
            set.add(edge.from);
          }
        }
      }
      return gatherDepSet(set, (edge) => !edge.optional);
    };
    module2.exports = optionalSet;
  }
});

// node_modules/@npmcli/arborist/lib/reset-dep-flags.js
var require_reset_dep_flags = __commonJS({
  "node_modules/@npmcli/arborist/lib/reset-dep-flags.js"(exports2, module2) {
    module2.exports = (tree) => {
      for (const node of tree.inventory.values()) {
        node.extraneous = true;
        node.dev = true;
        node.devOptional = true;
        node.peer = true;
        node.optional = true;
      }
    };
  }
});

// node_modules/@npmcli/arborist/lib/arborist/build-ideal-tree.js
var require_build_ideal_tree = __commonJS({
  "node_modules/@npmcli/arborist/lib/arborist/build-ideal-tree.js"(exports2, module2) {
    var localeCompare = require_string_locale_compare()("en");
    var rpj = require_lib36();
    var npa = require_npa();
    var pacote = require_lib33();
    var cacache = require_lib20();
    var { callLimit: promiseCallLimit } = require_commonjs7();
    var realpath = require_realpath();
    var { resolve, dirname } = require("node:path");
    var treeCheck = require_tree_check();
    var { readdirScoped } = require_lib18();
    var { lstat, readlink } = require("node:fs/promises");
    var { depth } = require_lib();
    var { log, time } = require_lib4();
    var { redact } = require_lib28();
    var semver = require_semver2();
    var {
      OK,
      REPLACE,
      CONFLICT
    } = require_can_place_dep();
    var PlaceDep = require_place_dep();
    var debug = require_debug2();
    var fromPath = require_from_path();
    var calcDepFlags = require_calc_dep_flags();
    var Shrinkwrap = require_shrinkwrap();
    var { defaultLockfileVersion } = Shrinkwrap;
    var Node = require_node5();
    var Link = require_link();
    var addRmPkgDeps = require_add_rm_pkg_deps();
    var optionalSet = require_optional_set();
    var { checkEngine, checkPlatform } = require_lib9();
    var relpath = require_relpath();
    var resetDepFlags = require_reset_dep_flags();
    var _updateAll = Symbol.for("updateAll");
    var _flagsSuspect = Symbol.for("flagsSuspect");
    var _setWorkspaces = Symbol.for("setWorkspaces");
    var _updateNames = Symbol.for("updateNames");
    var _resolvedAdd = Symbol.for("resolvedAdd");
    var _usePackageLock = Symbol.for("usePackageLock");
    var _rpcache = Symbol.for("realpathCache");
    var _stcache = Symbol.for("statCache");
    var _addNodeToTrashList = Symbol.for("addNodeToTrashList");
    var DepsQueue = class {
      #deps = [];
      #sorted = true;
      get length() {
        return this.#deps.length;
      }
      push(item) {
        if (!this.#deps.includes(item)) {
          this.#sorted = false;
          this.#deps.push(item);
        }
      }
      pop() {
        if (!this.#sorted) {
          this.#deps.sort((a, b) => a.depth - b.depth || localeCompare(a.path, b.path));
          this.#sorted = true;
        }
        return this.#deps.shift();
      }
    };
    module2.exports = (cls) => class IdealTreeBuilder extends cls {
      #complete;
      #currentDep = null;
      #depsQueue = new DepsQueue();
      #depsSeen = /* @__PURE__ */ new Set();
      #explicitRequests = /* @__PURE__ */ new Set();
      #follow;
      #installStrategy;
      #linkNodes = /* @__PURE__ */ new Set();
      #loadFailures = /* @__PURE__ */ new Set();
      #manifests = /* @__PURE__ */ new Map();
      #mutateTree = false;
      // a map of each module in a peer set to the thing that depended on
      // that set of peers in the first place.  Use a WeakMap so that we
      // don't hold onto references for nodes that are garbage collected.
      #peerSetSource = /* @__PURE__ */ new WeakMap();
      #preferDedupe = false;
      #prune;
      #strictPeerDeps;
      #virtualRoots = /* @__PURE__ */ new Map();
      constructor(options) {
        super(options);
        const registry = options.registry || "https://registry.npmjs.org";
        options.registry = this.registry = registry.replace(/\/+$/, "") + "/";
        const {
          follow = false,
          installStrategy = "hoisted",
          idealTree = null,
          installLinks = false,
          legacyPeerDeps = false,
          packageLock = true,
          strictPeerDeps = false,
          workspaces,
          global: global2
        } = options;
        this.#strictPeerDeps = !!strictPeerDeps;
        this.idealTree = idealTree;
        this.installLinks = installLinks;
        this.legacyPeerDeps = legacyPeerDeps;
        this[_usePackageLock] = packageLock;
        this.#installStrategy = global2 ? "shallow" : installStrategy;
        this.#follow = !!follow;
        if (workspaces?.length && global2) {
          throw new Error("Cannot operate on workspaces in global mode");
        }
        this[_updateAll] = false;
        this[_updateNames] = [];
        this[_resolvedAdd] = [];
      }
      get explicitRequests() {
        return new Set(this.#explicitRequests);
      }
      // public method
      async buildIdealTree(options = {}) {
        if (this.idealTree) {
          return this.idealTree;
        }
        options = { ...this.options, ...options };
        if (!options.add || options.add.length === 0) {
          options.add = null;
        }
        if (!options.rm || options.rm.length === 0) {
          options.rm = null;
        }
        const timeEnd = time.start("idealTree");
        if (!options.add && !options.rm && !options.update && this.options.global) {
          throw new Error("global requires add, rm, or update option");
        }
        this.#parseSettings(options);
        this.addTracker("idealTree");
        try {
          await this.#initTree();
          await this.#inflateAncientLockfile();
          await this.#applyUserRequests(options);
          await this.#buildDeps();
          await this.#fixDepFlags();
          await this.#pruneFailedOptional();
          await this.#checkEngineAndPlatform();
        } finally {
          timeEnd();
          this.finishTracker("idealTree");
        }
        return treeCheck(this.idealTree);
      }
      async #checkEngineAndPlatform() {
        const { engineStrict, npmVersion, nodeVersion } = this.options;
        for (const node of this.idealTree.inventory.values()) {
          if (!node.optional) {
            try {
              if (!(node.isRoot && node.package.devEngines)) {
                checkEngine(node.package, npmVersion, nodeVersion, this.options.force);
              }
            } catch (err) {
              if (engineStrict) {
                throw err;
              }
              log.warn(err.code, err.message, {
                package: err.pkgid,
                required: err.required,
                current: err.current
              });
            }
            checkPlatform(node.package, this.options.force);
          }
        }
      }
      #parseSettings(options) {
        const update = options.update === true ? { all: true } : Array.isArray(options.update) ? { names: options.update } : options.update || {};
        if (update.all || !Array.isArray(update.names)) {
          update.names = [];
        }
        this.#complete = !!options.complete;
        this.#preferDedupe = !!options.preferDedupe;
        for (const name of update.names) {
          const spec = npa(name);
          const validationError = new TypeError(`Update arguments must only contain package names, eg:
    npm update ${spec.name}`);
          validationError.code = "EUPDATEARGS";
          if (spec.raw !== spec.name) {
            throw validationError;
          }
        }
        this[_updateNames] = update.names;
        this[_updateAll] = update.all;
        this.#prune = options.prune !== false;
        this.#mutateTree = !!(options.add || options.rm || update.all || update.names.length);
      }
      // load the initial tree, either the virtualTree from a shrinkwrap,
      // or just the root node from a package.json
      async #initTree() {
        const timeEnd = time.start("idealTree:init");
        let root;
        if (this.options.global) {
          root = await this.#globalRootNode();
        } else {
          try {
            const pkg = await rpj(this.path + "/package.json");
            root = await this.#rootNodeFromPackage(pkg);
          } catch (err) {
            if (err.code === "EJSONPARSE") {
              throw err;
            }
            root = await this.#rootNodeFromPackage({});
          }
        }
        return this[_setWorkspaces](root).then((root2) => {
          if (this.options.global) {
            return root2;
          } else if (!this[_usePackageLock] || this[_updateAll]) {
            return Shrinkwrap.reset({
              path: this.path,
              lockfileVersion: this.options.lockfileVersion,
              resolveOptions: this.options
            }).then((meta) => Object.assign(root2, { meta }));
          } else {
            return this.loadVirtual({ root: root2 }).then((tree) => {
              this.#applyRootOverridesToWorkspaces(tree);
              return tree;
            });
          }
        }).then(async (root2) => {
          if (!this[_updateAll] && !this.options.global && !root2.meta.loadedFromDisk || this.options.global && this[_updateNames].length) {
            await new this.constructor(this.options).loadActual({ root: root2 });
            const tree = root2.target;
            if (tree.children.size) {
              root2.meta.loadedFromDisk = true;
              root2.meta.originalLockfileVersion = root2.meta.lockfileVersion = this.options.lockfileVersion || defaultLockfileVersion;
            }
          }
          root2.meta.inferFormattingOptions(root2.package);
          return root2;
        }).then((tree) => {
          depth({
            tree,
            getChildren: (node) => {
              const children = [];
              for (const edge of node.edgesOut.values()) {
                children.push(edge.to);
              }
              return children;
            },
            filter: (node) => node,
            visit: (node) => {
              for (const edge of node.edgesOut.values()) {
                if (!edge.valid) {
                  this.#depsQueue.push(node);
                  break;
                }
              }
            }
          });
          this.idealTree = tree;
          this.virtualTree = null;
          timeEnd();
          return tree;
        });
      }
      async #globalRootNode() {
        const root = await this.#rootNodeFromPackage({ dependencies: {} });
        const meta = new Shrinkwrap({
          path: this.path,
          lockfileVersion: this.options.lockfileVersion,
          resolveOptions: this.options
        });
        meta.reset();
        root.meta = meta;
        return root;
      }
      async #rootNodeFromPackage(pkg) {
        const real = await realpath(this.path, this[_rpcache], this[_stcache]);
        const Cls = real === this.path ? Node : Link;
        const root = new Cls({
          path: this.path,
          realpath: real,
          pkg,
          extraneous: false,
          dev: false,
          devOptional: false,
          peer: false,
          optional: false,
          global: this.options.global,
          installLinks: this.installLinks,
          legacyPeerDeps: this.legacyPeerDeps,
          loadOverrides: true
        });
        if (root.isLink) {
          root.target = new Node({
            path: real,
            realpath: real,
            pkg,
            extraneous: false,
            dev: false,
            devOptional: false,
            peer: false,
            optional: false,
            global: this.options.global,
            installLinks: this.installLinks,
            legacyPeerDeps: this.legacyPeerDeps,
            root
          });
        }
        return root;
      }
      // process the add/rm requests by modifying the root node, and the
      // update.names request by queueing nodes dependent on those named.
      async #applyUserRequests(options) {
        const timeEnd = time.start("idealTree:userRequests");
        const tree = this.idealTree.target;
        if (!this.options.workspaces.length) {
          await this.#applyUserRequestsToNode(tree, options);
        } else {
          const nodes = this.workspaceNodes(tree, this.options.workspaces);
          if (this.options.includeWorkspaceRoot) {
            nodes.push(tree);
          }
          const appliedRequests = nodes.map(
            (node) => this.#applyUserRequestsToNode(node, options)
          );
          await Promise.all(appliedRequests);
        }
        timeEnd();
      }
      async #applyUserRequestsToNode(tree, options) {
        if (!this.options.global && this[_updateNames].length) {
          this.#queueNamedUpdates();
        }
        const globalExplicitUpdateNames = [];
        if (this.options.global && (this[_updateAll] || this[_updateNames].length)) {
          const nm = resolve(this.path, "node_modules");
          const paths = await readdirScoped(nm).catch(() => []);
          for (const p of paths) {
            const name = p.replace(/\\/g, "/");
            tree.package.dependencies = tree.package.dependencies || {};
            const updateName = this[_updateNames].includes(name);
            if (this[_updateAll] || updateName) {
              if (updateName) {
                globalExplicitUpdateNames.push(name);
              }
              const dir = resolve(nm, name);
              const st = await lstat(dir).catch(
                /* istanbul ignore next */
                () => null
              );
              if (st && st.isSymbolicLink()) {
                const target = await readlink(dir);
                const real = resolve(dirname(dir), target);
                tree.package.dependencies[name] = `file:${real}`;
              } else {
                tree.package.dependencies[name] = "*";
              }
            }
          }
        }
        if (this.auditReport && this.auditReport.size > 0) {
          await this.#queueVulnDependents(options);
        }
        const { add, rm } = options;
        if (rm && rm.length) {
          addRmPkgDeps.rm(tree.package, rm);
          for (const name of rm) {
            this.#explicitRequests.add({ from: tree, name, action: "DELETE" });
          }
        }
        if (add && add.length) {
          await this.#add(tree, options);
        }
        if (add && add.length || rm && rm.length || this.options.global) {
          tree.package = tree.package;
        }
        for (const spec of this[_resolvedAdd]) {
          if (spec.tree === tree) {
            this.#explicitRequests.add(tree.edgesOut.get(spec.name));
          }
        }
        for (const name of globalExplicitUpdateNames) {
          this.#explicitRequests.add(tree.edgesOut.get(name));
        }
        this.#depsQueue.push(tree);
      }
      // This returns a promise because we might not have the name yet, and need to
      // call pacote.manifest to find the name.
      async #add(tree, { add, saveType = null, saveBundle = false }) {
        const path = tree.target.path;
        await Promise.all(add.map(async (rawSpec) => {
          let spec = npa(rawSpec);
          const isTag = spec.rawSpec && spec.type === "tag";
          if (!spec.name || isTag) {
            const mani = await pacote.manifest(spec, { ...this.options });
            if (isTag) {
              spec = npa(`${mani.name}@${mani.version}`);
            }
            spec.name = mani.name;
          }
          const { name } = spec;
          if (spec.type === "file") {
            spec = npa(`file:${relpath(path, spec.fetchSpec)}`, path);
            spec.name = name;
          } else if (spec.type === "directory") {
            try {
              const real = await realpath(spec.fetchSpec, this[_rpcache], this[_stcache]);
              spec = npa(`file:${relpath(path, real)}`, path);
              spec.name = name;
            } catch {
            }
          }
          spec.tree = tree;
          this[_resolvedAdd].push(spec);
        }));
        addRmPkgDeps.add({
          pkg: tree.package,
          add: this[_resolvedAdd],
          saveBundle,
          saveType
        });
      }
      // TODO: provide a way to fix bundled deps by exposing metadata about
      // what's in the bundle at each published manifest.  Without that, we
      // can't possibly fix bundled deps without breaking a ton of other stuff,
      // and leaving the user subject to getting it overwritten later anyway.
      async #queueVulnDependents(options) {
        for (const vuln of this.auditReport.values()) {
          for (const node of vuln.nodes) {
            const bundler = node.getBundler();
            if (bundler) {
              log.warn(
                `audit fix ${node.name}@${node.version}`,
                `${node.location}
is a bundled dependency of
${bundler.name}@${bundler.version} at ${bundler.location}
It cannot be fixed automatically.
Check for updates to the ${bundler.name} package.`
              );
              continue;
            }
            for (const edge of node.edgesIn) {
              this.addTracker("idealTree", edge.from.name, edge.from.location);
              this.#depsQueue.push(edge.from);
            }
          }
        }
        if (this.options.force && this.auditReport && this.auditReport.topVulns.size) {
          options.add = options.add || [];
          options.rm = options.rm || [];
          const nodesTouched = /* @__PURE__ */ new Set();
          for (const [name, topVuln] of this.auditReport.topVulns.entries()) {
            const {
              simpleRange,
              topNodes,
              fixAvailable
            } = topVuln;
            for (const node of topNodes) {
              if (!node.isProjectRoot && !node.isWorkspace) {
                log.warn("audit", `Manual fix required in linked project at ./${node.location} for ${name}@${simpleRange}.
'cd ./${node.location}' and run 'npm audit' for details.`);
                continue;
              }
              if (!fixAvailable) {
                log.warn("audit", `No fix available for ${name}@${simpleRange}`);
                continue;
              }
              const { isSemVerMajor, version, name: fixName } = fixAvailable;
              const breakingMessage = isSemVerMajor ? "a SemVer major change" : "outside your stated dependency range";
              log.warn("audit", `Updating ${fixName} to ${version}, which is ${breakingMessage}.`);
              await this.#add(node, { add: [`${fixName}@${version}`] });
              nodesTouched.add(node);
            }
          }
          for (const node of nodesTouched) {
            node.package = node.package;
          }
        }
      }
      #avoidRange(name) {
        if (!this.auditReport) {
          return null;
        }
        const vuln = this.auditReport.get(name);
        if (!vuln) {
          return null;
        }
        return vuln.range;
      }
      #queueNamedUpdates() {
        for (const node of this.idealTree.inventory.values()) {
          if (this[_updateNames].includes(node.name) && !node.isTop && !node.inDepBundle && !node.inShrinkwrap) {
            for (const edge of node.edgesIn) {
              this.addTracker("idealTree", edge.from.name, edge.from.location);
              this.#depsQueue.push(edge.from);
            }
          }
        }
      }
      async #inflateAncientLockfile() {
        const { meta, inventory } = this.idealTree;
        const ancient = meta.ancientLockfile;
        const old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2);
        if (inventory.size === 0 || !ancient && !old) {
          return;
        }
        const timeEnd = time.start("idealTree:inflate");
        const heading = ancient ? "ancient lockfile" : "old lockfile";
        if (ancient || !this.options.lockfileVersion || this.options.lockfileVersion >= defaultLockfileVersion) {
          log.warn(
            heading,
            `
The ${meta.type} file was created with an old version of npm,
so supplemental metadata must be fetched from the registry.

This is a one-time fix-up, please be patient...
`
          );
        }
        this.addTracker("idealTree:inflate");
        const queue = [];
        for (const node of inventory.values()) {
          if (node.isProjectRoot) {
            continue;
          }
          if (!node.location.startsWith("node_modules")) {
            continue;
          }
          queue.push(async () => {
            log.silly("inflate", node.location);
            const { resolved, version, path, name, location, integrity } = node;
            const useResolved = resolved && (!version || resolved.startsWith("file:"));
            const id = useResolved ? resolved : version;
            const spec = npa.resolve(name, id, dirname(path));
            const t = `idealTree:inflate:${location}`;
            this.addTracker(t);
            try {
              const mani = await pacote.manifest(spec, {
                ...this.options,
                resolved,
                integrity,
                fullMetadata: false
              });
              node.package = { ...mani, _id: `${mani.name}@${mani.version}` };
            } catch (er) {
              const warning = `Could not fetch metadata for ${name}@${id}`;
              log.warn(heading, warning, er);
            }
            this.finishTracker(t);
          });
        }
        await promiseCallLimit(queue);
        calcDepFlags(this.idealTree);
        if (!this.options.lockfileVersion && !meta.hiddenLockfile) {
          meta.originalLockfileVersion = defaultLockfileVersion;
        }
        this.finishTracker("idealTree:inflate");
        timeEnd();
      }
      // at this point we have a virtual tree with the actual root node's
      // package deps, which may be partly or entirely incomplete, invalid
      // or extraneous.
      #buildDeps() {
        const timeEnd = time.start("idealTree:buildDeps");
        const tree = this.idealTree.target;
        tree.assertRootOverrides();
        this.#depsQueue.push(tree);
        log.silly("idealTree", "buildDeps");
        this.addTracker("idealTree", tree.name, "");
        return this.#buildDepStep().then(timeEnd);
      }
      async #buildDepStep() {
        if (this.#currentDep) {
          const { location, name } = this.#currentDep;
          time.end(`idealTree:${location || "#root"}`);
          this.finishTracker("idealTree", name, location);
          this.#currentDep = null;
        }
        if (!this.#depsQueue.length) {
          return this.#resolveLinks();
        }
        const node = this.#depsQueue.pop();
        const bd = node.package.bundleDependencies;
        const hasBundle = bd && Array.isArray(bd) && bd.length;
        const { hasShrinkwrap } = node;
        if (this.#depsSeen.has(node) || node.root !== this.idealTree || hasShrinkwrap && !this.#complete) {
          return this.#buildDepStep();
        }
        this.#depsSeen.add(node);
        this.#currentDep = node;
        time.start(`idealTree:${node.location || "#root"}`);
        const crackOpen = this.#complete && node !== this.idealTree && node.resolved && (hasBundle || hasShrinkwrap) && !node.ideallyInert;
        if (crackOpen) {
          const Arborist2 = this.constructor;
          const opt = { ...this.options };
          await cacache.tmp.withTmp(this.cache, opt, async (path) => {
            await pacote.extract(node.resolved, path, {
              ...opt,
              Arborist: Arborist2,
              resolved: node.resolved,
              integrity: node.integrity
            });
            if (hasShrinkwrap) {
              await new Arborist2({ ...this.options, path }).loadVirtual({ root: node });
            }
            if (hasBundle) {
              await new Arborist2({ ...this.options, path }).loadActual({ root: node, ignoreMissing: true });
            }
          });
        }
        const tasks = [];
        const peerSource = this.#peerSetSource.get(node) || node;
        for (const edge of this.#problemEdges(node)) {
          if (edge.peerConflicted) {
            continue;
          }
          const source = edge.peer ? peerSource : node;
          const virtualRoot = this.#virtualRoot(source, true);
          const vrEdge = virtualRoot && virtualRoot.edgesOut.get(edge.name);
          const vrDep = vrEdge && vrEdge.valid && vrEdge.to;
          const required = /* @__PURE__ */ new Set([edge.from]);
          const parent = edge.peer ? virtualRoot : null;
          const dep = vrDep && vrDep.satisfies(edge) ? vrDep : await this.#nodeFromEdge(edge, parent, null, required);
          debug(() => {
            if (!dep) {
              throw new Error("no dep??");
            }
          });
          tasks.push({ edge, dep });
        }
        const placeDeps = tasks.sort((a, b) => localeCompare(a.edge.name, b.edge.name));
        const promises = [];
        for (const { edge, dep } of placeDeps) {
          const pd = new PlaceDep({
            edge,
            dep,
            auditReport: this.auditReport,
            explicitRequest: this.#explicitRequests.has(edge),
            force: this.options.force,
            installLinks: this.installLinks,
            installStrategy: this.#installStrategy,
            legacyPeerDeps: this.legacyPeerDeps,
            preferDedupe: this.#preferDedupe,
            strictPeerDeps: this.#strictPeerDeps,
            updateNames: this[_updateNames]
          });
          depth({
            tree: pd,
            getChildren: (pd2) => pd2.children,
            visit: (pd2) => {
              const { placed, edge: edge2, canPlace: cpd } = pd2;
              if (!placed) {
                return;
              }
              if (placed.errors.length) {
                this.#loadFailures.add(placed);
              }
              this.#mutateTree = true;
              if (cpd.canPlaceSelf === OK) {
                for (const edgeIn of placed.edgesIn) {
                  if (edgeIn === edge2) {
                    continue;
                  }
                  const { from, valid, peerConflicted } = edgeIn;
                  if (!peerConflicted && !valid && !this.#depsSeen.has(from)) {
                    this.addTracker("idealTree", from.name, from.location);
                    this.#depsQueue.push(edgeIn.from);
                  }
                }
              } else {
                if (cpd.canPlaceSelf === REPLACE) {
                  for (const edgeIn of placed.edgesIn) {
                    if (edgeIn === edge2) {
                      continue;
                    }
                    const { valid, peerConflicted } = edgeIn;
                    if (!valid && !peerConflicted) {
                      this.#depsSeen.delete(edgeIn.from);
                      this.#depsQueue.push(edgeIn.from);
                    }
                  }
                }
              }
              if (cpd.canPlaceSelf === CONFLICT) {
                debug(() => {
                  const er = new Error("placed with canPlaceSelf=CONFLICT");
                  throw Object.assign(er, { placeDep: pd2 });
                });
                return;
              }
              this.#depsQueue.push(placed);
              for (const dep2 of pd2.needEvaluation) {
                this.#depsSeen.delete(dep2);
                this.#depsQueue.push(dep2);
              }
              for (const e of this.#problemEdges(placed)) {
                promises.push(
                  () => this.#fetchManifest(npa.resolve(e.name, e.spec, fromPath(placed, e))).catch(() => null)
                );
              }
            }
          });
        }
        for (const { to } of node.edgesOut.values()) {
          if (to && to.isLink && to.target) {
            this.#linkNodes.add(to);
          }
        }
        await promiseCallLimit(promises);
        return this.#buildDepStep();
      }
      // loads a node from an edge, and then loads its peer deps (and their
      // peer deps, on down the line) into a virtual root parent.
      async #nodeFromEdge(edge, parent_, secondEdge, required) {
        const parent = parent_ || this.#virtualRoot(edge.from);
        const spec = npa.resolve(edge.name, edge.spec, edge.from.path);
        const first = await this.#nodeFromSpec(edge.name, spec, parent, edge);
        const spec2 = secondEdge && npa.resolve(
          edge.name,
          secondEdge.spec,
          secondEdge.from.path
        );
        const second = secondEdge && !secondEdge.valid ? await this.#nodeFromSpec(edge.name, spec2, parent, secondEdge) : null;
        const node = second && edge.valid ? second : first;
        node.parent = parent;
        if (required.has(edge.from) && edge.type !== "peerOptional" || secondEdge && (required.has(secondEdge.from) && secondEdge.type !== "peerOptional")) {
          required.add(node);
        }
        const src = parent.sourceReference;
        this.#peerSetSource.set(node, src);
        if (this.options.global && edge.from.isProjectRoot) {
          return node;
        }
        return this.#loadPeerSet(node, required);
      }
      #virtualRoot(node, reuse = false) {
        if (reuse && this.#virtualRoots.has(node)) {
          return this.#virtualRoots.get(node);
        }
        const vr = new Node({
          path: node.realpath,
          sourceReference: node,
          installLinks: this.installLinks,
          legacyPeerDeps: this.legacyPeerDeps,
          overrides: node.overrides
        });
        for (const child of node.children.values()) {
          if (child.isLink) {
            new Node({
              path: child.realpath,
              sourceReference: child.target,
              root: vr
            });
          }
        }
        this.#virtualRoots.set(node, vr);
        return vr;
      }
      #problemEdges(node) {
        const bd = node.isProjectRoot || node.isWorkspace ? null : node.package.bundleDependencies;
        const bundled = new Set(bd || []);
        const problems = [];
        for (const edge of node.edgesOut.values()) {
          if (bundled.has(edge.name)) {
            continue;
          }
          if (edge.to && this.#loadFailures.has(edge.to)) {
            continue;
          }
          if (edge.to && edge.to.inShrinkwrap) {
            continue;
          }
          if (!edge.to) {
            if (edge.type !== "peerOptional" || this.#explicitRequests.has(edge)) {
              problems.push(edge);
            }
            continue;
          }
          if (!edge.valid) {
            problems.push(edge);
            continue;
          }
          if (edge.to.isWorkspace) {
            continue;
          }
          if (this[_updateNames].includes(edge.name)) {
            problems.push(edge);
            continue;
          }
          if (this.auditReport && this.auditReport.isVulnerable(edge.to)) {
            problems.push(edge);
            continue;
          }
          if (this.#explicitRequests.has(edge)) {
            problems.push(edge);
            continue;
          }
        }
        return problems;
      }
      async #fetchManifest(spec) {
        const options = {
          ...this.options,
          avoid: this.#avoidRange(spec.name),
          fullMetadata: true
        };
        spec = this.idealTree.meta.checkYarnLock(spec, options);
        if (this.#manifests.has(spec.raw)) {
          return this.#manifests.get(spec.raw);
        } else {
          log.silly("fetch manifest", spec.raw.replace(spec.rawSpec, redact(spec.rawSpec)));
          const mani = await pacote.manifest(spec, options);
          this.#manifests.set(spec.raw, mani);
          return mani;
        }
      }
      #nodeFromSpec(name, spec, parent, edge) {
        const { installLinks, legacyPeerDeps } = this;
        const isWorkspace = this.idealTree.workspaces && this.idealTree.workspaces.has(spec.name);
        if (spec.type === "directory" && (isWorkspace || !installLinks)) {
          return this.#linkFromSpec(name, spec, parent, edge);
        }
        if (isWorkspace) {
          const existingNode = this.idealTree.edgesOut.get(spec.name).to;
          if (existingNode && existingNode.isWorkspace && existingNode.satisfies(edge)) {
            return existingNode;
          }
        }
        return this.#fetchManifest(spec).then((pkg) => new Node({ name, pkg, parent, installLinks, legacyPeerDeps }), (error) => {
          error.requiredBy = edge.from.location || ".";
          const n = new Node({
            name,
            parent,
            error,
            installLinks,
            legacyPeerDeps
          });
          this.#loadFailures.add(n);
          return n;
        });
      }
      #linkFromSpec(name, spec, parent) {
        const realpath2 = spec.fetchSpec;
        const { installLinks, legacyPeerDeps } = this;
        return rpj(realpath2 + "/package.json").catch(() => ({})).then((pkg) => {
          const link = new Link({ name, parent, realpath: realpath2, pkg, installLinks, legacyPeerDeps });
          this.#linkNodes.add(link);
          return link;
        });
      }
      // load all peer deps and meta-peer deps into the node's parent
      // At the end of this, the node's peer-type outward edges are all
      // resolved, and so are all of theirs, but other dep types are not.
      // We prefer to get peer deps that meet the requiring node's dependency,
      // if possible, since that almost certainly works (since that package was
      // developed with this set of deps) and will typically be more restrictive.
      // Note that the peers in the set can conflict either with each other,
      // or with a direct dependency from the virtual root parent!  In strict
      // mode, this is always an error.  In force mode, it never is, and we
      // prefer the parent's non-peer dep over a peer dep, or the version that
      // gets placed first.  In non-strict mode, we behave strictly if the
      // virtual root is based on the root project, and allow non-peer parent
      // deps to override, but throw if no preference can be determined.
      async #loadPeerSet(node, required) {
        const peerEdges = [...node.edgesOut.values()].filter((e) => e.peer && !(e.valid && e.to)).sort(({ name: a }, { name: b }) => localeCompare(a, b));
        for (const edge of peerEdges) {
          if (edge.valid && edge.to) {
            continue;
          }
          const parentEdge = node.parent.edgesOut.get(edge.name);
          const { isProjectRoot, isWorkspace } = node.parent.sourceReference;
          const isMine = isProjectRoot || isWorkspace;
          const conflictOK = this.options.force || !isMine && !this.#strictPeerDeps;
          if (!edge.to) {
            if (!parentEdge) {
              await this.#nodeFromEdge(edge, node.parent, null, required);
              continue;
            } else {
              const dep2 = await this.#nodeFromEdge(
                parentEdge,
                node.parent,
                edge,
                required
              );
              if (edge.valid) {
                continue;
              }
              if (conflictOK || !required.has(dep2)) {
                edge.peerConflicted = true;
                continue;
              }
              this.#failPeerConflict(edge, parentEdge);
            }
          }
          const current = edge.to;
          const dep = await this.#nodeFromEdge(edge, null, null, required);
          if (dep.canReplace(current)) {
            await this.#nodeFromEdge(edge, node.parent, null, required);
            continue;
          }
          if (conflictOK || !required.has(edge.from)) {
            continue;
          }
          this.#failPeerConflict(edge, parentEdge);
        }
        return node;
      }
      #failPeerConflict(edge, currentEdge) {
        const expl = this.#explainPeerConflict(edge, currentEdge);
        throw Object.assign(new Error("unable to resolve dependency tree"), expl);
      }
      #explainPeerConflict(edge, currentEdge) {
        const node = edge.from;
        const curNode = node.resolve(edge.name);
        const current = curNode.explain();
        return {
          code: "ERESOLVE",
          current,
          // it SHOULD be impossible to get here without a current node in place,
          // but this at least gives us something report on when bugs creep into
          // the tree handling logic.
          currentEdge: currentEdge ? currentEdge.explain() : null,
          edge: edge.explain(),
          strictPeerDeps: this.#strictPeerDeps,
          force: this.options.force
        };
      }
      // go through all the links in the this.#linkNodes set
      // for each one:
      // - if outside the root, ignore it, assume it's fine, it's not our problem
      // - if a node in the tree already, assign the target to that node.
      // - if a path under an existing node, then assign that as the fsParent,
      //   and add it to the _depsQueue
      //
      // call buildDepStep if anything was added to the queue, otherwise we're done
      #resolveLinks() {
        for (const link of this.#linkNodes) {
          this.#linkNodes.delete(link);
          if (link.root !== this.idealTree) {
            continue;
          }
          const tree = this.idealTree.target;
          const external = !link.target.isDescendantOf(tree);
          if (external && !this.#follow) {
            continue;
          }
          const unseenLink = (link.target.parent || link.target.fsParent) && !this.#depsSeen.has(link.target);
          if (this.#follow && !link.target.parent && !link.target.fsParent || unseenLink) {
            this.addTracker("idealTree", link.target.name, link.target.location);
            this.#depsQueue.push(link.target);
          }
        }
        if (this.#depsQueue.length) {
          return this.#buildDepStep();
        }
      }
      #fixDepFlags() {
        const timeEnd = time.start("idealTree:fixDepFlags");
        const metaFromDisk = this.idealTree.meta.loadedFromDisk;
        const flagsSuspect = this[_flagsSuspect];
        const mutateTree = this.#mutateTree;
        if (metaFromDisk && mutateTree) {
          resetDepFlags(this.idealTree);
        }
        if (!metaFromDisk || mutateTree) {
          calcDepFlags(this.idealTree);
        } else {
          this.idealTree.extraneous = false;
          this.idealTree.dev = false;
          this.idealTree.optional = false;
          this.idealTree.devOptional = false;
          this.idealTree.peer = false;
        }
        const needPrune = metaFromDisk && (mutateTree || flagsSuspect);
        if (this.#prune && needPrune) {
          this.#idealTreePrune();
          for (const node of this.idealTree.inventory.values()) {
            if (node.extraneous) {
              node.parent = null;
            }
          }
        }
        timeEnd();
      }
      #applyRootOverridesToWorkspaces(tree) {
        const rootOverrides = tree.root.package.overrides || {};
        for (const node of tree.root.inventory.values()) {
          if (!node.isWorkspace) {
            continue;
          }
          for (const depName of Object.keys(rootOverrides)) {
            const edge = node.edgesOut.get(depName);
            const rootNode = tree.root.children.get(depName);
            if (!edge || !rootNode) {
              continue;
            }
            const resolvedRootVersion = rootNode.package.version;
            if (!semver.satisfies(resolvedRootVersion, edge.spec)) {
              edge.detach();
              node.children.delete(depName);
            }
          }
        }
      }
      #idealTreePrune() {
        for (const node of this.idealTree.inventory.values()) {
          if (node.extraneous) {
            node.parent = null;
          }
        }
      }
      #pruneFailedOptional() {
        for (const node of this.#loadFailures) {
          if (!node.optional) {
            throw node.errors[0];
          }
          const set = optionalSet(node);
          for (const node2 of set) {
            node2.ideallyInert = true;
          }
        }
      }
      async prune(options = {}) {
        options = { ...this.options, ...options };
        await this.buildIdealTree(options);
        this.#idealTreePrune();
        if (!this.options.workspacesEnabled) {
          const excludeNodes = this.excludeWorkspacesDependencySet(this.idealTree);
          for (const node of this.idealTree.inventory.values()) {
            if (node.parent !== null && !node.isProjectRoot && !excludeNodes.has(node) && !node.ideallyInert) {
              this[_addNodeToTrashList](node);
            }
          }
        }
        return this.reify(options);
      }
    };
  }
});

// node_modules/common-ancestor-path/index.js
var require_common_ancestor_path = __commonJS({
  "node_modules/common-ancestor-path/index.js"(exports2, module2) {
    var { parse, sep, normalize: norm } = require("path");
    function* commonArrayMembers(a, b) {
      const [l, s] = a.length > b.length ? [a, b] : [b, a];
      for (const x of s) {
        if (x === l.shift())
          yield x;
        else
          break;
      }
    }
    var commonAncestorPath = (a, b) => a === b ? a : parse(a).root !== parse(b).root ? null : [...commonArrayMembers(norm(a).split(sep), norm(b).split(sep))].join(sep);
    module2.exports = (...paths) => paths.reduce(commonAncestorPath);
  }
});

// node_modules/@npmcli/arborist/lib/arborist/load-actual.js
var require_load_actual = __commonJS({
  "node_modules/@npmcli/arborist/lib/arborist/load-actual.js"(exports2, module2) {
    var { relative, dirname, resolve, join, normalize } = require("node:path");
    var rpj = require_lib36();
    var { readdirScoped } = require_lib18();
    var { walkUp } = require_commonjs8();
    var ancestorPath = require_common_ancestor_path();
    var treeCheck = require_tree_check();
    var Shrinkwrap = require_shrinkwrap();
    var calcDepFlags = require_calc_dep_flags();
    var Node = require_node5();
    var Link = require_link();
    var realpath = require_realpath();
    var _changePath = Symbol.for("_changePath");
    var _setWorkspaces = Symbol.for("setWorkspaces");
    var _rpcache = Symbol.for("realpathCache");
    var _stcache = Symbol.for("statCache");
    module2.exports = (cls) => class ActualLoader extends cls {
      #actualTree;
      // ensure when walking the tree that we don't call loadTree on the same
      // actual node more than one time.
      #actualTreeLoaded = /* @__PURE__ */ new Set();
      #actualTreePromise;
      // cache of nodes when loading the actualTree, so that we avoid loaded the
      // same node multiple times when symlinks attack.
      #cache = /* @__PURE__ */ new Map();
      #filter;
      // cache of link targets for setting fsParent links
      // We don't do fsParent as a magic getter/setter, because it'd be too costly
      // to keep up to date along the walk.
      // And, we know that it can ONLY be relevant when the node is a target of a
      // link, otherwise it'd be in a node_modules folder, so take advantage of
      // that to limit the scans later.
      #topNodes = /* @__PURE__ */ new Set();
      #transplantFilter;
      constructor(options) {
        super(options);
        this.actualTree = options.actualTree;
        const cwd = process.cwd();
        this[_rpcache] = /* @__PURE__ */ new Map([[cwd, cwd]]);
        this[_stcache] = /* @__PURE__ */ new Map();
      }
      // public method
      // TODO remove options param in next semver major
      async loadActual(options = {}) {
        if (this.actualTree) {
          return this.actualTree;
        }
        if (!this.#actualTreePromise) {
          options = { ...this.options, ...options };
          this.#actualTreePromise = this.#loadActual(options).then((tree) => {
            if (!options.root) {
              for (const node of tree.inventory.values()) {
                node.extraneous = true;
              }
            }
            calcDepFlags(tree, !options.root);
            this.actualTree = treeCheck(tree);
            return this.actualTree;
          });
        }
        return this.#actualTreePromise;
      }
      // return the promise so that we don't ever have more than one going at the
      // same time.  This is so that buildIdealTree can default to the actualTree
      // if no shrinkwrap present, but reify() can still call buildIdealTree and
      // loadActual in parallel safely.
      async #loadActual(options) {
        const {
          global: global2,
          filter = () => true,
          root = null,
          transplantFilter = () => true,
          ignoreMissing = false,
          forceActual = false
        } = options;
        this.#filter = filter;
        this.#transplantFilter = transplantFilter;
        if (global2) {
          const real = await realpath(this.path, this[_rpcache], this[_stcache]);
          const params = {
            path: this.path,
            realpath: real,
            pkg: {},
            global: global2,
            loadOverrides: true
          };
          if (this.path === real) {
            this.#actualTree = this.#newNode(params);
          } else {
            this.#actualTree = await this.#newLink(params);
          }
        } else {
          this.#actualTree = await this.#loadFSNode({
            path: this.path,
            real: await realpath(this.path, this[_rpcache], this[_stcache]),
            loadOverrides: true
          });
          this.#actualTree.assertRootOverrides();
          if (!forceActual) {
            const meta2 = await Shrinkwrap.load({
              path: this.#actualTree.path,
              hiddenLockfile: true,
              resolveOptions: this.options
            });
            if (meta2.loadedFromDisk) {
              this.#actualTree.meta = meta2;
              await new this.constructor({ ...this.options }).loadVirtual({
                root: this.#actualTree
              });
              await this[_setWorkspaces](this.#actualTree);
              this.#transplant(root);
              return this.#actualTree;
            }
          }
          const meta = await Shrinkwrap.load({
            path: this.#actualTree.path,
            lockfileVersion: this.options.lockfileVersion,
            resolveOptions: this.options
          });
          this.#actualTree.meta = meta;
        }
        await this.#loadFSTree(this.#actualTree);
        await this[_setWorkspaces](this.#actualTree);
        if (this.#actualTree.workspaces && this.#actualTree.workspaces.size) {
          const promises = [];
          for (const path of this.#actualTree.workspaces.values()) {
            if (!this.#cache.has(path)) {
              const p = this.#loadFSNode({ path, root: this.#actualTree, useRootOverrides: true }).then((node) => this.#loadFSTree(node));
              promises.push(p);
            }
          }
          await Promise.all(promises);
        }
        if (!ignoreMissing) {
          await this.#findMissingEdges();
        }
        for (const path of this.#topNodes) {
          const node = this.#cache.get(path);
          if (node && !node.parent && !node.fsParent) {
            for (const p of walkUp(dirname(path))) {
              if (this.#cache.has(p)) {
                node.fsParent = this.#cache.get(p);
                break;
              }
            }
          }
        }
        this.#transplant(root);
        if (global2) {
          const tree = this.#actualTree;
          const actualRoot = tree.isLink ? tree.target : tree;
          const { dependencies = {} } = actualRoot.package;
          for (const [name, kid] of actualRoot.children.entries()) {
            const def = kid.isLink ? `file:${kid.realpath}` : "*";
            dependencies[name] = dependencies[name] || def;
          }
          actualRoot.package = { ...actualRoot.package, dependencies };
        }
        return this.#actualTree;
      }
      #transplant(root) {
        if (!root || root === this.#actualTree) {
          return;
        }
        this.#actualTree[_changePath](root.path);
        for (const node of this.#actualTree.children.values()) {
          if (!this.#transplantFilter(node)) {
            node.root = null;
          }
        }
        root.replace(this.#actualTree);
        for (const node of this.#actualTree.fsChildren) {
          node.root = this.#transplantFilter(node) ? root : null;
        }
        this.#actualTree = root;
      }
      async #loadFSNode({ path, parent, real, root, loadOverrides, useRootOverrides }) {
        if (!real) {
          try {
            real = await realpath(path, this[_rpcache], this[_stcache]);
          } catch (error) {
            return new Node({
              error,
              path,
              realpath: path,
              parent,
              root,
              loadOverrides
            });
          }
        }
        const cached = this.#cache.get(path);
        let node;
        if (cached && !cached.dummy) {
          cached.parent = parent;
          return cached;
        } else {
          const params = {
            installLinks: this.installLinks,
            legacyPeerDeps: this.legacyPeerDeps,
            path,
            realpath: real,
            parent,
            root,
            loadOverrides
          };
          try {
            const pkg = await rpj(join(real, "package.json"));
            params.pkg = pkg;
            if (useRootOverrides && root.overrides) {
              params.overrides = root.overrides.getNodeRule({ name: pkg.name, version: pkg.version });
            }
          } catch (err) {
            params.error = err;
          }
          if (normalize(path) === real) {
            node = this.#newNode(params);
          } else {
            node = await this.#newLink(params);
          }
        }
        this.#cache.set(path, node);
        return node;
      }
      #newNode(options) {
        const { parent, realpath: realpath2 } = options;
        if (!parent) {
          this.#topNodes.add(realpath2);
        }
        return new Node(options);
      }
      async #newLink(options) {
        const { realpath: realpath2 } = options;
        this.#topNodes.add(realpath2);
        const target = this.#cache.get(realpath2);
        const link = new Link({ ...options, target });
        if (!target) {
          this.#cache.set(realpath2, link.target);
          await this.#loadFSTree(link.target);
        }
        return link;
      }
      async #loadFSTree(node) {
        const did = this.#actualTreeLoaded;
        if (!node.isLink && !did.has(node.target.realpath)) {
          did.add(node.target.realpath);
          await this.#loadFSChildren(node.target);
          return Promise.all(
            [...node.target.children.entries()].filter(([, kid]) => !did.has(kid.realpath)).map(([, kid]) => this.#loadFSTree(kid))
          );
        }
      }
      // create child nodes for all the entries in node_modules
      // and attach them to the node as a parent
      async #loadFSChildren(node) {
        const nm = resolve(node.realpath, "node_modules");
        try {
          const kids = await readdirScoped(nm).then((paths) => paths.map((p) => p.replace(/\\/g, "/")));
          return Promise.all(
            // ignore . dirs and retired scoped package folders
            kids.filter((kid) => !/^(@[^/]+\/)?\./.test(kid)).filter((kid) => this.#filter(node, kid)).map((kid) => this.#loadFSNode({
              parent: node,
              path: resolve(nm, kid)
            }))
          );
        } catch {
        }
      }
      async #findMissingEdges() {
        const nmContents = /* @__PURE__ */ new Map();
        const tree = this.#actualTree;
        for (const node of tree.inventory.values()) {
          const ancestor = ancestorPath(node.realpath, this.path);
          const depPromises = [];
          for (const [name, edge] of node.edgesOut.entries()) {
            const notMissing = !edge.missing && !(edge.to && (edge.to.dummy || edge.to.parent !== node));
            if (notMissing) {
              continue;
            }
            for (const p of walkUp(dirname(node.realpath))) {
              if (ancestor && /^\.\.(?:[\\/]|$)/.test(relative(ancestor, p))) {
                break;
              }
              let entries;
              if (!nmContents.has(p)) {
                entries = await readdirScoped(p + "/node_modules").catch(() => []).then((paths) => paths.map((p2) => p2.replace(/\\/g, "/")));
                nmContents.set(p, entries);
              } else {
                entries = nmContents.get(p);
              }
              if (!entries.includes(name)) {
                continue;
              }
              let d;
              if (!this.#cache.has(p)) {
                d = new Node({ path: p, root: node.root, dummy: true });
                this.#cache.set(p, d);
              } else {
                d = this.#cache.get(p);
              }
              if (d.dummy) {
                const depPath = normalize(`${p}/node_modules/${name}`);
                const cached = this.#cache.get(depPath);
                if (!cached || cached.dummy) {
                  depPromises.push(this.#loadFSNode({
                    path: depPath,
                    root: node.root,
                    parent: d
                  }).then((node2) => this.#loadFSTree(node2)));
                }
              }
              break;
            }
          }
          await Promise.all(depPromises);
        }
      }
    };
  }
});

// node_modules/@npmcli/arborist/lib/arborist/load-virtual.js
var require_load_virtual = __commonJS({
  "node_modules/@npmcli/arborist/lib/arborist/load-virtual.js"(exports2, module2) {
    var mapWorkspaces = require_lib14();
    var { resolve } = require("node:path");
    var nameFromFolder = require_lib2();
    var consistentResolve = require_consistent_resolve();
    var Shrinkwrap = require_shrinkwrap();
    var Node = require_node5();
    var Link = require_link();
    var relpath = require_relpath();
    var calcDepFlags = require_calc_dep_flags();
    var rpj = require_lib36();
    var treeCheck = require_tree_check();
    var flagsSuspect = Symbol.for("flagsSuspect");
    var setWorkspaces = Symbol.for("setWorkspaces");
    module2.exports = (cls) => class VirtualLoader extends cls {
      #rootOptionProvided;
      constructor(options) {
        super(options);
        this.virtualTree = options.virtualTree;
        this[flagsSuspect] = false;
      }
      // public method
      async loadVirtual(options = {}) {
        if (this.virtualTree) {
          return this.virtualTree;
        }
        options = { ...this.options, ...options };
        if (options.root && options.root.meta) {
          await this.#loadFromShrinkwrap(options.root.meta, options.root);
          return treeCheck(this.virtualTree);
        }
        const s = await Shrinkwrap.load({
          path: this.path,
          lockfileVersion: this.options.lockfileVersion,
          resolveOptions: this.options
        });
        if (!s.loadedFromDisk && !options.root) {
          const er = new Error("loadVirtual requires existing shrinkwrap file");
          throw Object.assign(er, { code: "ENOLOCK" });
        }
        const {
          root = await this.#loadRoot(s)
        } = options;
        this.#rootOptionProvided = options.root;
        await this.#loadFromShrinkwrap(s, root);
        root.assertRootOverrides();
        return treeCheck(this.virtualTree);
      }
      async #loadRoot(s) {
        const pj = this.path + "/package.json";
        const pkg = await rpj(pj).catch(() => s.data.packages[""]) || {};
        return this[setWorkspaces](this.#loadNode("", pkg, true));
      }
      async #loadFromShrinkwrap(s, root) {
        if (!this.#rootOptionProvided) {
          root.extraneous = false;
          root.dev = false;
          root.optional = false;
          root.devOptional = false;
          root.peer = false;
        } else {
          this[flagsSuspect] = true;
        }
        this.#checkRootEdges(s, root);
        root.meta = s;
        this.virtualTree = root;
        const { links, nodes } = this.#resolveNodes(s, root);
        await this.#resolveLinks(links, nodes);
        if (!(s.originalLockfileVersion >= 2)) {
          this.#assignBundles(nodes);
        }
        if (this[flagsSuspect]) {
          for (const node of nodes.values()) {
            if (node.isRoot || node === this.#rootOptionProvided) {
              continue;
            }
            node.extraneous = true;
            node.dev = true;
            node.optional = true;
            node.devOptional = true;
            node.peer = true;
          }
          calcDepFlags(this.virtualTree, !this.#rootOptionProvided);
        }
        return root;
      }
      // check the lockfile deps, and see if they match.  if they do not
      // then we have to reset dep flags at the end.  for example, if the
      // user manually edits their package.json file, then we need to know
      // that the idealTree is no longer entirely trustworthy.
      #checkRootEdges(s, root) {
        if (!s.loadedFromDisk || s.ancientLockfile) {
          return;
        }
        const lock = s.get("");
        const prod = lock.dependencies || {};
        const dev = lock.devDependencies || {};
        const optional = lock.optionalDependencies || {};
        const peer = lock.peerDependencies || {};
        const peerOptional = {};
        if (lock.peerDependenciesMeta) {
          for (const [name, meta] of Object.entries(lock.peerDependenciesMeta)) {
            if (meta.optional && peer[name] !== void 0) {
              peerOptional[name] = peer[name];
              delete peer[name];
            }
          }
        }
        for (const name of Object.keys(optional)) {
          delete prod[name];
        }
        const lockWS = {};
        const workspaces = mapWorkspaces.virtual({
          cwd: this.path,
          lockfile: s.data
        });
        for (const [name, path] of workspaces.entries()) {
          lockWS[name] = `file:${path}`;
        }
        const rootNames = new Set(root.edgesOut.keys());
        const lockByType = { dev, optional, peer, peerOptional, prod, workspace: lockWS };
        for (const type in lockByType) {
          const deps = lockByType[type];
          for (const name in deps) {
            const edge = root.edgesOut.get(name);
            if (!edge || edge.type !== type || edge.spec !== deps[name]) {
              return this[flagsSuspect] = true;
            }
            rootNames.delete(name);
          }
        }
        if (rootNames.size) {
          return this[flagsSuspect] = true;
        }
      }
      // separate out link metadatas, and create Node objects for nodes
      #resolveNodes(s, root) {
        const links = /* @__PURE__ */ new Map();
        const nodes = /* @__PURE__ */ new Map([["", root]]);
        for (const [location, meta] of Object.entries(s.data.packages)) {
          if (!location) {
            continue;
          }
          if (meta.link) {
            links.set(location, meta);
          } else {
            nodes.set(location, this.#loadNode(location, meta));
          }
        }
        return { links, nodes };
      }
      // links is the set of metadata, and nodes is the map of non-Link nodes
      // Set the targets to nodes in the set, if we have them (we might not)
      async #resolveLinks(links, nodes) {
        for (const [location, meta] of links.entries()) {
          const targetPath = resolve(this.path, meta.resolved);
          const targetLoc = relpath(this.path, targetPath);
          const target = nodes.get(targetLoc);
          const link = this.#loadLink(location, targetLoc, target, meta);
          nodes.set(location, link);
          nodes.set(targetLoc, link.target);
          if (!link.target.parent) {
            const pj = link.realpath + "/package.json";
            const pkg = await rpj(pj).catch(() => null);
            if (pkg) {
              link.target.package = pkg;
            }
          }
        }
      }
      #assignBundles(nodes) {
        for (const [location, node] of nodes) {
          if (!location || node.isLink && !node.target.location) {
            continue;
          }
          const { name, parent, package: { inBundle } } = node;
          if (!parent) {
            continue;
          }
          const { package: ppkg } = parent;
          const { inBundle: parentBundled } = ppkg;
          if (inBundle && !parentBundled && parent.edgesOut.has(node.name)) {
            if (!ppkg.bundleDependencies) {
              ppkg.bundleDependencies = [name];
            } else {
              ppkg.bundleDependencies.push(name);
            }
          }
        }
      }
      #loadNode(location, sw, loadOverrides) {
        const p = this.virtualTree ? this.virtualTree.realpath : this.path;
        const path = resolve(p, location);
        if (!sw.name) {
          sw.name = nameFromFolder(path);
        }
        const dev = sw.dev;
        const optional = sw.optional;
        const devOptional = dev || optional || sw.devOptional;
        const peer = sw.peer;
        const node = new Node({
          installLinks: this.installLinks,
          legacyPeerDeps: this.legacyPeerDeps,
          root: this.virtualTree,
          path,
          realpath: path,
          integrity: sw.integrity,
          resolved: consistentResolve(sw.resolved, this.path, path),
          pkg: sw,
          ideallyInert: sw.ideallyInert,
          hasShrinkwrap: sw.hasShrinkwrap,
          dev,
          optional,
          devOptional,
          peer,
          loadOverrides
        });
        node.extraneous = !!sw.extraneous;
        node.devOptional = !!(sw.devOptional || sw.dev || sw.optional);
        node.peer = !!sw.peer;
        node.optional = !!sw.optional;
        node.dev = !!sw.dev;
        return node;
      }
      #loadLink(location, targetLoc, target) {
        const path = resolve(this.path, location);
        const link = new Link({
          installLinks: this.installLinks,
          legacyPeerDeps: this.legacyPeerDeps,
          path,
          realpath: resolve(this.path, targetLoc),
          target,
          pkg: target && target.package
        });
        link.extraneous = target.extraneous;
        link.devOptional = target.devOptional;
        link.peer = target.peer;
        link.optional = target.optional;
        link.dev = target.dev;
        return link;
      }
    };
  }
});

// node_modules/promise-all-reject-late/index.js
var require_promise_all_reject_late = __commonJS({
  "node_modules/promise-all-reject-late/index.js"(exports2, module2) {
    var allSettled = Promise.allSettled ? (promises) => Promise.allSettled(promises) : (promises) => {
      const reflections = [];
      for (let i = 0; i < promises.length; i++) {
        reflections[i] = Promise.resolve(promises[i]).then((value) => ({
          status: "fulfilled",
          value
        }), (reason) => ({
          status: "rejected",
          reason
        }));
      }
      return Promise.all(reflections);
    };
    module2.exports = (promises) => allSettled(promises).then((results) => {
      let er = null;
      const ret = new Array(results.length);
      results.forEach((result, i) => {
        if (result.status === "rejected")
          throw result.reason;
        else
          ret[i] = result.value;
      });
      return ret;
    });
  }
});

// node_modules/@npmcli/arborist/lib/arborist/rebuild.js
var require_rebuild = __commonJS({
  "node_modules/@npmcli/arborist/lib/arborist/rebuild.js"(exports2, module2) {
    var localeCompare = require_string_locale_compare()("en");
    var { depth: dfwalk } = require_lib();
    var promiseAllRejectLate = require_promise_all_reject_late();
    var rpj = require_lib36();
    var binLinks = require_lib40();
    var runScript = require_run_script();
    var { callLimit: promiseCallLimit } = require_commonjs7();
    var { resolve } = require("node:path");
    var { isNodeGypPackage, defaultGypInstallScript } = require_lib25();
    var { log, time } = require_lib4();
    var boolEnv = (b) => b ? "1" : "";
    var sortNodes = (a, b) => a.depth - b.depth || localeCompare(a.path, b.path);
    var _checkBins = Symbol.for("checkBins");
    var _handleOptionalFailure = Symbol.for("handleOptionalFailure");
    var _trashList = Symbol.for("trashList");
    module2.exports = (cls) => class Builder extends cls {
      #doHandleOptionalFailure;
      #oldMeta = null;
      #queues;
      constructor(options) {
        super(options);
        this.scriptsRun = /* @__PURE__ */ new Set();
        this.#resetQueues();
      }
      async rebuild({ nodes, handleOptionalFailure = false } = {}) {
        if (this.options.ignoreScripts && !this.options.binLinks) {
          return;
        }
        this.#doHandleOptionalFailure = handleOptionalFailure;
        if (!nodes) {
          nodes = await this.#loadDefaultNodes();
        }
        const timeEnd = time.start("build");
        const {
          depNodes,
          linkNodes
        } = this.#retrieveNodesByType(nodes);
        await this.#build(depNodes, {});
        if (linkNodes.size) {
          this.#resetQueues();
          await this.#build(linkNodes, { type: "links" });
        }
        timeEnd();
      }
      // if we don't have a set of nodes, then just rebuild
      // the actual tree on disk.
      async #loadDefaultNodes() {
        let nodes;
        const tree = await this.loadActual();
        let filterSet;
        if (!this.options.workspacesEnabled) {
          filterSet = this.excludeWorkspacesDependencySet(tree);
          nodes = tree.inventory.filter(
            (node) => filterSet.has(node) || node.isProjectRoot
          );
        } else if (this.options.workspaces.length) {
          filterSet = this.workspaceDependencySet(
            tree,
            this.options.workspaces,
            this.options.includeWorkspaceRoot
          );
          nodes = tree.inventory.filter((node) => filterSet.has(node));
        } else {
          nodes = tree.inventory.values();
        }
        return nodes;
      }
      #retrieveNodesByType(nodes) {
        const depNodes = /* @__PURE__ */ new Set();
        const linkNodes = /* @__PURE__ */ new Set();
        const storeNodes = /* @__PURE__ */ new Set();
        for (const node of nodes) {
          if (node.isStoreLink) {
            storeNodes.add(node);
          } else if (node.isLink) {
            linkNodes.add(node);
          } else {
            depNodes.add(node);
          }
        }
        for (const node of storeNodes) {
          depNodes.add(node);
        }
        if (!this.options.global) {
          for (const node of linkNodes) {
            depNodes.delete(node.target);
          }
        }
        return {
          depNodes,
          linkNodes
        };
      }
      #resetQueues() {
        this.#queues = {
          preinstall: [],
          install: [],
          postinstall: [],
          prepare: [],
          bin: []
        };
      }
      async #build(nodes, { type = "deps" }) {
        const timeEnd = time.start(`build:${type}`);
        await this.#buildQueues(nodes);
        if (!this.options.ignoreScripts) {
          await this.#runScripts("preinstall");
        }
        if (type === "links") {
          if (!this.options.ignoreScripts) {
            await this.#runScripts("prepare");
          }
        }
        if (this.options.binLinks) {
          await this.#linkAllBins();
        }
        if (!this.options.ignoreScripts) {
          await this.#runScripts("install");
          await this.#runScripts("postinstall");
        }
        timeEnd();
      }
      async #buildQueues(nodes) {
        const timeEnd = time.start("build:queue");
        const set = /* @__PURE__ */ new Set();
        const promises = [];
        for (const node of nodes) {
          promises.push(this.#addToBuildSet(node, set));
          if (this.options.rebuildBundle !== false) {
            const bd = node.package.bundleDependencies;
            if (bd && bd.length) {
              dfwalk({
                tree: node,
                leave: (node2) => promises.push(this.#addToBuildSet(node2, set)),
                getChildren: (node2) => [...node2.children.values()],
                filter: (node2) => node2.inBundle
              });
            }
          }
        }
        await promiseAllRejectLate(promises);
        const queue = [...set].sort(sortNodes);
        for (const node of queue) {
          const { package: { bin, scripts = {} } } = node.target;
          const { preinstall, install, postinstall, prepare } = scripts;
          const tests = { bin, preinstall, install, postinstall, prepare };
          for (const [key, has] of Object.entries(tests)) {
            if (has) {
              this.#queues[key].push(node);
            }
          }
        }
        timeEnd();
      }
      async [_checkBins](node) {
        if (!node.globalTop || this.options.force) {
          return;
        }
        const { path, package: pkg } = node;
        await binLinks.checkBins({ pkg, path, top: true, global: true });
      }
      async #addToBuildSet(node, set, refreshed = false) {
        if (set.has(node)) {
          return;
        }
        if (this.#oldMeta === null) {
          const { root: { meta } } = node;
          this.#oldMeta = meta && meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2);
        }
        const { package: pkg, hasInstallScript } = node.target;
        const { gypfile, bin, scripts = {} } = pkg;
        const { preinstall, install, postinstall, prepare } = scripts;
        const anyScript = preinstall || install || postinstall || prepare;
        if (!refreshed && !anyScript && (hasInstallScript || this.#oldMeta)) {
          set.add(node);
          const pkg2 = await rpj(node.path + "/package.json").catch(() => ({}));
          set.delete(node);
          const { scripts: scripts2 = {} } = pkg2;
          node.package.scripts = scripts2;
          return this.#addToBuildSet(node, set, true);
        }
        const isGyp = gypfile !== false && !install && !preinstall && await isNodeGypPackage(node.path);
        if (bin || preinstall || install || postinstall || prepare || isGyp) {
          if (bin) {
            await this[_checkBins](node);
          }
          if (isGyp) {
            scripts.install = defaultGypInstallScript;
            node.package.scripts = scripts;
          }
          set.add(node);
        }
      }
      async #runScripts(event) {
        const queue = this.#queues[event];
        if (!queue.length) {
          return;
        }
        const timeEnd = time.start(`build:run:${event}`);
        const stdio = this.options.foregroundScripts ? "inherit" : "pipe";
        const limit = this.options.foregroundScripts ? 1 : void 0;
        await promiseCallLimit(queue.map((node) => async () => {
          const {
            path,
            integrity,
            resolved,
            optional,
            peer,
            dev,
            devOptional,
            package: pkg,
            location,
            isStoreLink
          } = node.target;
          if (this[_trashList].has(path) || isStoreLink) {
            return;
          }
          const timeEndLocation = time.start(`build:run:${event}:${location}`);
          log.info("run", pkg._id, event, location, pkg.scripts[event]);
          const env = {
            npm_package_resolved: resolved,
            npm_package_integrity: integrity,
            npm_package_json: resolve(path, "package.json"),
            npm_package_optional: boolEnv(optional),
            npm_package_dev: boolEnv(dev),
            npm_package_peer: boolEnv(peer),
            npm_package_dev_optional: boolEnv(devOptional && !dev && !optional)
          };
          const runOpts = {
            event,
            path,
            pkg,
            stdio,
            env,
            scriptShell: this.options.scriptShell
          };
          const p = runScript(runOpts).catch((er) => {
            const { code, signal } = er;
            log.info("run", pkg._id, event, { code, signal });
            throw er;
          }).then(({ args, code, signal, stdout, stderr }) => {
            this.scriptsRun.add({
              pkg,
              path,
              event,
              // I do not know why this needs to be on THIS line but refactoring
              // this function would be quite a process
              // eslint-disable-next-line promise/always-return
              cmd: args && args[args.length - 1],
              env,
              code,
              signal,
              stdout,
              stderr
            });
            log.info("run", pkg._id, event, { code, signal });
          });
          await (this.#doHandleOptionalFailure ? this[_handleOptionalFailure](node, p) : p);
          timeEndLocation();
        }), { limit });
        timeEnd();
      }
      async #linkAllBins() {
        const queue = this.#queues.bin;
        if (!queue.length) {
          return;
        }
        const timeEnd = time.start("build:link");
        const promises = [];
        for (const node of queue.sort(sortNodes)) {
          promises.push(this.#createBinLinks(node));
        }
        await promiseAllRejectLate(promises);
        timeEnd();
      }
      async #createBinLinks(node) {
        if (this[_trashList].has(node.path)) {
          return;
        }
        const timeEnd = time.start(`build:link:${node.location}`);
        const p = binLinks({
          pkg: node.package,
          path: node.path,
          top: !!(node.isTop || node.globalTop),
          force: this.options.force,
          global: !!node.globalTop
        });
        await (this.#doHandleOptionalFailure ? this[_handleOptionalFailure](node, p) : p);
        timeEnd();
      }
    };
  }
});

// node_modules/@npmcli/arborist/lib/signals.js
var require_signals2 = __commonJS({
  "node_modules/@npmcli/arborist/lib/signals.js"(exports2, module2) {
    var platform = global.__ARBORIST_FAKE_PLATFORM__ || process.platform;
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (platform !== "win32") {
      module2.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (platform === "linux") {
      module2.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  }
});

// node_modules/@npmcli/arborist/lib/signal-handling.js
var require_signal_handling = __commonJS({
  "node_modules/@npmcli/arborist/lib/signal-handling.js"(exports2, module2) {
    var signals = require_signals2();
    module2.exports = Object.assign((fn) => setup(fn), { process });
    var setup = (fn) => {
      const { process: process2 } = module2.exports;
      const sigListeners = { loaded: false };
      const unload = () => {
        if (!sigListeners.loaded) {
          return;
        }
        for (const sig of signals) {
          try {
            process2.removeListener(sig, sigListeners[sig]);
          } catch {
          }
        }
        process2.removeListener("beforeExit", onBeforeExit);
        sigListeners.loaded = false;
      };
      const onBeforeExit = () => {
        unload();
        process2.kill(process2.pid, signalReceived);
        setTimeout(() => {
        }, 500);
      };
      let signalReceived = null;
      const listener = (sig, fn2) => () => {
        signalReceived = sig;
        unload();
        if (process2.listeners(sig).length < 1) {
          process2.once("beforeExit", onBeforeExit);
        }
        fn2({ signal: sig });
      };
      for (const sig of signals) {
        sigListeners[sig] = listener(sig, fn);
        const max = process2.getMaxListeners();
        try {
          const { length } = process2.listeners(sig);
          if (length >= max) {
            process2.setMaxListeners(length + 1);
          }
          process2.on(sig, sigListeners[sig]);
        } catch {
        }
      }
      sigListeners.loaded = true;
      return unload;
    };
  }
});

// node_modules/@npmcli/arborist/lib/diff.js
var require_diff2 = __commonJS({
  "node_modules/@npmcli/arborist/lib/diff.js"(exports2, module2) {
    var { depth } = require_lib();
    var { existsSync } = require("node:fs");
    var ssri = require_lib15();
    var Diff = class _Diff {
      constructor({ actual, ideal, filterSet, shrinkwrapInflated }) {
        this.filterSet = filterSet;
        this.shrinkwrapInflated = shrinkwrapInflated;
        this.children = [];
        this.actual = actual;
        this.ideal = ideal;
        if (this.ideal) {
          this.resolved = this.ideal.resolved;
          this.integrity = this.ideal.integrity;
        }
        this.action = getAction(this);
        this.parent = null;
        this.leaves = [];
        this.unchanged = [];
        this.removed = [];
      }
      static calculate({
        actual,
        ideal,
        filterNodes = [],
        shrinkwrapInflated = /* @__PURE__ */ new Set()
      }) {
        const filterSet = /* @__PURE__ */ new Set();
        const extraneous = /* @__PURE__ */ new Set();
        for (const filterNode of filterNodes) {
          const { root } = filterNode;
          if (root !== ideal && root !== actual) {
            throw new Error("invalid filterNode: outside idealTree/actualTree");
          }
          const rootTarget = root.target;
          const edge = [...rootTarget.edgesOut.values()].filter((e) => {
            return e.to && (e.to === filterNode || e.to.target === filterNode);
          })[0];
          filterSet.add(root);
          filterSet.add(rootTarget);
          filterSet.add(ideal);
          filterSet.add(actual);
          if (edge && edge.to) {
            filterSet.add(edge.to);
            filterSet.add(edge.to.target);
          }
          filterSet.add(filterNode);
          depth({
            tree: filterNode,
            visit: (node) => filterSet.add(node),
            getChildren: (node) => {
              node = node.target;
              const loc = node.location;
              const idealNode = ideal.inventory.get(loc);
              const ideals = !idealNode ? [] : [...idealNode.edgesOut.values()].filter((e) => e.to).map((e) => e.to);
              const actualNode = actual.inventory.get(loc);
              const actuals = !actualNode ? [] : [...actualNode.edgesOut.values()].filter((e) => e.to).map((e) => e.to);
              if (actualNode) {
                for (const child of actualNode.children.values()) {
                  if (child.extraneous) {
                    extraneous.add(child);
                  }
                }
              }
              return ideals.concat(actuals);
            }
          });
        }
        for (const extra of extraneous) {
          filterSet.add(extra);
        }
        return depth({
          tree: new _Diff({ actual, ideal, filterSet, shrinkwrapInflated }),
          getChildren,
          leave
        });
      }
    };
    var getAction = ({ actual, ideal }) => {
      if (!ideal) {
        return "REMOVE";
      }
      if (!actual) {
        return ideal.inDepBundle ? null : "ADD";
      }
      if (ideal.isRoot && actual.isRoot) {
        return null;
      }
      if (ideal.version !== actual.version) {
        return "CHANGE";
      }
      const binsExist = ideal.binPaths.every((path) => existsSync(path));
      const noIntegrity = !ideal.integrity && !actual.integrity;
      const noResolved = !ideal.resolved && !actual.resolved;
      const resolvedMatch = ideal.resolved && ideal.resolved === actual.resolved;
      if (noIntegrity && binsExist && (resolvedMatch || noResolved)) {
        return null;
      }
      const integrityMismatch = !ideal.integrity || !actual.integrity || !ssri.parse(ideal.integrity).match(actual.integrity);
      if (integrityMismatch || !binsExist) {
        return "CHANGE";
      }
      return null;
    };
    var allChildren = (node) => {
      if (!node) {
        return /* @__PURE__ */ new Map();
      }
      if (node.isRoot && node.isLink) {
        return allChildren(node.target);
      }
      const kids = /* @__PURE__ */ new Map();
      for (const n of [node, ...node.fsChildren]) {
        for (const kid of n.children.values()) {
          kids.set(kid.path, kid);
        }
      }
      return kids;
    };
    var getChildren = (diff) => {
      const children = [];
      const {
        actual,
        ideal,
        unchanged,
        removed,
        filterSet,
        shrinkwrapInflated
      } = diff;
      const actualKids = allChildren(actual);
      const idealKids = allChildren(ideal);
      if (ideal && ideal.hasShrinkwrap && !shrinkwrapInflated.has(ideal)) {
        diff.leaves.push(diff);
        return children;
      }
      const paths = /* @__PURE__ */ new Set([...actualKids.keys(), ...idealKids.keys()]);
      for (const path of paths) {
        const actual2 = actualKids.get(path);
        const ideal2 = idealKids.get(path);
        diffNode({
          actual: actual2,
          ideal: ideal2,
          children,
          unchanged,
          removed,
          filterSet,
          shrinkwrapInflated
        });
      }
      if (diff.leaves && !children.length) {
        diff.leaves.push(diff);
      }
      return children;
    };
    var diffNode = ({
      actual,
      ideal,
      children,
      unchanged,
      removed,
      filterSet,
      shrinkwrapInflated
    }) => {
      if (filterSet.size && !(filterSet.has(ideal) || filterSet.has(actual))) {
        return;
      }
      const action = getAction({ actual, ideal });
      if (action || !shrinkwrapInflated.has(ideal) && ideal.hasShrinkwrap) {
        if (action === "REMOVE") {
          removed.push(actual);
        }
        children.push(new Diff({ actual, ideal, filterSet, shrinkwrapInflated }));
      } else {
        unchanged.push(ideal);
        const bd = ideal.package.bundleDependencies;
        if (actual && bd && bd.length) {
          const bundledChildren = [];
          for (const node of actual.children.values()) {
            if (node.inBundle) {
              bundledChildren.push(node);
            }
          }
          for (const node of bundledChildren) {
            node.parent = ideal;
          }
        }
        children.push(...getChildren({
          actual,
          ideal,
          unchanged,
          removed,
          filterSet,
          shrinkwrapInflated
        }));
      }
    };
    var leave = (diff, children) => {
      children.forEach((kid) => {
        kid.parent = diff;
        diff.leaves.push(...kid.leaves);
        diff.unchanged.push(...kid.unchanged);
        diff.removed.push(...kid.removed);
      });
      diff.children = children;
      return diff;
    };
    module2.exports = Diff;
  }
});

// node_modules/@npmcli/arborist/lib/retire-path.js
var require_retire_path = __commonJS({
  "node_modules/@npmcli/arborist/lib/retire-path.js"(exports2, module2) {
    var crypto = require("node:crypto");
    var { dirname, basename, resolve } = require("node:path");
    var pathSafeHash = (s) => crypto.createHash("sha1").update(s).digest("base64").replace(/[^a-zA-Z0-9]+/g, "").slice(0, 8);
    var retirePath = (from) => {
      const d = dirname(from);
      const b = basename(from);
      const hash = pathSafeHash(from);
      return resolve(d, `.${b}-${hash}`);
    };
    module2.exports = retirePath;
  }
});

// node_modules/@npmcli/arborist/lib/arborist/reify.js
var require_reify = __commonJS({
  "node_modules/@npmcli/arborist/lib/arborist/reify.js"(exports2, module2) {
    var onExit = require_signal_handling();
    var pacote = require_lib33();
    var AuditReport = require_audit_report();
    var { subset, intersects } = require_semver2();
    var npa = require_npa();
    var semver = require_semver2();
    var debug = require_debug2();
    var { walkUp } = require_commonjs8();
    var { log, time } = require_lib4();
    var rpj = require_lib36();
    var { dirname, resolve, relative, join } = require("node:path");
    var { depth: dfwalk } = require_lib();
    var {
      lstat,
      mkdir,
      rm,
      symlink
    } = require("node:fs/promises");
    var { moveFile } = require_lib18();
    var PackageJson = require_lib13();
    var packageContents = require_lib22();
    var runScript = require_run_script();
    var { checkEngine, checkPlatform } = require_lib9();
    var treeCheck = require_tree_check();
    var relpath = require_relpath();
    var Diff = require_diff2();
    var retirePath = require_retire_path();
    var promiseAllRejectLate = require_promise_all_reject_late();
    var { callLimit: promiseCallLimit } = require_commonjs7();
    var optionalSet = require_optional_set();
    var calcDepFlags = require_calc_dep_flags();
    var { saveTypeMap, hasSubKey } = require_add_rm_pkg_deps();
    var Shrinkwrap = require_shrinkwrap();
    var { defaultLockfileVersion } = Shrinkwrap;
    var _retireShallowNodes = Symbol.for("retireShallowNodes");
    var _loadBundlesAndUpdateTrees = Symbol.for("loadBundlesAndUpdateTrees");
    var _submitQuickAudit = Symbol("submitQuickAudit");
    var _addOmitsToTrashList = Symbol("addOmitsToTrashList");
    var _unpackNewModules = Symbol.for("unpackNewModules");
    var _build = Symbol.for("build");
    var _trashList = Symbol.for("trashList");
    var _handleOptionalFailure = Symbol.for("handleOptionalFailure");
    var _loadTrees = Symbol.for("loadTrees");
    var _checkBins = Symbol.for("checkBins");
    var _diffTrees = Symbol.for("diffTrees");
    var _createSparseTree = Symbol.for("createSparseTree");
    var _loadShrinkwrapsAndUpdateTrees = Symbol.for("loadShrinkwrapsAndUpdateTrees");
    var _reifyNode = Symbol.for("reifyNode");
    var _updateAll = Symbol.for("updateAll");
    var _updateNames = Symbol.for("updateNames");
    var _moveContents = Symbol.for("moveContents");
    var _moveBackRetiredUnchanged = Symbol.for("moveBackRetiredUnchanged");
    var _removeTrash = Symbol.for("removeTrash");
    var _renamePath = Symbol.for("renamePath");
    var _rollbackRetireShallowNodes = Symbol.for("rollbackRetireShallowNodes");
    var _rollbackCreateSparseTree = Symbol.for("rollbackCreateSparseTree");
    var _rollbackMoveBackRetiredUnchanged = Symbol.for("rollbackMoveBackRetiredUnchanged");
    var _saveIdealTree = Symbol.for("saveIdealTree");
    var _reifyPackages = Symbol.for("reifyPackages");
    var _resolvedAdd = Symbol.for("resolvedAdd");
    var _usePackageLock = Symbol.for("usePackageLock");
    var _addNodeToTrashList = Symbol.for("addNodeToTrashList");
    var _createIsolatedTree = Symbol.for("createIsolatedTree");
    module2.exports = (cls) => class Reifier extends cls {
      #bundleMissing = /* @__PURE__ */ new Set();
      // child nodes we'd EXPECT to be included in a bundle, but aren't
      #bundleUnpacked = /* @__PURE__ */ new Set();
      // the nodes we unpack to read their bundles
      #dryRun;
      #nmValidated = /* @__PURE__ */ new Set();
      #omitDev;
      #omitPeer;
      #omitOptional;
      #retiredPaths = {};
      #retiredUnchanged = {};
      #savePrefix;
      #shrinkwrapInflated = /* @__PURE__ */ new Set();
      #sparseTreeDirs = /* @__PURE__ */ new Set();
      #sparseTreeRoots = /* @__PURE__ */ new Set();
      constructor(options) {
        super(options);
        this[_trashList] = /* @__PURE__ */ new Set();
      }
      // public method
      async reify(options = {}) {
        const linked = (options.installStrategy || this.options.installStrategy) === "linked";
        if (this.options.packageLockOnly && this.options.global) {
          const er = new Error("cannot generate lockfile for global packages");
          er.code = "ESHRINKWRAPGLOBAL";
          throw er;
        }
        const omit = new Set(options.omit || []);
        this.#omitDev = omit.has("dev");
        this.#omitOptional = omit.has("optional");
        this.#omitPeer = omit.has("peer");
        this.addTracker("reify");
        const timeEnd = time.start("reify");
        if (!this.options.packageLockOnly && !this.options.dryRun) {
          await mkdir(resolve(this.path), { recursive: true });
          await this.#validateNodeModules(resolve(this.path, "node_modules"));
        }
        await this[_loadTrees](options);
        const oldTree = this.idealTree;
        if (linked) {
          log.warn("reify", 'The "linked" install strategy is EXPERIMENTAL and may contain bugs.');
          this.idealTree = await this[_createIsolatedTree]();
        }
        await this[_diffTrees]();
        await this[_reifyPackages]();
        if (linked) {
          this.idealTree = oldTree;
        }
        await this[_saveIdealTree](options);
        for (const path of this[_trashList]) {
          const loc = relpath(this.idealTree.realpath, path);
          const node = this.idealTree.inventory.get(loc);
          if (node && node.root === this.idealTree && !node.ideallyInert) {
            node.parent = null;
          }
        }
        if (this.diff && this.diff.filterSet.size) {
          const reroot = /* @__PURE__ */ new Set();
          const { filterSet } = this.diff;
          const seen = /* @__PURE__ */ new Set();
          for (const [loc, ideal] of this.idealTree.inventory.entries()) {
            seen.add(loc);
            if (filterSet.has(ideal)) {
              continue;
            }
            const actual = this.actualTree.inventory.get(loc);
            if (!actual) {
              ideal.root = null;
            } else {
              if ([...actual.linksIn].some((link) => filterSet.has(link))) {
                seen.add(actual.location);
                continue;
              }
              const { realpath, isLink } = actual;
              if (isLink && ideal.isLink && ideal.realpath === realpath) {
                continue;
              } else {
                reroot.add(actual);
              }
            }
          }
          for (const [loc, actual] of this.actualTree.inventory.entries()) {
            if (seen.has(loc)) {
              continue;
            }
            seen.add(loc);
            if (filterSet.has(actual)) {
              continue;
            }
            reroot.add(actual);
          }
          for (const actual of reroot) {
            actual.root = this.idealTree;
          }
          for (const top of this.idealTree.tops) {
            if (top.linksIn.size === 0) {
              top.root = null;
            }
          }
          calcDepFlags(this.idealTree);
        }
        this.idealTree.meta.filename = this.idealTree.realpath + "/node_modules/.package-lock.json";
        this.idealTree.meta.hiddenLockfile = true;
        this.idealTree.meta.lockfileVersion = defaultLockfileVersion;
        if (this.actualTree) {
          for (const [loc, actual] of this.actualTree.inventory.entries()) {
            if (actual.ideallyInert) {
              const ideal = this.idealTree.inventory.get(loc);
              if (ideal) {
                ideal.ideallyInert = true;
              }
            }
          }
        }
        this.actualTree = this.idealTree;
        this.idealTree = null;
        if (!this.options.global) {
          await this.actualTree.meta.save();
          const ignoreScripts = !!this.options.ignoreScripts;
          if (!this.options.dryRun && !ignoreScripts && this.diff && this.diff.children.length) {
            const { path, package: pkg } = this.actualTree.target;
            const stdio = this.options.foregroundScripts ? "inherit" : "pipe";
            const { scripts = {} } = pkg;
            for (const event of ["predependencies", "dependencies", "postdependencies"]) {
              if (Object.prototype.hasOwnProperty.call(scripts, event)) {
                log.info("run", pkg._id, event, scripts[event]);
                await time.start(`reify:run:${event}`, () => runScript({
                  event,
                  path,
                  pkg,
                  stdio,
                  scriptShell: this.options.scriptShell
                }));
              }
            }
          }
        }
        this.auditReport = await this.auditReport;
        this.finishTracker("reify");
        timeEnd();
        return treeCheck(this.actualTree);
      }
      async [_reifyPackages]() {
        if (this.options.dryRun) {
          return;
        }
        if (this.options.packageLockOnly) {
          return this[_submitQuickAudit]();
        }
        let reifyTerminated = null;
        const removeHandler = onExit(({ signal }) => {
          removeHandler();
          reifyTerminated = Object.assign(new Error("process terminated"), {
            signal
          });
          return false;
        });
        const steps = [
          [_rollbackRetireShallowNodes, [
            _retireShallowNodes
          ]],
          [_rollbackCreateSparseTree, [
            _createSparseTree,
            _addOmitsToTrashList,
            _loadShrinkwrapsAndUpdateTrees,
            _loadBundlesAndUpdateTrees,
            _submitQuickAudit,
            _unpackNewModules
          ]],
          [_rollbackMoveBackRetiredUnchanged, [
            _moveBackRetiredUnchanged,
            _build
          ]]
        ];
        for (const [rollback, actions] of steps) {
          for (const action of actions) {
            try {
              await this[action]();
              if (reifyTerminated) {
                throw reifyTerminated;
              }
            } catch (er) {
              await this[rollback](er);
              throw er;
            }
          }
        }
        await this[_removeTrash]();
        if (reifyTerminated) {
          throw reifyTerminated;
        }
        removeHandler();
      }
      // when doing a local install, we load everything and figure it all out.
      // when doing a global install, we *only* care about the explicit requests.
      [_loadTrees](options) {
        const timeEnd = time.start("reify:loadTrees");
        const bitOpt = {
          ...options,
          complete: this.options.packageLockOnly || this.options.dryRun
        };
        if (this.options.packageLockOnly) {
          return this.buildIdealTree(bitOpt).then(timeEnd);
        }
        const actualOpt = this.options.global ? {
          ignoreMissing: true,
          global: true,
          filter: (node, kid) => {
            if (this.explicitRequests.size === 0 || !node.isProjectRoot) {
              return true;
            }
            if (this.idealTree.edgesOut.has(kid)) {
              return true;
            }
            const hasExplicit = [...this.explicitRequests].some((edge) => edge.name === kid);
            if (hasExplicit) {
              return true;
            }
            return false;
          }
        } : { ignoreMissing: true };
        if (!this.options.global) {
          return Promise.all([
            this.loadActual(actualOpt),
            this.buildIdealTree(bitOpt)
          ]).then(timeEnd);
        }
        return this.buildIdealTree(bitOpt).then(() => this.loadActual(actualOpt)).then(timeEnd);
      }
      [_diffTrees]() {
        if (this.options.packageLockOnly) {
          return;
        }
        const timeEnd = time.start("reify:diffTrees");
        const includeWorkspaces = this.options.workspacesEnabled;
        const includeRootDeps = !includeWorkspaces || this.options.includeWorkspaceRoot && this.options.workspaces.length > 0;
        const filterNodes = [];
        if (this.options.global && this.explicitRequests.size) {
          const idealTree = this.idealTree.target;
          const actualTree = this.actualTree.target;
          for (const { name } of this.explicitRequests) {
            const ideal = idealTree.children.get(name);
            if (ideal) {
              filterNodes.push(ideal);
            }
            const actual = actualTree.children.get(name);
            if (actual) {
              filterNodes.push(actual);
            }
          }
        } else {
          if (includeWorkspaces) {
            for (const ws of this.options.workspaces) {
              const ideal = this.idealTree.children.get(ws);
              if (ideal) {
                filterNodes.push(ideal);
              }
              const actual = this.actualTree.children.get(ws);
              if (actual) {
                filterNodes.push(actual);
              }
            }
          }
          if (includeRootDeps) {
            for (const tree of [this.idealTree, this.actualTree]) {
              for (const { type, to } of tree.edgesOut.values()) {
                if (type !== "workspace" && to) {
                  filterNodes.push(to);
                }
              }
            }
          }
        }
        this.diff = Diff.calculate({
          shrinkwrapInflated: this.#shrinkwrapInflated,
          filterNodes,
          actual: this.actualTree,
          ideal: this.idealTree
        });
        timeEnd();
      }
      // add the node and all its bins to the list of things to be
      // removed later on in the process.  optionally, also mark them
      // as a retired paths, so that we move them out of the way and
      // replace them when rolling back on failure.
      [_addNodeToTrashList](node, retire = false) {
        const paths = [node.path, ...node.binPaths];
        const moves = this.#retiredPaths;
        log.silly("reify", "mark", retire ? "retired" : "deleted", paths);
        for (const path of paths) {
          if (retire) {
            const retired = retirePath(path);
            moves[path] = retired;
            this[_trashList].add(retired);
          } else {
            this[_trashList].add(path);
          }
        }
      }
      // move aside the shallowest nodes in the tree that have to be
      // changed or removed, so that we can rollback if necessary.
      [_retireShallowNodes]() {
        const timeEnd = time.start("reify:retireShallow");
        const moves = this.#retiredPaths = {};
        for (const diff of this.diff.children) {
          if (diff.action === "CHANGE" || diff.action === "REMOVE") {
            this[_addNodeToTrashList](diff.actual, true);
          }
        }
        log.silly("reify", "moves", moves);
        const movePromises = Object.entries(moves).map(([from, to]) => this[_renamePath](from, to));
        return promiseAllRejectLate(movePromises).then(timeEnd);
      }
      [_renamePath](from, to, didMkdirp = false) {
        return moveFile(from, to).catch((er) => {
          if (er.code === "ENOENT") {
            return didMkdirp ? null : mkdir(dirname(to), { recursive: true }).then(() => this[_renamePath](from, to, true));
          } else if (er.code === "EEXIST") {
            return rm(to, { recursive: true, force: true }).then(() => moveFile(from, to));
          } else {
            throw er;
          }
        });
      }
      [_rollbackRetireShallowNodes](er) {
        const timeEnd = time.start("reify:rollback:retireShallow");
        const moves = this.#retiredPaths;
        const movePromises = Object.entries(moves).map(([from, to]) => this[_renamePath](to, from));
        return promiseAllRejectLate(movePromises).catch(() => {
        }).then(timeEnd).then(() => {
          throw er;
        });
      }
      // adding to the trash list will skip reifying, and delete them
      // if they are currently in the tree and otherwise untouched.
      [_addOmitsToTrashList]() {
        if (!this.#omitDev && !this.#omitOptional && !this.#omitPeer) {
          return;
        }
        const timeEnd = time.start("reify:trashOmits");
        for (const node of this.idealTree.inventory.values()) {
          const { top } = node;
          if (!top.isProjectRoot && !top.isWorkspace) {
            continue;
          }
          if (this.diff?.filterSet?.size && !this.diff.filterSet.has(top)) {
            continue;
          }
          if (node.peer && this.#omitPeer || node.dev && this.#omitDev || node.optional && this.#omitOptional || node.devOptional && this.#omitOptional && this.#omitDev) {
            this[_addNodeToTrashList](node);
          }
        }
        timeEnd();
      }
      [_createSparseTree]() {
        const timeEnd = time.start("reify:createSparse");
        const leaves = this.diff.leaves.filter((diff) => {
          return (diff.action === "ADD" || diff.action === "CHANGE") && !this.#sparseTreeDirs.has(diff.ideal.path) && !diff.ideal.isLink;
        }).map((diff) => diff.ideal);
        const dirsChecked = /* @__PURE__ */ new Set();
        return promiseAllRejectLate(leaves.map(async (node) => {
          if (node.ideallyInert) {
            return;
          }
          for (const d of walkUp(node.path)) {
            if (d === node.top.path) {
              break;
            }
            if (dirsChecked.has(d)) {
              continue;
            }
            dirsChecked.add(d);
            const st = await lstat(d).catch(() => null);
            if (st && !st.isDirectory()) {
              const retired = retirePath(d);
              this.#retiredPaths[d] = retired;
              this[_trashList].add(retired);
              await this[_renamePath](d, retired);
            }
          }
          this.#sparseTreeDirs.add(node.path);
          const made = await mkdir(node.path, { recursive: true });
          if (made) {
            this.#sparseTreeRoots.add(made);
          }
        })).then(timeEnd);
      }
      [_rollbackCreateSparseTree](er) {
        const timeEnd = time.start("reify:rollback:createSparse");
        const roots = this.#sparseTreeRoots;
        const failures = [];
        const targets = [...roots, ...Object.keys(this.#retiredPaths)];
        const unlinks = targets.map((path) => rm(path, { recursive: true, force: true }).catch((er2) => failures.push([path, er2])));
        return promiseAllRejectLate(unlinks).then(() => {
          if (failures.length) {
            log.warn("cleanup", "Failed to remove some directories", failures);
          }
        }).then(timeEnd).then(() => this[_rollbackRetireShallowNodes](er));
      }
      // shrinkwrap nodes define their dependency branches with a file, so
      // we need to unpack them, read that shrinkwrap file, and then update
      // the tree by calling loadVirtual with the node as the root.
      [_loadShrinkwrapsAndUpdateTrees]() {
        const seen = this.#shrinkwrapInflated;
        const shrinkwraps = this.diff.leaves.filter((d) => (d.action === "CHANGE" || d.action === "ADD" || !d.action) && d.ideal.hasShrinkwrap && !seen.has(d.ideal) && !this[_trashList].has(d.ideal.path));
        if (!shrinkwraps.length) {
          return;
        }
        const timeEnd = time.start("reify:loadShrinkwraps");
        const Arborist2 = this.constructor;
        return promiseAllRejectLate(shrinkwraps.map((diff) => {
          const node = diff.ideal;
          seen.add(node);
          return diff.action ? this[_reifyNode](node) : node;
        })).then((nodes) => promiseAllRejectLate(nodes.map((node) => new Arborist2({
          ...this.options,
          path: node.path
        }).loadVirtual({ root: node })))).then(() => this[_diffTrees]()).then(() => this[_createSparseTree]()).then(() => this[_addOmitsToTrashList]()).then(() => this[_loadShrinkwrapsAndUpdateTrees]()).then(timeEnd);
      }
      // create a symlink for Links, extract for Nodes
      // return the node object, since we usually want that
      // handle optional dep failures here
      // If node is in trash list, skip it
      // If reifying fails, and the node is optional, add it and its optionalSet
      // to the trash list
      // Always return the node.
      [_reifyNode](node) {
        if (this[_trashList].has(node.path)) {
          return node;
        }
        const timeEnd = time.start(`reifyNode:${node.location}`);
        this.addTracker("reify", node.name, node.location);
        const { npmVersion, nodeVersion, cpu, os, libc } = this.options;
        const p = Promise.resolve().then(async () => {
          if (node.optional) {
            checkEngine(node.package, npmVersion, nodeVersion, false);
            checkPlatform(node.package, false, { cpu, os, libc });
          }
          await this[_checkBins](node);
          await this.#extractOrLink(node);
          const { _id, deprecated } = node.package;
          if (deprecated) {
            log.warn("deprecated", `${_id}: ${deprecated}`);
          }
        });
        return this[_handleOptionalFailure](node, p).then(() => {
          this.finishTracker("reify", node.name, node.location);
          timeEnd();
          return node;
        });
      }
      // do not allow node_modules to be a symlink
      async #validateNodeModules(nm) {
        if (this.options.force || this.#nmValidated.has(nm)) {
          return;
        }
        const st = await lstat(nm).catch(() => null);
        if (!st || st.isDirectory()) {
          this.#nmValidated.add(nm);
          return;
        }
        log.warn("reify", "Removing non-directory", nm);
        await rm(nm, { recursive: true, force: true });
      }
      async #extractOrLink(node) {
        if (node.ideallyInert) {
          return;
        }
        const nm = resolve(node.parent.path, "node_modules");
        await this.#validateNodeModules(nm);
        if (!node.isLink) {
          let res = null;
          if (node.resolved) {
            const registryResolved = this.#registryResolved(node.resolved);
            if (registryResolved) {
              res = `${node.name}@${registryResolved}`;
            }
          } else if (node.package.name && node.version) {
            res = `${node.package.name}@${node.version}`;
          }
          if (!res) {
            const warning = "invalid or damaged lockfile detected\nplease re-try this operation once it completes\nso that the damage can be corrected, or perform\na fresh install with no lockfile if the problem persists.";
            log.warn("reify", warning);
            log.verbose("reify", "unrecognized node in tree", node.path);
            node.parent = null;
            node.fsParent = null;
            this[_addNodeToTrashList](node);
            return;
          }
          await debug(async () => {
            const st = await lstat(node.path).catch(() => null);
            if (st && !st.isDirectory()) {
              debug.log("unpacking into a non-directory", node);
              throw Object.assign(new Error("ENOTDIR: not a directory"), {
                code: "ENOTDIR",
                path: node.path
              });
            }
          });
          await pacote.extract(res, node.path, {
            ...this.options,
            resolved: node.resolved,
            integrity: node.integrity
          });
          if (node.isInStore) {
            const pkg = await rpj(join(node.path, "package.json"));
            node.package.scripts = pkg.scripts;
          }
          return;
        }
        await rm(node.path, { recursive: true, force: true });
        const dir = dirname(node.path);
        const target = node.realpath;
        const rel = relative(dir, target);
        await mkdir(dir, { recursive: true });
        return symlink(rel, node.path, "junction");
      }
      // if the node is optional, then the failure of the promise is nonfatal
      // just add it and its optional set to the trash list.
      [_handleOptionalFailure](node, p) {
        return (node.optional ? p.catch(() => {
          const set = optionalSet(node);
          for (node of set) {
            log.verbose("reify", "failed optional dependency", node.path);
            node.ideallyInert = true;
            this[_addNodeToTrashList](node);
          }
        }) : p).then(() => node);
      }
      #registryResolved(resolved) {
        try {
          const resolvedURL = new URL(resolved);
          if (this.options.replaceRegistryHost === resolvedURL.hostname || this.options.replaceRegistryHost === "always") {
            const registryURL = new URL(this.registry);
            resolvedURL.hostname = registryURL.hostname;
            resolvedURL.port = registryURL.port;
            return resolvedURL.toString();
          }
          return resolved;
        } catch (e) {
          return void 0;
        }
      }
      // bundles are *sort of* like shrinkwraps, in that the branch is defined
      // by the contents of the package.  however, in their case, rather than
      // shipping a virtual tree that must be reified, they ship an entire
      // reified actual tree that must be unpacked and not modified.
      [_loadBundlesAndUpdateTrees](depth = 0, bundlesByDepth) {
        let maxBundleDepth;
        if (!bundlesByDepth) {
          bundlesByDepth = /* @__PURE__ */ new Map();
          maxBundleDepth = -1;
          dfwalk({
            tree: this.diff,
            visit: (diff) => {
              const node = diff.ideal;
              if (!node) {
                return;
              }
              if (node.isProjectRoot) {
                return;
              }
              const { bundleDependencies } = node.package;
              if (bundleDependencies && bundleDependencies.length) {
                maxBundleDepth = Math.max(maxBundleDepth, node.depth);
                if (!bundlesByDepth.has(node.depth)) {
                  bundlesByDepth.set(node.depth, [node]);
                } else {
                  bundlesByDepth.get(node.depth).push(node);
                }
              }
            },
            getChildren: (diff) => diff.children
          });
          bundlesByDepth.set("maxBundleDepth", maxBundleDepth);
        } else {
          maxBundleDepth = bundlesByDepth.get("maxBundleDepth");
        }
        if (depth === 0) {
          time.start("reify:loadBundles");
        }
        if (depth > maxBundleDepth) {
          if (maxBundleDepth !== -1) {
            this.#pruneBundledMetadeps(bundlesByDepth);
            this[_diffTrees]();
          }
          time.end("reify:loadBundles");
          return;
        }
        const set = (bundlesByDepth.get(depth) || []).filter((node) => node.root === this.idealTree && node.target !== node.root && !this[_trashList].has(node.path));
        if (!set.length) {
          return this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth);
        }
        return promiseCallLimit(set.map((node) => {
          return () => {
            this.#bundleUnpacked.add(node);
            return this[_reifyNode](node);
          };
        }), { rejectLate: true }).then((nodes) => promiseAllRejectLate(nodes.map(async (node) => {
          const arb = new this.constructor({
            ...this.options,
            path: node.path
          });
          const notTransplanted = new Set(node.children.keys());
          await arb.loadActual({
            root: node,
            // don't transplant any sparse folders we created
            // loadActual will set node.package to {} for empty directories
            // if by chance there are some empty folders in the node_modules
            // tree for some other reason, then ok, ignore those too.
            transplantFilter: (node2) => {
              if (node2.package._id) {
                notTransplanted.delete(node2.name);
                return true;
              } else {
                return false;
              }
            }
          });
          for (const name of notTransplanted) {
            this.#bundleMissing.add(node.children.get(name));
          }
        }))).then(() => this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth));
      }
      // https://github.com/npm/cli/issues/1597#issuecomment-667639545
      #pruneBundledMetadeps(bundlesByDepth) {
        const bundleShadowed = /* @__PURE__ */ new Set();
        for (const bundles of bundlesByDepth.values()) {
          if (!Array.isArray(bundles)) {
            continue;
          }
          for (const node of bundles) {
            for (const name of node.children.keys()) {
              const shadow = node.parent.resolve(name);
              if (!shadow) {
                continue;
              }
              bundleShadowed.add(shadow);
              shadow.extraneous = true;
            }
          }
        }
        for (const shadow of bundleShadowed) {
          for (const shadDep of shadow.edgesOut.values()) {
            if (shadDep.to) {
              bundleShadowed.add(shadDep.to);
              shadDep.to.extraneous = true;
            }
          }
        }
        let changed;
        do {
          changed = false;
          for (const shadow of bundleShadowed) {
            for (const edge of shadow.edgesIn) {
              if (!bundleShadowed.has(edge.from)) {
                shadow.extraneous = false;
                bundleShadowed.delete(shadow);
                changed = true;
                break;
              }
            }
          }
        } while (changed);
        for (const shadow of bundleShadowed) {
          this[_addNodeToTrashList](shadow);
          shadow.root = null;
        }
      }
      async [_submitQuickAudit]() {
        if (this.options.audit === false) {
          this.auditReport = null;
          return;
        }
        const timeEnd = time.start("reify:audit");
        const options = { ...this.options };
        const tree = this.idealTree;
        if (this.options.workspaces.length) {
          options.filterSet = this.workspaceDependencySet(
            tree,
            this.options.workspaces,
            this.options.includeWorkspaceRoot
          );
        }
        this.auditReport = AuditReport.load(tree, options).then((res) => {
          timeEnd();
          return res;
        });
      }
      // ok!  actually unpack stuff into their target locations!
      // The sparse tree has already been created, so we walk the diff
      // kicking off each unpack job.  If any fail, we rm the sparse
      // tree entirely and try to put everything back where it was.
      [_unpackNewModules]() {
        const timeEnd = time.start("reify:unpack");
        const unpacks = [];
        dfwalk({
          tree: this.diff,
          visit: (diff) => {
            if (diff.action !== "CHANGE" && diff.action !== "ADD") {
              return;
            }
            const node = diff.ideal;
            const bd = this.#bundleUnpacked.has(node);
            const sw = this.#shrinkwrapInflated.has(node);
            const bundleMissing = this.#bundleMissing.has(node);
            const doUnpack = node && // can't unpack if removed!
            // root node already exists
            !node.isRoot && // already unpacked to read bundle
            !bd && // already unpacked to read sw
            !sw && // already unpacked by another dep's bundle
            (bundleMissing || !node.inDepBundle);
            if (doUnpack) {
              unpacks.push(this[_reifyNode](node));
            }
          },
          getChildren: (diff) => diff.children
        });
        return promiseAllRejectLate(unpacks).then(timeEnd);
      }
      // This is the part where we move back the unchanging nodes that were
      // the children of a node that did change.  If this fails, the rollback
      // is a three-step process.  First, we try to move the retired unchanged
      // nodes BACK to their retirement folders, then delete the sparse tree,
      // then move everything out of retirement.
      [_moveBackRetiredUnchanged]() {
        const timeEnd = time.start("reify:unretire");
        const moves = this.#retiredPaths;
        this.#retiredUnchanged = {};
        return promiseAllRejectLate(this.diff.children.map((diff) => {
          if (diff.action !== "CHANGE" && diff.action !== "REMOVE") {
            return;
          }
          const { path: realFolder } = diff.actual;
          const retireFolder = moves[realFolder];
          debug(() => {
            if (!retireFolder) {
              const er = new Error("trying to un-retire but not retired");
              throw Object.assign(er, {
                realFolder,
                retireFolder,
                actual: diff.actual,
                ideal: diff.ideal,
                action: diff.action
              });
            }
          });
          this.#retiredUnchanged[retireFolder] = [];
          return promiseAllRejectLate(diff.unchanged.map((node) => {
            if (node.ideallyInert) {
              return;
            }
            if (node.isLink) {
              return mkdir(dirname(node.path), { recursive: true, force: true }).then(() => this[_reifyNode](node));
            }
            if (node.inDepBundle && !this.#bundleMissing.has(node)) {
              return;
            }
            this.#retiredUnchanged[retireFolder].push(node);
            const rel = relative(realFolder, node.path);
            const fromPath = resolve(retireFolder, rel);
            const bd = node.package.bundleDependencies;
            const dir = bd && bd.length ? node.path + "/node_modules" : node.path;
            return mkdir(dir, { recursive: true }).then(() => this[_moveContents](node, fromPath));
          }));
        })).then(timeEnd);
      }
      // move the contents from the fromPath to the node.path
      [_moveContents](node, fromPath) {
        return packageContents({
          path: fromPath,
          depth: 1,
          packageJsonCache: /* @__PURE__ */ new Map([[fromPath + "/package.json", node.package]])
        }).then((res) => promiseAllRejectLate(res.map((path) => {
          const rel = relative(fromPath, path);
          const to = resolve(node.path, rel);
          return this[_renamePath](path, to);
        })));
      }
      [_rollbackMoveBackRetiredUnchanged](er) {
        const moves = this.#retiredPaths;
        const realFolders = new Map(Object.entries(moves).map(([k, v]) => [v, k]));
        const promises = Object.entries(this.#retiredUnchanged).map(([retireFolder, nodes]) => promiseAllRejectLate(nodes.map((node) => {
          const realFolder = realFolders.get(retireFolder);
          const rel = relative(realFolder, node.path);
          const fromPath = resolve(retireFolder, rel);
          return this[_moveContents]({ ...node, path: fromPath }, node.path);
        })));
        return promiseAllRejectLate(promises).then(() => this[_rollbackCreateSparseTree](er));
      }
      [_build]() {
        const timeEnd = time.start("reify:build");
        const nodes = [];
        dfwalk({
          tree: this.diff,
          leave: (diff) => {
            if (!diff.ideal.isProjectRoot) {
              nodes.push(diff.ideal);
            }
          },
          // process adds before changes, ignore removals
          getChildren: (diff) => diff && diff.children,
          filter: (diff) => diff.action === "ADD" || diff.action === "CHANGE"
        });
        for (const node of this.diff.unchanged) {
          const tree = node.root.target;
          const linkedFromRoot = node.parent === tree && !node.ideallyInert || node.target.fsTop === tree;
          if (node.isLink && linkedFromRoot) {
            nodes.push(node);
          }
        }
        return this.rebuild({ nodes, handleOptionalFailure: true }).then(timeEnd);
      }
      // the tree is pretty much built now, so it's cleanup time.
      // remove the retired folders, and any deleted nodes
      // If this fails, there isn't much we can do but tell the user about it.
      // Thankfully, it's pretty unlikely that it'll fail, since rm is a node builtin.
      async [_removeTrash]() {
        const timeEnd = time.start("reify:trash");
        const promises = [];
        const failures = [];
        const _rm = (path) => rm(path, { recursive: true, force: true }).catch((er) => failures.push([path, er]));
        for (const path of this[_trashList]) {
          promises.push(_rm(path));
        }
        await promiseAllRejectLate(promises);
        if (failures.length) {
          log.warn("cleanup", "Failed to remove some directories", failures);
        }
        timeEnd();
      }
      // last but not least, we save the ideal tree metadata to the package-lock
      // or shrinkwrap file, and any additions or removals to package.json
      async [_saveIdealTree](options) {
        const save = !(options.save === false);
        const hasUpdates = this[_updateAll] || this[_updateNames].length;
        const saveIdealTree = !(!save && !hasUpdates || this.options.global || this.options.dryRun);
        if (!saveIdealTree) {
          return false;
        }
        const timeEnd = time.start("reify:save");
        const updatedTrees = /* @__PURE__ */ new Set();
        const updateNodes = (nodes) => {
          for (const { name, tree: addTree } of nodes) {
            const edge = addTree.edgesOut.get(name);
            const pkg = addTree.package;
            const req = npa.resolve(name, edge.spec, addTree.realpath);
            const { rawSpec, subSpec } = req;
            const spec = subSpec ? subSpec.rawSpec : rawSpec;
            const child = edge.to;
            if (!child || !addTree.isTop) {
              continue;
            }
            let newSpec;
            const isLocalDep = req.type === "directory" || req.type === "file";
            if (req.registry) {
              const version = child.version;
              const prefixRange = version ? this.options.savePrefix + version : "*";
              const isRange = (subSpec || req).type === "range";
              let range = spec;
              if (!isRange || spec === "*" || subset(prefixRange, spec, { loose: true })) {
                range = prefixRange;
              }
              const pname = child.packageName;
              const alias = name !== pname;
              newSpec = alias ? `npm:${pname}@${range}` : range;
            } else if (req.hosted) {
              const h = req.hosted;
              const opt = { noCommittish: false };
              if (h.https && h.auth) {
                newSpec = `git+${h.https(opt)}`;
              } else {
                newSpec = h.shortcut(opt);
              }
            } else if (isLocalDep) {
              if (edge.type === "workspace") {
                const { version } = edge.to.target;
                const prefixRange = version ? this.options.savePrefix + version : "*";
                newSpec = prefixRange;
              } else {
                const p = req.fetchSpec.replace(/^file:/, "");
                const rel = relpath(addTree.realpath, p);
                newSpec = `file:${rel}`;
              }
            } else {
              newSpec = req.saveSpec;
            }
            if (options.saveType) {
              const depType = saveTypeMap.get(options.saveType);
              pkg[depType][name] = newSpec;
              if (options.saveType === "prod" && pkg.optionalDependencies) {
                delete pkg.optionalDependencies[name];
              }
            } else {
              if (hasSubKey(pkg, "dependencies", name)) {
                pkg.dependencies[name] = newSpec;
              }
              if (hasSubKey(pkg, "devDependencies", name)) {
                pkg.devDependencies[name] = newSpec;
                if (hasSubKey(pkg, "peerDependencies", name) && (isLocalDep || !intersects(newSpec, pkg.peerDependencies[name]))) {
                  pkg.peerDependencies[name] = newSpec;
                }
                if (hasSubKey(pkg, "optionalDependencies", name) && (isLocalDep || !intersects(newSpec, pkg.optionalDependencies[name]))) {
                  pkg.optionalDependencies[name] = newSpec;
                }
              } else {
                if (hasSubKey(pkg, "peerDependencies", name)) {
                  pkg.peerDependencies[name] = newSpec;
                }
                if (hasSubKey(pkg, "optionalDependencies", name)) {
                  pkg.optionalDependencies[name] = newSpec;
                }
              }
            }
            updatedTrees.add(addTree);
          }
        };
        const exactVersion = (node) => {
          for (const edge of node.edgesIn) {
            try {
              if (semver.subset(edge.spec, node.version)) {
                return false;
              }
            } catch {
            }
          }
          return true;
        };
        const retrieveUpdatedNodes = (names) => {
          const filterDirectDependencies = (node) => !node.isRoot && node.resolveParent && node.resolveParent.isRoot && (!names || names.includes(node.name)) && exactVersion(node);
          const directDeps = this.idealTree.inventory.filter(filterDirectDependencies);
          const nodes = [];
          for (const node of directDeps) {
            for (const edgeIn of node.edgesIn) {
              nodes.push({
                name: node.name,
                tree: edgeIn.from.target
              });
            }
          }
          return nodes;
        };
        if (save) {
          if (this[_updateAll]) {
            const nodes = retrieveUpdatedNodes();
            updateNodes(nodes);
          } else {
            if (this[_resolvedAdd].length) {
              updateNodes(this[_resolvedAdd]);
            }
            if (this[_updateNames].length) {
              const nodes = retrieveUpdatedNodes(this[_updateNames]);
              updateNodes(nodes);
            }
            for (const { from: tree } of this.explicitRequests) {
              updatedTrees.add(tree);
            }
          }
        }
        if (save) {
          for (const tree of updatedTrees) {
            tree.package = tree.package;
            const pkgJson = await PackageJson.load(tree.path, { create: true });
            const {
              dependencies = {},
              devDependencies = {},
              optionalDependencies = {},
              peerDependencies = {},
              // bundleDependencies is not required by PackageJson like the other
              // fields here PackageJson also doesn't omit an empty array for this
              // field so defaulting this to an empty array would add that field to
              // every package.json file.
              bundleDependencies
            } = tree.package;
            pkgJson.update({
              dependencies,
              devDependencies,
              optionalDependencies,
              peerDependencies,
              bundleDependencies
            });
            await pkgJson.save();
          }
        }
        if (this[_usePackageLock]) {
          let format = this.idealTree.package[Symbol.for("indent")];
          if (format === void 0) {
            format = "  ";
          }
          await this.idealTree.meta.save({
            format: this.options.formatPackageLock && format ? format : this.options.formatPackageLock
          });
        }
        timeEnd();
        return true;
      }
    };
  }
});

// node_modules/@npmcli/arborist/lib/arborist/isolated-reifier.js
var require_isolated_reifier = __commonJS({
  "node_modules/@npmcli/arborist/lib/arborist/isolated-reifier.js"(exports2, module2) {
    var _makeIdealGraph = Symbol("makeIdealGraph");
    var _createIsolatedTree = Symbol.for("createIsolatedTree");
    var _createBundledTree = Symbol("createBundledTree");
    var { mkdirSync } = require("node:fs");
    var pacote = require_lib33();
    var { join } = require("node:path");
    var { depth } = require_lib();
    var crypto = require("node:crypto");
    var memoize = (fn) => {
      const memo = /* @__PURE__ */ new Map();
      return async function(arg) {
        const key = arg;
        if (memo.has(key)) {
          return memo.get(key);
        }
        const result = {};
        memo.set(key, result);
        await fn(result, arg);
        return result;
      };
    };
    module2.exports = (cls) => class IsolatedReifier extends cls {
      /**
       * Create an ideal graph.
       *
       * An implementation of npm RFC-0042
       * https://github.com/npm/rfcs/blob/main/accepted/0042-isolated-mode.md
       *
       * This entire file should be considered technical debt that will be resolved
       * with an Arborist refactor or rewrite. Embedded logic in Nodes and Links,
       * and the incremental state of building trees and reifying contains too many
       * assumptions to do a linked mode properly.
       *
       * Instead, this approach takes a tree built from build-ideal-tree, and
       * returns a new tree-like structure without the embedded logic of Node and
       * Link classes.
       *
       * Since the RFC requires leaving the package-lock in place, this approach
       * temporarily replaces the tree state for a couple of steps of reifying.
       *
       **/
      async [_makeIdealGraph](options) {
        const bitOpt = {
          ...options,
          complete: false
        };
        await this.buildIdealTree(bitOpt);
        const idealTree = this.idealTree;
        this.rootNode = {};
        const root = this.rootNode;
        this.counter = 0;
        this.externalProxyMemo = memoize(this.externalProxy.bind(this));
        this.workspaceProxyMemo = memoize(this.workspaceProxy.bind(this));
        root.external = [];
        root.isProjectRoot = true;
        root.localLocation = idealTree.location;
        root.localPath = idealTree.path;
        root.workspaces = await Promise.all(
          Array.from(idealTree.fsChildren.values(), this.workspaceProxyMemo)
        );
        const processed = /* @__PURE__ */ new Set();
        const queue = [idealTree, ...idealTree.fsChildren];
        while (queue.length !== 0) {
          const next = queue.pop();
          if (processed.has(next.location)) {
            continue;
          }
          processed.add(next.location);
          next.edgesOut.forEach((e) => {
            if (!e.to || (next.package.bundleDependencies || next.package.bundledDependencies || []).includes(e.to.name)) {
              return;
            }
            queue.push(e.to);
          });
          if (!next.isProjectRoot && !next.isWorkspace && !next.ideallyInert) {
            root.external.push(await this.externalProxyMemo(next));
          }
        }
        await this.assignCommonProperties(idealTree, root);
        this.idealGraph = root;
      }
      async workspaceProxy(result, node) {
        result.localLocation = node.location;
        result.localPath = node.path;
        result.isWorkspace = true;
        result.resolved = node.resolved;
        await this.assignCommonProperties(node, result);
      }
      async externalProxy(result, node) {
        await this.assignCommonProperties(node, result);
        if (node.hasShrinkwrap) {
          const dir = join(
            node.root.path,
            "node_modules",
            ".store",
            `${node.name}@${node.version}`
          );
          mkdirSync(dir, { recursive: true });
          await pacote.extract(node.resolved, dir, {
            ...this.options,
            resolved: node.resolved,
            integrity: node.integrity
          });
          const Arborist2 = this.constructor;
          const arb = new Arborist2({ ...this.options, path: dir });
          await arb[_makeIdealGraph]({ dev: false });
          this.rootNode.external.push(...arb.idealGraph.external);
          arb.idealGraph.external.forEach((e) => {
            e.root = this.rootNode;
            e.id = `${node.id}=>${e.id}`;
          });
          result.localDependencies = [];
          result.externalDependencies = arb.idealGraph.externalDependencies;
          result.externalOptionalDependencies = arb.idealGraph.externalOptionalDependencies;
          result.dependencies = [
            ...result.externalDependencies,
            ...result.localDependencies,
            ...result.externalOptionalDependencies
          ];
        }
        result.optional = node.optional;
        result.resolved = node.resolved;
        result.version = node.version;
      }
      async assignCommonProperties(node, result) {
        function validEdgesOut(node2) {
          return [...node2.edgesOut.values()].filter((e) => e.to && e.to.target && !(node2.package.bundledDepenedencies || node2.package.bundleDependencies || []).includes(e.to.name));
        }
        const edges = validEdgesOut(node);
        const optionalDeps = edges.filter((e) => e.optional).map((e) => e.to.target);
        const nonOptionalDeps = edges.filter((e) => !e.optional).map((e) => e.to.target);
        result.localDependencies = await Promise.all(nonOptionalDeps.filter((n) => n.isWorkspace).map(this.workspaceProxyMemo));
        result.externalDependencies = await Promise.all(nonOptionalDeps.filter((n) => !n.isWorkspace && !n.ideallyInert).map(this.externalProxyMemo));
        result.externalOptionalDependencies = await Promise.all(optionalDeps.filter((n) => !n.ideallyInert).map(this.externalProxyMemo));
        result.dependencies = [
          ...result.externalDependencies,
          ...result.localDependencies,
          ...result.externalOptionalDependencies
        ];
        result.root = this.rootNode;
        result.id = this.counter++;
        result.name = node.name;
        result.package = { ...node.package };
        result.package.bundleDependencies = void 0;
        result.hasInstallScript = node.hasInstallScript;
      }
      async [_createBundledTree]() {
        const idealTree = this.idealTree;
        const queue = [];
        for (const [, edge] of idealTree.edgesOut) {
          if (edge.to && (idealTree.package.bundleDependencies || idealTree.package.bundledDependencies || []).includes(edge.to.name)) {
            queue.push({ from: idealTree, to: edge.to });
          }
        }
        for (const child of idealTree.fsChildren) {
          for (const [, edge] of child.edgesOut) {
            if (edge.to && (child.package.bundleDependencies || child.package.bundledDependencies || []).includes(edge.to.name)) {
              queue.push({ from: child, to: edge.to });
            }
          }
        }
        const processed = /* @__PURE__ */ new Set();
        const nodes = /* @__PURE__ */ new Map();
        const edges = [];
        while (queue.length !== 0) {
          const nextEdge = queue.pop();
          const key = `${nextEdge.from.location}=>${nextEdge.to.location}`;
          if (processed.has(key)) {
            continue;
          }
          processed.add(key);
          const from = nextEdge.from;
          if (!from.isRoot && !from.isWorkspace) {
            nodes.set(from.location, { location: from.location, resolved: from.resolved, name: from.name, optional: from.optional, pkg: { ...from.package, bundleDependencies: void 0 } });
          }
          const to = nextEdge.to;
          nodes.set(to.location, { location: to.location, resolved: to.resolved, name: to.name, optional: to.optional, pkg: { ...to.package, bundleDependencies: void 0 } });
          edges.push({ from: from.isRoot ? "root" : from.location, to: to.location });
          to.edgesOut.forEach((e) => {
            if (e.to) {
              queue.push({ from: e.from, to: e.to });
            }
          });
        }
        return { edges, nodes };
      }
      async [_createIsolatedTree]() {
        await this[_makeIdealGraph](this.options);
        const proxiedIdealTree = this.idealGraph;
        const bundledTree = await this[_createBundledTree]();
        const treeHash = (startNode) => {
          const deps = [];
          const branch = [];
          depth({
            tree: startNode,
            getChildren: (node) => node.dependencies,
            filter: (node) => node,
            visit: (node) => {
              branch.push(`${node.name}@${node.version}`);
              deps.push(`${branch.join("->")}::${node.resolved}`);
            },
            leave: () => {
              branch.pop();
            }
          });
          deps.sort();
          return crypto.createHash("shake256", { outputLength: 16 }).update(deps.join(",")).digest("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/m, "");
        };
        const getKey = (idealTreeNode) => {
          return `${idealTreeNode.name}@${idealTreeNode.version}-${treeHash(idealTreeNode)}`;
        };
        const root = {
          fsChildren: [],
          integrity: null,
          inventory: /* @__PURE__ */ new Map(),
          isLink: false,
          isRoot: true,
          binPaths: [],
          edgesIn: /* @__PURE__ */ new Set(),
          edgesOut: /* @__PURE__ */ new Map(),
          hasShrinkwrap: false,
          parent: null,
          // TODO: we should probably not reference this.idealTree
          resolved: this.idealTree.resolved,
          isTop: true,
          path: proxiedIdealTree.root.localPath,
          realpath: proxiedIdealTree.root.localPath,
          package: proxiedIdealTree.root.package,
          meta: { loadedFromDisk: false },
          global: false,
          isProjectRoot: true,
          children: []
        };
        root.inventory.query = () => {
          return [];
        };
        const processed = /* @__PURE__ */ new Set();
        proxiedIdealTree.workspaces.forEach((c) => {
          const workspace = {
            edgesIn: /* @__PURE__ */ new Set(),
            edgesOut: /* @__PURE__ */ new Map(),
            children: [],
            hasInstallScript: c.hasInstallScript,
            binPaths: [],
            package: c.package,
            location: c.localLocation,
            path: c.localPath,
            realpath: c.localPath,
            resolved: c.resolved
          };
          root.fsChildren.push(workspace);
          root.inventory.set(workspace.location, workspace);
        });
        const generateChild = (node, location, pkg, inStore) => {
          const newChild = {
            global: false,
            globalTop: false,
            isProjectRoot: false,
            isTop: false,
            location,
            name: node.name,
            optional: node.optional,
            top: { path: proxiedIdealTree.root.localPath },
            children: [],
            edgesIn: /* @__PURE__ */ new Set(),
            edgesOut: /* @__PURE__ */ new Map(),
            binPaths: [],
            fsChildren: [],
            /* istanbul ignore next -- emulate Node */
            getBundler() {
              return null;
            },
            hasShrinkwrap: false,
            inDepBundle: false,
            integrity: null,
            isLink: false,
            isRoot: false,
            isInStore: inStore,
            path: join(proxiedIdealTree.root.localPath, location),
            realpath: join(proxiedIdealTree.root.localPath, location),
            resolved: node.resolved,
            version: pkg.version,
            package: pkg
          };
          newChild.target = newChild;
          root.children.push(newChild);
          root.inventory.set(newChild.location, newChild);
        };
        proxiedIdealTree.external.forEach((c) => {
          const key = getKey(c);
          if (processed.has(key)) {
            return;
          }
          processed.add(key);
          const location = join("node_modules", ".store", key, "node_modules", c.name);
          generateChild(c, location, c.package, true);
        });
        bundledTree.nodes.forEach((node) => {
          generateChild(node, node.location, node.pkg, false);
        });
        bundledTree.edges.forEach((e) => {
          const from = e.from === "root" ? root : root.inventory.get(e.from);
          const to = root.inventory.get(e.to);
          const edge = { optional: false, from, to };
          from.edgesOut.set(to.name, edge);
          to.edgesIn.add(edge);
        });
        const memo = /* @__PURE__ */ new Set();
        function processEdges(node, externalEdge) {
          externalEdge = !!externalEdge;
          const key = getKey(node);
          if (memo.has(key)) {
            return;
          }
          memo.add(key);
          let from, nmFolder;
          if (externalEdge) {
            const fromLocation = join("node_modules", ".store", key, "node_modules", node.name);
            from = root.children.find((c) => c.location === fromLocation);
            nmFolder = join("node_modules", ".store", key, "node_modules");
          } else {
            from = node.isProjectRoot ? root : root.fsChildren.find((c) => c.location === node.localLocation);
            nmFolder = join(node.localLocation, "node_modules");
          }
          const processDeps = (dep, optional, external) => {
            optional = !!optional;
            external = !!external;
            const location = join(nmFolder, dep.name);
            const binNames = dep.package.bin && Object.keys(dep.package.bin) || [];
            const toKey = getKey(dep);
            let target;
            if (external) {
              const toLocation = join("node_modules", ".store", toKey, "node_modules", dep.name);
              target = root.children.find((c) => c.location === toLocation);
            } else {
              target = root.fsChildren.find((c) => c.location === dep.localLocation);
            }
            binNames.forEach((bn) => {
              target.binPaths.push(join(from.realpath, "node_modules", ".bin", bn));
            });
            const link = {
              global: false,
              globalTop: false,
              isProjectRoot: false,
              edgesIn: /* @__PURE__ */ new Set(),
              edgesOut: /* @__PURE__ */ new Map(),
              binPaths: [],
              isTop: false,
              optional,
              location,
              path: join(dep.root.localPath, nmFolder, dep.name),
              realpath: target.path,
              name: toKey,
              resolved: dep.resolved,
              top: { path: dep.root.localPath },
              children: [],
              fsChildren: [],
              isLink: true,
              isStoreLink: true,
              isRoot: false,
              package: { _id: "abc", bundleDependencies: void 0, deprecated: void 0, bin: target.package.bin, scripts: dep.package.scripts },
              target
            };
            const newEdge1 = { optional, from, to: link };
            from.edgesOut.set(dep.name, newEdge1);
            link.edgesIn.add(newEdge1);
            const newEdge2 = { optional: false, from: link, to: target };
            link.edgesOut.set(dep.name, newEdge2);
            target.edgesIn.add(newEdge2);
            root.children.push(link);
          };
          for (const dep of node.localDependencies) {
            processEdges(dep, false);
            processDeps(dep, false, false);
          }
          for (const dep of node.externalDependencies) {
            processEdges(dep, true);
            processDeps(dep, false, true);
          }
          for (const dep of node.externalOptionalDependencies) {
            processEdges(dep, true);
            processDeps(dep, true, true);
          }
        }
        processEdges(proxiedIdealTree, false);
        for (const node of proxiedIdealTree.workspaces) {
          processEdges(node, false);
        }
        root.children.forEach((c) => c.parent = root);
        root.children.forEach((c) => c.root = root);
        root.root = root;
        root.target = root;
        return root;
      }
    };
  }
});

// node_modules/@npmcli/arborist/lib/arborist/index.js
var require_arborist = __commonJS({
  "node_modules/@npmcli/arborist/lib/arborist/index.js"(exports2, module2) {
    var { resolve } = require("node:path");
    var { homedir } = require("node:os");
    var { depth } = require_lib();
    var mapWorkspaces = require_lib14();
    var { log, time } = require_lib4();
    var { saveTypeMap } = require_add_rm_pkg_deps();
    var AuditReport = require_audit_report();
    var relpath = require_relpath();
    var PackumentCache = require_packument_cache();
    var mixins = [
      require_tracker2(),
      require_build_ideal_tree(),
      require_load_actual(),
      require_load_virtual(),
      require_rebuild(),
      require_reify(),
      require_isolated_reifier()
    ];
    var _setWorkspaces = Symbol.for("setWorkspaces");
    var Base = mixins.reduce((a, b) => b(a), require("node:events"));
    var lockfileVersion = (lfv) => {
      if (lfv === 1 || lfv === 2 || lfv === 3) {
        return lfv;
      }
      if (lfv === void 0 || lfv === null) {
        return null;
      }
      throw new TypeError("Invalid lockfileVersion config: " + lfv);
    };
    var Arborist2 = class extends Base {
      constructor(options = {}) {
        const timeEnd = time.start("arborist:ctor");
        super(options);
        this.options = {
          nodeVersion: process.version,
          ...options,
          Arborist: this.constructor,
          binLinks: "binLinks" in options ? !!options.binLinks : true,
          cache: options.cache || `${homedir()}/.npm/_cacache`,
          dryRun: !!options.dryRun,
          formatPackageLock: "formatPackageLock" in options ? !!options.formatPackageLock : true,
          force: !!options.force,
          global: !!options.global,
          ignoreScripts: !!options.ignoreScripts,
          installStrategy: options.global ? "shallow" : options.installStrategy ? options.installStrategy : "hoisted",
          lockfileVersion: lockfileVersion(options.lockfileVersion),
          packageLockOnly: !!options.packageLockOnly,
          packumentCache: options.packumentCache || new PackumentCache(),
          path: options.path || ".",
          rebuildBundle: "rebuildBundle" in options ? !!options.rebuildBundle : true,
          replaceRegistryHost: options.replaceRegistryHost,
          savePrefix: "savePrefix" in options ? options.savePrefix : "^",
          scriptShell: options.scriptShell,
          workspaces: options.workspaces || [],
          workspacesEnabled: options.workspacesEnabled !== false
        };
        this.replaceRegistryHost = this.options.replaceRegistryHost = !this.options.replaceRegistryHost || this.options.replaceRegistryHost === "npmjs" ? "registry.npmjs.org" : this.options.replaceRegistryHost;
        if (options.saveType && !saveTypeMap.get(options.saveType)) {
          throw new Error(`Invalid saveType ${options.saveType}`);
        }
        this.cache = resolve(this.options.cache);
        this.diff = null;
        this.path = resolve(this.options.path);
        timeEnd();
      }
      // TODO: We should change these to static functions instead
      //   of methods for the next major version
      // Get the actual nodes corresponding to a root node's child workspaces,
      // given a list of workspace names.
      workspaceNodes(tree, workspaces) {
        const wsMap = tree.workspaces;
        if (!wsMap) {
          log.warn("workspaces", "filter set, but no workspaces present");
          return [];
        }
        const nodes = [];
        for (const name of workspaces) {
          const path = wsMap.get(name);
          if (!path) {
            log.warn("workspaces", `${name} in filter set, but not in workspaces`);
            continue;
          }
          const loc = relpath(tree.realpath, path);
          const node = tree.inventory.get(loc);
          if (!node) {
            log.warn("workspaces", `${name} in filter set, but no workspace folder present`);
            continue;
          }
          nodes.push(node);
        }
        return nodes;
      }
      // returns a set of workspace nodes and all their deps
      // TODO why is includeWorkspaceRoot a param?
      // TODO why is workspaces a param?
      workspaceDependencySet(tree, workspaces, includeWorkspaceRoot) {
        const wsNodes = this.workspaceNodes(tree, workspaces);
        if (includeWorkspaceRoot) {
          for (const edge of tree.edgesOut.values()) {
            if (edge.type !== "workspace" && edge.to) {
              wsNodes.push(edge.to);
            }
          }
        }
        const wsDepSet = new Set(wsNodes);
        const extraneous = /* @__PURE__ */ new Set();
        for (const node of wsDepSet) {
          for (const edge of node.edgesOut.values()) {
            const dep = edge.to;
            if (dep) {
              wsDepSet.add(dep);
              if (dep.isLink) {
                wsDepSet.add(dep.target);
              }
            }
          }
          for (const child of node.children.values()) {
            if (child.extraneous) {
              extraneous.add(child);
            }
          }
        }
        for (const extra of extraneous) {
          wsDepSet.add(extra);
        }
        return wsDepSet;
      }
      // returns a set of root dependencies, excluding dependencies that are
      // exclusively workspace dependencies
      excludeWorkspacesDependencySet(tree) {
        const rootDepSet = /* @__PURE__ */ new Set();
        depth({
          tree,
          visit: (node) => {
            for (const { to } of node.edgesOut.values()) {
              if (!to || to.isWorkspace) {
                continue;
              }
              for (const edgeIn of to.edgesIn.values()) {
                if (edgeIn.from.isRoot || rootDepSet.has(edgeIn.from)) {
                  rootDepSet.add(to);
                }
              }
            }
            return node;
          },
          filter: (node) => node,
          getChildren: (node, tree2) => [...tree2.edgesOut.values()].map((edge) => edge.to)
        });
        return rootDepSet;
      }
      async [_setWorkspaces](node) {
        const workspaces = await mapWorkspaces({
          cwd: node.path,
          pkg: node.package
        });
        if (node && workspaces.size) {
          node.workspaces = workspaces;
        }
        return node;
      }
      async audit(options = {}) {
        this.addTracker("audit");
        if (this.options.global) {
          throw Object.assign(
            new Error("`npm audit` does not support testing globals"),
            { code: "EAUDITGLOBAL" }
          );
        }
        options = { ...this.options, ...options };
        const timeEnd = time.start("audit");
        let tree;
        if (options.packageLock === false) {
          await this.loadActual(options);
          await this.buildIdealTree();
          tree = this.idealTree;
        } else {
          tree = await this.loadVirtual();
        }
        if (this.options.workspaces.length) {
          options.filterSet = this.workspaceDependencySet(
            tree,
            this.options.workspaces,
            this.options.includeWorkspaceRoot
          );
        }
        if (!options.workspacesEnabled) {
          options.filterSet = this.excludeWorkspacesDependencySet(tree);
        }
        this.auditReport = await AuditReport.load(tree, options);
        const ret = options.fix ? this.reify(options) : this.auditReport;
        timeEnd();
        this.finishTracker("audit");
        return ret;
      }
      async dedupe(options = {}) {
        options = { ...this.options, ...options };
        const tree = await this.loadVirtual().catch(() => this.loadActual());
        const names = [];
        for (const name of tree.inventory.query("name")) {
          if (tree.inventory.query("name", name).size > 1) {
            names.push(name);
          }
        }
        return this.reify({
          ...options,
          preferDedupe: true,
          update: { names }
        });
      }
    };
    module2.exports = Arborist2;
  }
});

// node_modules/@npmcli/arborist/lib/index.js
var require_lib43 = __commonJS({
  "node_modules/@npmcli/arborist/lib/index.js"(exports2, module2) {
    module2.exports = require_arborist();
    module2.exports.Arborist = module2.exports;
    module2.exports.Node = require_node5();
    module2.exports.Link = require_link();
    module2.exports.Edge = require_edge();
    module2.exports.Shrinkwrap = require_shrinkwrap();
  }
});

// arborist.js
var Arborist = require_lib43();
var fs = require("fs");
async function getDependencyTree(packageName) {
  const arb = new Arborist({
    registry: "https://registry.npmjs.org",
    token: "",
    authToken: ""
  });
  try {
    const idealTree = await arb.buildIdealTree({
      add: [packageName]
    });
    const packageNames = [];
    idealTree.children.forEach((node) => {
      packageNames.push(`${node.name}@${node.version}`);
    });
    return packageNames;
  } catch (error) {
    console.error(`Failed to fetch dependency tree for ${packageName}:`, error);
    return [];
  }
}
function writeToFile(packages, filename) {
  try {
    fs.writeFileSync(filename, packages.join("\n"), "utf8");
    console.log(`Dependencies written to ${filename}`);
  } catch (error) {
    console.error(`Failed to write to file ${filename}:`, error);
    process.exit(1);
  }
}
var packageArg = process.argv[2];
var outputFile = process.argv[3];
if (!packageArg) {
  console.error("Please provide a package name as an argument");
  process.exit(1);
}
if (!outputFile) {
  console.error("Please provide an output filename as the second argument");
  process.exit(1);
}
getDependencyTree(packageArg).then((packages) => {
  writeToFile(packages, outputFile);
}).catch((err) => {
  console.error("Error:", err);
  process.exit(1);
});
/*! Bundled license information:

imurmurhash/imurmurhash.js:
  (**
   * @preserve
   * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
   *
   * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
   * @see http://github.com/homebrewing/brauhaus-diff
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *)

negotiator/index.js:
  (*!
   * negotiator
   * Copyright(c) 2012 Federico Romero
   * Copyright(c) 2012-2014 Isaac Z. Schlueter
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

make-fetch-happen/lib/fetch.js:
  (**
   * @license
   * Copyright (c) 2010-2012 Mikeal Rogers
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * http://www.apache.org/licenses/LICENSE-2.0
   * Unless required by applicable law or agreed to in writing,
   * software distributed under the License is distributed on an "AS
   * IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
   * express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   *)

cssesc/cssesc.js:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)
*/
